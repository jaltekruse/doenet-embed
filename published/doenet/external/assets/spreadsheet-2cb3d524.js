import { ax as commonjsGlobal, R as React, bO as ReactDOM, bx as useDoenetRenderer, r as reactExports, j as jsx, b as jsxs, bP as HyperFormula } from "./PageViewer-d914b069.js";
import { h as hooks, c as commonjsRequire, r as require$$0 } from "./moment-feb1c730.js";
import { s as sizeToCSS } from "./css-5483d03f.js";
import { V as VisibilitySensor } from "./visibility-sensor-57589aaf.js";
var check = function(it) {
  return it && it.Math == Math && it;
};
var global$s = (
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  function() {
    return this;
  }() || Function("return this")()
);
var objectGetOwnPropertyDescriptor = {};
var fails$G = function(exec2) {
  try {
    return !!exec2();
  } catch (error2) {
    return true;
  }
};
var fails$F = fails$G;
var descriptors = !fails$F(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$E = fails$G;
var functionBindNative = !fails$E(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$4 = functionBindNative;
var call$m = Function.prototype.call;
var functionCall = NATIVE_BIND$4 ? call$m.bind(call$m) : function() {
  return call$m.apply(call$m, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$2 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$6 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$6 && !$propertyIsEnumerable$2.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$6(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$2;
var createPropertyDescriptor$5 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var call$l = FunctionPrototype$3.call;
var uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$3.bind.bind(call$l, call$l);
var functionUncurryThisRaw = NATIVE_BIND$3 ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$l.apply(fn, arguments);
  };
};
var uncurryThisRaw$1 = functionUncurryThisRaw;
var toString$l = uncurryThisRaw$1({}.toString);
var stringSlice$a = uncurryThisRaw$1("".slice);
var classofRaw$2 = function(it) {
  return stringSlice$a(toString$l(it), 8, -1);
};
var classofRaw$1 = classofRaw$2;
var uncurryThisRaw = functionUncurryThisRaw;
var functionUncurryThis = function(fn) {
  if (classofRaw$1(fn) === "Function")
    return uncurryThisRaw(fn);
};
var uncurryThis$G = functionUncurryThis;
var fails$D = fails$G;
var classof$b = classofRaw$2;
var $Object$4 = Object;
var split = uncurryThis$G("".split);
var indexedObject = fails$D(function() {
  return !$Object$4("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$b(it) == "String" ? split(it, "") : $Object$4(it);
} : $Object$4;
var isNullOrUndefined$b = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$a = isNullOrUndefined$b;
var $TypeError$h = TypeError;
var requireObjectCoercible$e = function(it) {
  if (isNullOrUndefined$a(it))
    throw $TypeError$h("Can't call method on " + it);
  return it;
};
var IndexedObject$4 = indexedObject;
var requireObjectCoercible$d = requireObjectCoercible$e;
var toIndexedObject$d = function(it) {
  return IndexedObject$4(requireObjectCoercible$d(it));
};
var documentAll$2 = typeof document == "object" && document.all;
var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA
};
var $documentAll$1 = documentAll_1;
var documentAll$1 = $documentAll$1.all;
var isCallable$o = $documentAll$1.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$1;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$n = isCallable$o;
var $documentAll = documentAll_1;
var documentAll = $documentAll.all;
var isObject$n = $documentAll.IS_HTMLDDA ? function(it) {
  return typeof it == "object" ? it !== null : isCallable$n(it) || it === documentAll;
} : function(it) {
  return typeof it == "object" ? it !== null : isCallable$n(it);
};
var global$r = global$s;
var isCallable$m = isCallable$o;
var aFunction = function(argument) {
  return isCallable$m(argument) ? argument : void 0;
};
var getBuiltIn$a = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$r[namespace]) : global$r[namespace] && global$r[namespace][method];
};
var uncurryThis$F = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$F({}.isPrototypeOf);
var getBuiltIn$9 = getBuiltIn$a;
var engineUserAgent = getBuiltIn$9("navigator", "userAgent") || "";
var global$q = global$s;
var userAgent$5 = engineUserAgent;
var process$2 = global$q.process;
var Deno = global$q.Deno;
var versions = process$2 && process$2.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version$1;
if (v8) {
  match = v8.split(".");
  version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version$1 && userAgent$5) {
  match = userAgent$5.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$5.match(/Chrome\/(\d+)/);
    if (match)
      version$1 = +match[1];
  }
}
var engineV8Version = version$1;
var V8_VERSION$2 = engineV8Version;
var fails$C = fails$G;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$C(function() {
  var symbol = Symbol();
  return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
});
var NATIVE_SYMBOL$6 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$6 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$8 = getBuiltIn$a;
var isCallable$l = isCallable$o;
var isPrototypeOf$7 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$3 = Object;
var isSymbol$5 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol2 = getBuiltIn$8("Symbol");
  return isCallable$l($Symbol2) && isPrototypeOf$7($Symbol2.prototype, $Object$3(it));
};
var $String$4 = String;
var tryToString$6 = function(argument) {
  try {
    return $String$4(argument);
  } catch (error2) {
    return "Object";
  }
};
var isCallable$k = isCallable$o;
var tryToString$5 = tryToString$6;
var $TypeError$g = TypeError;
var aCallable$6 = function(argument) {
  if (isCallable$k(argument))
    return argument;
  throw $TypeError$g(tryToString$5(argument) + " is not a function");
};
var aCallable$5 = aCallable$6;
var isNullOrUndefined$9 = isNullOrUndefined$b;
var getMethod$7 = function(V, P) {
  var func = V[P];
  return isNullOrUndefined$9(func) ? void 0 : aCallable$5(func);
};
var call$k = functionCall;
var isCallable$j = isCallable$o;
var isObject$m = isObject$n;
var $TypeError$f = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$j(fn = input.toString) && !isObject$m(val = call$k(fn, input)))
    return val;
  if (isCallable$j(fn = input.valueOf) && !isObject$m(val = call$k(fn, input)))
    return val;
  if (pref !== "string" && isCallable$j(fn = input.toString) && !isObject$m(val = call$k(fn, input)))
    return val;
  throw $TypeError$f("Can't convert object to primitive value");
};
var sharedExports = {};
var shared$7 = {
  get exports() {
    return sharedExports;
  },
  set exports(v2) {
    sharedExports = v2;
  }
};
var global$p = global$s;
var defineProperty$c = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$c(global$p, key, { value, configurable: true, writable: true });
  } catch (error2) {
    global$p[key] = value;
  }
  return value;
};
var global$o = global$s;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = global$o[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$7.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.26.0",
  mode: "global",
  copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var requireObjectCoercible$c = requireObjectCoercible$e;
var $Object$2 = Object;
var toObject$f = function(argument) {
  return $Object$2(requireObjectCoercible$c(argument));
};
var uncurryThis$E = functionUncurryThis;
var toObject$e = toObject$f;
var hasOwnProperty$3 = uncurryThis$E({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty$3(toObject$e(it), key);
};
var uncurryThis$D = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$k = uncurryThis$D(1 .toString);
var uid$4 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$k(++id$2 + postfix, 36);
};
var global$n = global$s;
var shared$6 = sharedExports;
var hasOwn$l = hasOwnProperty_1;
var uid$3 = uid$4;
var NATIVE_SYMBOL$5 = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore$1 = shared$6("wks");
var Symbol$1 = global$n.Symbol;
var symbolFor = Symbol$1 && Symbol$1["for"];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$3;
var wellKnownSymbol$p = function(name) {
  if (!hasOwn$l(WellKnownSymbolsStore$1, name) || !(NATIVE_SYMBOL$5 || typeof WellKnownSymbolsStore$1[name] == "string")) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL$5 && hasOwn$l(Symbol$1, name)) {
      WellKnownSymbolsStore$1[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore$1[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore$1[name];
};
var call$j = functionCall;
var isObject$l = isObject$n;
var isSymbol$4 = isSymbol$5;
var getMethod$6 = getMethod$7;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$o = wellKnownSymbol$p;
var $TypeError$e = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$o("toPrimitive");
var toPrimitive$2 = function(input, pref) {
  if (!isObject$l(input) || isSymbol$4(input))
    return input;
  var exoticToPrim = getMethod$6(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$j(exoticToPrim, input, pref);
    if (!isObject$l(result) || isSymbol$4(result))
      return result;
    throw $TypeError$e("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive$1 = toPrimitive$2;
var isSymbol$3 = isSymbol$5;
var toPropertyKey$4 = function(argument) {
  var key = toPrimitive$1(argument, "string");
  return isSymbol$3(key) ? key : key + "";
};
var global$m = global$s;
var isObject$k = isObject$n;
var document$1 = global$m.document;
var EXISTS$1 = isObject$k(document$1) && isObject$k(document$1.createElement);
var documentCreateElement$2 = function(it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};
var DESCRIPTORS$k = descriptors;
var fails$B = fails$G;
var createElement$2 = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$k && !fails$B(function() {
  return Object.defineProperty(createElement$2("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$j = descriptors;
var call$i = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$4 = createPropertyDescriptor$5;
var toIndexedObject$c = toIndexedObject$d;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$k = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$j ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$c(O);
  P = toPropertyKey$3(P);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$2(O, P);
    } catch (error2) {
    }
  if (hasOwn$k(O, P))
    return createPropertyDescriptor$4(!call$i(propertyIsEnumerableModule$2.f, O, P), O[P]);
};
var objectDefineProperty = {};
var DESCRIPTORS$i = descriptors;
var fails$A = fails$G;
var v8PrototypeDefineBug = DESCRIPTORS$i && fails$A(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var isObject$j = isObject$n;
var $String$3 = String;
var $TypeError$d = TypeError;
var anObject$l = function(argument) {
  if (isObject$j(argument))
    return argument;
  throw $TypeError$d($String$3(argument) + " is not an object");
};
var DESCRIPTORS$h = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$k = anObject$l;
var toPropertyKey$2 = toPropertyKey$4;
var $TypeError$c = TypeError;
var $defineProperty$1 = Object.defineProperty;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$h ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$k(O);
  P = toPropertyKey$2(P);
  anObject$k(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty$1(O, P, Attributes);
} : $defineProperty$1 : function defineProperty2(O, P, Attributes) {
  anObject$k(O);
  P = toPropertyKey$2(P);
  anObject$k(Attributes);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty$1(O, P, Attributes);
    } catch (error2) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError$c("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$g = descriptors;
var definePropertyModule$6 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$5;
var createNonEnumerableProperty$7 = DESCRIPTORS$g ? function(object, key, value) {
  return definePropertyModule$6.f(object, key, createPropertyDescriptor$3(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltInExports = {};
var makeBuiltIn$2 = {
  get exports() {
    return makeBuiltInExports;
  },
  set exports(v2) {
    makeBuiltInExports = v2;
  }
};
var DESCRIPTORS$f = descriptors;
var hasOwn$j = hasOwnProperty_1;
var FunctionPrototype$2 = Function.prototype;
var getDescriptor = DESCRIPTORS$f && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$j(FunctionPrototype$2, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$f || DESCRIPTORS$f && getDescriptor(FunctionPrototype$2, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$C = functionUncurryThis;
var isCallable$i = isCallable$o;
var store$1 = sharedStore;
var functionToString$1 = uncurryThis$C(Function.toString);
if (!isCallable$i(store$1.inspectSource)) {
  store$1.inspectSource = function(it) {
    return functionToString$1(it);
  };
}
var inspectSource$2 = store$1.inspectSource;
var global$l = global$s;
var isCallable$h = isCallable$o;
var WeakMap$2 = global$l.WeakMap;
var weakMapBasicDetection = isCallable$h(WeakMap$2) && /native code/.test(String(WeakMap$2));
var shared$5 = sharedExports;
var uid$2 = uid$4;
var keys$2 = shared$5("keys");
var sharedKey$4 = function(key) {
  return keys$2[key] || (keys$2[key] = uid$2(key));
};
var hiddenKeys$6 = {};
var NATIVE_WEAK_MAP$1 = weakMapBasicDetection;
var global$k = global$s;
var isObject$i = isObject$n;
var createNonEnumerableProperty$6 = createNonEnumerableProperty$7;
var hasOwn$i = hasOwnProperty_1;
var shared$4 = sharedStore;
var sharedKey$3 = sharedKey$4;
var hiddenKeys$5 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$3 = global$k.TypeError;
var WeakMap$1 = global$k.WeakMap;
var set$1, get$1, has;
var enforce = function(it) {
  return has(it) ? get$1(it) : set$1(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$i(it) || (state = get$1(it)).type !== TYPE) {
      throw TypeError$3("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$1 || shared$4.state) {
  var store = shared$4.state || (shared$4.state = new WeakMap$1());
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  set$1 = function(it, metadata) {
    if (store.has(it))
      throw TypeError$3(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get$1 = function(it) {
    return store.get(it) || {};
  };
  has = function(it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey$3("state");
  hiddenKeys$5[STATE] = true;
  set$1 = function(it, metadata) {
    if (hasOwn$i(it, STATE))
      throw TypeError$3(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$6(it, STATE, metadata);
    return metadata;
  };
  get$1 = function(it) {
    return hasOwn$i(it, STATE) ? it[STATE] : {};
  };
  has = function(it) {
    return hasOwn$i(it, STATE);
  };
}
var internalState = {
  set: set$1,
  get: get$1,
  has,
  enforce,
  getterFor
};
var fails$z = fails$G;
var isCallable$g = isCallable$o;
var hasOwn$h = hasOwnProperty_1;
var DESCRIPTORS$e = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource$1 = inspectSource$2;
var InternalStateModule$5 = internalState;
var enforceInternalState$2 = InternalStateModule$5.enforce;
var getInternalState$4 = InternalStateModule$5.get;
var defineProperty$b = Object.defineProperty;
var CONFIGURABLE_LENGTH = DESCRIPTORS$e && !fails$z(function() {
  return defineProperty$b(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {
  if (String(name).slice(0, 7) === "Symbol(") {
    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter)
    name = "get " + name;
  if (options && options.setter)
    name = "set " + name;
  if (!hasOwn$h(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    if (DESCRIPTORS$e)
      defineProperty$b(value, "name", { value: name, configurable: true });
    else
      value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$h(options, "arity") && value.length !== options.arity) {
    defineProperty$b(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$h(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$e)
        defineProperty$b(value, "prototype", { writable: false });
    } else if (value.prototype)
      value.prototype = void 0;
  } catch (error2) {
  }
  var state = enforceInternalState$2(value);
  if (!hasOwn$h(state, "source")) {
    state.source = TEMPLATE.join(typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$1(function toString() {
  return isCallable$g(this) && getInternalState$4(this).source || inspectSource$1(this);
}, "toString");
var isCallable$f = isCallable$o;
var definePropertyModule$5 = objectDefineProperty;
var makeBuiltIn = makeBuiltInExports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$c = function(O, key, value, options) {
  if (!options)
    options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$f(value))
    makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple)
      O[key] = value;
    else
      defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe)
        delete O[key];
      else if (O[key])
        simple = true;
    } catch (error2) {
    }
    if (simple)
      O[key] = value;
    else
      definePropertyModule$5.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
  }
  return O;
};
var objectGetOwnPropertyNames = {};
var ceil$1 = Math.ceil;
var floor$4 = Math.floor;
var mathTrunc = Math.trunc || function trunc(x2) {
  var n2 = +x2;
  return (n2 > 0 ? floor$4 : ceil$1)(n2);
};
var trunc2 = mathTrunc;
var toIntegerOrInfinity$8 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2(number);
};
var toIntegerOrInfinity$7 = toIntegerOrInfinity$8;
var max$4 = Math.max;
var min$7 = Math.min;
var toAbsoluteIndex$5 = function(index2, length) {
  var integer = toIntegerOrInfinity$7(index2);
  return integer < 0 ? max$4(integer + length, 0) : min$7(integer, length);
};
var toIntegerOrInfinity$6 = toIntegerOrInfinity$8;
var min$6 = Math.min;
var toLength$7 = function(argument) {
  return argument > 0 ? min$6(toIntegerOrInfinity$6(argument), 9007199254740991) : 0;
};
var toLength$6 = toLength$7;
var lengthOfArrayLike$c = function(obj) {
  return toLength$6(obj.length);
};
var toIndexedObject$b = toIndexedObject$d;
var toAbsoluteIndex$4 = toAbsoluteIndex$5;
var lengthOfArrayLike$b = lengthOfArrayLike$c;
var createMethod$6 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$b($this);
    var length = lengthOfArrayLike$b(O);
    var index2 = toAbsoluteIndex$4(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index2) {
        value = O[index2++];
        if (value != value)
          return true;
      }
    else
      for (; length > index2; index2++) {
        if ((IS_INCLUDES || index2 in O) && O[index2] === el)
          return IS_INCLUDES || index2 || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$6(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$6(false)
};
var uncurryThis$B = functionUncurryThis;
var hasOwn$g = hasOwnProperty_1;
var toIndexedObject$a = toIndexedObject$d;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$4 = hiddenKeys$6;
var push$7 = uncurryThis$B([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject$a(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$g(hiddenKeys$4, key) && hasOwn$g(O, key) && push$7(result, key);
  while (names.length > i)
    if (hasOwn$g(O, key = names[i++])) {
      ~indexOf$1(result, key) || push$7(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$3 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$3);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$7 = getBuiltIn$a;
var uncurryThis$A = functionUncurryThis;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols;
var anObject$j = anObject$l;
var concat$3 = uncurryThis$A([].concat);
var ownKeys$k = getBuiltIn$7("Reflect", "ownKeys") || function ownKeys(it) {
  var keys3 = getOwnPropertyNamesModule$2.f(anObject$j(it));
  var getOwnPropertySymbols3 = getOwnPropertySymbolsModule$3.f;
  return getOwnPropertySymbols3 ? concat$3(keys3, getOwnPropertySymbols3(it)) : keys3;
};
var hasOwn$f = hasOwnProperty_1;
var ownKeys$j = ownKeys$k;
var getOwnPropertyDescriptorModule$3 = objectGetOwnPropertyDescriptor;
var definePropertyModule$4 = objectDefineProperty;
var copyConstructorProperties$2 = function(target, source, exceptions) {
  var keys3 = ownKeys$j(source);
  var defineProperty5 = definePropertyModule$4.f;
  var getOwnPropertyDescriptor5 = getOwnPropertyDescriptorModule$3.f;
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (!hasOwn$f(target, key) && !(exceptions && hasOwn$f(exceptions, key))) {
      defineProperty5(target, key, getOwnPropertyDescriptor5(source, key));
    }
  }
};
var fails$y = fails$G;
var isCallable$e = isCallable$o;
var replacement = /#|\.prototype\./;
var isForced$4 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$e(detection) ? fails$y(detection) : !!detection;
};
var normalize = isForced$4.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$4.data = {};
var NATIVE = isForced$4.NATIVE = "N";
var POLYFILL = isForced$4.POLYFILL = "P";
var isForced_1 = isForced$4;
var global$j = global$s;
var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$7;
var defineBuiltIn$b = defineBuiltIn$c;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties$1 = copyConstructorProperties$2;
var isForced$3 = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$j;
  } else if (STATIC) {
    target = global$j[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$j[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$5(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced$3(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties$1(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$5(sourceProperty, "sham", true);
      }
      defineBuiltIn$b(target, key, sourceProperty, options);
    }
};
var fails$x = fails$G;
var correctPrototypeGetter = !fails$x(function() {
  function F() {
  }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$e = hasOwnProperty_1;
var isCallable$d = isCallable$o;
var toObject$d = toObject$f;
var sharedKey$2 = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var IE_PROTO$1 = sharedKey$2("IE_PROTO");
var $Object$1 = Object;
var ObjectPrototype$2 = $Object$1.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? $Object$1.getPrototypeOf : function(O) {
  var object = toObject$d(O);
  if (hasOwn$e(object, IE_PROTO$1))
    return object[IE_PROTO$1];
  var constructor = object.constructor;
  if (isCallable$d(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof $Object$1 ? ObjectPrototype$2 : null;
};
var $$M = _export;
var fails$w = fails$G;
var toObject$c = toObject$f;
var nativeGetPrototypeOf = objectGetPrototypeOf;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$4 = fails$w(function() {
  nativeGetPrototypeOf(1);
});
$$M({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$4, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject$c(it));
  }
});
var objectDefineProperties = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$4 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};
var DESCRIPTORS$d = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$3 = objectDefineProperty;
var anObject$i = anObject$l;
var toIndexedObject$9 = toIndexedObject$d;
var objectKeys$3 = objectKeys$4;
objectDefineProperties.f = DESCRIPTORS$d && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$i(O);
  var props = toIndexedObject$9(Properties);
  var keys3 = objectKeys$3(Properties);
  var length = keys3.length;
  var index2 = 0;
  var key;
  while (length > index2)
    definePropertyModule$3.f(O, key = keys3[index2++], props[key]);
  return O;
};
var getBuiltIn$6 = getBuiltIn$a;
var html$4 = getBuiltIn$6("document", "documentElement");
var anObject$h = anObject$l;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = hiddenKeys$6;
var html$3 = html$4;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$1 = sharedKey$4;
var GT = ">";
var LT = "<";
var PROTOTYPE$1 = "prototype";
var SCRIPT = "script";
var IE_PROTO = sharedKey$1("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$3.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error2) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys$2[IE_PROTO] = true;
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$h(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null;
    result[IE_PROTO] = O;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule$1.f(result, Properties);
};
var wellKnownSymbol$n = wellKnownSymbol$p;
var create$5 = objectCreate;
var defineProperty$a = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$n("unscopables");
var ArrayPrototype$1 = Array.prototype;
if (ArrayPrototype$1[UNSCOPABLES] == void 0) {
  defineProperty$a(ArrayPrototype$1, UNSCOPABLES, {
    configurable: true,
    value: create$5(null)
  });
}
var addToUnscopables$5 = function(key) {
  ArrayPrototype$1[UNSCOPABLES][key] = true;
};
var $$L = _export;
var $includes = arrayIncludes.includes;
var fails$v = fails$G;
var addToUnscopables$4 = addToUnscopables$5;
var BROKEN_ON_SPARSE = fails$v(function() {
  return !Array(1).includes();
});
$$L({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$4("includes");
var isObject$h = isObject$n;
var classof$a = classofRaw$2;
var wellKnownSymbol$m = wellKnownSymbol$p;
var MATCH$2 = wellKnownSymbol$m("match");
var isRegexp = function(it) {
  var isRegExp2;
  return isObject$h(it) && ((isRegExp2 = it[MATCH$2]) !== void 0 ? !!isRegExp2 : classof$a(it) == "RegExp");
};
var isRegExp$3 = isRegexp;
var $TypeError$b = TypeError;
var notARegexp = function(it) {
  if (isRegExp$3(it)) {
    throw $TypeError$b("The method doesn't accept regular expressions");
  }
  return it;
};
var wellKnownSymbol$l = wellKnownSymbol$p;
var TO_STRING_TAG$3 = wellKnownSymbol$l("toStringTag");
var test$2 = {};
test$2[TO_STRING_TAG$3] = "z";
var toStringTagSupport = String(test$2) === "[object z]";
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$c = isCallable$o;
var classofRaw = classofRaw$2;
var wellKnownSymbol$k = wellKnownSymbol$p;
var TO_STRING_TAG$2 = wellKnownSymbol$k("toStringTag");
var $Object = Object;
var CORRECT_ARGUMENTS = classofRaw(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error2) {
  }
};
var classof$9 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG$2)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable$c(O.callee) ? "Arguments" : result;
};
var classof$8 = classof$9;
var $String$2 = String;
var toString$j = function(argument) {
  if (classof$8(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$2(argument);
};
var wellKnownSymbol$j = wellKnownSymbol$p;
var MATCH$1 = wellKnownSymbol$j("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH$1] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$K = _export;
var uncurryThis$z = functionUncurryThis;
var notARegExp$2 = notARegexp;
var requireObjectCoercible$b = requireObjectCoercible$e;
var toString$i = toString$j;
var correctIsRegExpLogic$2 = correctIsRegexpLogic;
var stringIndexOf$3 = uncurryThis$z("".indexOf);
$$K({ target: "String", proto: true, forced: !correctIsRegExpLogic$2("includes") }, {
  includes: function includes2(searchString) {
    return !!~stringIndexOf$3(
      toString$i(requireObjectCoercible$b(this)),
      toString$i(notARegExp$2(searchString)),
      arguments.length > 1 ? arguments[1] : void 0
    );
  }
});
var classof$7 = classofRaw$2;
var isArray$6 = Array.isArray || function isArray(argument) {
  return classof$7(argument) == "Array";
};
var uncurryThis$y = functionUncurryThis;
var fails$u = fails$G;
var isCallable$b = isCallable$o;
var classof$6 = classof$9;
var getBuiltIn$5 = getBuiltIn$a;
var inspectSource = inspectSource$2;
var noop = function() {
};
var empty$1 = [];
var construct$2 = getBuiltIn$5("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$4 = uncurryThis$y(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$b(argument))
    return false;
  try {
    construct$2(noop, empty$1, argument);
    return true;
  } catch (error2) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$b(argument))
    return false;
  switch (classof$6(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$4(constructorRegExp, inspectSource(argument));
  } catch (error2) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$4 = !construct$2 || fails$u(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var toPropertyKey$1 = toPropertyKey$4;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor$2 = createPropertyDescriptor$5;
var createProperty$6 = function(object, key, value) {
  var propertyKey = toPropertyKey$1(key);
  if (propertyKey in object)
    definePropertyModule$2.f(object, propertyKey, createPropertyDescriptor$2(0, value));
  else
    object[propertyKey] = value;
};
var fails$t = fails$G;
var wellKnownSymbol$i = wellKnownSymbol$p;
var V8_VERSION$1 = engineV8Version;
var SPECIES$5 = wellKnownSymbol$i("species");
var arrayMethodHasSpeciesSupport$5 = function(METHOD_NAME) {
  return V8_VERSION$1 >= 51 || !fails$t(function() {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$5] = function() {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};
var uncurryThis$x = functionUncurryThis;
var arraySlice$8 = uncurryThis$x([].slice);
var $$J = _export;
var isArray$5 = isArray$6;
var isConstructor$3 = isConstructor$4;
var isObject$g = isObject$n;
var toAbsoluteIndex$3 = toAbsoluteIndex$5;
var lengthOfArrayLike$a = lengthOfArrayLike$c;
var toIndexedObject$8 = toIndexedObject$d;
var createProperty$5 = createProperty$6;
var wellKnownSymbol$h = wellKnownSymbol$p;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var nativeSlice = arraySlice$8;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$4("slice");
var SPECIES$4 = wellKnownSymbol$h("species");
var $Array$3 = Array;
var max$3 = Math.max;
$$J({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
  slice: function slice(start, end) {
    var O = toIndexedObject$8(this);
    var length = lengthOfArrayLike$a(O);
    var k2 = toAbsoluteIndex$3(start, length);
    var fin = toAbsoluteIndex$3(end === void 0 ? length : end, length);
    var Constructor, result, n2;
    if (isArray$5(O)) {
      Constructor = O.constructor;
      if (isConstructor$3(Constructor) && (Constructor === $Array$3 || isArray$5(Constructor.prototype))) {
        Constructor = void 0;
      } else if (isObject$g(Constructor)) {
        Constructor = Constructor[SPECIES$4];
        if (Constructor === null)
          Constructor = void 0;
      }
      if (Constructor === $Array$3 || Constructor === void 0) {
        return nativeSlice(O, k2, fin);
      }
    }
    result = new (Constructor === void 0 ? $Array$3 : Constructor)(max$3(fin - k2, 0));
    for (n2 = 0; k2 < fin; k2++, n2++)
      if (k2 in O)
        createProperty$5(result, n2, O[k2]);
    result.length = n2;
    return result;
  }
});
var fails$s = fails$G;
var arrayMethodIsStrict$6 = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$s(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var $$I = _export;
var uncurryThis$w = functionUncurryThis;
var $indexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict$5 = arrayMethodIsStrict$6;
var nativeIndexOf = uncurryThis$w([].indexOf);
var NEGATIVE_ZERO$1 = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
var STRICT_METHOD$5 = arrayMethodIsStrict$5("indexOf");
$$I({ target: "Array", proto: true, forced: NEGATIVE_ZERO$1 || !STRICT_METHOD$5 }, {
  indexOf: function indexOf(searchElement) {
    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
    return NEGATIVE_ZERO$1 ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
  }
});
var uncurryThis$v = functionUncurryThis;
var aCallable$4 = aCallable$6;
var NATIVE_BIND$2 = functionBindNative;
var bind$6 = uncurryThis$v(uncurryThis$v.bind);
var functionBindContext = function(fn, that) {
  aCallable$4(fn);
  return that === void 0 ? fn : NATIVE_BIND$2 ? bind$6(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var isArray$4 = isArray$6;
var isConstructor$2 = isConstructor$4;
var isObject$f = isObject$n;
var wellKnownSymbol$g = wellKnownSymbol$p;
var SPECIES$3 = wellKnownSymbol$g("species");
var $Array$2 = Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C;
  if (isArray$4(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor$2(C) && (C === $Array$2 || isArray$4(C.prototype)))
      C = void 0;
    else if (isObject$f(C)) {
      C = C[SPECIES$3];
      if (C === null)
        C = void 0;
    }
  }
  return C === void 0 ? $Array$2 : C;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$3 = function(originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};
var bind$5 = functionBindContext;
var uncurryThis$u = functionUncurryThis;
var IndexedObject$3 = indexedObject;
var toObject$b = toObject$f;
var lengthOfArrayLike$9 = lengthOfArrayLike$c;
var arraySpeciesCreate$2 = arraySpeciesCreate$3;
var push$6 = uncurryThis$u([].push);
var createMethod$5 = function(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that, specificCreate) {
    var O = toObject$b($this);
    var self2 = IndexedObject$3(O);
    var boundFunction = bind$5(callbackfn, that);
    var length = lengthOfArrayLike$9(self2);
    var index2 = 0;
    var create4 = specificCreate || arraySpeciesCreate$2;
    var target = IS_MAP ? create4($this, length) : IS_FILTER || IS_FILTER_REJECT ? create4($this, 0) : void 0;
    var value, result;
    for (; length > index2; index2++)
      if (NO_HOLES || index2 in self2) {
        value = self2[index2];
        result = boundFunction(value, index2, O);
        if (TYPE) {
          if (IS_MAP)
            target[index2] = result;
          else if (result)
            switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index2;
              case 2:
                push$6(target, value);
            }
          else
            switch (TYPE) {
              case 4:
                return false;
              case 7:
                push$6(target, value);
            }
        }
      }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$5(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$5(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$5(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$5(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$5(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$5(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$5(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$5(7)
};
var $$H = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$3("filter");
$$H({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
  filter: function filter(callbackfn) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$5 = classof$9;
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString2() {
  return "[object " + classof$5(this) + "]";
};
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineBuiltIn$a = defineBuiltIn$c;
var toString$h = objectToString;
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn$a(Object.prototype, "toString", toString$h, { unsafe: true });
}
var isCallable$a = isCallable$o;
var $String$1 = String;
var $TypeError$a = TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$a(argument))
    return argument;
  throw $TypeError$a("Can't set " + $String$1(argument) + " as a prototype");
};
var uncurryThis$t = functionUncurryThis;
var anObject$g = anObject$l;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThis$t(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error2) {
  }
  return function setPrototypeOf2(O, proto) {
    anObject$g(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O, proto);
    else
      O.__proto__ = proto;
    return O;
  };
}() : void 0);
var isCallable$9 = isCallable$o;
var isObject$e = isObject$n;
var setPrototypeOf$3 = objectSetPrototypeOf;
var inheritIfRequired$3 = function($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf$3 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable$9(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$e(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
  )
    setPrototypeOf$3($this, NewTargetPrototype);
  return $this;
};
var anObject$f = anObject$l;
var regexpFlags$1 = function() {
  var that = anObject$f(this);
  var result = "";
  if (that.hasIndices)
    result += "d";
  if (that.global)
    result += "g";
  if (that.ignoreCase)
    result += "i";
  if (that.multiline)
    result += "m";
  if (that.dotAll)
    result += "s";
  if (that.unicode)
    result += "u";
  if (that.unicodeSets)
    result += "v";
  if (that.sticky)
    result += "y";
  return result;
};
var call$h = functionCall;
var hasOwn$d = hasOwnProperty_1;
var isPrototypeOf$6 = objectIsPrototypeOf;
var regExpFlags = regexpFlags$1;
var RegExpPrototype$3 = RegExp.prototype;
var regexpGetFlags = function(R) {
  var flags = R.flags;
  return flags === void 0 && !("flags" in RegExpPrototype$3) && !hasOwn$d(R, "flags") && isPrototypeOf$6(RegExpPrototype$3, R) ? call$h(regExpFlags, R) : flags;
};
var fails$r = fails$G;
var global$i = global$s;
var $RegExp$2 = global$i.RegExp;
var UNSUPPORTED_Y$3 = fails$r(function() {
  var re = $RegExp$2("a", "y");
  re.lastIndex = 2;
  return re.exec("abcd") != null;
});
var MISSED_STICKY$1 = UNSUPPORTED_Y$3 || fails$r(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$3 || fails$r(function() {
  var re = $RegExp$2("^r", "gy");
  re.lastIndex = 2;
  return re.exec("str") != null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY$1,
  UNSUPPORTED_Y: UNSUPPORTED_Y$3
};
var defineProperty$9 = objectDefineProperty.f;
var proxyAccessor$1 = function(Target, Source, key) {
  key in Target || defineProperty$9(Target, key, {
    configurable: true,
    get: function() {
      return Source[key];
    },
    set: function(it) {
      Source[key] = it;
    }
  });
};
var getBuiltIn$4 = getBuiltIn$a;
var definePropertyModule$1 = objectDefineProperty;
var wellKnownSymbol$f = wellKnownSymbol$p;
var DESCRIPTORS$c = descriptors;
var SPECIES$2 = wellKnownSymbol$f("species");
var setSpecies$2 = function(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);
  var defineProperty5 = definePropertyModule$1.f;
  if (DESCRIPTORS$c && Constructor && !Constructor[SPECIES$2]) {
    defineProperty5(Constructor, SPECIES$2, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var fails$q = fails$G;
var global$h = global$s;
var $RegExp$1 = global$h.RegExp;
var regexpUnsupportedDotAll = fails$q(function() {
  var re = $RegExp$1(".", "s");
  return !(re.dotAll && re.exec("\n") && re.flags === "s");
});
var fails$p = fails$G;
var global$g = global$s;
var $RegExp = global$g.RegExp;
var regexpUnsupportedNcg = fails$p(function() {
  var re = $RegExp("(?<a>b)", "g");
  return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
});
var DESCRIPTORS$b = descriptors;
var global$f = global$s;
var uncurryThis$s = functionUncurryThis;
var isForced$2 = isForced_1;
var inheritIfRequired$2 = inheritIfRequired$3;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$7;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var isPrototypeOf$5 = objectIsPrototypeOf;
var isRegExp$2 = isRegexp;
var toString$g = toString$j;
var getRegExpFlags$1 = regexpGetFlags;
var stickyHelpers$2 = regexpStickyHelpers;
var proxyAccessor = proxyAccessor$1;
var defineBuiltIn$9 = defineBuiltIn$c;
var fails$o = fails$G;
var hasOwn$c = hasOwnProperty_1;
var enforceInternalState$1 = internalState.enforce;
var setSpecies$1 = setSpecies$2;
var wellKnownSymbol$e = wellKnownSymbol$p;
var UNSUPPORTED_DOT_ALL$1 = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG$1 = regexpUnsupportedNcg;
var MATCH = wellKnownSymbol$e("match");
var NativeRegExp = global$f.RegExp;
var RegExpPrototype$2 = NativeRegExp.prototype;
var SyntaxError = global$f.SyntaxError;
var exec$3 = uncurryThis$s(RegExpPrototype$2.exec);
var charAt$6 = uncurryThis$s("".charAt);
var replace$6 = uncurryThis$s("".replace);
var stringIndexOf$2 = uncurryThis$s("".indexOf);
var stringSlice$9 = uncurryThis$s("".slice);
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var MISSED_STICKY = stickyHelpers$2.MISSED_STICKY;
var UNSUPPORTED_Y$2 = stickyHelpers$2.UNSUPPORTED_Y;
var BASE_FORCED = DESCRIPTORS$b && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL$1 || UNSUPPORTED_NCG$1 || fails$o(function() {
  re2[MATCH] = false;
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
}));
var handleDotAll = function(string) {
  var length = string.length;
  var index2 = 0;
  var result = "";
  var brackets = false;
  var chr;
  for (; index2 <= length; index2++) {
    chr = charAt$6(string, index2);
    if (chr === "\\") {
      result += chr + charAt$6(string, ++index2);
      continue;
    }
    if (!brackets && chr === ".") {
      result += "[\\s\\S]";
    } else {
      if (chr === "[") {
        brackets = true;
      } else if (chr === "]") {
        brackets = false;
      }
      result += chr;
    }
  }
  return result;
};
var handleNCG = function(string) {
  var length = string.length;
  var index2 = 0;
  var result = "";
  var named = [];
  var names = {};
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = "";
  var chr;
  for (; index2 <= length; index2++) {
    chr = charAt$6(string, index2);
    if (chr === "\\") {
      chr = chr + charAt$6(string, ++index2);
    } else if (chr === "]") {
      brackets = false;
    } else if (!brackets)
      switch (true) {
        case chr === "[":
          brackets = true;
          break;
        case chr === "(":
          if (exec$3(IS_NCG, stringSlice$9(string, index2 + 1))) {
            index2 += 2;
            ncg = true;
          }
          result += chr;
          groupid++;
          continue;
        case (chr === ">" && ncg):
          if (groupname === "" || hasOwn$c(names, groupname)) {
            throw new SyntaxError("Invalid capture group name");
          }
          names[groupname] = true;
          named[named.length] = [groupname, groupid];
          ncg = false;
          groupname = "";
          continue;
      }
    if (ncg)
      groupname += chr;
    else
      result += chr;
  }
  return [result, named];
};
if (isForced$2("RegExp", BASE_FORCED)) {
  var RegExpWrapper = function RegExp2(pattern, flags) {
    var thisIsRegExp = isPrototypeOf$5(RegExpPrototype$2, this);
    var patternIsRegExp = isRegExp$2(pattern);
    var flagsAreUndefined = flags === void 0;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;
    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }
    if (patternIsRegExp || isPrototypeOf$5(RegExpPrototype$2, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined)
        flags = getRegExpFlags$1(rawPattern);
    }
    pattern = pattern === void 0 ? "" : toString$g(pattern);
    flags = flags === void 0 ? "" : toString$g(flags);
    rawPattern = pattern;
    if (UNSUPPORTED_DOT_ALL$1 && "dotAll" in re1) {
      dotAll = !!flags && stringIndexOf$2(flags, "s") > -1;
      if (dotAll)
        flags = replace$6(flags, /s/g, "");
    }
    rawFlags = flags;
    if (MISSED_STICKY && "sticky" in re1) {
      sticky = !!flags && stringIndexOf$2(flags, "y") > -1;
      if (sticky && UNSUPPORTED_Y$2)
        flags = replace$6(flags, /y/g, "");
    }
    if (UNSUPPORTED_NCG$1) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }
    result = inheritIfRequired$2(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$2, RegExpWrapper);
    if (dotAll || sticky || groups.length) {
      state = enforceInternalState$1(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky)
        state.sticky = true;
      if (groups.length)
        state.groups = groups;
    }
    if (pattern !== rawPattern)
      try {
        createNonEnumerableProperty$4(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
      } catch (error2) {
      }
    return result;
  };
  for (var keys$1 = getOwnPropertyNames$1(NativeRegExp), index$1 = 0; keys$1.length > index$1; ) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys$1[index$1++]);
  }
  RegExpPrototype$2.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype$2;
  defineBuiltIn$9(global$f, "RegExp", RegExpWrapper, { constructor: true });
}
setSpecies$1("RegExp");
var call$g = functionCall;
var uncurryThis$r = functionUncurryThis;
var toString$f = toString$j;
var regexpFlags = regexpFlags$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared$3 = sharedExports;
var create$4 = objectCreate;
var getInternalState$3 = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared$3("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$5 = uncurryThis$r("".charAt);
var indexOf2 = uncurryThis$r("".indexOf);
var replace$5 = uncurryThis$r("".replace);
var stringSlice$8 = uncurryThis$r("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re12 = /a/;
  var re22 = /b*/g;
  call$g(nativeExec, re12, "a");
  call$g(nativeExec, re22, "a");
  return re12.lastIndex !== 0 || re22.lastIndex !== 0;
}();
var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH) {
  patchedExec = function exec2(string) {
    var re = this;
    var state = getInternalState$3(re);
    var str = toString$f(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match2, i, object, group;
    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call$g(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re.sticky;
    var flags = call$g(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$5(flags, "y", "");
      if (indexOf2(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$8(str, re.lastIndex);
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$5(str, re.lastIndex - 1) !== "\n")) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG)
      lastIndex = re.lastIndex;
    match2 = call$g(nativeExec, sticky ? reCopy : re, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$8(match2.input, charsAdded);
        match2[0] = stringSlice$8(match2[0], charsAdded);
        match2.index = re.lastIndex;
        re.lastIndex += match2[0].length;
      } else
        re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re.lastIndex = re.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$g(nativeReplace, match2[0], reCopy, function() {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === void 0)
            match2[i] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create$4(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match2[group[1]];
      }
    }
    return match2;
  };
}
var regexpExec$3 = patchedExec;
var $$G = _export;
var exec$2 = regexpExec$3;
$$G({ target: "RegExp", proto: true, forced: /./.exec !== exec$2 }, {
  exec: exec$2
});
var PROPER_FUNCTION_NAME$2 = functionName.PROPER;
var defineBuiltIn$8 = defineBuiltIn$c;
var anObject$e = anObject$l;
var $toString$1 = toString$j;
var fails$n = fails$G;
var getRegExpFlags = regexpGetFlags;
var TO_STRING = "toString";
var RegExpPrototype$1 = RegExp.prototype;
var nativeToString = RegExpPrototype$1[TO_STRING];
var NOT_GENERIC = fails$n(function() {
  return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME$2 && nativeToString.name != TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn$8(RegExp.prototype, TO_STRING, function toString4() {
    var R = anObject$e(this);
    var pattern = $toString$1(R.source);
    var flags = $toString$1(getRegExpFlags(R));
    return "/" + pattern + "/" + flags;
  }, { unsafe: true });
}
var $$F = _export;
var uncurryThis$q = functionUncurryThis;
var IndexedObject$2 = indexedObject;
var toIndexedObject$7 = toIndexedObject$d;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$6;
var nativeJoin = uncurryThis$q([].join);
var ES3_STRINGS = IndexedObject$2 != Object;
var STRICT_METHOD$4 = arrayMethodIsStrict$4("join", ",");
$$F({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD$4 }, {
  join: function join(separator) {
    return nativeJoin(toIndexedObject$7(this), separator === void 0 ? "," : separator);
  }
});
var whitespaces$2 = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF";
var uncurryThis$p = functionUncurryThis;
var requireObjectCoercible$a = requireObjectCoercible$e;
var toString$e = toString$j;
var whitespaces$1 = whitespaces$2;
var replace$4 = uncurryThis$p("".replace);
var whitespace = "[" + whitespaces$1 + "]";
var ltrim = RegExp("^" + whitespace + whitespace + "*");
var rtrim = RegExp(whitespace + whitespace + "*$");
var createMethod$4 = function(TYPE) {
  return function($this) {
    var string = toString$e(requireObjectCoercible$a($this));
    if (TYPE & 1)
      string = replace$4(string, ltrim, "");
    if (TYPE & 2)
      string = replace$4(string, rtrim, "");
    return string;
  };
};
var stringTrim$1 = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$4(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$4(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$4(3)
};
var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
var fails$m = fails$G;
var whitespaces = whitespaces$2;
var non = "âÂá ";
var stringTrimForced = function(METHOD_NAME) {
  return fails$m(function() {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};
var $$E = _export;
var $trim = stringTrim$1.trim;
var forcedStringTrimMethod = stringTrimForced;
$$E({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
  trim: function trim() {
    return $trim(this);
  }
});
var NATIVE_BIND$1 = functionBindNative;
var FunctionPrototype$1 = Function.prototype;
var apply$8 = FunctionPrototype$1.apply;
var call$f = FunctionPrototype$1.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1 ? call$f.bind(apply$8) : function() {
  return call$f.apply(apply$8, arguments);
});
var uncurryThis$o = functionUncurryThis;
var defineBuiltIn$7 = defineBuiltIn$c;
var regexpExec$2 = regexpExec$3;
var fails$l = fails$G;
var wellKnownSymbol$d = wellKnownSymbol$p;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$7;
var SPECIES$1 = wellKnownSymbol$d("species");
var RegExpPrototype = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY2, exec2, FORCED2, SHAM) {
  var SYMBOL2 = wellKnownSymbol$d(KEY2);
  var DELEGATES_TO_SYMBOL = !fails$l(function() {
    var O = {};
    O[SYMBOL2] = function() {
      return 7;
    };
    return ""[KEY2](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$l(function() {
    var execCalled = false;
    var re = /a/;
    if (KEY2 === "split") {
      re = {};
      re.constructor = {};
      re.constructor[SPECIES$1] = function() {
        return re;
      };
      re.flags = "";
      re[SYMBOL2] = /./[SYMBOL2];
    }
    re.exec = function() {
      execCalled = true;
      return null;
    };
    re[SYMBOL2]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
    var uncurriedNativeRegExpMethod = uncurryThis$o(/./[SYMBOL2]);
    var methods = exec2(SYMBOL2, ""[KEY2], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis$o(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec$2 || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });
    defineBuiltIn$7(String.prototype, KEY2, methods[0]);
    defineBuiltIn$7(RegExpPrototype, SYMBOL2, methods[1]);
  }
  if (SHAM)
    createNonEnumerableProperty$3(RegExpPrototype[SYMBOL2], "sham", true);
};
var uncurryThis$n = functionUncurryThis;
var toIntegerOrInfinity$5 = toIntegerOrInfinity$8;
var toString$d = toString$j;
var requireObjectCoercible$9 = requireObjectCoercible$e;
var charAt$4 = uncurryThis$n("".charAt);
var charCodeAt$2 = uncurryThis$n("".charCodeAt);
var stringSlice$7 = uncurryThis$n("".slice);
var createMethod$3 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S = toString$d(requireObjectCoercible$9($this));
    var position = toIntegerOrInfinity$5(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size)
      return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt$2(S, position);
    return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt$2(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$4(S, position) : first : CONVERT_TO_STRING ? stringSlice$7(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$3(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$3(true)
};
var charAt$3 = stringMultibyte.charAt;
var advanceStringIndex$3 = function(S, index2, unicode) {
  return index2 + (unicode ? charAt$3(S, index2).length : 1);
};
var uncurryThis$m = functionUncurryThis;
var toObject$a = toObject$f;
var floor$3 = Math.floor;
var charAt$2 = uncurryThis$m("".charAt);
var replace$3 = uncurryThis$m("".replace);
var stringSlice$6 = uncurryThis$m("".slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
var getSubstitution$1 = function(matched, str, position, captures, namedCaptures, replacement2) {
  var tailPos = position + matched.length;
  var m2 = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== void 0) {
    namedCaptures = toObject$a(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace$3(replacement2, symbols, function(match2, ch) {
    var capture;
    switch (charAt$2(ch, 0)) {
      case "$":
        return "$";
      case "&":
        return matched;
      case "`":
        return stringSlice$6(str, 0, position);
      case "'":
        return stringSlice$6(str, tailPos);
      case "<":
        capture = namedCaptures[stringSlice$6(ch, 1, -1)];
        break;
      default:
        var n2 = +ch;
        if (n2 === 0)
          return match2;
        if (n2 > m2) {
          var f2 = floor$3(n2 / 10);
          if (f2 === 0)
            return match2;
          if (f2 <= m2)
            return captures[f2 - 1] === void 0 ? charAt$2(ch, 1) : captures[f2 - 1] + charAt$2(ch, 1);
          return match2;
        }
        capture = captures[n2 - 1];
    }
    return capture === void 0 ? "" : capture;
  });
};
var call$e = functionCall;
var anObject$d = anObject$l;
var isCallable$8 = isCallable$o;
var classof$4 = classofRaw$2;
var regexpExec$1 = regexpExec$3;
var $TypeError$9 = TypeError;
var regexpExecAbstract = function(R, S) {
  var exec2 = R.exec;
  if (isCallable$8(exec2)) {
    var result = call$e(exec2, R, S);
    if (result !== null)
      anObject$d(result);
    return result;
  }
  if (classof$4(R) === "RegExp")
    return call$e(regexpExec$1, R, S);
  throw $TypeError$9("RegExp#exec called on incompatible receiver");
};
var apply$7 = functionApply;
var call$d = functionCall;
var uncurryThis$l = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$3 = fixRegexpWellKnownSymbolLogic;
var fails$k = fails$G;
var anObject$c = anObject$l;
var isCallable$7 = isCallable$o;
var isNullOrUndefined$8 = isNullOrUndefined$b;
var toIntegerOrInfinity$4 = toIntegerOrInfinity$8;
var toLength$5 = toLength$7;
var toString$c = toString$j;
var requireObjectCoercible$8 = requireObjectCoercible$e;
var advanceStringIndex$2 = advanceStringIndex$3;
var getMethod$5 = getMethod$7;
var getSubstitution = getSubstitution$1;
var regExpExec$3 = regexpExecAbstract;
var wellKnownSymbol$c = wellKnownSymbol$p;
var REPLACE = wellKnownSymbol$c("replace");
var max$2 = Math.max;
var min$5 = Math.min;
var concat$2 = uncurryThis$l([].concat);
var push$5 = uncurryThis$l([].push);
var stringIndexOf$1 = uncurryThis$l("".indexOf);
var stringSlice$5 = uncurryThis$l("".slice);
var maybeToString = function(it) {
  return it === void 0 ? it : String(it);
};
var REPLACE_KEEPS_$0 = function() {
  return "a".replace(/./, "$0") === "$0";
}();
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
  if (/./[REPLACE]) {
    return /./[REPLACE]("a", "$0") === "";
  }
  return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$k(function() {
  var re = /./;
  re.exec = function() {
    var result = [];
    result.groups = { a: "7" };
    return result;
  };
  return "".replace(re, "$<a>") !== "7";
});
fixRegExpWellKnownSymbolLogic$3("replace", function(_, nativeReplace2, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace2(searchValue, replaceValue) {
      var O = requireObjectCoercible$8(this);
      var replacer = isNullOrUndefined$8(searchValue) ? void 0 : getMethod$5(searchValue, REPLACE);
      return replacer ? call$d(replacer, searchValue, O, replaceValue) : call$d(nativeReplace2, toString$c(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(string, replaceValue) {
      var rx = anObject$c(this);
      var S = toString$c(string);
      if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
        var res = maybeCallNative(nativeReplace2, rx, S, replaceValue);
        if (res.done)
          return res.value;
      }
      var functionalReplace = isCallable$7(replaceValue);
      if (!functionalReplace)
        replaceValue = toString$c(replaceValue);
      var global2 = rx.global;
      if (global2) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec$3(rx, S);
        if (result === null)
          break;
        push$5(results, result);
        if (!global2)
          break;
        var matchStr = toString$c(result[0]);
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex$2(S, toLength$5(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = "";
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = toString$c(result[0]);
        var position = max$2(min$5(toIntegerOrInfinity$4(result.index), S.length), 0);
        var captures = [];
        for (var j = 1; j < result.length; j++)
          push$5(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat$2([matched], captures, position, S);
          if (namedCaptures !== void 0)
            push$5(replacerArgs, namedCaptures);
          var replacement2 = toString$c(apply$7(replaceValue, void 0, replacerArgs));
        } else {
          replacement2 = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice$5(S, nextSourcePosition, position) + replacement2;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + stringSlice$5(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
var $TypeError$8 = TypeError;
var MAX_SAFE_INTEGER = 9007199254740991;
var doesNotExceedSafeInteger$2 = function(it) {
  if (it > MAX_SAFE_INTEGER)
    throw $TypeError$8("Maximum allowed index exceeded");
  return it;
};
var $$D = _export;
var fails$j = fails$G;
var isArray$3 = isArray$6;
var isObject$d = isObject$n;
var toObject$9 = toObject$f;
var lengthOfArrayLike$8 = lengthOfArrayLike$c;
var doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$2;
var createProperty$4 = createProperty$6;
var arraySpeciesCreate$1 = arraySpeciesCreate$3;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$b = wellKnownSymbol$p;
var V8_VERSION = engineV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$b("isConcatSpreadable");
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$j(function() {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$2("concat");
var isConcatSpreadable = function(O) {
  if (!isObject$d(O))
    return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== void 0 ? !!spreadable : isArray$3(O);
};
var FORCED$6 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
$$D({ target: "Array", proto: true, arity: 1, forced: FORCED$6 }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject$9(this);
    var A2 = arraySpeciesCreate$1(O, 0);
    var n2 = 0;
    var i, k2, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike$8(E);
        doesNotExceedSafeInteger$1(n2 + len);
        for (k2 = 0; k2 < len; k2++, n2++)
          if (k2 in E)
            createProperty$4(A2, n2, E[k2]);
      } else {
        doesNotExceedSafeInteger$1(n2 + 1);
        createProperty$4(A2, n2++, E);
      }
    }
    A2.length = n2;
    return A2;
  }
});
var objectGetOwnPropertyNamesExternal = {};
var toAbsoluteIndex$2 = toAbsoluteIndex$5;
var lengthOfArrayLike$7 = lengthOfArrayLike$c;
var createProperty$3 = createProperty$6;
var $Array$1 = Array;
var max$1 = Math.max;
var arraySliceSimple = function(O, start, end) {
  var length = lengthOfArrayLike$7(O);
  var k2 = toAbsoluteIndex$2(start, length);
  var fin = toAbsoluteIndex$2(end === void 0 ? length : end, length);
  var result = $Array$1(max$1(fin - k2, 0));
  for (var n2 = 0; k2 < fin; k2++, n2++)
    createProperty$3(result, n2, O[k2]);
  result.length = n2;
  return result;
};
var classof$3 = classofRaw$2;
var toIndexedObject$6 = toIndexedObject$d;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$7 = arraySliceSimple;
var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
  try {
    return $getOwnPropertyNames$1(it);
  } catch (error2) {
    return arraySlice$7(windowNames);
  }
};
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames2(it) {
  return windowNames && classof$3(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$6(it));
};
var wellKnownSymbolWrapped = {};
var wellKnownSymbol$a = wellKnownSymbol$p;
wellKnownSymbolWrapped.f = wellKnownSymbol$a;
var global$e = global$s;
var path$1 = global$e;
var path = path$1;
var hasOwn$b = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$8 = objectDefineProperty.f;
var wellKnownSymbolDefine = function(NAME2) {
  var Symbol2 = path.Symbol || (path.Symbol = {});
  if (!hasOwn$b(Symbol2, NAME2))
    defineProperty$8(Symbol2, NAME2, {
      value: wrappedWellKnownSymbolModule$1.f(NAME2)
    });
};
var call$c = functionCall;
var getBuiltIn$3 = getBuiltIn$a;
var wellKnownSymbol$9 = wellKnownSymbol$p;
var defineBuiltIn$6 = defineBuiltIn$c;
var symbolDefineToPrimitive = function() {
  var Symbol2 = getBuiltIn$3("Symbol");
  var SymbolPrototype2 = Symbol2 && Symbol2.prototype;
  var valueOf = SymbolPrototype2 && SymbolPrototype2.valueOf;
  var TO_PRIMITIVE2 = wellKnownSymbol$9("toPrimitive");
  if (SymbolPrototype2 && !SymbolPrototype2[TO_PRIMITIVE2]) {
    defineBuiltIn$6(SymbolPrototype2, TO_PRIMITIVE2, function(hint) {
      return call$c(valueOf, this);
    }, { arity: 1 });
  }
};
var defineProperty$7 = objectDefineProperty.f;
var hasOwn$a = hasOwnProperty_1;
var wellKnownSymbol$8 = wellKnownSymbol$p;
var TO_STRING_TAG$1 = wellKnownSymbol$8("toStringTag");
var setToStringTag$4 = function(target, TAG, STATIC) {
  if (target && !STATIC)
    target = target.prototype;
  if (target && !hasOwn$a(target, TO_STRING_TAG$1)) {
    defineProperty$7(target, TO_STRING_TAG$1, { configurable: true, value: TAG });
  }
};
var $$C = _export;
var global$d = global$s;
var call$b = functionCall;
var uncurryThis$k = functionUncurryThis;
var DESCRIPTORS$a = descriptors;
var NATIVE_SYMBOL$4 = symbolConstructorDetection;
var fails$i = fails$G;
var hasOwn$9 = hasOwnProperty_1;
var isPrototypeOf$4 = objectIsPrototypeOf;
var anObject$b = anObject$l;
var toIndexedObject$5 = toIndexedObject$d;
var toPropertyKey = toPropertyKey$4;
var $toString = toString$j;
var createPropertyDescriptor$1 = createPropertyDescriptor$5;
var nativeObjectCreate = objectCreate;
var objectKeys$2 = objectKeys$4;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
var definePropertyModule = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var defineBuiltIn$5 = defineBuiltIn$c;
var shared$2 = sharedExports;
var sharedKey = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$1 = uid$4;
var wellKnownSymbol$7 = wellKnownSymbol$p;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$1 = wellKnownSymbolDefine;
var defineSymbolToPrimitive = symbolDefineToPrimitive;
var setToStringTag$3 = setToStringTag$4;
var InternalStateModule$4 = internalState;
var $forEach$1 = arrayIteration.forEach;
var HIDDEN = sharedKey("hidden");
var SYMBOL = "Symbol";
var PROTOTYPE = "prototype";
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState$2 = InternalStateModule$4.getterFor(SYMBOL);
var ObjectPrototype$1 = Object[PROTOTYPE];
var $Symbol = global$d.Symbol;
var SymbolPrototype$1 = $Symbol && $Symbol[PROTOTYPE];
var TypeError$2 = global$d.TypeError;
var QObject = global$d.QObject;
var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$2.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;
var push$4 = uncurryThis$k([].push);
var AllSymbols = shared$2("symbols");
var ObjectPrototypeSymbols = shared$2("op-symbols");
var WellKnownSymbolsStore = shared$2("wks");
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var setSymbolDescriptor = DESCRIPTORS$a && fails$i(function() {
  return nativeObjectCreate(nativeDefineProperty({}, "a", {
    get: function() {
      return nativeDefineProperty(this, "a", { value: 7 }).a;
    }
  })).a != 7;
}) ? function(O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);
  if (ObjectPrototypeDescriptor)
    delete ObjectPrototype$1[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
    nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;
var wrap$1 = function(tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype$1);
  setInternalState$4(symbol, {
    type: SYMBOL,
    tag,
    description
  });
  if (!DESCRIPTORS$a)
    symbol.description = description;
  return symbol;
};
var $defineProperty = function defineProperty3(O, P, Attributes) {
  if (O === ObjectPrototype$1)
    $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject$b(O);
  var key = toPropertyKey(P);
  anObject$b(Attributes);
  if (hasOwn$9(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn$9(O, HIDDEN))
        nativeDefineProperty(O, HIDDEN, createPropertyDescriptor$1(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn$9(O, HIDDEN) && O[HIDDEN][key])
        O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor$1(0, false) });
    }
    return setSymbolDescriptor(O, key, Attributes);
  }
  return nativeDefineProperty(O, key, Attributes);
};
var $defineProperties = function defineProperties2(O, Properties) {
  anObject$b(O);
  var properties = toIndexedObject$5(Properties);
  var keys3 = objectKeys$2(properties).concat($getOwnPropertySymbols(properties));
  $forEach$1(keys3, function(key) {
    if (!DESCRIPTORS$a || call$b($propertyIsEnumerable$1, properties, key))
      $defineProperty(O, key, properties[key]);
  });
  return O;
};
var $create = function create2(O, Properties) {
  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};
var $propertyIsEnumerable$1 = function propertyIsEnumerable2(V) {
  var P = toPropertyKey(V);
  var enumerable = call$b(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype$1 && hasOwn$9(AllSymbols, P) && !hasOwn$9(ObjectPrototypeSymbols, P))
    return false;
  return enumerable || !hasOwn$9(this, P) || !hasOwn$9(AllSymbols, P) || hasOwn$9(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O, P) {
  var it = toIndexedObject$5(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype$1 && hasOwn$9(AllSymbols, key) && !hasOwn$9(ObjectPrototypeSymbols, key))
    return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
  if (descriptor && hasOwn$9(AllSymbols, key) && !(hasOwn$9(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames3(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$5(O));
  var result = [];
  $forEach$1(names, function(key) {
    if (!hasOwn$9(AllSymbols, key) && !hasOwn$9(hiddenKeys$1, key))
      push$4(result, key);
  });
  return result;
};
var $getOwnPropertySymbols = function(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$5(O));
  var result = [];
  $forEach$1(names, function(key) {
    if (hasOwn$9(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$9(ObjectPrototype$1, key))) {
      push$4(result, AllSymbols[key]);
    }
  });
  return result;
};
if (!NATIVE_SYMBOL$4) {
  $Symbol = function Symbol2() {
    if (isPrototypeOf$4(SymbolPrototype$1, this))
      throw TypeError$2("Symbol is not a constructor");
    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
    var tag = uid$1(description);
    var setter = function(value) {
      if (this === ObjectPrototype$1)
        call$b(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$9(this, HIDDEN) && hasOwn$9(this[HIDDEN], tag))
        this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor$1(1, value));
    };
    if (DESCRIPTORS$a && USE_SETTER)
      setSymbolDescriptor(ObjectPrototype$1, tag, { configurable: true, set: setter });
    return wrap$1(tag, description);
  };
  SymbolPrototype$1 = $Symbol[PROTOTYPE];
  defineBuiltIn$5(SymbolPrototype$1, "toString", function toString4() {
    return getInternalState$2(this).tag;
  });
  defineBuiltIn$5($Symbol, "withoutSetter", function(description) {
    return wrap$1(uid$1(description), description);
  });
  propertyIsEnumerableModule$1.f = $propertyIsEnumerable$1;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$1.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;
  wrappedWellKnownSymbolModule.f = function(name) {
    return wrap$1(wellKnownSymbol$7(name), name);
  };
  if (DESCRIPTORS$a) {
    nativeDefineProperty(SymbolPrototype$1, "description", {
      configurable: true,
      get: function description() {
        return getInternalState$2(this).description;
      }
    });
    {
      defineBuiltIn$5(ObjectPrototype$1, "propertyIsEnumerable", $propertyIsEnumerable$1, { unsafe: true });
    }
  }
}
$$C({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$4, sham: !NATIVE_SYMBOL$4 }, {
  Symbol: $Symbol
});
$forEach$1(objectKeys$2(WellKnownSymbolsStore), function(name) {
  defineWellKnownSymbol$1(name);
});
$$C({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$4 }, {
  useSetter: function() {
    USE_SETTER = true;
  },
  useSimple: function() {
    USE_SETTER = false;
  }
});
$$C({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$4, sham: !DESCRIPTORS$a }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$C({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$4 }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});
defineSymbolToPrimitive();
setToStringTag$3($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;
var NATIVE_SYMBOL$3 = symbolConstructorDetection;
var symbolRegistryDetection = NATIVE_SYMBOL$3 && !!Symbol["for"] && !!Symbol.keyFor;
var $$B = _export;
var getBuiltIn$2 = getBuiltIn$a;
var hasOwn$8 = hasOwnProperty_1;
var toString$b = toString$j;
var shared$1 = sharedExports;
var NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;
var StringToSymbolRegistry = shared$1("string-to-symbol-registry");
var SymbolToStringRegistry$1 = shared$1("symbol-to-string-registry");
$$B({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, {
  "for": function(key) {
    var string = toString$b(key);
    if (hasOwn$8(StringToSymbolRegistry, string))
      return StringToSymbolRegistry[string];
    var symbol = getBuiltIn$2("Symbol")(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry$1[symbol] = string;
    return symbol;
  }
});
var $$A = _export;
var hasOwn$7 = hasOwnProperty_1;
var isSymbol$2 = isSymbol$5;
var tryToString$4 = tryToString$6;
var shared = sharedExports;
var NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;
var SymbolToStringRegistry = shared("symbol-to-string-registry");
$$A({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol$2(sym))
      throw TypeError(tryToString$4(sym) + " is not a symbol");
    if (hasOwn$7(SymbolToStringRegistry, sym))
      return SymbolToStringRegistry[sym];
  }
});
var $$z = _export;
var getBuiltIn$1 = getBuiltIn$a;
var apply$6 = functionApply;
var call$a = functionCall;
var uncurryThis$j = functionUncurryThis;
var fails$h = fails$G;
var isArray$2 = isArray$6;
var isCallable$6 = isCallable$o;
var isObject$c = isObject$n;
var isSymbol$1 = isSymbol$5;
var arraySlice$6 = arraySlice$8;
var NATIVE_SYMBOL$2 = symbolConstructorDetection;
var $stringify = getBuiltIn$1("JSON", "stringify");
var exec$1 = uncurryThis$j(/./.exec);
var charAt$1 = uncurryThis$j("".charAt);
var charCodeAt$1 = uncurryThis$j("".charCodeAt);
var replace$2 = uncurryThis$j("".replace);
var numberToString = uncurryThis$j(1 .toString);
var tester$1 = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$2 || fails$h(function() {
  var symbol = getBuiltIn$1("Symbol")();
  return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
});
var ILL_FORMED_UNICODE = fails$h(function() {
  return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
});
var stringifyWithSymbolsFix = function(it, replacer) {
  var args = arraySlice$6(arguments);
  var $replacer = replacer;
  if (!isObject$c(replacer) && it === void 0 || isSymbol$1(it))
    return;
  if (!isArray$2(replacer))
    replacer = function(key, value) {
      if (isCallable$6($replacer))
        value = call$a($replacer, this, key, value);
      if (!isSymbol$1(value))
        return value;
    };
  args[1] = replacer;
  return apply$6($stringify, null, args);
};
var fixIllFormed = function(match2, offset2, string) {
  var prev = charAt$1(string, offset2 - 1);
  var next2 = charAt$1(string, offset2 + 1);
  if (exec$1(low, match2) && !exec$1(hi, next2) || exec$1(hi, match2) && !exec$1(low, prev)) {
    return "\\u" + numberToString(charCodeAt$1(match2, 0), 16);
  }
  return match2;
};
if ($stringify) {
  $$z({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify2(it, replacer, space) {
      var args = arraySlice$6(arguments);
      var result = apply$6(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == "string" ? replace$2(result, tester$1, fixIllFormed) : result;
    }
  });
}
var $$y = _export;
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var fails$g = fails$G;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var toObject$8 = toObject$f;
var FORCED$5 = !NATIVE_SYMBOL$1 || fails$g(function() {
  getOwnPropertySymbolsModule$1.f(1);
});
$$y({ target: "Object", stat: true, forced: FORCED$5 }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols2 = getOwnPropertySymbolsModule$1.f;
    return $getOwnPropertySymbols2 ? $getOwnPropertySymbols2(toObject$8(it)) : [];
  }
});
var $$x = _export;
var DESCRIPTORS$9 = descriptors;
var global$c = global$s;
var uncurryThis$i = functionUncurryThis;
var hasOwn$6 = hasOwnProperty_1;
var isCallable$5 = isCallable$o;
var isPrototypeOf$3 = objectIsPrototypeOf;
var toString$a = toString$j;
var defineProperty$6 = objectDefineProperty.f;
var copyConstructorProperties = copyConstructorProperties$2;
var NativeSymbol = global$c.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
if (DESCRIPTORS$9 && isCallable$5(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
NativeSymbol().description !== void 0)) {
  var EmptyStringDescriptionStore = {};
  var SymbolWrapper = function Symbol2() {
    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString$a(arguments[0]);
    var result = isPrototypeOf$3(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
    if (description === "")
      EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;
  var NATIVE_SYMBOL = String(NativeSymbol("test")) == "Symbol(test)";
  var thisSymbolValue = uncurryThis$i(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis$i(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace$1 = uncurryThis$i("".replace);
  var stringSlice$4 = uncurryThis$i("".slice);
  defineProperty$6(SymbolPrototype, "description", {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn$6(EmptyStringDescriptionStore, symbol))
        return "";
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL ? stringSlice$4(string, 7, -1) : replace$1(string, regexp, "$1");
      return desc === "" ? void 0 : desc;
    }
  });
  $$x({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}
var defineWellKnownSymbol = wellKnownSymbolDefine;
defineWellKnownSymbol("iterator");
var iterators = {};
var fails$f = fails$G;
var isCallable$4 = isCallable$o;
var isObject$b = isObject$n;
var getPrototypeOf$3 = objectGetPrototypeOf;
var defineBuiltIn$4 = defineBuiltIn$c;
var wellKnownSymbol$6 = wellKnownSymbol$p;
var ITERATOR$5 = wellKnownSymbol$6("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject$b(IteratorPrototype$2) || fails$f(function() {
  var test2 = {};
  return IteratorPrototype$2[ITERATOR$5].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$2 = {};
if (!isCallable$4(IteratorPrototype$2[ITERATOR$5])) {
  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create$3 = objectCreate;
var createPropertyDescriptor = createPropertyDescriptor$5;
var setToStringTag$2 = setToStringTag$4;
var Iterators$4 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor, NAME2, next2, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  IteratorConstructor.prototype = create$3(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next2) });
  setToStringTag$2(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$4[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var $$w = _export;
var call$9 = functionCall;
var FunctionName = functionName;
var isCallable$3 = isCallable$o;
var createIteratorConstructor = iteratorCreateConstructor;
var getPrototypeOf$2 = objectGetPrototypeOf;
var setPrototypeOf$2 = objectSetPrototypeOf;
var setToStringTag$1 = setToStringTag$4;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$7;
var defineBuiltIn$3 = defineBuiltIn$c;
var wellKnownSymbol$5 = wellKnownSymbol$p;
var Iterators$3 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$4 = wellKnownSymbol$5("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME2, IteratorConstructor, next2, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME2, next2);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys3() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values3() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY2;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf$2) {
          setPrototypeOf$2(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$4])) {
          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);
        }
      }
      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$2(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values3() {
        return call$9(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY2 in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY2 in IterablePrototype)) {
          defineBuiltIn$3(IterablePrototype, KEY2, methods[KEY2]);
        }
      }
    else
      $$w({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
    defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });
  }
  Iterators$3[NAME2] = defaultIterator;
  return methods;
};
var createIterResultObject$3 = function(value, done) {
  return { value, done };
};
var toIndexedObject$4 = toIndexedObject$d;
var addToUnscopables$3 = addToUnscopables$5;
var Iterators$2 = iterators;
var InternalStateModule$3 = internalState;
var defineProperty$5 = objectDefineProperty.f;
var defineIterator$2 = iteratorDefine;
var createIterResultObject$2 = createIterResultObject$3;
var DESCRIPTORS$8 = descriptors;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState$1 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator$2(Array, "Array", function(iterated, kind) {
  setInternalState$3(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$4(iterated),
    // target
    index: 0,
    // next index
    kind
    // kind
  });
}, function() {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index2 = state.index++;
  if (!target || index2 >= target.length) {
    state.target = void 0;
    return createIterResultObject$2(void 0, true);
  }
  if (kind == "keys")
    return createIterResultObject$2(index2, false);
  if (kind == "values")
    return createIterResultObject$2(target[index2], false);
  return createIterResultObject$2([index2, target[index2]], false);
}, "values");
var values = Iterators$2.Arguments = Iterators$2.Array;
addToUnscopables$3("keys");
addToUnscopables$3("values");
addToUnscopables$3("entries");
if (DESCRIPTORS$8 && values.name !== "values")
  try {
    defineProperty$5(values, "name", { value: "values" });
  } catch (error2) {
  }
var charAt = stringMultibyte.charAt;
var toString$9 = toString$j;
var InternalStateModule$2 = internalState;
var defineIterator$1 = iteratorDefine;
var createIterResultObject$1 = createIterResultObject$3;
var STRING_ITERATOR = "String Iterator";
var setInternalState$2 = InternalStateModule$2.set;
var getInternalState = InternalStateModule$2.getterFor(STRING_ITERATOR);
defineIterator$1(String, "String", function(iterated) {
  setInternalState$2(this, {
    type: STRING_ITERATOR,
    string: toString$9(iterated),
    index: 0
  });
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index2 = state.index;
  var point;
  if (index2 >= string.length)
    return createIterResultObject$1(void 0, true);
  point = charAt(string, index2);
  state.index += point.length;
  return createIterResultObject$1(point, false);
});
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$2 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$2 === Object.prototype ? void 0 : DOMTokenListPrototype$2;
var global$b = global$s;
var DOMIterables$1 = domIterables;
var DOMTokenListPrototype$1 = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$7;
var wellKnownSymbol$4 = wellKnownSymbol$p;
var ITERATOR$3 = wellKnownSymbol$4("iterator");
var TO_STRING_TAG = wellKnownSymbol$4("toStringTag");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype$1 = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR$3] !== ArrayValues)
      try {
        createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$3, ArrayValues);
      } catch (error2) {
        CollectionPrototype[ITERATOR$3] = ArrayValues;
      }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables$1[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
          try {
            createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error2) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
      }
  }
};
for (var COLLECTION_NAME$1 in DOMIterables$1) {
  handlePrototype$1(global$b[COLLECTION_NAME$1] && global$b[COLLECTION_NAME$1].prototype, COLLECTION_NAME$1);
}
handlePrototype$1(DOMTokenListPrototype$1, "DOMTokenList");
var call$8 = functionCall;
var anObject$a = anObject$l;
var getMethod$4 = getMethod$7;
var iteratorClose$2 = function(iterator, kind, value) {
  var innerResult, innerError;
  anObject$a(iterator);
  try {
    innerResult = getMethod$4(iterator, "return");
    if (!innerResult) {
      if (kind === "throw")
        throw value;
      return value;
    }
    innerResult = call$8(innerResult, iterator);
  } catch (error2) {
    innerError = true;
    innerResult = error2;
  }
  if (kind === "throw")
    throw value;
  if (innerError)
    throw innerResult;
  anObject$a(innerResult);
  return value;
};
var anObject$9 = anObject$l;
var iteratorClose$1 = iteratorClose$2;
var callWithSafeIterationClosing$1 = function(iterator, fn, value, ENTRIES2) {
  try {
    return ENTRIES2 ? fn(anObject$9(value)[0], value[1]) : fn(value);
  } catch (error2) {
    iteratorClose$1(iterator, "throw", error2);
  }
};
var wellKnownSymbol$3 = wellKnownSymbol$p;
var Iterators$1 = iterators;
var ITERATOR$2 = wellKnownSymbol$3("iterator");
var ArrayPrototype = Array.prototype;
var isArrayIteratorMethod$2 = function(it) {
  return it !== void 0 && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);
};
var classof$2 = classof$9;
var getMethod$3 = getMethod$7;
var isNullOrUndefined$7 = isNullOrUndefined$b;
var Iterators = iterators;
var wellKnownSymbol$2 = wellKnownSymbol$p;
var ITERATOR$1 = wellKnownSymbol$2("iterator");
var getIteratorMethod$3 = function(it) {
  if (!isNullOrUndefined$7(it))
    return getMethod$3(it, ITERATOR$1) || getMethod$3(it, "@@iterator") || Iterators[classof$2(it)];
};
var call$7 = functionCall;
var aCallable$3 = aCallable$6;
var anObject$8 = anObject$l;
var tryToString$3 = tryToString$6;
var getIteratorMethod$2 = getIteratorMethod$3;
var $TypeError$7 = TypeError;
var getIterator$2 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;
  if (aCallable$3(iteratorMethod))
    return anObject$8(call$7(iteratorMethod, argument));
  throw $TypeError$7(tryToString$3(argument) + " is not iterable");
};
var bind$4 = functionBindContext;
var call$6 = functionCall;
var toObject$7 = toObject$f;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$1 = isConstructor$4;
var lengthOfArrayLike$6 = lengthOfArrayLike$c;
var createProperty$2 = createProperty$6;
var getIterator$1 = getIterator$2;
var getIteratorMethod$1 = getIteratorMethod$3;
var $Array = Array;
var arrayFrom = function from(arrayLike) {
  var O = toObject$7(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$1(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  if (mapping)
    mapfn = bind$4(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
  var iteratorMethod = getIteratorMethod$1(O);
  var index2 = 0;
  var length, result, step, iterator, next2, value;
  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod$1(iteratorMethod))) {
    iterator = getIterator$1(O, iteratorMethod);
    next2 = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (; !(step = call$6(next2, iterator)).done; index2++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
      createProperty$2(result, index2, value);
    }
  } else {
    length = lengthOfArrayLike$6(O);
    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
    for (; length > index2; index2++) {
      value = mapping ? mapfn(O[index2], index2) : O[index2];
      createProperty$2(result, index2, value);
    }
  }
  result.length = index2;
  return result;
};
var wellKnownSymbol$1 = wellKnownSymbol$p;
var ITERATOR = wellKnownSymbol$1("iterator");
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error2) {
}
var checkCorrectnessOfIteration$2 = function(exec2, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING)
    return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object);
  } catch (error2) {
  }
  return ITERATION_SUPPORT;
};
var $$v = _export;
var from2 = arrayFrom;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration$1(function(iterable) {
  Array.from(iterable);
});
$$v({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
  from: from2
});
var DESCRIPTORS$7 = descriptors;
var FUNCTION_NAME_EXISTS = functionName.EXISTS;
var uncurryThis$h = functionUncurryThis;
var defineProperty$4 = objectDefineProperty.f;
var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis$h(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec$2 = uncurryThis$h(nameRE.exec);
var NAME = "name";
if (DESCRIPTORS$7 && !FUNCTION_NAME_EXISTS) {
  defineProperty$4(FunctionPrototype, NAME, {
    configurable: true,
    get: function() {
      try {
        return regExpExec$2(nameRE, functionToString(this))[1];
      } catch (error2) {
        return "";
      }
    }
  });
}
var $TypeError$6 = TypeError;
var validateArgumentsLength$2 = function(passed, required) {
  if (passed < required)
    throw $TypeError$6("Not enough arguments");
  return passed;
};
var global$a = global$s;
var apply$5 = functionApply;
var isCallable$2 = isCallable$o;
var userAgent$4 = engineUserAgent;
var arraySlice$5 = arraySlice$8;
var validateArgumentsLength$1 = validateArgumentsLength$2;
var MSIE = /MSIE .\./.test(userAgent$4);
var Function$2 = global$a.Function;
var wrap = function(scheduler) {
  return MSIE ? function(handler, timeout) {
    var boundArgs = validateArgumentsLength$1(arguments.length, 1) > 2;
    var fn = isCallable$2(handler) ? handler : Function$2(handler);
    var args = boundArgs ? arraySlice$5(arguments, 2) : void 0;
    return scheduler(boundArgs ? function() {
      apply$5(fn, this, args);
    } : fn, timeout);
  } : scheduler;
};
var schedulersFix = {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global$a.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global$a.setInterval)
};
var $$u = _export;
var global$9 = global$s;
var setInterval = schedulersFix.setInterval;
$$u({ global: true, bind: true, forced: global$9.setInterval !== setInterval }, {
  setInterval
});
var $$t = _export;
var global$8 = global$s;
var setTimeout$1 = schedulersFix.setTimeout;
$$t({ global: true, bind: true, forced: global$8.setTimeout !== setTimeout$1 }, {
  setTimeout: setTimeout$1
});
function _typeof$1D(obj) {
  "@babel/helpers - typeof";
  return _typeof$1D = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1D(obj);
}
var lastTime = 0;
var vendors = ["ms", "moz", "webkit", "o"];
var _requestAnimationFrame = window.requestAnimationFrame;
var _cancelAnimationFrame = window.cancelAnimationFrame;
for (var x$1 = 0; x$1 < vendors.length && !_requestAnimationFrame; ++x$1) {
  _requestAnimationFrame = window["".concat(vendors[x$1], "RequestAnimationFrame")];
  _cancelAnimationFrame = window["".concat(vendors[x$1], "CancelAnimationFrame")] || window["".concat(vendors[x$1], "CancelRequestAnimationFrame")];
}
if (!_requestAnimationFrame) {
  _requestAnimationFrame = function _requestAnimationFrame2(callback) {
    var currTime = (/* @__PURE__ */ new Date()).getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id2 = window.setTimeout(function() {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id2;
  };
}
if (!_cancelAnimationFrame) {
  _cancelAnimationFrame = function _cancelAnimationFrame2(id2) {
    clearTimeout(id2);
  };
}
function requestAnimationFrame(callback) {
  return _requestAnimationFrame.call(window, callback);
}
function isClassListSupported() {
  return !!document.documentElement.classList;
}
function isTextContentSupported() {
  return !!document.createTextNode("test").textContent;
}
function isGetComputedStyleSupported() {
  return !!window.getComputedStyle;
}
function cancelAnimationFrame(id2) {
  _cancelAnimationFrame.call(window, id2);
}
function isTouchSupported() {
  return "ontouchstart" in window;
}
var _hasCaptionProblem;
function detectCaptionProblem() {
  var TABLE = document.createElement("TABLE");
  TABLE.style.borderSpacing = "0";
  TABLE.style.borderWidth = "0";
  TABLE.style.padding = "0";
  var TBODY = document.createElement("TBODY");
  TABLE.appendChild(TBODY);
  TBODY.appendChild(document.createElement("TR"));
  TBODY.firstChild.appendChild(document.createElement("TD"));
  TBODY.firstChild.firstChild.innerHTML = "<tr><td>t<br>t</td></tr>";
  var CAPTION = document.createElement("CAPTION");
  CAPTION.innerHTML = "c<br>c<br>c<br>c";
  CAPTION.style.padding = "0";
  CAPTION.style.margin = "0";
  TABLE.insertBefore(CAPTION, TBODY);
  document.body.appendChild(TABLE);
  _hasCaptionProblem = TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight;
  document.body.removeChild(TABLE);
}
function hasCaptionProblem() {
  if (_hasCaptionProblem === void 0) {
    detectCaptionProblem();
  }
  return _hasCaptionProblem;
}
var comparisonFunction;
function getComparisonFunction(language) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (comparisonFunction) {
    return comparisonFunction;
  }
  if ((typeof Intl === "undefined" ? "undefined" : _typeof$1D(Intl)) === "object") {
    comparisonFunction = new Intl.Collator(language, options).compare;
  } else if (typeof String.prototype.localeCompare === "function") {
    comparisonFunction = function comparisonFunction2(a, b2) {
      return "".concat(a).localeCompare(b2);
    };
  } else {
    comparisonFunction = function comparisonFunction2(a, b2) {
      if (a === b2) {
        return 0;
      }
      return a > b2 ? -1 : 1;
    };
  }
  return comparisonFunction;
}
var passiveSupported;
function isPassiveEventSupported() {
  if (passiveSupported !== void 0) {
    return passiveSupported;
  }
  try {
    var options = {
      get passive() {
        passiveSupported = true;
      }
    };
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}
var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$6;
var STRICT_METHOD$3 = arrayMethodIsStrict$3("forEach");
var arrayForEach$1 = !STRICT_METHOD$3 ? function forEach(callbackfn) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;
var global$7 = global$s;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var forEach2 = arrayForEach$1;
var createNonEnumerableProperty = createNonEnumerableProperty$7;
var handlePrototype = function(CollectionPrototype) {
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach2)
    try {
      createNonEnumerableProperty(CollectionPrototype, "forEach", forEach2);
    } catch (error2) {
      CollectionPrototype.forEach = forEach2;
    }
};
for (var COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(global$7[COLLECTION_NAME] && global$7[COLLECTION_NAME].prototype);
  }
}
handlePrototype(DOMTokenListPrototype);
var internalMetadataExports = {};
var internalMetadata = {
  get exports() {
    return internalMetadataExports;
  },
  set exports(v2) {
    internalMetadataExports = v2;
  }
};
var fails$e = fails$G;
var arrayBufferNonExtensible = fails$e(function() {
  if (typeof ArrayBuffer == "function") {
    var buffer = new ArrayBuffer(8);
    if (Object.isExtensible(buffer))
      Object.defineProperty(buffer, "a", { value: 8 });
  }
});
var fails$d = fails$G;
var isObject$a = isObject$n;
var classof$1 = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES$3 = fails$d(function() {
  $isExtensible(1);
});
var objectIsExtensible = FAILS_ON_PRIMITIVES$3 || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$a(it))
    return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$1(it) == "ArrayBuffer")
    return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;
var fails$c = fails$G;
var freezing = !fails$c(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var $$s = _export;
var uncurryThis$g = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$9 = isObject$n;
var hasOwn$5 = hasOwnProperty_1;
var defineProperty$3 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid = uid$4;
var FREEZING$1 = freezing;
var REQUIRED = false;
var METADATA = uid("meta");
var id$1 = 0;
var setMetadata = function(it) {
  defineProperty$3(it, METADATA, { value: {
    objectID: "O" + id$1++,
    // object ID
    weakData: {}
    // weak collections IDs
  } });
};
var fastKey$1 = function(it, create4) {
  if (!isObject$9(it))
    return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
  if (!hasOwn$5(it, METADATA)) {
    if (!isExtensible$1(it))
      return "F";
    if (!create4)
      return "E";
    setMetadata(it);
  }
  return it[METADATA].objectID;
};
var getWeakData$1 = function(it, create4) {
  if (!hasOwn$5(it, METADATA)) {
    if (!isExtensible$1(it))
      return true;
    if (!create4)
      return false;
    setMetadata(it);
  }
  return it[METADATA].weakData;
};
var onFreeze$1 = function(it) {
  if (FREEZING$1 && REQUIRED && isExtensible$1(it) && !hasOwn$5(it, METADATA))
    setMetadata(it);
  return it;
};
var enable = function() {
  meta.enable = function() {
  };
  REQUIRED = true;
  var getOwnPropertyNames5 = getOwnPropertyNamesModule.f;
  var splice3 = uncurryThis$g([].splice);
  var test2 = {};
  test2[METADATA] = 1;
  if (getOwnPropertyNames5(test2).length) {
    getOwnPropertyNamesModule.f = function(it) {
      var result = getOwnPropertyNames5(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice3(result, i, 1);
          break;
        }
      }
      return result;
    };
    $$s({ target: "Object", stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze: onFreeze$1
};
hiddenKeys[METADATA] = true;
var bind$3 = functionBindContext;
var call$5 = functionCall;
var anObject$7 = anObject$l;
var tryToString$2 = tryToString$6;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike$5 = lengthOfArrayLike$c;
var isPrototypeOf$2 = objectIsPrototypeOf;
var getIterator = getIterator$2;
var getIteratorMethod = getIteratorMethod$3;
var iteratorClose = iteratorClose$2;
var $TypeError$5 = TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$3 = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$3(unboundFunction, that);
  var iterator, iterFn, index2, length, result, next2, step;
  var stop = function(condition2) {
    if (iterator)
      iteratorClose(iterator, "normal", condition2);
    return new Result(true, condition2);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$7(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn)
      throw $TypeError$5(tryToString$2(iterable) + " is not iterable");
    if (isArrayIteratorMethod(iterFn)) {
      for (index2 = 0, length = lengthOfArrayLike$5(iterable); length > index2; index2++) {
        result = callFn(iterable[index2]);
        if (result && isPrototypeOf$2(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }
  next2 = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call$5(next2, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error2) {
      iteratorClose(iterator, "throw", error2);
    }
    if (typeof result == "object" && result && isPrototypeOf$2(ResultPrototype, result))
      return result;
  }
  return new Result(false);
};
var isPrototypeOf$1 = objectIsPrototypeOf;
var $TypeError$4 = TypeError;
var anInstance$3 = function(it, Prototype) {
  if (isPrototypeOf$1(Prototype, it))
    return it;
  throw $TypeError$4("Incorrect invocation");
};
var $$r = _export;
var global$6 = global$s;
var uncurryThis$f = functionUncurryThis;
var isForced$1 = isForced_1;
var defineBuiltIn$2 = defineBuiltIn$c;
var InternalMetadataModule$1 = internalMetadataExports;
var iterate$2 = iterate$3;
var anInstance$2 = anInstance$3;
var isCallable$1 = isCallable$o;
var isNullOrUndefined$6 = isNullOrUndefined$b;
var isObject$8 = isObject$n;
var fails$b = fails$G;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;
var setToStringTag = setToStringTag$4;
var inheritIfRequired$1 = inheritIfRequired$3;
var collection$5 = function(CONSTRUCTOR_NAME, wrapper2, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
  var ADDER = IS_MAP ? "set" : "add";
  var NativeConstructor = global$6[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};
  var fixMethod = function(KEY2) {
    var uncurriedNativeMethod = uncurryThis$f(NativePrototype[KEY2]);
    defineBuiltIn$2(
      NativePrototype,
      KEY2,
      KEY2 == "add" ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY2 == "delete" ? function(key) {
        return IS_WEAK && !isObject$8(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY2 == "get" ? function get2(key) {
        return IS_WEAK && !isObject$8(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY2 == "has" ? function has2(key) {
        return IS_WEAK && !isObject$8(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set2(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };
  var REPLACE2 = isForced$1(
    CONSTRUCTOR_NAME,
    !isCallable$1(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$b(function() {
      new NativeConstructor().entries().next();
    }))
  );
  if (REPLACE2) {
    Constructor = common.getConstructor(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else if (isForced$1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    var THROWS_ON_PRIMITIVES = fails$b(function() {
      instance.has(1);
    });
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
      new NativeConstructor(iterable);
    });
    var BUGGY_ZERO = !IS_WEAK && fails$b(function() {
      var $instance = new NativeConstructor();
      var index2 = 5;
      while (index2--)
        $instance[ADDER](index2, index2);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper2(function(dummy, iterable) {
        anInstance$2(dummy, NativePrototype);
        var that = inheritIfRequired$1(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined$6(iterable))
          iterate$2(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod("delete");
      fixMethod("has");
      IS_MAP && fixMethod("get");
    }
    if (BUGGY_ZERO || HASNT_CHAINING)
      fixMethod(ADDER);
    if (IS_WEAK && NativePrototype.clear)
      delete NativePrototype.clear;
  }
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$r({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);
  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK)
    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};
var defineBuiltIn$1 = defineBuiltIn$c;
var defineBuiltIns$3 = function(target, src, options) {
  for (var key in src)
    defineBuiltIn$1(target, key, src[key], options);
  return target;
};
var defineProperty$2 = objectDefineProperty.f;
var create$2 = objectCreate;
var defineBuiltIns$2 = defineBuiltIns$3;
var bind$2 = functionBindContext;
var anInstance$1 = anInstance$3;
var isNullOrUndefined$5 = isNullOrUndefined$b;
var iterate$1 = iterate$3;
var defineIterator = iteratorDefine;
var createIterResultObject = createIterResultObject$3;
var setSpecies = setSpecies$2;
var DESCRIPTORS$6 = descriptors;
var fastKey = internalMetadataExports.fastKey;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var internalStateGetterFor$1 = InternalStateModule$1.getterFor;
var collectionStrong$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper2(function(that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$1(that, {
        type: CONSTRUCTOR_NAME,
        index: create$2(null),
        first: void 0,
        last: void 0,
        size: 0
      });
      if (!DESCRIPTORS$6)
        that.size = 0;
      if (!isNullOrUndefined$5(iterable))
        iterate$1(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var entry = getEntry(that, key);
      var previous, index2;
      if (entry) {
        entry.value = value;
      } else {
        state.last = entry = {
          index: index2 = fastKey(key, true),
          key,
          value,
          previous: previous = state.last,
          next: void 0,
          removed: false
        };
        if (!state.first)
          state.first = entry;
        if (previous)
          previous.next = entry;
        if (DESCRIPTORS$6)
          state.size++;
        else
          that.size++;
        if (index2 !== "F")
          state.index[index2] = entry;
      }
      return that;
    };
    var getEntry = function(that, key) {
      var state = getInternalState2(that);
      var index2 = fastKey(key);
      var entry;
      if (index2 !== "F")
        return state.index[index2];
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key)
          return entry;
      }
    };
    defineBuiltIns$2(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear2() {
        var that = this;
        var state = getInternalState2(that);
        var data2 = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous)
            entry.previous = entry.previous.next = void 0;
          delete data2[entry.index];
          entry = entry.next;
        }
        state.first = state.last = void 0;
        if (DESCRIPTORS$6)
          state.size = 0;
        else
          that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      "delete": function(key) {
        var that = this;
        var state = getInternalState2(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next2 = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev)
            prev.next = next2;
          if (next2)
            next2.previous = prev;
          if (state.first == entry)
            state.first = next2;
          if (state.last == entry)
            state.last = prev;
          if (DESCRIPTORS$6)
            state.size--;
          else
            that.size--;
        }
        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach3(callbackfn) {
        var state = getInternalState2(this);
        var boundFunction = bind$2(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          while (entry && entry.removed)
            entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has2(key) {
        return !!getEntry(this, key);
      }
    });
    defineBuiltIns$2(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get2(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set2(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$6)
      defineProperty$2(Prototype, "size", {
        get: function() {
          return getInternalState2(this).size;
        }
      });
    return Constructor;
  },
  setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);
    defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
      setInternalState$1(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind,
        last: void 0
      });
    }, function() {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      while (entry && entry.removed)
        entry = entry.previous;
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      if (kind == "keys")
        return createIterResultObject(entry.key, false);
      if (kind == "values")
        return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
    setSpecies(CONSTRUCTOR_NAME);
  }
};
var collection$4 = collection$5;
var collectionStrong$1 = collectionStrong$2;
collection$4("Set", function(init) {
  return function Set2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong$1);
var isConstructor3 = isConstructor$4;
var tryToString$1 = tryToString$6;
var $TypeError$3 = TypeError;
var aConstructor$2 = function(argument) {
  if (isConstructor3(argument))
    return argument;
  throw $TypeError$3(tryToString$1(argument) + " is not a constructor");
};
var anObject$6 = anObject$l;
var aConstructor$1 = aConstructor$2;
var isNullOrUndefined$4 = isNullOrUndefined$b;
var wellKnownSymbol = wellKnownSymbol$p;
var SPECIES = wellKnownSymbol("species");
var speciesConstructor$1 = function(O, defaultConstructor) {
  var C = anObject$6(O).constructor;
  var S;
  return C === void 0 || isNullOrUndefined$4(S = anObject$6(C)[SPECIES]) ? defaultConstructor : aConstructor$1(S);
};
var apply$4 = functionApply;
var call$4 = functionCall;
var uncurryThis$e = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
var anObject$5 = anObject$l;
var isNullOrUndefined$3 = isNullOrUndefined$b;
var isRegExp$1 = isRegexp;
var requireObjectCoercible$7 = requireObjectCoercible$e;
var speciesConstructor = speciesConstructor$1;
var advanceStringIndex$1 = advanceStringIndex$3;
var toLength$4 = toLength$7;
var toString$8 = toString$j;
var getMethod$2 = getMethod$7;
var arraySlice$4 = arraySliceSimple;
var callRegExpExec = regexpExecAbstract;
var regexpExec = regexpExec$3;
var stickyHelpers = regexpStickyHelpers;
var fails$a = fails$G;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min$4 = Math.min;
var $push = [].push;
var exec = uncurryThis$e(/./.exec);
var push$3 = uncurryThis$e($push);
var stringSlice$3 = uncurryThis$e("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$a(function() {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function() {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
fixRegExpWellKnownSymbolLogic$2("split", function(SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if ("abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
  "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
  ".".split(/()()/).length > 1 || "".split(/.?/).length) {
    internalSplit = function(separator, limit) {
      var string = toString$8(requireObjectCoercible$7(this));
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (separator === void 0)
        return [string];
      if (!isRegExp$1(separator)) {
        return call$4(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
      var lastLastIndex = 0;
      var separatorCopy = new RegExp(separator.source, flags + "g");
      var match2, lastIndex, lastLength;
      while (match2 = call$4(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push$3(output, stringSlice$3(string, lastLastIndex, match2.index));
          if (match2.length > 1 && match2.index < string.length)
            apply$4($push, output, arraySlice$4(match2, 1));
          lastLength = match2[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim)
            break;
        }
        if (separatorCopy.lastIndex === match2.index)
          separatorCopy.lastIndex++;
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec(separatorCopy, ""))
          push$3(output, "");
      } else
        push$3(output, stringSlice$3(string, lastLastIndex));
      return output.length > lim ? arraySlice$4(output, 0, lim) : output;
    };
  } else if ("0".split(void 0, 0).length) {
    internalSplit = function(separator, limit) {
      return separator === void 0 && limit === 0 ? [] : call$4(nativeSplit, this, separator, limit);
    };
  } else
    internalSplit = nativeSplit;
  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split2(separator, limit) {
      var O = requireObjectCoercible$7(this);
      var splitter = isNullOrUndefined$3(separator) ? void 0 : getMethod$2(separator, SPLIT);
      return splitter ? call$4(splitter, separator, O, limit) : call$4(internalSplit, toString$8(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function(string, limit) {
      var rx = anObject$5(this);
      var S = toString$8(string);
      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
      if (res.done)
        return res.value;
      var C = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
      var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (S.length === 0)
        return callRegExpExec(splitter, S) === null ? [S] : [];
      var p2 = 0;
      var q2 = 0;
      var A2 = [];
      while (q2 < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
        var z2 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice$3(S, q2) : S);
        var e2;
        if (z2 === null || (e2 = min$4(toLength$4(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S.length)) === p2) {
          q2 = advanceStringIndex$1(S, q2, unicodeMatching);
        } else {
          push$3(A2, stringSlice$3(S, p2, q2));
          if (A2.length === lim)
            return A2;
          for (var i = 1; i <= z2.length - 1; i++) {
            push$3(A2, z2[i]);
            if (A2.length === lim)
              return A2;
          }
          q2 = p2 = e2;
        }
      }
      push$3(A2, stringSlice$3(S, p2));
      return A2;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
function to2dArray(arr) {
  var ilen = arr.length;
  var i = 0;
  while (i < ilen) {
    arr[i] = [arr[i]];
    i += 1;
  }
}
function extendArray(arr, extension) {
  var ilen = extension.length;
  var i = 0;
  while (i < ilen) {
    arr.push(extension[i]);
    i += 1;
  }
}
function pivot(arr) {
  var pivotedArr = [];
  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
    return pivotedArr;
  }
  var rowCount = arr.length;
  var colCount = arr[0].length;
  for (var i = 0; i < rowCount; i++) {
    for (var j = 0; j < colCount; j++) {
      if (!pivotedArr[j]) {
        pivotedArr[j] = [];
      }
      pivotedArr[j][i] = arr[i][j];
    }
  }
  return pivotedArr;
}
function arrayReduce$1(array, iteratee, accumulator, initFromArray) {
  var index2 = -1;
  var iterable = array;
  var result = accumulator;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  if (initFromArray && length) {
    index2 += 1;
    result = iterable[index2];
  }
  index2 += 1;
  while (index2 < length) {
    result = iteratee(result, iterable[index2], index2, iterable);
    index2 += 1;
  }
  return result;
}
function arrayFilter(array, predicate) {
  var index2 = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  var result = [];
  var resIndex = -1;
  while (index2 < length) {
    var value = iterable[index2];
    if (predicate(value, index2, iterable)) {
      resIndex += 1;
      result[resIndex] = value;
    }
    index2 += 1;
  }
  return result;
}
function arrayMap(array, iteratee) {
  var index2 = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  var result = [];
  var resIndex = -1;
  while (index2 < length) {
    var value = iterable[index2];
    resIndex += 1;
    result[resIndex] = iteratee(value, index2, iterable);
    index2 += 1;
  }
  return result;
}
function arrayEach(array, iteratee) {
  var index2 = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  while (index2 < length) {
    if (iteratee(iterable[index2], index2, iterable) === false) {
      break;
    }
    index2 += 1;
  }
  return array;
}
function arrayUnique(array) {
  var unique = [];
  arrayEach(array, function(value) {
    if (unique.indexOf(value) === -1) {
      unique.push(value);
    }
  });
  return unique;
}
function getDifferenceOfArrays() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }
  var _ref2 = [].concat(arrays), first = _ref2[0], rest = _ref2.slice(1);
  var filteredFirstArray = first;
  arrayEach(rest, function(array) {
    filteredFirstArray = filteredFirstArray.filter(function(value) {
      return !array.includes(value);
    });
  });
  return filteredFirstArray;
}
function stringToArray(value) {
  var delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
  return value.split(delimiter);
}
function _defineProperty$H(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _typeof$1C(obj) {
  "@babel/helpers - typeof";
  return _typeof$1C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1C(obj);
}
function duckSchema(object) {
  var schema;
  if (Array.isArray(object)) {
    schema = [];
  } else {
    schema = {};
    objectEach(object, function(value, key) {
      if (key === "__children") {
        return;
      }
      if (value && _typeof$1C(value) === "object" && !Array.isArray(value)) {
        schema[key] = duckSchema(value);
      } else if (Array.isArray(value)) {
        if (value.length && _typeof$1C(value[0]) === "object" && !Array.isArray(value[0])) {
          schema[key] = [duckSchema(value[0])];
        } else {
          schema[key] = [];
        }
      } else {
        schema[key] = null;
      }
    });
  }
  return schema;
}
function inherit(Child, Parent) {
  Parent.prototype.constructor = Parent;
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  return Child;
}
function extend(target, extension, writableKeys) {
  var hasWritableKeys = Array.isArray(writableKeys);
  objectEach(extension, function(value, key) {
    if (hasWritableKeys === false || writableKeys.includes(key)) {
      target[key] = value;
    }
  });
  return target;
}
function deepExtend(target, extension) {
  objectEach(extension, function(value, key) {
    if (extension[key] && _typeof$1C(extension[key]) === "object") {
      if (!target[key]) {
        if (Array.isArray(extension[key])) {
          target[key] = [];
        } else if (Object.prototype.toString.call(extension[key]) === "[object Date]") {
          target[key] = extension[key];
        } else {
          target[key] = {};
        }
      }
      deepExtend(target[key], extension[key]);
    } else {
      target[key] = extension[key];
    }
  });
}
function deepClone(obj) {
  if (_typeof$1C(obj) === "object") {
    return JSON.parse(JSON.stringify(obj));
  }
  return obj;
}
function clone$1(object) {
  var result = {};
  objectEach(object, function(value, key) {
    result[key] = value;
  });
  return result;
}
function mixin(Base) {
  if (!Base.MIXINS) {
    Base.MIXINS = [];
  }
  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }
  arrayEach(mixins, function(mixinItem) {
    Base.MIXINS.push(mixinItem.MIXIN_NAME);
    objectEach(mixinItem, function(value, key) {
      if (Base.prototype[key] !== void 0) {
        throw new Error("Mixin conflict. Property '".concat(key, "' already exist and cannot be overwritten."));
      }
      if (typeof value === "function") {
        Base.prototype[key] = value;
      } else {
        var getter = function _getter(property, initialValue) {
          var propertyName = "_".concat(property);
          var initValue = function initValue2(newValue) {
            var result = newValue;
            if (Array.isArray(result) || isObject$7(result)) {
              result = deepClone(result);
            }
            return result;
          };
          return function() {
            if (this[propertyName] === void 0) {
              this[propertyName] = initValue(initialValue);
            }
            return this[propertyName];
          };
        };
        var setter = function _setter(property) {
          var propertyName = "_".concat(property);
          return function(newValue) {
            this[propertyName] = newValue;
          };
        };
        Object.defineProperty(Base.prototype, key, {
          get: getter(key, value),
          set: setter(key),
          configurable: true
        });
      }
    });
  });
  return Base;
}
function isObjectEqual(object1, object2) {
  return JSON.stringify(object1) === JSON.stringify(object2);
}
function isObject$7(object) {
  return Object.prototype.toString.call(object) === "[object Object]";
}
function defineGetter(object, property, value, options) {
  options.value = value;
  options.writable = options.writable !== false;
  options.enumerable = options.enumerable !== false;
  options.configurable = options.configurable !== false;
  Object.defineProperty(object, property, options);
}
function objectEach(object, iteratee) {
  for (var key in object) {
    if (!object.hasOwnProperty || object.hasOwnProperty && Object.prototype.hasOwnProperty.call(object, key)) {
      if (iteratee(object[key], key, object) === false) {
        break;
      }
    }
  }
  return object;
}
function getProperty(object, name) {
  var names = name.split(".");
  var result = object;
  objectEach(names, function(nameItem) {
    result = result[nameItem];
    if (result === void 0) {
      result = void 0;
      return false;
    }
  });
  return result;
}
function setProperty(object, name, value) {
  var names = name.split(".");
  var workingObject = object;
  names.forEach(function(propName, index2) {
    if (index2 !== names.length - 1) {
      if (!hasOwnProperty$2(workingObject, propName)) {
        workingObject[propName] = {};
      }
      workingObject = workingObject[propName];
    } else {
      workingObject[propName] = value;
    }
  });
}
function deepObjectSize(object) {
  if (!isObject$7(object)) {
    return 0;
  }
  var recursObjLen = function recursObjLen2(obj) {
    var result = 0;
    if (isObject$7(obj)) {
      objectEach(obj, function(value, key) {
        if (key === "__children") {
          return;
        }
        result += recursObjLen2(value);
      });
    } else {
      result += 1;
    }
    return result;
  };
  return recursObjLen(object);
}
function createObjectPropListener(defaultValue) {
  var _holder;
  var propertyToListen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "value";
  var privateProperty = "_".concat(propertyToListen);
  var holder2 = (_holder = {
    _touched: false
  }, _defineProperty$H(_holder, privateProperty, defaultValue), _defineProperty$H(_holder, "isTouched", function isTouched() {
    return this._touched;
  }), _holder);
  Object.defineProperty(holder2, propertyToListen, {
    get: function get2() {
      return this[privateProperty];
    },
    set: function set2(value) {
      this._touched = true;
      this[privateProperty] = value;
    },
    enumerable: true,
    configurable: true
  });
  return holder2;
}
function hasOwnProperty$2(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}
var tester = function tester2(testerFunc) {
  var result = {
    value: false
  };
  result.test = function(ua, vendor) {
    result.value = testerFunc(ua, vendor);
  };
  return result;
};
var browsers = {
  chrome: tester(function(ua, vendor) {
    return /Chrome/.test(ua) && /Google/.test(vendor);
  }),
  chromeWebKit: tester(function(ua) {
    return /CriOS/.test(ua);
  }),
  edge: tester(function(ua) {
    return /Edge/.test(ua);
  }),
  edgeWebKit: tester(function(ua) {
    return /EdgiOS/.test(ua);
  }),
  firefox: tester(function(ua) {
    return /Firefox/.test(ua);
  }),
  firefoxWebKit: tester(function(ua) {
    return /FxiOS/.test(ua);
  }),
  ie: tester(function(ua) {
    return /Trident/.test(ua);
  }),
  // eslint-disable-next-line no-restricted-globals
  ie9: tester(function() {
    return !!document.documentMode;
  }),
  mobile: tester(function(ua) {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
  }),
  safari: tester(function(ua, vendor) {
    return /Safari/.test(ua) && /Apple Computer/.test(vendor);
  })
};
var platforms = {
  mac: tester(function(platform) {
    return /^Mac/.test(platform);
  }),
  win: tester(function(platform) {
    return /^Win/.test(platform);
  }),
  linux: tester(function(platform) {
    return /^Linux/.test(platform);
  }),
  ios: tester(function(ua) {
    return /iPhone|iPad|iPod/i.test(ua);
  })
};
function setBrowserMeta() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$userAgent = _ref2.userAgent, userAgent2 = _ref$userAgent === void 0 ? navigator.userAgent : _ref$userAgent, _ref$vendor = _ref2.vendor, vendor = _ref$vendor === void 0 ? navigator.vendor : _ref$vendor;
  objectEach(browsers, function(_ref22) {
    var test2 = _ref22.test;
    return void test2(userAgent2, vendor);
  });
}
function setPlatformMeta() {
  var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$platform = _ref3.platform, platform = _ref3$platform === void 0 ? navigator.platform : _ref3$platform;
  objectEach(platforms, function(_ref4) {
    var test2 = _ref4.test;
    return void test2(platform);
  });
}
setBrowserMeta();
setPlatformMeta();
function isChrome() {
  return browsers.chrome.value;
}
function isChromeWebKit() {
  return browsers.chromeWebKit.value;
}
function isFirefox() {
  return browsers.firefox.value;
}
function isFirefoxWebKit() {
  return browsers.firefoxWebKit.value;
}
function isSafari() {
  return browsers.safari.value;
}
function isEdge() {
  return browsers.edge.value;
}
function isIE() {
  return browsers.ie.value;
}
function isIE9() {
  return browsers.ie9.value;
}
function isMobileBrowser() {
  return browsers.mobile.value;
}
function isIOS() {
  return platforms.ios.value;
}
function isIpadOS() {
  var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : navigator, maxTouchPoints = _ref5.maxTouchPoints;
  return maxTouchPoints > 2 && platforms.mac.value;
}
function isWindowsOS() {
  return platforms.win.value;
}
function isMacOS() {
  return platforms.mac.value;
}
/*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */
function _typeof$1B(obj) {
  "@babel/helpers - typeof";
  return _typeof$1B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1B(obj);
}
function _setPrototypeOf$1r(o, p2) {
  _setPrototypeOf$1r = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1r(o, p2);
}
function _isNativeReflectConstruct$1r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct$6(Parent, args, Class) {
  if (_isNativeReflectConstruct$1r()) {
    _construct$6 = Reflect.construct;
  } else {
    _construct$6 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1r(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$6.apply(null, arguments);
}
function _toConsumableArray$C(arr) {
  return _arrayWithoutHoles$C(arr) || _iterableToArray$E(arr) || _unsupportedIterableToArray$1e(arr) || _nonIterableSpread$C();
}
function _arrayWithoutHoles$C(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1e(arr);
}
function _iterableToArray$E(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$1e(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1e(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1e(o, minLen);
}
function _arrayLikeToArray$1e(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread$C() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var hasOwnProperty$1 = Object.hasOwnProperty, setPrototypeOf$1 = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf$1 = Object.getPrototypeOf, getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze, seal = Object.seal, create$1 = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect, apply$3 = _ref.apply, construct$1 = _ref.construct;
if (!apply$3) {
  apply$3 = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze3(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct$1) {
  construct$1 = function construct3(Func, args) {
    return _construct$6(Func, _toConsumableArray$C(args));
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply$3(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct$1(func, args);
  };
}
function addToSet(set2, array, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf$1) {
    setPrototypeOf$1(set2, null);
  }
  var l2 = array.length;
  while (l2--) {
    var element = array[l2];
    if (typeof element === "string") {
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone(object) {
  var newObject = create$1(null);
  var property;
  for (property in object) {
    if (apply$3(hasOwnProperty$1, object, [property])) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor$4(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf$1(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html$2 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if (_typeof$1B(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML2(html2) {
        return html2;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root) {
    return createDOMPurify(root);
  };
  DOMPurify.version = "2.4.0";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement2 = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement2 === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_) {
  }
  var hooks2 = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$C(html$1), _toConsumableArray$C(svg$1), _toConsumableArray$C(svgFilters), _toConsumableArray$C(mathMl$1), _toConsumableArray$C(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$C(html$2), _toConsumableArray$C(svg), _toConsumableArray$C(mathMl), _toConsumableArray$C(xml)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || _typeof$1B(cfg) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
      return x2;
    } : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray$C(text));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html$2);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_2) {
        node.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc;
    var leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
  };
  var _isNode = function _isNode2(object) {
    return _typeof$1B(Node2) === "object" ? object instanceof Node2 : object && _typeof$1B(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
    if (!hooks2[entryPoint]) {
      return;
    }
    arrayForEach(hooks2[entryPoint], function(hook2) {
      hook2.call(DOMPurify, currentNode, data2, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$1, " ");
      content = stringReplace(content, ERB_EXPR$1, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      )
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if (!value)
      ;
    else {
      return false;
    }
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr;
    var value;
    var lcName;
    var l2;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l2 = attributes.length;
    while (l2--) {
      attr = attributes[l2];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = name === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, " ");
        value = stringReplace(value, ERB_EXPR$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && _typeof$1B(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML":
              value = trustedTypesPolicy.createHTML(value);
              break;
            case "TrustedScriptURL":
              value = trustedTypesPolicy.createScriptURL(value);
              break;
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof$1B(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks2[entryPoint] = hooks2[entryPoint] || [];
    arrayPush(hooks2[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks2[entryPoint]) {
      return arrayPop(hooks2[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks2[entryPoint]) {
      hooks2[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks2 = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
var $$q = _export;
var FREEZING = freezing;
var fails$9 = fails$G;
var isObject$6 = isObject$n;
var onFreeze = internalMetadataExports.onFreeze;
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES$2 = fails$9(function() {
  $freeze(1);
});
$$q({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$2, sham: !FREEZING }, {
  freeze: function freeze2(it) {
    return $freeze && isObject$6(it) ? $freeze(onFreeze(it)) : it;
  }
});
var $$p = _export;
var codeAt = stringMultibyte.codeAt;
$$p({ target: "String", proto: true }, {
  codePointAt: function codePointAt(pos) {
    return codeAt(this, pos);
  }
});
var toIntegerOrInfinity$3 = toIntegerOrInfinity$8;
var toString$7 = toString$j;
var requireObjectCoercible$6 = requireObjectCoercible$e;
var $RangeError$1 = RangeError;
var stringRepeat = function repeat(count) {
  var str = toString$7(requireObjectCoercible$6(this));
  var result = "";
  var n2 = toIntegerOrInfinity$3(count);
  if (n2 < 0 || n2 == Infinity)
    throw $RangeError$1("Wrong number of repetitions");
  for (; n2 > 0; (n2 >>>= 1) && (str += str))
    if (n2 & 1)
      result += str;
  return result;
};
var uncurryThis$d = functionUncurryThis;
var toLength$3 = toLength$7;
var toString$6 = toString$j;
var $repeat$1 = stringRepeat;
var requireObjectCoercible$5 = requireObjectCoercible$e;
var repeat$1 = uncurryThis$d($repeat$1);
var stringSlice$2 = uncurryThis$d("".slice);
var ceil = Math.ceil;
var createMethod$2 = function(IS_END) {
  return function($this, maxLength, fillString) {
    var S = toString$6(requireObjectCoercible$5($this));
    var intMaxLength = toLength$3(maxLength);
    var stringLength = S.length;
    var fillStr = fillString === void 0 ? " " : toString$6(fillString);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == "")
      return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat$1(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen)
      stringFiller = stringSlice$2(stringFiller, 0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};
var stringPad = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod$2(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod$2(true)
};
var userAgent$3 = engineUserAgent;
var stringPadWebkitBug = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent$3);
var $$o = _export;
var $padStart = stringPad.start;
var WEBKIT_BUG = stringPadWebkitBug;
$$o({ target: "String", proto: true, forced: WEBKIT_BUG }, {
  padStart: function padStart(maxLength) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
  }
});
function toSingleLine(strings) {
  for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    expressions[_key - 1] = arguments[_key];
  }
  var result = arrayReduce$1(strings, function(previousValue, currentValue, index2) {
    var valueWithoutWhiteSpaces = currentValue.replace(/\r?\n\s*/g, "");
    var expressionForIndex = expressions[index2] ? expressions[index2] : "";
    return previousValue + valueWithoutWhiteSpaces + expressionForIndex;
  }, "");
  return result.trim();
}
var _templateObject$h, _templateObject2$3, _templateObject3$1, _templateObject4$1, _templateObject5, _templateObject6;
function _taggedTemplateLiteral$h(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _typeof$1A(obj) {
  "@babel/helpers - typeof";
  return _typeof$1A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1A(obj);
}
function stringify$1(value) {
  var result;
  switch (_typeof$1A(value)) {
    case "string":
    case "number":
      result = "".concat(value);
      break;
    case "object":
      result = value === null ? "" : value.toString();
      break;
    case "undefined":
      result = "";
      break;
    default:
      result = value.toString();
      break;
  }
  return result;
}
function isDefined(variable) {
  return typeof variable !== "undefined";
}
function isUndefined(variable) {
  return typeof variable === "undefined";
}
function isEmpty(variable) {
  return variable === null || variable === "" || isUndefined(variable);
}
function isRegExp(variable) {
  return Object.prototype.toString.call(variable) === "[object RegExp]";
}
var _m = "length";
var _hd = function _hd2(v2) {
  return parseInt(v2, 16);
};
var _pi = function _pi2(v2) {
  return parseInt(v2, 10);
};
var _ss = function _ss2(v2, s, l2) {
  return v2["substr"](s, l2);
};
var _cp = function _cp2(v2) {
  return v2["codePointAt"](0) - 65;
};
var _norm = function _norm2(v2) {
  return "".concat(v2).replace(/\-/g, "");
};
var _extractTime = function _extractTime2(v2) {
  return _hd(_ss(_norm(v2), _hd("12"), _cp("F"))) / (_hd(_ss(_norm(v2), _cp("B"), ~~![][_m])) || 9);
};
var _ignored = function _ignored2() {
  return typeof location !== "undefined" && /^([a-z0-9\-]+\.)?\x68\x61\x6E\x64\x73\x6F\x6E\x74\x61\x62\x6C\x65\x2E\x63\x6F\x6D$/i.test(location.host);
};
var _notified = false;
var consoleMessages = {
  invalid: function invalid() {
    return toSingleLine(_templateObject$h || (_templateObject$h = _taggedTemplateLiteral$h(["\n    The license key for Handsontable is invalid. \n    If you need any help, contact us at support@handsontable.com."], ["\n    The license key for Handsontable is invalid.\\x20\n    If you need any help, contact us at support@handsontable.com."])));
  },
  expired: function expired(_ref2) {
    var keyValidityDate = _ref2.keyValidityDate, hotVersion = _ref2.hotVersion;
    return toSingleLine(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral$h(["\n    The license key for Handsontable expired on ", ", and is not valid for the installed \n    version ", ". Renew your license key at handsontable.com or downgrade to a version released prior \n    to ", ". If you need any help, contact us at sales@handsontable.com."], ["\n    The license key for Handsontable expired on ", ", and is not valid for the installed\\x20\n    version ", ". Renew your license key at handsontable.com or downgrade to a version released prior\\x20\n    to ", ". If you need any help, contact us at sales@handsontable.com."])), keyValidityDate, hotVersion, keyValidityDate);
  },
  missing: function missing() {
    return toSingleLine(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral$h(["\n    The license key for Handsontable is missing. Use your purchased key to activate the product. \n    Alternatively, you can activate Handsontable to use for non-commercial purposes by \n    passing the key: 'non-commercial-and-evaluation'. If you need any help, contact \n    us at support@handsontable.com."], ["\n    The license key for Handsontable is missing. Use your purchased key to activate the product.\\x20\n    Alternatively, you can activate Handsontable to use for non-commercial purposes by\\x20\n    passing the key: 'non-commercial-and-evaluation'. If you need any help, contact\\x20\n    us at support@handsontable.com."])));
  },
  non_commercial: function non_commercial() {
    return "";
  }
};
var domMessages = {
  invalid: function invalid2() {
    return toSingleLine(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral$h(['\n    The license key for Handsontable is invalid. \n    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> on how to \n    install it properly or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.'], ['\n    The license key for Handsontable is invalid.\\x20\n    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> on how to\\x20\n    install it properly or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.'])));
  },
  expired: function expired2(_ref2) {
    var keyValidityDate = _ref2.keyValidityDate, hotVersion = _ref2.hotVersion;
    return toSingleLine(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral$h(["\n    The license key for Handsontable expired on ", ", and is not valid for the installed \n    version ", '. <a href="https://handsontable.com/pricing" target="_blank">Renew</a> your \n    license key or downgrade to a version released prior to ', '. If you need any \n    help, contact us at <a href="mailto:sales@handsontable.com">sales@handsontable.com</a>.'], ["\n    The license key for Handsontable expired on ", ", and is not valid for the installed\\x20\n    version ", '. <a href="https://handsontable.com/pricing" target="_blank">Renew</a> your\\x20\n    license key or downgrade to a version released prior to ', '. If you need any\\x20\n    help, contact us at <a href="mailto:sales@handsontable.com">sales@handsontable.com</a>.'])), keyValidityDate, hotVersion, keyValidityDate);
  },
  missing: function missing2() {
    return toSingleLine(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral$h([`
    The license key for Handsontable is missing. Use your purchased key to activate the product. 
    Alternatively, you can activate Handsontable to use for non-commercial purposes by 
    passing the key: 'non-commercial-and-evaluation'. 
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> about it in 
    the documentation or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`], [`
    The license key for Handsontable is missing. Use your purchased key to activate the product.\\x20
    Alternatively, you can activate Handsontable to use for non-commercial purposes by\\x20
    passing the key: 'non-commercial-and-evaluation'.\\x20
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> about it in\\x20
    the documentation or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`])));
  },
  non_commercial: function non_commercial2() {
    return "";
  }
};
function _injectProductInfo(key, element) {
  var hasValidType = !isEmpty(key);
  var isNonCommercial = typeof key === "string" && key.toLowerCase() === "non-commercial-and-evaluation";
  var hotVersion = "12.1.3";
  var keyValidityDate;
  var consoleMessageState = "invalid";
  var domMessageState = "invalid";
  key = _norm(key || "");
  var schemaValidity = _checkKeySchema(key);
  if (hasValidType || isNonCommercial || schemaValidity) {
    if (schemaValidity) {
      var releaseDate = hooks("22/09/2022", "DD/MM/YYYY");
      var releaseDays = Math.floor(releaseDate.toDate().getTime() / 864e5);
      var keyValidityDays = _extractTime(key);
      keyValidityDate = hooks((keyValidityDays + 1) * 864e5, "x").format("MMMM DD, YYYY");
      if (releaseDays > keyValidityDays) {
        var daysAfterRelease = hooks().diff(releaseDate, "days");
        consoleMessageState = daysAfterRelease <= 1 ? "valid" : "expired";
        domMessageState = daysAfterRelease <= 15 ? "valid" : "expired";
      } else {
        consoleMessageState = "valid";
        domMessageState = "valid";
      }
    } else if (isNonCommercial) {
      consoleMessageState = "non_commercial";
      domMessageState = "valid";
    } else {
      consoleMessageState = "invalid";
      domMessageState = "invalid";
    }
  } else {
    consoleMessageState = "missing";
    domMessageState = "missing";
  }
  if (_ignored()) {
    consoleMessageState = "valid";
    domMessageState = "valid";
  }
  if (!_notified && consoleMessageState !== "valid") {
    var message = consoleMessages[consoleMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (message) {
      console[consoleMessageState === "non_commercial" ? "info" : "warn"](consoleMessages[consoleMessageState]({
        keyValidityDate,
        hotVersion
      }));
    }
    _notified = true;
  }
  if (domMessageState !== "valid" && element.parentNode) {
    var _message = domMessages[domMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (_message) {
      var messageNode = document.createElement("div");
      messageNode.id = "hot-display-license-info";
      messageNode.innerHTML = domMessages[domMessageState]({
        keyValidityDate,
        hotVersion
      });
      element.parentNode.insertBefore(messageNode, element.nextSibling);
    }
  }
}
function _checkKeySchema(v2) {
  var z2 = [][_m];
  var p2 = z2;
  if (v2[_m] !== _cp("Z")) {
    return false;
  }
  for (var c2 = "", i = "B<H4P+".split(""), j = _cp(i.shift()); j; j = _cp(i.shift() || "A")) {
    --j < ""[_m] ? p2 = p2 | (_pi("".concat(_pi(_hd(c2) + (_hd(_ss(v2, Math.abs(j), 2)) + []).padStart(2, "0")))) % 97 || 2) >> 1 : c2 = _ss(v2, j, !j ? 6 : i[_m] === 1 ? 9 : 8);
  }
  return p2 === z2;
}
function toUpperCaseFirst(string) {
  return string[0].toUpperCase() + string.substr(1);
}
function randomString() {
  function s4() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return s4() + s4() + s4() + s4();
}
function isPercentValue(value) {
  return /^([0-9][0-9]?%$)|(^100%$)/.test(value);
}
function substitute(template) {
  var variables = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return "".concat(template).replace(/(?:\\)?\[([^[\]]+)]/g, function(match2, name) {
    if (match2.charAt(0) === "\\") {
      return match2.substr(1, match2.length - 1);
    }
    return variables[name] === void 0 ? "" : variables[name];
  });
}
function stripTags(string) {
  return sanitize("".concat(string), {
    ALLOWED_TAGS: []
  });
}
function sanitize(string, options) {
  return purify.sanitize(string, options);
}
function _toConsumableArray$B(arr) {
  return _arrayWithoutHoles$B(arr) || _iterableToArray$D(arr) || _unsupportedIterableToArray$1d(arr) || _nonIterableSpread$B();
}
function _nonIterableSpread$B() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1d(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1d(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1d(o, minLen);
}
function _iterableToArray$D(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$B(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1d(arr);
}
function _arrayLikeToArray$1d(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getParent(element) {
  var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var iteration = -1;
  var parent = null;
  var elementToCheck = element;
  while (elementToCheck !== null) {
    if (iteration === level) {
      parent = elementToCheck;
      break;
    }
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      iteration += 1;
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return parent;
}
function getFrameElement(frame) {
  return Object.getPrototypeOf(frame.parent) && frame.frameElement;
}
function getParentWindow(frame) {
  return getFrameElement(frame) && frame.parent;
}
function closest(element) {
  var nodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var until = arguments.length > 2 ? arguments[2] : void 0;
  var _Node = Node, ELEMENT_NODE = _Node.ELEMENT_NODE, DOCUMENT_FRAGMENT_NODE = _Node.DOCUMENT_FRAGMENT_NODE;
  var elementToCheck = element;
  while (elementToCheck !== null && elementToCheck !== void 0 && elementToCheck !== until) {
    var _elementToCheck = elementToCheck, nodeType = _elementToCheck.nodeType, nodeName = _elementToCheck.nodeName;
    if (nodeType === ELEMENT_NODE && (nodes.includes(nodeName) || nodes.includes(elementToCheck))) {
      return elementToCheck;
    }
    var _elementToCheck2 = elementToCheck, host = _elementToCheck2.host;
    if (host && nodeType === DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return null;
}
function closestDown(element, nodes, until) {
  var matched = [];
  var elementToCheck = element;
  while (elementToCheck) {
    elementToCheck = closest(elementToCheck, nodes, until);
    if (!elementToCheck || until && !until.contains(elementToCheck)) {
      break;
    }
    matched.push(elementToCheck);
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  var length = matched.length;
  return length ? matched[length - 1] : null;
}
function isChildOf(child, parent) {
  var node = child.parentNode;
  var queriedParents = [];
  if (typeof parent === "string") {
    if (child.defaultView) {
      queriedParents = Array.prototype.slice.call(child.querySelectorAll(parent), 0);
    } else {
      queriedParents = Array.prototype.slice.call(child.ownerDocument.querySelectorAll(parent), 0);
    }
  } else {
    queriedParents.push(parent);
  }
  while (node !== null) {
    if (queriedParents.indexOf(node) > -1) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
function index(element) {
  var i = 0;
  var elementToCheck = element;
  if (elementToCheck.previousSibling) {
    while (elementToCheck = elementToCheck.previousSibling) {
      i += 1;
    }
  }
  return i;
}
function overlayContainsElement(overlayType, element, root) {
  var overlayElement = root.parentElement.querySelector(".ht_clone_".concat(overlayType));
  return overlayElement ? overlayElement.contains(element) : null;
}
var _hasClass;
var _addClass;
var _removeClass;
function filterEmptyClassNames(classNames) {
  if (!classNames || !classNames.length) {
    return [];
  }
  return classNames.filter(function(x2) {
    return !!x2;
  });
}
if (isClassListSupported()) {
  var isSupportMultipleClassesArg = function isSupportMultipleClassesArg2(rootDocument) {
    var element = rootDocument.createElement("div");
    element.classList.add("test", "test2");
    return element.classList.contains("test2");
  };
  _hasClass = function _hasClass2(element, className) {
    if (element.classList === void 0 || typeof className !== "string" || className === "") {
      return false;
    }
    return element.classList.contains(className);
  };
  _addClass = function _addClass2(element, classes) {
    var rootDocument = element.ownerDocument;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (className.length > 0) {
      if (isSupportMultipleClassesArg(rootDocument)) {
        var _element$classList;
        (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray$B(className));
      } else {
        var len = 0;
        while (className[len]) {
          element.classList.add(className[len]);
          len += 1;
        }
      }
    }
  };
  _removeClass = function _removeClass2(element, classes) {
    var rootDocument = element.ownerDocument;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (className.length > 0) {
      if (isSupportMultipleClassesArg(rootDocument)) {
        var _element$classList2;
        (_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray$B(className));
      } else {
        var len = 0;
        while (className[len]) {
          element.classList.remove(className[len]);
          len += 1;
        }
      }
    }
  };
} else {
  var createClassNameRegExp = function createClassNameRegExp2(className) {
    return new RegExp("(\\s|^)".concat(className, "(\\s|$)"));
  };
  _hasClass = function _hasClass2(element, className) {
    return element.className !== void 0 && createClassNameRegExp(className).test(element.className);
  };
  _addClass = function _addClass2(element, classes) {
    var _className = element.className;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (_className === "") {
      _className = className.join(" ");
    } else {
      for (var len = 0; len < className.length; len++) {
        if (className[len] && !createClassNameRegExp(className[len]).test(_className)) {
          _className += " ".concat(className[len]);
        }
      }
    }
    element.className = _className;
  };
  _removeClass = function _removeClass2(element, classes) {
    var len = 0;
    var _className = element.className;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    while (className[len]) {
      _className = _className.replace(createClassNameRegExp(className[len]), " ").trim();
      len += 1;
    }
    if (element.className !== _className) {
      element.className = _className;
    }
  };
}
function hasClass(element, className) {
  return _hasClass(element, className);
}
function addClass(element, className) {
  _addClass(element, className);
}
function removeClass(element, className) {
  _removeClass(element, className);
}
function removeTextNodes(element) {
  if (element.nodeType === 3) {
    element.parentNode.removeChild(element);
  } else if (["TABLE", "THEAD", "TBODY", "TFOOT", "TR"].indexOf(element.nodeName) > -1) {
    var childs = element.childNodes;
    for (var i = childs.length - 1; i >= 0; i--) {
      removeTextNodes(childs[i]);
    }
  }
}
function empty(element) {
  var child;
  while (child = element.lastChild) {
    element.removeChild(child);
  }
}
var HTML_CHARACTERS = /(<(.*)>|&(.*);)/;
function fastInnerHTML(element, content) {
  var sanitizeContent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (HTML_CHARACTERS.test(content)) {
    element.innerHTML = sanitizeContent ? sanitize(content) : content;
  } else {
    fastInnerText(element, content);
  }
}
function fastInnerText(element, content) {
  var child = element.firstChild;
  if (child && child.nodeType === 3 && child.nextSibling === null) {
    if (isTextContentSupported) {
      child.textContent = content;
    } else {
      child.data = content;
    }
  } else {
    empty(element);
    element.appendChild(element.ownerDocument.createTextNode(content));
  }
}
function isVisible(element) {
  var documentElement = element.ownerDocument.documentElement;
  var next2 = element;
  while (next2 !== documentElement) {
    if (next2 === null) {
      return false;
    } else if (next2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      if (next2.host) {
        if (next2.host.impl) {
          return isVisible(next2.host.impl);
        } else if (next2.host) {
          return isVisible(next2.host);
        }
        throw new Error("Lost in Web Components world");
      } else {
        return false;
      }
    } else if (next2.style && next2.style.display === "none") {
      return false;
    }
    next2 = next2.parentNode;
  }
  return true;
}
function offset(element) {
  var rootDocument = element.ownerDocument;
  var rootWindow = rootDocument.defaultView;
  var documentElement = rootDocument.documentElement;
  var elementToCheck = element;
  var offsetLeft;
  var offsetTop;
  var lastElem;
  var box;
  if (hasCaptionProblem() && elementToCheck.firstChild && elementToCheck.firstChild.nodeName === "CAPTION") {
    box = elementToCheck.getBoundingClientRect();
    return {
      top: box.top + (rootWindow.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
      left: box.left + (rootWindow.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)
    };
  }
  offsetLeft = elementToCheck.offsetLeft;
  offsetTop = elementToCheck.offsetTop;
  lastElem = elementToCheck;
  while (elementToCheck = elementToCheck.offsetParent) {
    if (elementToCheck === rootDocument.body) {
      break;
    }
    offsetLeft += elementToCheck.offsetLeft;
    offsetTop += elementToCheck.offsetTop;
    lastElem = elementToCheck;
  }
  if (lastElem && lastElem.style.position === "fixed") {
    offsetLeft += rootWindow.pageXOffset || documentElement.scrollLeft;
    offsetTop += rootWindow.pageYOffset || documentElement.scrollTop;
  }
  return {
    left: offsetLeft,
    top: offsetTop
  };
}
function getWindowScrollTop() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var res = rootWindow.scrollY;
  if (res === void 0) {
    res = rootWindow.document.documentElement.scrollTop;
  }
  return res;
}
function getWindowScrollLeft() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var res = rootWindow.scrollX;
  if (res === void 0) {
    res = rootWindow.document.documentElement.scrollLeft;
  }
  return res;
}
function getScrollTop(element) {
  var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollTop(rootWindow);
  }
  return element.scrollTop;
}
function getScrollLeft(element) {
  var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollLeft(rootWindow);
  }
  return element.scrollLeft;
}
function getScrollableElement(element) {
  var rootDocument = element.ownerDocument;
  var rootWindow = rootDocument ? rootDocument.defaultView : void 0;
  if (!rootDocument) {
    rootDocument = element.document ? element.document : element;
    rootWindow = rootDocument.defaultView;
  }
  var props = ["auto", "scroll"];
  var supportedGetComputedStyle = isGetComputedStyleSupported();
  var el = element.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    var _el$style = el.style, overflow = _el$style.overflow, overflowX = _el$style.overflowX, overflowY = _el$style.overflowY;
    if ([overflow, overflowX, overflowY].includes("scroll")) {
      return el;
    } else if (supportedGetComputedStyle) {
      var _rootWindow$getComput = rootWindow.getComputedStyle(el);
      overflow = _rootWindow$getComput.overflow;
      overflowX = _rootWindow$getComput.overflowX;
      overflowY = _rootWindow$getComput.overflowY;
      if (props.includes(overflow) || props.includes(overflowX) || props.includes(overflowY)) {
        return el;
      }
    }
    if (el.clientHeight <= el.scrollHeight + 1 && (props.includes(overflowY) || props.includes(overflow))) {
      return el;
    }
    if (el.clientWidth <= el.scrollWidth + 1 && (props.includes(overflowX) || props.includes(overflow))) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}
function getTrimmingContainer(base) {
  var rootDocument = base.ownerDocument;
  var rootWindow = rootDocument.defaultView;
  var el = base.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    if (el.style.overflow !== "visible" && el.style.overflow !== "") {
      return el;
    }
    var computedStyle = getComputedStyle(el, rootWindow);
    var allowedProperties = ["scroll", "hidden", "auto"];
    var property = computedStyle.getPropertyValue("overflow");
    var propertyY = computedStyle.getPropertyValue("overflow-y");
    var propertyX = computedStyle.getPropertyValue("overflow-x");
    if (allowedProperties.includes(property) || allowedProperties.includes(propertyY) || allowedProperties.includes(propertyX)) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}
function getStyle(element, prop) {
  var rootWindow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : window;
  if (!element) {
    return;
  } else if (element === rootWindow) {
    if (prop === "width") {
      return "".concat(rootWindow.innerWidth, "px");
    } else if (prop === "height") {
      return "".concat(rootWindow.innerHeight, "px");
    }
    return;
  }
  var styleProp = element.style[prop];
  if (styleProp !== "" && styleProp !== void 0) {
    return styleProp;
  }
  var computedStyle = getComputedStyle(element, rootWindow);
  if (computedStyle[prop] !== "" && computedStyle[prop] !== void 0) {
    return computedStyle[prop];
  }
}
function getComputedStyle(element) {
  var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  return element.currentStyle || rootWindow.getComputedStyle(element);
}
function outerWidth(element) {
  return element.offsetWidth;
}
function outerHeight(element) {
  if (hasCaptionProblem() && element.firstChild && element.firstChild.nodeName === "CAPTION") {
    return element.offsetHeight + element.firstChild.offsetHeight;
  }
  return element.offsetHeight;
}
function innerHeight(element) {
  return element.clientHeight || element.innerHeight;
}
function innerWidth(element) {
  return element.clientWidth || element.innerWidth;
}
function getCaretPosition(el) {
  var rootDocument = el.ownerDocument;
  if (el.selectionStart) {
    return el.selectionStart;
  } else if (rootDocument.selection) {
    el.focus();
    var r2 = rootDocument.selection.createRange();
    if (r2 === null) {
      return 0;
    }
    var re = el.createTextRange();
    var rc = re.duplicate();
    re.moveToBookmark(r2.getBookmark());
    rc.setEndPoint("EndToStart", re);
    return rc.text.length;
  }
  return 0;
}
function getSelectionEndPosition(el) {
  var rootDocument = el.ownerDocument;
  if (el.selectionEnd) {
    return el.selectionEnd;
  } else if (rootDocument.selection) {
    var r2 = rootDocument.selection.createRange();
    if (r2 === null) {
      return 0;
    }
    var re = el.createTextRange();
    return re.text.indexOf(r2.text) + r2.text.length;
  }
  return 0;
}
function getSelectionText() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var rootDocument = rootWindow.document;
  var text2 = "";
  if (rootWindow.getSelection) {
    text2 = rootWindow.getSelection().toString();
  } else if (rootDocument.selection && rootDocument.selection.type !== "Control") {
    text2 = rootDocument.selection.createRange().text;
  }
  return text2;
}
function clearTextSelection() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var rootDocument = rootWindow.document;
  if (rootWindow.getSelection) {
    if (rootWindow.getSelection().empty) {
      rootWindow.getSelection().empty();
    } else if (rootWindow.getSelection().removeAllRanges) {
      rootWindow.getSelection().removeAllRanges();
    }
  } else if (rootDocument.selection) {
    rootDocument.selection.empty();
  }
}
function setCaretPosition(element, pos, endPos) {
  if (endPos === void 0) {
    endPos = pos;
  }
  if (element.setSelectionRange) {
    element.focus();
    try {
      element.setSelectionRange(pos, endPos);
    } catch (err) {
      var elementParent = element.parentNode;
      var parentDisplayValue = elementParent.style.display;
      elementParent.style.display = "block";
      element.setSelectionRange(pos, endPos);
      elementParent.style.display = parentDisplayValue;
    }
  }
}
var cachedScrollbarWidth;
function walkontableCalculateScrollbarWidth() {
  var rootDocument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  var inner = rootDocument.createElement("div");
  inner.style.height = "200px";
  inner.style.width = "100%";
  var outer = rootDocument.createElement("div");
  outer.style.boxSizing = "content-box";
  outer.style.height = "150px";
  outer.style.left = "0px";
  outer.style.overflow = "hidden";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.width = "200px";
  outer.style.visibility = "hidden";
  outer.appendChild(inner);
  (rootDocument.body || rootDocument.documentElement).appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  var w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  (rootDocument.body || rootDocument.documentElement).removeChild(outer);
  return w1 - w2;
}
function getScrollbarWidth() {
  var rootDocument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  if (cachedScrollbarWidth === void 0) {
    cachedScrollbarWidth = walkontableCalculateScrollbarWidth(rootDocument);
  }
  return cachedScrollbarWidth;
}
function hasVerticalScrollbar(element) {
  return element.offsetWidth !== element.clientWidth;
}
function hasHorizontalScrollbar(element) {
  return element.offsetHeight !== element.clientHeight;
}
function setOverlayPosition(overlayElem, left2, top2) {
  if (isIE9()) {
    overlayElem.style.top = top2;
    overlayElem.style.left = left2;
  } else if (isSafari()) {
    overlayElem.style["-webkit-transform"] = "translate3d(".concat(left2, ",").concat(top2, ",0)");
  } else {
    overlayElem.style.transform = "translate3d(".concat(left2, ",").concat(top2, ",0)");
  }
}
function resetCssTransform(element) {
  if (element.style.transform && element.style.transform !== "") {
    element.style.transform = "";
  } else if (element.style["-webkit-transform"] && element.style["-webkit-transform"] !== "") {
    element.style["-webkit-transform"] = "";
  }
}
function isInput(element) {
  var inputs = ["INPUT", "SELECT", "TEXTAREA"];
  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === "true");
}
function isOutsideInput(element) {
  return isInput(element) && element.hasAttribute("data-hot-input") === false;
}
function selectElementIfAllowed(element) {
  var activeElement = element.ownerDocument.activeElement;
  if (!isOutsideInput(activeElement)) {
    element.select();
  }
}
function isDetached(element) {
  return !element.parentNode;
}
var RENDERER_TYPE$7 = "base";
function baseRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var classesToAdd = [];
  var classesToRemove = [];
  if (cellProperties.className) {
    addClass(TD, cellProperties.className);
  }
  if (cellProperties.readOnly) {
    classesToAdd.push(cellProperties.readOnlyCellClassName);
  }
  if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
    classesToAdd.push(cellProperties.invalidCellClassName);
  } else {
    classesToRemove.push(cellProperties.invalidCellClassName);
  }
  if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
    classesToAdd.push(cellProperties.noWordWrapClassName);
  }
  if (!value && cellProperties.placeholder) {
    classesToAdd.push(cellProperties.placeholderCellClassName);
  }
  removeClass(TD, classesToRemove);
  addClass(TD, classesToAdd);
}
baseRenderer.RENDERER_TYPE = RENDERER_TYPE$7;
var RENDERER_TYPE$6 = "html";
function htmlRenderer(instance, TD, row, col, prop, value, cellProperties) {
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  fastInnerHTML(TD, value === null || value === void 0 ? "" : value, false);
}
htmlRenderer.RENDERER_TYPE = RENDERER_TYPE$6;
var RENDERER_TYPE$5 = "text";
function textRenderer(instance, TD, row, col, prop, value, cellProperties) {
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  var escaped = value;
  if (!escaped && cellProperties.placeholder) {
    escaped = cellProperties.placeholder;
  }
  escaped = stringify$1(escaped);
  if (cellProperties.trimWhitespace) {
    escaped = escaped.trim();
  }
  if (cellProperties.rendererTemplate) {
    empty(TD);
    var TEMPLATE2 = instance.rootDocument.createElement("TEMPLATE");
    TEMPLATE2.setAttribute("bind", "{{}}");
    TEMPLATE2.innerHTML = cellProperties.rendererTemplate;
    HTMLTemplateElement.decorate(TEMPLATE2);
    TEMPLATE2.model = instance.getSourceDataAtRow(row);
    TD.appendChild(TEMPLATE2);
  } else {
    fastInnerText(TD, escaped);
  }
}
textRenderer.RENDERER_TYPE = RENDERER_TYPE$5;
var DESCRIPTORS$5 = descriptors;
var isArray$1 = isArray$6;
var $TypeError$2 = TypeError;
var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$5 && !function() {
  if (this !== void 0)
    return true;
  try {
    Object.defineProperty([], "length", { writable: false }).length = 1;
  } catch (error2) {
    return error2 instanceof TypeError;
  }
}();
var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
  if (isArray$1(O) && !getOwnPropertyDescriptor$3(O, "length").writable) {
    throw $TypeError$2("Cannot set read only .length");
  }
  return O.length = length;
} : function(O, length) {
  return O.length = length;
};
var tryToString = tryToString$6;
var $TypeError$1 = TypeError;
var deletePropertyOrThrow$2 = function(O, P) {
  if (!delete O[P])
    throw $TypeError$1("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
};
var $$n = _export;
var toObject$6 = toObject$f;
var toAbsoluteIndex$1 = toAbsoluteIndex$5;
var toIntegerOrInfinity$2 = toIntegerOrInfinity$8;
var lengthOfArrayLike$4 = lengthOfArrayLike$c;
var setArrayLength = arraySetLength;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$2;
var arraySpeciesCreate = arraySpeciesCreate$3;
var createProperty$1 = createProperty$6;
var deletePropertyOrThrow$1 = deletePropertyOrThrow$2;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1("splice");
var max = Math.max;
var min$3 = Math.min;
$$n({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
  splice: function splice(start, deleteCount) {
    var O = toObject$6(this);
    var len = lengthOfArrayLike$4(O);
    var actualStart = toAbsoluteIndex$1(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A2, k2, from3, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$3(max(toIntegerOrInfinity$2(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
    A2 = arraySpeciesCreate(O, actualDeleteCount);
    for (k2 = 0; k2 < actualDeleteCount; k2++) {
      from3 = actualStart + k2;
      if (from3 in O)
        createProperty$1(A2, k2, O[from3]);
    }
    A2.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
        from3 = k2 + actualDeleteCount;
        to = k2 + insertCount;
        if (from3 in O)
          O[to] = O[from3];
        else
          deletePropertyOrThrow$1(O, to);
      }
      for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)
        deletePropertyOrThrow$1(O, k2 - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
        from3 = k2 + actualDeleteCount - 1;
        to = k2 + insertCount - 1;
        if (from3 in O)
          O[to] = O[from3];
        else
          deletePropertyOrThrow$1(O, to);
      }
    }
    for (k2 = 0; k2 < insertCount; k2++) {
      O[k2 + actualStart] = arguments[k2 + 2];
    }
    setArrayLength(O, len - actualDeleteCount + insertCount);
    return A2;
  }
});
function stopImmediatePropagation(event2) {
  event2.isImmediatePropagationEnabled = false;
  event2.cancelBubble = true;
}
function isImmediatePropagationStopped(event2) {
  return event2.isImmediatePropagationEnabled === false;
}
function isRightClick(event2) {
  return event2.button === 2;
}
function isLeftClick(event2) {
  return event2.button === 0;
}
function _classCallCheck$2K(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2K(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2K(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2K(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2K(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var EventManager = /* @__PURE__ */ function() {
  function EventManager2() {
    var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    _classCallCheck$2K(this, EventManager2);
    this.context = context || this;
    if (!this.context.eventListeners) {
      this.context.eventListeners = [];
    }
  }
  _createClass$2K(EventManager2, [{
    key: "addEventListener",
    value: function addEventListener(element, eventName, callback) {
      var _this = this;
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      function callbackProxy(event2) {
        callback.call(this, extendEvent(event2));
      }
      if (typeof options !== "boolean" && !isPassiveEventSupported()) {
        options = false;
      }
      this.context.eventListeners.push({
        element,
        event: eventName,
        callback,
        callbackProxy,
        options,
        eventManager: this
      });
      element.addEventListener(eventName, callbackProxy, options);
      return function() {
        _this.removeEventListener(element, eventName, callback);
      };
    }
    /**
     * Remove the event listener previously registered.
     *
     * @param {Element} element Target element.
     * @param {string} eventName Event name.
     * @param {Function} callback Function to remove from the event target. It must be the same as during registration listener.
     * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.
     */
  }, {
    key: "removeEventListener",
    value: function removeEventListener(element, eventName, callback) {
      var onlyOwnEvents = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var len = this.context.eventListeners.length;
      var tmpEvent;
      while (len) {
        len -= 1;
        tmpEvent = this.context.eventListeners[len];
        if (tmpEvent.event === eventName && tmpEvent.element === element) {
          if (callback && callback !== tmpEvent.callback) {
            continue;
          }
          if (onlyOwnEvents && tmpEvent.eventManager !== this) {
            continue;
          }
          this.context.eventListeners.splice(len, 1);
          tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, tmpEvent.options);
        }
      }
    }
    /**
     * Clear all previously registered events.
     *
     * @private
     * @since 0.15.0-beta3
     * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.
     */
  }, {
    key: "clearEvents",
    value: function clearEvents() {
      var onlyOwnEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!this.context) {
        return;
      }
      var len = this.context.eventListeners.length;
      while (len) {
        len -= 1;
        var event2 = this.context.eventListeners[len];
        if (onlyOwnEvents && event2.eventManager !== this) {
          continue;
        }
        this.context.eventListeners.splice(len, 1);
        event2.element.removeEventListener(event2.event, event2.callbackProxy, event2.options);
      }
    }
    /**
     * Clear all previously registered events.
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.clearEvents();
    }
    /**
     * Destroy instance of EventManager, clearing all events of the context.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearEvents();
      this.context = null;
    }
    /**
     * Destroy instance of EventManager, clearing only the own events.
     */
  }, {
    key: "destroyWithOwnEventsOnly",
    value: function destroyWithOwnEventsOnly() {
      this.clearEvents(true);
      this.context = null;
    }
    /**
     * Trigger event at the specified target element.
     *
     * @param {Element} element Target element.
     * @param {string} eventName Event name.
     */
  }, {
    key: "fireEvent",
    value: function fireEvent(element, eventName) {
      var rootDocument = element.document;
      var rootWindow = element;
      if (!rootDocument) {
        rootDocument = element.ownerDocument ? element.ownerDocument : element;
        rootWindow = rootDocument.defaultView;
      }
      var options = {
        bubbles: true,
        cancelable: eventName !== "mousemove",
        view: rootWindow,
        detail: 0,
        screenX: 0,
        screenY: 0,
        clientX: 1,
        clientY: 1,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: void 0
      };
      var event2;
      if (rootDocument.createEvent) {
        event2 = rootDocument.createEvent("MouseEvents");
        event2.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, rootDocument.body.parentNode);
      } else {
        event2 = rootDocument.createEventObject();
      }
      if (element.dispatchEvent) {
        element.dispatchEvent(event2);
      } else {
        element.fireEvent("on".concat(eventName), event2);
      }
    }
  }]);
  return EventManager2;
}();
function extendEvent(event2) {
  var nativeStopImmediatePropagation = event2.stopImmediatePropagation;
  event2.stopImmediatePropagation = function() {
    nativeStopImmediatePropagation.apply(this);
    stopImmediatePropagation(this);
  };
  return event2;
}
const EventManager$1 = EventManager;
var RENDERER_TYPE$4 = "autocomplete";
function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var rootDocument = instance.rootDocument;
  var rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;
  var ARROW = rootDocument.createElement("DIV");
  ARROW.className = "htAutocompleteArrow";
  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));
  rendererFunc.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  if (!TD.firstChild) {
    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160)));
  }
  TD.insertBefore(ARROW, TD.firstChild);
  addClass(TD, "htAutocomplete");
  if (!instance.acArrowListener) {
    var eventManager = new EventManager$1(instance);
    instance.acArrowListener = function(event2) {
      if (hasClass(event2.target, "htAutocompleteArrow")) {
        instance.view._wt.getSetting("onCellDblClick", null, instance._createCellCoords(row, col), TD);
      }
    };
    eventManager.addEventListener(instance.rootElement, "mousedown", instance.acArrowListener);
    instance.addHookOnce("afterDestroy", function() {
      eventManager.destroy();
    });
  }
}
autocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE$4;
var uncurryThis$c = functionUncurryThis;
var defineBuiltIns$1 = defineBuiltIns$3;
var getWeakData = internalMetadataExports.getWeakData;
var anInstance = anInstance$3;
var anObject$4 = anObject$l;
var isNullOrUndefined$2 = isNullOrUndefined$b;
var isObject$5 = isObject$n;
var iterate = iterate$3;
var ArrayIterationModule = arrayIteration;
var hasOwn$4 = hasOwnProperty_1;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice2 = uncurryThis$c([].splice);
var id = 0;
var uncaughtFrozenStore = function(store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
  this.entries = [];
};
var findUncaughtFrozen = function(store, key) {
  return find(store.entries, function(it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry)
      return entry[1];
  },
  has: function(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry)
      entry[1] = value;
    else
      this.entries.push([key, value]);
  },
  "delete": function(key) {
    var index2 = findIndex(this.entries, function(it) {
      return it[0] === key;
    });
    if (~index2)
      splice2(this.entries, index2, 1);
    return !!~index2;
  }
};
var collectionWeak$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper2(function(that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: void 0
      });
      if (!isNullOrUndefined$2(iterable))
        iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var data2 = getWeakData(anObject$4(key), true);
      if (data2 === true)
        uncaughtFrozenStore(state).set(key, value);
      else
        data2[state.id] = value;
      return that;
    };
    defineBuiltIns$1(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      "delete": function(key) {
        var state = getInternalState2(this);
        if (!isObject$5(key))
          return false;
        var data2 = getWeakData(key);
        if (data2 === true)
          return uncaughtFrozenStore(state)["delete"](key);
        return data2 && hasOwn$4(data2, state.id) && delete data2[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has2(key) {
        var state = getInternalState2(this);
        if (!isObject$5(key))
          return false;
        var data2 = getWeakData(key);
        if (data2 === true)
          return uncaughtFrozenStore(state).has(key);
        return data2 && hasOwn$4(data2, state.id);
      }
    });
    defineBuiltIns$1(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get2(key) {
        var state = getInternalState2(this);
        if (isObject$5(key)) {
          var data2 = getWeakData(key);
          if (data2 === true)
            return uncaughtFrozenStore(state).get(key);
          return data2 ? data2[state.id] : void 0;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set2(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return Constructor;
  }
};
var global$5 = global$s;
var uncurryThis$b = functionUncurryThis;
var defineBuiltIns = defineBuiltIns$3;
var InternalMetadataModule = internalMetadataExports;
var collection$3 = collection$5;
var collectionWeak$1 = collectionWeak$2;
var isObject$4 = isObject$n;
var isExtensible2 = objectIsExtensible;
var enforceInternalState = internalState.enforce;
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var IS_IE11 = !global$5.ActiveXObject && "ActiveXObject" in global$5;
var InternalWeakMap;
var wrapper = function(init) {
  return function WeakMap2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
};
var $WeakMap = collection$3("WeakMap", wrapper, collectionWeak$1);
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak$1.getConstructor(wrapper, "WeakMap", true);
  InternalMetadataModule.enable();
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = uncurryThis$b(WeakMapPrototype["delete"]);
  var nativeHas = uncurryThis$b(WeakMapPrototype.has);
  var nativeGet = uncurryThis$b(WeakMapPrototype.get);
  var nativeSet = uncurryThis$b(WeakMapPrototype.set);
  defineBuiltIns(WeakMapPrototype, {
    "delete": function(key) {
      if (isObject$4(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen["delete"](key);
      }
      return nativeDelete(this, key);
    },
    has: function has2(key) {
      if (isObject$4(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      }
      return nativeHas(this, key);
    },
    get: function get2(key) {
      if (isObject$4(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      }
      return nativeGet(this, key);
    },
    set: function set2(key, value) {
      if (isObject$4(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else
        nativeSet(this, key, value);
      return this;
    }
  });
}
var KEY_CODES = {
  ALT: 18,
  ARROW_DOWN: 40,
  ARROW_LEFT: 37,
  ARROW_RIGHT: 39,
  ARROW_UP: 38,
  AUDIO_DOWN: isFirefox() ? 182 : 174,
  AUDIO_MUTE: isFirefox() ? 181 : 173,
  AUDIO_UP: isFirefox() ? 183 : 175,
  BACKSPACE: 8,
  CAPS_LOCK: 20,
  COMMA: 188,
  COMMAND_LEFT: 91,
  COMMAND_RIGHT: 93,
  COMMAND_FIREFOX: 224,
  CONTROL: 17,
  DELETE: 46,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  F13: 124,
  F14: 125,
  F15: 126,
  F16: 127,
  F17: 128,
  F18: 129,
  F19: 130,
  HOME: 36,
  INSERT: 45,
  MEDIA_NEXT: 176,
  MEDIA_PLAY_PAUSE: 179,
  MEDIA_PREV: 177,
  MEDIA_STOP: 178,
  NULL: 0,
  NUM_LOCK: 144,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PAUSE: 19,
  PERIOD: 190,
  SCROLL_LOCK: 145,
  SHIFT: 16,
  SPACE: 32,
  TAB: 9,
  A: 65,
  C: 67,
  D: 68,
  F: 70,
  L: 76,
  O: 79,
  P: 80,
  S: 83,
  V: 86,
  X: 88,
  Y: 89,
  Z: 90
};
var FUNCTION_KEYS = [KEY_CODES.ALT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_UP, KEY_CODES.AUDIO_DOWN, KEY_CODES.AUDIO_MUTE, KEY_CODES.AUDIO_UP, KEY_CODES.BACKSPACE, KEY_CODES.CAPS_LOCK, KEY_CODES.DELETE, KEY_CODES.END, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.F13, KEY_CODES.F14, KEY_CODES.F15, KEY_CODES.F16, KEY_CODES.F17, KEY_CODES.F18, KEY_CODES.F19, KEY_CODES.HOME, KEY_CODES.INSERT, KEY_CODES.MEDIA_NEXT, KEY_CODES.MEDIA_PLAY_PAUSE, KEY_CODES.MEDIA_PREV, KEY_CODES.MEDIA_STOP, KEY_CODES.NULL, KEY_CODES.NUM_LOCK, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.PAUSE, KEY_CODES.SCROLL_LOCK, KEY_CODES.SHIFT, KEY_CODES.TAB];
function isPrintableChar(keyCode) {
  return keyCode === 32 || // space
  keyCode >= 48 && keyCode <= 57 || // 0-9
  keyCode >= 96 && keyCode <= 111 || // numpad
  keyCode >= 186 && keyCode <= 192 || // ;=,-./`
  keyCode >= 219 && keyCode <= 222 || // []{}\|"'
  keyCode >= 226 || // special chars (229 for Asian chars)
  keyCode >= 65 && keyCode <= 90;
}
function isFunctionKey(keyCode) {
  return FUNCTION_KEYS.includes(keyCode);
}
function isCtrlMetaKey(keyCode) {
  return [KEY_CODES.CONTROL, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX].includes(keyCode);
}
function isKey(keyCode, baseCode) {
  var keys3 = baseCode.split("|");
  var result = false;
  arrayEach(keys3, function(key) {
    if (keyCode === KEY_CODES[key]) {
      result = true;
      return false;
    }
  });
  return result;
}
var collection$2 = collection$5;
var collectionStrong = collectionStrong$2;
collection$2("Map", function(init) {
  return function Map2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong);
function warn$1() {
  if (isDefined(console)) {
    var _console2;
    (_console2 = console).warn.apply(_console2, arguments);
  }
}
function error() {
  if (isDefined(console)) {
    var _console4;
    (_console4 = console).error.apply(_console4, arguments);
  }
}
var $$m = _export;
var uncurryThis$a = functionUncurryThis;
var isArray2 = isArray$6;
var nativeReverse = uncurryThis$a([].reverse);
var test$1 = [1, 2];
$$m({ target: "Array", proto: true, forced: String(test$1) === String(test$1.reverse()) }, {
  reverse: function reverse() {
    if (isArray2(this))
      this.length = this.length;
    return nativeReverse(this);
  }
});
function isFunction(func) {
  return typeof func === "function";
}
function debounce(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  var lastTimer = null;
  var result;
  function _debounce() {
    var _this2 = this;
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    if (lastTimer) {
      clearTimeout(lastTimer);
    }
    lastTimer = setTimeout(function() {
      result = func.apply(_this2, args);
    }, wait);
    return result;
  }
  return _debounce;
}
function partial(func) {
  for (var _len6 = arguments.length, params = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    params[_key6 - 1] = arguments[_key6];
  }
  return function _partial() {
    for (var _len7 = arguments.length, restParams = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      restParams[_key7] = arguments[_key7];
    }
    return func.apply(this, params.concat(restParams));
  };
}
function curry(func) {
  var argsLength = func.length;
  function given(argsSoFar) {
    return function _curry() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }
      var passedArgsSoFar = argsSoFar.concat(params);
      var result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}
function fastCall(func, context, arg1, arg2, arg3, arg4, arg5, arg6) {
  if (isDefined(arg6)) {
    return func.call(context, arg1, arg2, arg3, arg4, arg5, arg6);
  } else if (isDefined(arg5)) {
    return func.call(context, arg1, arg2, arg3, arg4, arg5);
  } else if (isDefined(arg4)) {
    return func.call(context, arg1, arg2, arg3, arg4);
  } else if (isDefined(arg3)) {
    return func.call(context, arg1, arg2, arg3);
  } else if (isDefined(arg2)) {
    return func.call(context, arg1, arg2);
  } else if (isDefined(arg1)) {
    return func.call(context, arg1);
  }
  return func.call(context);
}
var _templateObject$g;
function _classCallCheck$2J(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2J(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2J(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2J(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2J(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _taggedTemplateLiteral$g(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
var REGISTERED_HOOKS = [
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Fired after resetting a cell's meta. This happens when the {@link Core#updateSettings} method is called.
   *
   * @event Hooks#afterCellMetaReset
   */
  "afterCellMetaReset",
  /**
   * Fired after one or more cells has been changed. The changes are triggered in any situation when the
   * value is entered using an editor or changed using API (e.q setDataAtCell).
   *
   * __Note:__ For performance reasons, the `changes` array is null for `"loadData"` source.
   *
   * @event Hooks#afterChange
   * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.
   * @param {string} [source] String that identifies source of hook call ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @example
   * ```js
   * new Handsontable(element, {
   *   afterChange: (changes) => {
   *     changes.forEach(([row, prop, oldValue, newValue]) => {
   *       // Some logic...
   *     });
   *   }
   * })
   * ```
   */
  "afterChange",
  /**
   * Fired each time user opens {@link ContextMenu} and after setting up the Context Menu's default options. These options are a collection
   * which user can select by setting an array of keys or an array of objects in {@link Options#contextMenu} option.
   *
   * @event Hooks#afterContextMenuDefaultOptions
   * @param {Array} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
   */
  "afterContextMenuDefaultOptions",
  /**
   * Fired each time user opens {@link ContextMenu} plugin before setting up the Context Menu's items but after filtering these options by
   * user (`contextMenu` option). This hook can by helpful to determine if user use specified menu item or to set up
   * one of the menu item to by always visible.
   *
   * @event Hooks#beforeContextMenuSetItems
   * @param {object[]} menuItems An array of objects containing information about to generated Context Menu items.
   */
  "beforeContextMenuSetItems",
  /**
   * Fired by {@link DropdownMenu} plugin after setting up the Dropdown Menu's default options. These options are a
   * collection which user can select by setting an array of keys or an array of objects in {@link Options#dropdownMenu}
   * option.
   *
   * @event Hooks#afterDropdownMenuDefaultOptions
   * @param {object[]} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
   */
  "afterDropdownMenuDefaultOptions",
  /**
   * Fired by {@link DropdownMenu} plugin before setting up the Dropdown Menu's items but after filtering these options
   * by user (`dropdownMenu` option). This hook can by helpful to determine if user use specified menu item or to set
   * up one of the menu item to by always visible.
   *
   * @event Hooks#beforeDropdownMenuSetItems
   * @param {object[]} menuItems An array of objects containing information about to generated Dropdown Menu items.
   */
  "beforeDropdownMenuSetItems",
  /**
   * Fired by {@link ContextMenu} plugin after hiding the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#afterContextMenuHide
   * @param {object} context The Context Menu plugin instance.
   */
  "afterContextMenuHide",
  /**
   * Fired by {@link ContextMenu} plugin before opening the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#beforeContextMenuShow
   * @param {object} context The Context Menu instance.
   */
  "beforeContextMenuShow",
  /**
   * Fired by {@link ContextMenu} plugin after opening the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#afterContextMenuShow
   * @param {object} context The Context Menu plugin instance.
   */
  "afterContextMenuShow",
  /**
   * Fired by {@link CopyPaste} plugin after reaching the copy limit while copying data. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterCopyLimit
   * @param {number} selectedRows Count of selected copyable rows.
   * @param {number} selectedColumns Count of selected copyable columns.
   * @param {number} copyRowsLimit Current copy rows limit.
   * @param {number} copyColumnsLimit Current copy columns limit.
   */
  "afterCopyLimit",
  /**
   * Fired before created a new column.
   *
   * @event Hooks#beforeCreateCol
   * @param {number} index Represents the visual index of first newly created column in the data source array.
   * @param {number} amount Number of newly created columns in the data source array.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*} If `false` then creating columns is cancelled.
   * @example
   * ```js
   * // Return `false` to cancel column inserting.
   * new Handsontable(element, {
   *   beforeCreateCol: function(data, coords) {
   *     return false;
   *   }
   * });
   * ```
   */
  "beforeCreateCol",
  /**
   * Fired after created a new column.
   *
   * @event Hooks#afterCreateCol
   * @param {number} index Represents the visual index of first newly created column in the data source.
   * @param {number} amount Number of newly created columns in the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterCreateCol",
  /**
   * Fired before created a new row.
   *
   * @event Hooks#beforeCreateRow
   * @param {number} index Represents the visual index of first newly created row in the data source array.
   * @param {number} amount Number of newly created rows in the data source array.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeCreateRow",
  /**
   * Fired after created a new row.
   *
   * @event Hooks#afterCreateRow
   * @param {number} index Represents the visual index of first newly created row in the data source array.
   * @param {number} amount Number of newly created rows in the data source array.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterCreateRow",
  /**
   * Fired after all selected cells are deselected.
   *
   * @event Hooks#afterDeselect
   */
  "afterDeselect",
  /**
   * Fired after destroying the Handsontable instance.
   *
   * @event Hooks#afterDestroy
   */
  "afterDestroy",
  /**
   * Hook fired after keydown event is handled.
   *
   * @event Hooks#afterDocumentKeyDown
   * @param {Event} event A native `keydown` event object.
   */
  "afterDocumentKeyDown",
  /**
   * Fired inside the Walkontable's selection `draw` method. Can be used to add additional class names to cells, depending on the current selection.
   *
   * @event Hooks#afterDrawSelection
   * @param {number} currentRow Row index of the currently processed cell.
   * @param {number} currentColumn Column index of the currently cell.
   * @param {number[]} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
   * @since 0.38.1
   * @returns {string|undefined} Can return a `String`, which will act as an additional `className` to be added to the currently processed cell.
   */
  "afterDrawSelection",
  /**
   * Fired inside the Walkontable's `refreshSelections` method. Can be used to remove additional class names from all cells in the table.
   *
   * @event Hooks#beforeRemoveCellClassNames
   * @since 0.38.1
   * @returns {string[]|undefined} Can return an `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
   */
  "beforeRemoveCellClassNames",
  /**
   * Fired after getting the cell settings.
   *
   * @event Hooks#afterGetCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} cellProperties Object containing the cell properties.
   */
  "afterGetCellMeta",
  /**
   * Fired after retrieving information about a column header and appending it to the table header.
   *
   * @event Hooks#afterGetColHeader
   * @param {number} column Visual column index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   */
  "afterGetColHeader",
  /**
   * Fired after retrieving information about a row header and appending it to the table header.
   *
   * @event Hooks#afterGetRowHeader
   * @param {number} row Visual row index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   */
  "afterGetRowHeader",
  /**
   * Fired after the Handsontable instance is initiated.
   *
   * @event Hooks#afterInit
   */
  "afterInit",
  /**
   * Fired after Handsontable's [`data`](@/api/options.md#data)
   * gets modified by the [`loadData()`](@/api/core.md#loaddata) method
   * or the [`updateSettings()`](@/api/core.md#updatesettings) method.
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#afterLoadData
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   */
  "afterLoadData",
  /**
   * Fired after the [`updateData()`](@/api/core.md#updatedata) method
   * modifies Handsontable's [`data`](@/api/options.md#data).
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#afterUpdateData
   * @since 11.1.0
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   */
  "afterUpdateData",
  /**
   * Fired after a scroll event, which is identified as a momentum scroll (e.g. On an iPad).
   *
   * @event Hooks#afterMomentumScroll
   */
  "afterMomentumScroll",
  /**
   * Fired after a `mousedown` event is triggered on the cell corner (the drag handle).
   *
   * @event Hooks#afterOnCellCornerMouseDown
   * @param {Event} event `mousedown` event object.
   */
  "afterOnCellCornerMouseDown",
  /**
   * Fired after a `dblclick` event is triggered on the cell corner (the drag handle).
   *
   * @event Hooks#afterOnCellCornerDblClick
   * @param {Event} event `dblclick` event object.
   */
  "afterOnCellCornerDblClick",
  /**
   * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
   * indexes are negative.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseDown` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseDown
   * @param {Event} event `mousedown` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseDown",
  /**
   * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
   * indexes are negative.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseUp` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseUp
   * @param {Event} event `mouseup` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseUp",
  /**
   * Fired after clicking right mouse button on a cell or row/column header.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellContextMenu` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellContextMenu
   * @since 4.1.0
   * @param {Event} event `contextmenu` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellContextMenu",
  /**
   * Fired after hovering a cell or row/column header with the mouse cursor. In case the row/column header was
   * hovered, the index is negative.
   *
   * For example, hovering over the row header of cell (0, 0) results with `afterOnCellMouseOver` called
   * with coords `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseOver
   * @param {Event} event `mouseover` event object.
   * @param {CellCoords} coords Hovered cell's visual coordinate object.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseOver",
  /**
   * Fired after leaving a cell or row/column header with the mouse cursor.
   *
   * @event Hooks#afterOnCellMouseOut
   * @param {Event} event `mouseout` event object.
   * @param {CellCoords} coords Leaved cell's visual coordinate object.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseOut",
  /**
   * Fired after one or more columns are removed.
   *
   * @event Hooks#afterRemoveCol
   * @param {number} index Visual index of starter column.
   * @param {number} amount An amount of removed columns.
   * @param {number[]} physicalColumns An array of physical columns removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterRemoveCol",
  /**
   * Fired after one or more rows are removed.
   *
   * @event Hooks#afterRemoveRow
   * @param {number} index Visual index of starter row.
   * @param {number} amount An amount of removed rows.
   * @param {number[]} physicalRows An array of physical rows removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterRemoveRow",
  /**
   * Fired before starting rendering the cell.
   *
   * @event Hooks#beforeRenderer
   * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
   * @param {*} value Value of the rendered cell.
   * @param {object} cellProperties Object containing the cell's properties.
   */
  "beforeRenderer",
  /**
   * Fired after finishing rendering the cell (after the renderer finishes).
   *
   * @event Hooks#afterRenderer
   * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
   * @param {*} value Value of the rendered cell.
   * @param {object} cellProperties Object containing the cell's properties.
   */
  "afterRenderer",
  /**
   * Fired after the horizontal scroll event.
   *
   * @event Hooks#afterScrollHorizontally
   */
  "afterScrollHorizontally",
  /**
   * Fired after the vertical scroll event.
   *
   * @event Hooks#afterScrollVertically
   */
  "afterScrollVertically",
  /**
   * Fired after one or more cells are selected (e.g. During mouse move).
   *
   * @event Hooks#afterSelection
   * @param {number} row Selection start visual row index.
   * @param {number} column Selection start visual column index.
   * @param {number} row2 Selection end visual row index.
   * @param {number} column2 Selection end visual column index.
   * @param {object} preventScrolling A reference to the observable object with the `value` property.
   *                                  Property `preventScrolling.value` expects a boolean value that
   *                                  Handsontable uses to control scroll behavior after selection.
   * @param {object} preventScrolling Object with `value` property where its value change will be observed.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   * @example
   * ```js
   * new Handsontable(element, {
   *   afterSelection: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // If set to `false` (default): when cell selection is outside the viewport,
   *     // Handsontable scrolls the viewport to cell selection's end corner.
   *     // If set to `true`: when cell selection is outside the viewport,
   *     // Handsontable doesn't scroll to cell selection's end corner.
   *     preventScrolling.value = true;
   *   }
   * })
   * ```
   */
  "afterSelection",
  /**
   * Fired after one or more cells are selected.
   *
   * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
   *
   * @event Hooks#afterSelectionByProp
   * @param {number} row Selection start visual row index.
   * @param {string} prop Selection start data source object property name.
   * @param {number} row2 Selection end visual row index.
   * @param {string} prop2 Selection end data source object property name.
   * @param {object} preventScrolling Object with `value` property where its value change will be observed.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   * @example
   * ```js
   * new Handsontable(element, {
   *   afterSelectionByProp: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // setting if prevent scrolling after selection
   *     preventScrolling.value = true;
   *   }
   * })
   * ```
   */
  "afterSelectionByProp",
  /**
   * Fired after one or more cells are selected (e.g. On mouse up).
   *
   * @event Hooks#afterSelectionEnd
   * @param {number} row Selection start visual row index.
   * @param {number} column Selection start visual column index.
   * @param {number} row2 Selection end visual row index.
   * @param {number} column2 Selection end visual column index.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   */
  "afterSelectionEnd",
  /**
   * Fired after one or more cells are selected (e.g. On mouse up).
   *
   * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
   *
   * @event Hooks#afterSelectionEndByProp
   * @param {number} row Selection start visual row index.
   * @param {string} prop Selection start data source object property index.
   * @param {number} row2 Selection end visual row index.
   * @param {string} prop2 Selection end data source object property index.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   */
  "afterSelectionEndByProp",
  /**
   * Fired after cell meta is changed.
   *
   * @event Hooks#afterSetCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The updated meta key.
   * @param {*} value The updated meta value.
   */
  "afterSetCellMeta",
  /**
   * Fired after cell meta is removed.
   *
   * @event Hooks#afterRemoveCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The removed meta key.
   * @param {*} value Value which was under removed key of cell meta.
   */
  "afterRemoveCellMeta",
  /**
   * Fired after cell data was changed.
   *
   * @event Hooks#afterSetDataAtCell
   * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterSetDataAtCell",
  /**
   * Fired after cell data was changed.
   * Called only when `setDataAtRowProp` was executed.
   *
   * @event Hooks#afterSetDataAtRowProp
   * @param {Array} changes An array of changes in format `[[row, prop, oldValue, value], ...]`.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterSetDataAtRowProp",
  /**
   * Fired after cell source data was changed.
   *
   * @event Hooks#afterSetSourceDataAtCell
   * @since 8.0.0
   * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.
   * @param {string} [source] String that identifies source of hook call.
   */
  "afterSetSourceDataAtCell",
  /**
   * Fired after calling the `updateSettings` method.
   *
   * @event Hooks#afterUpdateSettings
   * @param {object} newSettings New settings object.
   */
  "afterUpdateSettings",
  /**
   * @description
   * A plugin hook executed after validator function, only if validator function is defined.
   * Validation result is the first parameter. This can be used to determinate if validation passed successfully or not.
   *
   * __Returning false from the callback will mark the cell as invalid__.
   *
   * @event Hooks#afterValidate
   * @param {boolean} isValid `true` if valid, `false` if not.
   * @param {*} value The value in question.
   * @param {number} row Visual row index.
   * @param {string|number} prop Property name / visual column index.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {undefined | boolean} If `false` the cell will be marked as invalid, `true` otherwise.
   */
  "afterValidate",
  /**
   * Fired before successful change of language (when proper language code was set).
   *
   * @event Hooks#beforeLanguageChange
   * @since 0.35.0
   * @param {string} languageCode New language code.
   */
  "beforeLanguageChange",
  /**
   * Fired after successful change of language (when proper language code was set).
   *
   * @event Hooks#afterLanguageChange
   * @since 0.35.0
   * @param {string} languageCode New language code.
   */
  "afterLanguageChange",
  /**
   * Fired by {@link Autofill} plugin before populating the data in the autofill feature. This hook is fired when
   * {@link Options#fillHandle} option is enabled.
   *
   * @event Hooks#beforeAutofill
   * @param {Array[]} selectionData Data the autofill operation will start from.
   * @param {CellRange} sourceRange The range values will be filled from.
   * @param {CellRange} targetRange The range new values will be filled into.
   * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
   *
   * @returns {boolean|Array[]} If false, the operation is cancelled. If array of arrays, the returned data
   *                              will be passed into `populateFromArray` instead of the default autofill
   *                              algorithm's result.
   */
  "beforeAutofill",
  /**
   * Fired by {@link Autofill} plugin after populating the data in the autofill feature. This hook is fired when
   * {@link Options#fillHandle} option is enabled.
   *
   * @event Hooks#afterAutofill
   * @since 8.0.0
   * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used
   *                            and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.
   * @param {CellRange} sourceRange The range values will be filled from.
   * @param {CellRange} targetRange The range new values will be filled into.
   * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
   */
  "afterAutofill",
  /**
   * Fired before aligning the cell contents.
   *
   * @event Hooks#beforeCellAlignment
   * @param {object} stateBefore An object with class names defining the cell alignment.
   * @param {CellRange[]} range An array of CellRange coordinates where the alignment will be applied.
   * @param {string} type Type of the alignment - either `horizontal` or `vertical`.
   * @param {string} alignmentClass String defining the alignment class added to the cell.
   * Possible values:
   * * `htLeft`
   * * `htCenter`
   * * `htRight`
   * * `htJustify`
   * * `htTop`
   * * `htMiddle`
   * * `htBottom`.
   */
  "beforeCellAlignment",
  /**
   * Fired before one or more cells is changed. Its main purpose is to alter changes silently after input and before
   * table rendering.
   *
   * @event Hooks#beforeChange
   * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {undefined | boolean} If `false` all changes were cancelled, `true` otherwise.
   * @example
   * ```js
   * // To disregard a single change, set changes[i] to null or remove it from array using changes.splice(i, 1).
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0] = null;
   *   }
   * });
   * // To alter a single change, overwrite the desired value to changes[i][3].
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0][3] = 10;
   *   }
   * });
   * // To cancel all edit, return false from the callback or set array length to 0 (changes.length = 0).
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     return false;
   *   }
   * });
   * ```
   */
  "beforeChange",
  /**
   * Fired right before rendering the changes.
   *
   * @event Hooks#beforeChangeRender
   * @param {Array[]} changes Array in form of `[row, prop, oldValue, newValue]`.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "beforeChangeRender",
  /**
   * Fired before drawing the borders.
   *
   * @event Hooks#beforeDrawBorders
   * @param {Array} corners Array specifying the current selection borders.
   * @param {string} borderClassName Specifies the border class name.
   */
  "beforeDrawBorders",
  /**
   * Fired before getting cell settings.
   *
   * @event Hooks#beforeGetCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} cellProperties Object containing the cell's properties.
   */
  "beforeGetCellMeta",
  /**
   * Fired before cell meta is removed.
   *
   * @event Hooks#beforeRemoveCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The removed meta key.
   * @param {*} value Value which is under removed key of cell meta.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRemoveCellMeta",
  /**
   * Fired before the Handsontable instance is initiated.
   *
   * @event Hooks#beforeInit
   */
  "beforeInit",
  /**
   * Fired before the Walkontable instance is initiated.
   *
   * @event Hooks#beforeInitWalkontable
   * @param {object} walkontableConfig Walkontable configuration object.
   */
  "beforeInitWalkontable",
  /**
   * Fired before Handsontable's [`data`](@/api/options.md#data)
   * gets modified by the [`loadData()`](@/api/core.md#loaddata) method
   * or the [`updateSettings()`](@/api/core.md#updatesettings) method.
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#beforeLoadData
   * @since 8.0.0
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   * @returns {Array} The returned array will be used as Handsontable's new dataset.
   */
  "beforeLoadData",
  /**
   * Fired before the [`updateData()`](@/api/core.md#updatedata) method
   * modifies Handsontable's [`data`](@/api/options.md#data).
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#beforeUpdateData
   * @since 11.1.0
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   * @returns {Array} The returned array will be used as Handsontable's new dataset.
   */
  "beforeUpdateData",
  /**
   * Hook fired before keydown event is handled. It can be used to stop default key bindings.
   *
   * __Note__: To prevent default behavior you need to call `false` in your `beforeKeyDown` handler.
   *
   * @event Hooks#beforeKeyDown
   * @param {Event} event Original DOM event.
   */
  "beforeKeyDown",
  /**
   * Fired after the user clicked a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseDown
   * @param {Event} event The `mousedown` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  "beforeOnCellMouseDown",
  /**
   * Fired after the user clicked a cell.
   *
   * @event Hooks#beforeOnCellMouseUp
   * @param {Event} event The `mouseup` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellMouseUp",
  /**
   * Fired after the user clicked a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellContextMenu
   * @since 4.1.0
   * @param {Event} event The `contextmenu` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellContextMenu",
  /**
   * Fired after the user moved cursor over a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseOver
   * @param {Event} event The `mouseover` event object.
   * @param {CellCoords} coords CellCoords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  "beforeOnCellMouseOver",
  /**
   * Fired after the user moved cursor out from a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseOut
   * @param {Event} event The `mouseout` event object.
   * @param {CellCoords} coords CellCoords object containing the visual coordinates of the leaved cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellMouseOut",
  /**
   * Fired before one or more columns are about to be removed.
   *
   * @event Hooks#beforeRemoveCol
   * @param {number} index Visual index of starter column.
   * @param {number} amount Amount of columns to be removed.
   * @param {number[]} physicalColumns An array of physical columns removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRemoveCol",
  /**
   * Fired when one or more rows are about to be removed.
   *
   * @event Hooks#beforeRemoveRow
   * @param {number} index Visual index of starter row.
   * @param {number} amount Amount of rows to be removed.
   * @param {number[]} physicalRows An array of physical rows removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRemoveRow",
  /**
   * Fired before Handsontable's view-rendering engine is rendered.
   *
   * __Note:__ In Handsontable 9.x and earlier, the `beforeViewRender` hook was named `beforeRender`.
   *
   * @event Hooks#beforeViewRender
   * @since 10.0.0
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering cycle will be skipped.
   */
  "beforeViewRender",
  /**
   * Fired after Handsontable's view-rendering engine is rendered,
   * but before redrawing the selection borders and before scroll syncing.
   *
   * __Note:__ In Handsontable 9.x and earlier, the `afterViewRender` hook was named `afterRender`.
   *
   * @event Hooks#afterViewRender
   * @since 10.0.0
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   */
  "afterViewRender",
  /**
   * Fired before Handsontable's view-rendering engine updates the view.
   *
   * The `beforeRender` event is fired right after the Handsontable
   * business logic is executed and right before the rendering engine starts calling
   * the Core logic, renderers, cell meta objects etc. to update the view.
   *
   * @event Hooks#beforeRender
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   */
  "beforeRender",
  /**
   * Fired after Handsontable's view-rendering engine updates the view.
   *
   * @event Hooks#afterRender
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   */
  "afterRender",
  /**
   * Fired before cell meta is changed.
   *
   * @event Hooks#beforeSetCellMeta
   * @since 8.0.0
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The updated meta key.
   * @param {*} value The updated meta value.
   * @returns {boolean|undefined} If false is returned the action is canceled.
   */
  "beforeSetCellMeta",
  /**
   * Fired before setting range is started but not finished yet.
   *
   * @event Hooks#beforeSetRangeStartOnly
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeStartOnly",
  /**
   * Fired before setting range is started.
   *
   * @event Hooks#beforeSetRangeStart
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeStart",
  /**
   * Fired before setting range is ended.
   *
   * @event Hooks#beforeSetRangeEnd
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeEnd",
  /**
   * Fired before the logic of handling a touch scroll, when user started scrolling on a touch-enabled device.
   *
   * @event Hooks#beforeTouchScroll
   */
  "beforeTouchScroll",
  /**
   * Fired before cell validation, only if validator function is defined. This can be used to manipulate the value
   * of changed cell before it is applied to the validator function.
   *
   * __Note:__ this will not affect values of changes. This will change value *ONLY* for validation.
   *
   * @event Hooks#beforeValidate
   * @param {*} value Value of the cell.
   * @param {number} row Visual row index.
   * @param {string|number} prop Property name / column index.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "beforeValidate",
  /**
   * Fired before cell value is rendered into the DOM (through renderer function). This can be used to manipulate the
   * value which is passed to the renderer without modifying the renderer itself.
   *
   * @event Hooks#beforeValueRender
   * @param {*} value Cell value to render.
   * @param {object} cellProperties An object containing the cell properties.
   */
  "beforeValueRender",
  /**
   * Fired after Handsontable instance is constructed (using `new` operator).
   *
   * @event Hooks#construct
   */
  "construct",
  /**
   * Fired after Handsontable instance is initiated but before table is rendered.
   *
   * @event Hooks#init
   */
  "init",
  /**
   * Fired when a column header index is about to be modified by a callback function.
   *
   * @event Hooks#modifyColHeader
   * @param {number} column Visual column header index.
   */
  "modifyColHeader",
  /**
   * Fired when a column width is about to be modified by a callback function.
   *
   * @event Hooks#modifyColWidth
   * @param {number} width Current column width.
   * @param {number} column Visual column index.
   */
  "modifyColWidth",
  /**
   * Fired when a row header index is about to be modified by a callback function.
   *
   * @event Hooks#modifyRowHeader
   * @param {number} row Visual row header index.
   */
  "modifyRowHeader",
  /**
   * Fired when a row height is about to be modified by a callback function.
   *
   * @event Hooks#modifyRowHeight
   * @param {number} height Row height.
   * @param {number} row Visual row index.
   */
  "modifyRowHeight",
  /**
   * Fired when a data was retrieved or modified.
   *
   * @event Hooks#modifyData
   * @param {number} row Physical row height.
   * @param {number} column Physical column index.
   * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.
   * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
   */
  "modifyData",
  /**
   * Fired when a data was retrieved or modified from the source data set.
   *
   * @event Hooks#modifySourceData
   * @since 8.0.0
   * @param {number} row Physical row index.
   * @param {number} column Physical column index.
   * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.
   * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
   */
  "modifySourceData",
  /**
   * Fired when a data was retrieved or modified.
   *
   * @event Hooks#modifyRowData
   * @param {number} row Physical row index.
   */
  "modifyRowData",
  /**
   * Used to modify the cell coordinates when using the `getCell` method, opening editor, getting value from the editor
   * and saving values from the closed editor.
   *
   * @event Hooks#modifyGetCellCoords
   * @since 0.36.0
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {boolean} topmost If set to `true`, it returns the TD element from the topmost overlay. For example,
   *                          if the wanted cell is in the range of fixed rows, it will return a TD element
   *                          from the `top` overlay.
   * @returns {undefined|number[]}
   */
  "modifyGetCellCoords",
  /**
   * Allows modify the visual row index that is used to retrieve the row header element (TH) before it's
   * highlighted (proper CSS class names are added). Modifying the visual row index allows building a custom
   * implementation of the nested headers feature or other features that require highlighting other DOM
   * elements than that the rendering engine, by default, would have highlighted.
   *
   * @event Hooks#beforeHighlightingRowHeader
   * @since 8.4.0
   * @param {number} row Visual row index.
   * @param {number} headerLevel Column header level (0 = most distant to the table).
   * @param {object} highlightMeta An object that contains additional information about processed selection.
   * @returns {number|undefined}
   */
  "beforeHighlightingRowHeader",
  /**
   * Allows modify the visual column index that is used to retrieve the column header element (TH) before it's
   * highlighted (proper CSS class names are added). Modifying the visual column index allows building a custom
   * implementation of the nested headers feature or other features that require highlighting other DOM
   * elements than that the rendering engine, by default, would have highlighted.
   *
   * @event Hooks#beforeHighlightingColumnHeader
   * @since 8.4.0
   * @param {number} column Visual column index.
   * @param {number} headerLevel Row header level (0 = most distant to the table).
   * @param {object} highlightMeta An object that contains additional information about processed selection.
   * @returns {number|undefined}
   */
  "beforeHighlightingColumnHeader",
  /**
   * Fired by {@link PersistentState} plugin, after loading value, saved under given key, from browser local storage.
   *
   * The `persistentStateLoad` hook is fired even when the {@link Options#persistentState} option is disabled.
   *
   * @event Hooks#persistentStateLoad
   * @param {string} key Key.
   * @param {object} valuePlaceholder Object containing the loaded value under `valuePlaceholder.value` (if no value have been saved, `value` key will be undefined).
   */
  "persistentStateLoad",
  /**
   * Fired by {@link PersistentState} plugin after resetting data from local storage. If no key is given, all values associated with table will be cleared.
   * This hook is fired when {@link Options#persistentState} option is enabled.
   *
   * @event Hooks#persistentStateReset
   * @param {string} [key] Key.
   */
  "persistentStateReset",
  /**
   * Fired by {@link PersistentState} plugin, after saving value under given key in browser local storage.
   *
   * The `persistentStateSave` hook is fired even when the {@link Options#persistentState} option is disabled.
   *
   * @event Hooks#persistentStateSave
   * @param {string} key Key.
   * @param {Mixed} value Value to save.
   */
  "persistentStateSave",
  /**
   * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins before sorting the column. If you return `false` value inside callback for hook, then sorting
   * will be not applied by the Handsontable (useful for server-side sorting).
   *
   * This hook is fired when {@link Options#columnSorting} or {@link Options#multiColumnSorting} option is enabled.
   *
   * @event Hooks#beforeColumnSort
   * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
   * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
   * @returns {boolean | undefined} If `false` the column will not be sorted, `true` otherwise.
   */
  "beforeColumnSort",
  /**
   * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins after sorting the column. This hook is fired when {@link Options#columnSorting}
   * or {@link Options#multiColumnSorting} option is enabled.
   *
   * @event Hooks#afterColumnSort
   * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
   * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
   */
  "afterColumnSort",
  /**
   * Fired by {@link Autofill} plugin after setting range of autofill. This hook is fired when {@link Options#fillHandle}
   * option is enabled.
   *
   * @event Hooks#modifyAutofillRange
   * @param {Array} startArea Array of visual coordinates of the starting point for the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
   * @param {Array} entireArea Array of visual coordinates of the entire area of the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
   */
  "modifyAutofillRange",
  /**
   * Fired to allow modifying the copyable range with a callback function.
   *
   * @event Hooks#modifyCopyableRange
   * @param {Array[]} copyableRanges Array of objects defining copyable cells.
   */
  "modifyCopyableRange",
  /**
   * Fired by {@link CopyPaste} plugin before copying the values into clipboard and before clearing values of
   * the selected cells. This hook is fired when {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#beforeCut
   * @param {Array[]} data An array of arrays which contains data to cut.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       which will be cut out.
   * @returns {*} If returns `false` then operation of the cutting out is canceled.
   * @example
   * ```js
   * // To disregard a single row, remove it from the array using data.splice(i, 1).
   * new Handsontable(element, {
   *   beforeCut: function(data, coords) {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * // To cancel a cutting action, just return `false`.
   * new Handsontable(element, {
   *   beforeCut: function(data, coords) {
   *     return false;
   *   }
   * });
   * ```
   */
  "beforeCut",
  /**
   * Fired by {@link CopyPaste} plugin after data was cut out from the table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterCut
   * @param {Array[]} data An array of arrays which contains the cutted out data.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       which was cut out.
   */
  "afterCut",
  /**
   * Fired before values are copied into clipboard.
   *
   * @event Hooks#beforeCopy
   * @param {Array[]} data An array of arrays which contains data to copied.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                         which will copied.
   * @returns {*} If returns `false` then copying is canceled.
   *
   * @example
   * ```js
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * ...
   * new Handsontable(document.getElementById('example'), {
   *   beforeCopy: (data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * ...
   *
   * // To cancel copying, return false from the callback.
   * ...
   * new Handsontable(document.getElementById('example'), {
   *   beforeCopy: (data, coords) => {
   *     return false;
   *   }
   * });
   * ...
   * ```
   */
  "beforeCopy",
  /**
   * Fired by {@link CopyPaste} plugin after data are pasted into table. This hook is fired when {@link Options#copyPaste}
   * option is enabled.
   *
   * @event Hooks#afterCopy
   * @param {Array[]} data An array of arrays which contains the copied data.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                         which was copied.
   */
  "afterCopy",
  /**
   * Fired by {@link CopyPaste} plugin before values are pasted into table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#beforePaste
   * @param {Array[]} data An array of arrays which contains data to paste.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       that correspond to the previously selected area.
   * @returns {*} If returns `false` then pasting is canceled.
   * @example
   * ```js
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * new Handsontable(example, {
   *   beforePaste: (data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * // To cancel pasting, return false from the callback.
   * new Handsontable(example, {
   *   beforePaste: (data, coords) => {
   *     return false;
   *   }
   * });
   * ```
   */
  "beforePaste",
  /**
   * Fired by {@link CopyPaste} plugin after values are pasted into table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterPaste
   * @param {Array[]} data An array of arrays which contains the pasted data.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       that correspond to the previously selected area.
   */
  "afterPaste",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, before freezing a column.
   *
   * @event Hooks#beforeColumnFreeze
   * @since 12.1.0
   * @param {number} column The visual index of the column that is going to freeze.
   * @param {boolean} freezePerformed If `true`: the column is going to freeze. If `false`: the column is not going to freeze (which might happen if the column is already frozen).
   * @returns {boolean|undefined} If `false`: the column is not going to freeze, and the `afterColumnFreeze` hook won't fire.
   */
  "beforeColumnFreeze",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, right after freezing a column.
   *
   * @event Hooks#afterColumnFreeze
   * @since 12.1.0
   * @param {number} column The visual index of the frozen column.
   * @param {boolean} freezePerformed If `true`: the column got successfully frozen. If `false`: the column didn't get frozen.
   */
  "afterColumnFreeze",
  /**
   * Fired by {@link ManualColumnMove} plugin before change order of the visual indexes. This hook is fired when
   * {@link Options#manualColumnMove} option is enabled.
   *
   * @event Hooks#beforeColumnMove
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/columns/column-moving.md).
   * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.
   *                                     Points to where we are going to drop the moved elements. To check
   *                                     visualization of drop index please take a look at
   *                                     [documentation](@/guides/columns/column-moving.md).
   *                                     It's `undefined` when `dragColumns` function wasn't called.
   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
   * @returns {undefined | boolean} If `false` the column will not be moved, `true` otherwise.
   */
  "beforeColumnMove",
  /**
   * Fired by {@link ManualColumnMove} plugin after changing order of the visual indexes.
   * This hook is fired when {@link Options#manualColumnMove} option is enabled.
   *
   * @event Hooks#afterColumnMove
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/columns/column-moving.md).
   * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.
   *                                     Points to where we are going to drop the moved elements.
   *                                     To check visualization of drop index please take a look at
   *                                     [documentation](@/guides/columns/column-moving.md).
   *                                     It's `undefined` when `dragColumns` function wasn't called.
   * @param {boolean} movePossible Indicates if it was possible to move columns to the desired position.
   * @param {boolean} orderChanged Indicates if order of columns was changed by move.
   */
  "afterColumnMove",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, before unfreezing a column.
   *
   * @event Hooks#beforeColumnUnfreeze
   * @since 12.1.0
   * @param {number} column The visual index of the column that is going to unfreeze.
   * @param {boolean} unfreezePerformed If `true`: the column is going to unfreeze. If `false`: the column is not going to unfreeze (which might happen if the column is already unfrozen).
   * @returns {boolean|undefined} If `false`: the column is not going to unfreeze, and the `afterColumnUnfreeze` hook won't fire.
   */
  "beforeColumnUnfreeze",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, right after unfreezing a column.
   *
   * @event Hooks#afterColumnUnfreeze
   * @since 12.1.0
   * @param {number} column The visual index of the unfrozen column.
   * @param {boolean} unfreezePerformed If `true`: the column got successfully unfrozen. If `false`: the column didn't get unfrozen.
   */
  "afterColumnUnfreeze",
  /**
   * Fired by {@link ManualRowMove} plugin before changing the order of the visual indexes. This hook is fired when
   * {@link Options#manualRowMove} option is enabled.
   *
   * @event Hooks#beforeRowMove
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/rows/row-moving.md).
   * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.
   *                                     Points to where we are going to drop the moved elements.
   *                                     To check visualization of drop index please take a look at
   *                                     [documentation](@/guides/rows/row-moving.md).
   *                                     It's `undefined` when `dragRows` function wasn't called.
   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRowMove",
  /**
   * Fired by {@link ManualRowMove} plugin after changing the order of the visual indexes.
   * This hook is fired when {@link Options#manualRowMove} option is enabled.
   *
   * @event Hooks#afterRowMove
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/rows/row-moving.md).
   * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.
   *                                     Points to where we are going to drop the moved elements.
   *                                     To check visualization of drop index please take a look at
   *                                     [documentation](@/guides/rows/row-moving.md).
   *                                     It's `undefined` when `dragRows` function wasn't called.
   * @param {boolean} movePossible Indicates if it was possible to move rows to the desired position.
   * @param {boolean} orderChanged Indicates if order of rows was changed by move.
   */
  "afterRowMove",
  /**
   * Fired by {@link ManualColumnResize} plugin before rendering the table with modified column sizes. This hook is
   * fired when {@link Options#manualColumnResize} option is enabled.
   *
   * @event Hooks#beforeColumnResize
   * @param {number} newSize Calculated new column width.
   * @param {number} column Visual index of the resized column.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   * @returns {number} Returns a new column size or `undefined`, if column size should be calculated automatically.
   */
  "beforeColumnResize",
  /**
   * Fired by {@link ManualColumnResize} plugin after rendering the table with modified column sizes. This hook is
   * fired when {@link Options#manualColumnResize} option is enabled.
   *
   * @event Hooks#afterColumnResize
   * @param {number} newSize Calculated new column width.
   * @param {number} column Visual index of the resized column.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   */
  "afterColumnResize",
  /**
   * Fired by {@link ManualRowResize} plugin before rendering the table with modified row sizes. This hook is
   * fired when {@link Options#manualRowResize} option is enabled.
   *
   * @event Hooks#beforeRowResize
   * @param {number} newSize Calculated new row height.
   * @param {number} row Visual index of the resized row.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   * @returns {number|undefined} Returns the new row size or `undefined` if row size should be calculated automatically.
   */
  "beforeRowResize",
  /**
   * Fired by {@link ManualRowResize} plugin after rendering the table with modified row sizes. This hook is
   * fired when {@link Options#manualRowResize} option is enabled.
   *
   * @event Hooks#afterRowResize
   * @param {number} newSize Calculated new row height.
   * @param {number} row Visual index of the resized row.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   */
  "afterRowResize",
  /**
   * Fired after getting the column header renderers.
   *
   * @event Hooks#afterGetColumnHeaderRenderers
   * @param {Function[]} renderers An array of the column header renderers.
   */
  "afterGetColumnHeaderRenderers",
  /**
   * Fired after getting the row header renderers.
   *
   * @event Hooks#afterGetRowHeaderRenderers
   * @param {Function[]} renderers An array of the row header renderers.
   */
  "afterGetRowHeaderRenderers",
  /**
   * Fired before applying stretched column width to column.
   *
   * @event Hooks#beforeStretchingColumnWidth
   * @param {number} stretchedWidth Calculated width.
   * @param {number} column Visual column index.
   * @returns {number|undefined} Returns new width which will be applied to the column element.
   */
  "beforeStretchingColumnWidth",
  /**
   * Fired by {@link Filters} plugin before applying [filtering](@/guides/columns/column-filter.md).
   * This hook is fired when {@link Options#filters} option is enabled.
   *
   * @event Hooks#beforeFilter
   * @param {object[]} conditionsStack An array of objects with added formulas.
   * ```js
   * // Example format of the conditionsStack argument:
   * [
   *   {
   *     column: 2,
   *     conditions: [
   *       {name: 'begins_with', args: [['S']]}
   *     ],
   *     operation: 'conjunction'
   *   },
   *   {
   *     column: 4,
   *     conditions: [
   *       {name: 'not_empty', args: []}
   *     ],
   *     operation: 'conjunction'
   *   },
   * ]
   * ```
   * @returns {boolean} If hook returns `false` value then filtering won't be applied on the UI side (server-side filtering).
   */
  "beforeFilter",
  /**
   * Fired by {@link Filters} plugin after applying [filtering](@/guides/columns/column-filter.md).
   * This hook is fired when {@link Options#filters} option is enabled.
   *
   * @event Hooks#afterFilter
   * @param {object[]} conditionsStack An array of objects with added conditions.
   * ```js
   * // Example format of the conditionsStack argument:
   * [
   *   {
   *     column: 2,
   *     conditions: [
   *       {name: 'begins_with', args: [['S']]}
   *     ],
   *     operation: 'conjunction'
   *   },
   *   {
   *     column: 4,
   *     conditions: [
   *       {name: 'not_empty', args: []}
   *     ],
   *     operation: 'conjunction'
   *   },
   * ]
   * ```
   */
  "afterFilter",
  /**
   * Called when a value is updated in the engine.
   *
   * @since 9.0.0
   * @event Hooks#afterFormulasValuesUpdate
   * @param {Array} changes The values and location of applied changes.
   */
  "afterFormulasValuesUpdate",
  /**
   * Called when a named expression is added to the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterNamedExpressionAdded
   * @param {string} namedExpressionName The name of the added expression.
   * @param {Array} changes The values and location of applied changes.
   */
  "afterNamedExpressionAdded",
  /**
   * Called when a named expression is removed from the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterNamedExpressionRemoved
   * @param {string} namedExpressionName The name of the removed expression.
   * @param {Array} changes The values and location of applied changes.
   */
  "afterNamedExpressionRemoved",
  /**
   * Called when a new sheet is added to the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterSheetAdded
   * @param {string} addedSheetDisplayName The name of the added sheet.
   */
  "afterSheetAdded",
  /**
   * Called when a sheet in the Formulas' engine instance is renamed.
   *
   * @since 9.0.0
   * @event Hooks#afterSheetRenamed
   * @param {string} oldDisplayName The old name of the sheet.
   * @param {string} newDisplayName The new name of the sheet.
   */
  "afterSheetRenamed",
  /**
   * Called when a sheet is removed from the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterSheetRemoved
   * @param {string} removedSheetDisplayName The removed sheet name.
   * @param {Array} changes The values and location of applied changes.
   */
  "afterSheetRemoved",
  /**
   * Fired while retrieving the column header height.
   *
   * @event Hooks#modifyColumnHeaderHeight
   */
  "modifyColumnHeaderHeight",
  /**
   * Fired by {@link UndoRedo} plugin before the undo action. Contains information about the action that is being undone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#beforeUndo
   * @param {object} action The action object. Contains information about the action being undone. The `actionType`
   *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeUndo",
  /**
   * Fired by {@link UndoRedo} plugin before changing undo stack.
   *
   * @event Hooks#beforeUndoStackChange
   * @since 8.4.0
   * @param {Array} doneActions Stack of actions which may be undone.
   * @param {string} [source] String that identifies source of action
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action of changing undo stack is canceled.
   */
  "beforeUndoStackChange",
  /**
   * Fired by {@link UndoRedo} plugin after the undo action. Contains information about the action that is being undone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#afterUndo
   * @param {object} action The action object. Contains information about the action being undone. The `actionType`
   *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
   */
  "afterUndo",
  /**
   * Fired by {@link UndoRedo} plugin after changing undo stack.
   *
   * @event Hooks#afterUndoStackChange
   * @since 8.4.0
   * @param {Array} doneActionsBefore Stack of actions which could be undone before performing new action.
   * @param {Array} doneActionsAfter Stack of actions which can be undone after performing new action.
   */
  "afterUndoStackChange",
  /**
   * Fired by {@link UndoRedo} plugin before the redo action. Contains information about the action that is being redone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#beforeRedo
   * @param {object} action The action object. Contains information about the action being redone. The `actionType`
   *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRedo",
  /**
   * Fired by {@link UndoRedo} plugin before changing redo stack.
   *
   * @event Hooks#beforeRedoStackChange
   * @since 8.4.0
   * @param {Array} undoneActions Stack of actions which may be redone.
   */
  "beforeRedoStackChange",
  /**
   * Fired by {@link UndoRedo} plugin after the redo action. Contains information about the action that is being redone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#afterRedo
   * @param {object} action The action object. Contains information about the action being redone. The `actionType`
   *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
   */
  "afterRedo",
  /**
   * Fired by {@link UndoRedo} plugin after changing redo stack.
   *
   * @event Hooks#afterRedoStackChange
   * @since 8.4.0
   * @param {Array} undoneActionsBefore Stack of actions which could be redone before performing new action.
   * @param {Array} undoneActionsAfter Stack of actions which can be redone after performing new action.
   */
  "afterRedoStackChange",
  /**
   * Fired while retrieving the row header width.
   *
   * @event Hooks#modifyRowHeaderWidth
   * @param {number} rowHeaderWidth Row header width.
   */
  "modifyRowHeaderWidth",
  /**
   * Fired from the `populateFromArray` method during the `autofill` process. Fired for each "autofilled" cell individually.
   *
   * @deprecated
   * @event Hooks#beforeAutofillInsidePopulate
   * @param {object} index Object containing `row` and `col` properties, defining the number of rows/columns from the initial cell of the autofill.
   * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
   * @param {Array[]} input Contains an array of rows with data being used in the autofill.
   * @param {Array} deltas The deltas array passed to the `populateFromArray` method.
   */
  "beforeAutofillInsidePopulate",
  /**
   * Fired when the start of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#modifyTransformStart
   * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
   */
  "modifyTransformStart",
  /**
   * Fired when the end of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#modifyTransformEnd
   * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
   */
  "modifyTransformEnd",
  /**
   * Fired after the start of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#afterModifyTransformStart
   * @param {CellCoords} coords Coords of the freshly selected cell.
   * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
   * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
   */
  "afterModifyTransformStart",
  /**
   * Fired after the end of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#afterModifyTransformEnd
   * @param {CellCoords} coords Visual coords of the freshly selected cell.
   * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
   * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
   */
  "afterModifyTransformEnd",
  /**
   * Fired inside the `viewportRowCalculatorOverride` method. Allows modifying the row calculator parameters.
   *
   * @event Hooks#afterViewportRowCalculatorOverride
   * @param {object} calc The row calculator.
   */
  "afterViewportRowCalculatorOverride",
  /**
   * Fired inside the `viewportColumnCalculatorOverride` method. Allows modifying the row calculator parameters.
   *
   * @event Hooks#afterViewportColumnCalculatorOverride
   * @param {object} calc The row calculator.
   */
  "afterViewportColumnCalculatorOverride",
  /**
   * Fired after initializing all the plugins.
   * This hook should be added before Handsontable is initialized.
   *
   * @event Hooks#afterPluginsInitialized
   *
   * @example
   * ```js
   * Handsontable.hooks.add('afterPluginsInitialized', myCallback);
   * ```
   */
  "afterPluginsInitialized",
  /**
   * Fired by {@link HiddenRows} plugin before marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   * Returning `false` in the callback will prevent the hiding action from completing.
   *
   * @event Hooks#beforeHideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
   */
  "beforeHideRows",
  /**
   * Fired by {@link HiddenRows} plugin after marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   *
   * @event Hooks#afterHideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any non-hidden rows, `false` otherwise.
   */
  "afterHideRows",
  /**
   * Fired by {@link HiddenRows} plugin before marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   * Returning `false` in the callback will prevent the row revealing action from completing.
   *
   * @event Hooks#beforeUnhideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the revealing action will not be completed.
   */
  "beforeUnhideRows",
  /**
   * Fired by {@link HiddenRows} plugin after marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   *
   * @event Hooks#afterUnhideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any hidden rows, `false` otherwise.
   */
  "afterUnhideRows",
  /**
   * Fired by {@link HiddenColumns} plugin before marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   * Returning `false` in the callback will prevent the hiding action from completing.
   *
   * @event Hooks#beforeHideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
   */
  "beforeHideColumns",
  /**
   * Fired by {@link HiddenColumns} plugin after marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   *
   * @event Hooks#afterHideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any non-hidden columns, `false` otherwise.
   */
  "afterHideColumns",
  /**
   * Fired by {@link HiddenColumns} plugin before marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   * Returning `false` in the callback will prevent the column revealing action from completing.
   *
   * @event Hooks#beforeUnhideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
   */
  "beforeUnhideColumns",
  /**
   * Fired by {@link HiddenColumns} plugin after marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   *
   * @event Hooks#afterUnhideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any hidden columns, `false` otherwise.
   */
  "afterUnhideColumns",
  /**
   * Fired by {@link TrimRows} plugin before trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#beforeTrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.
   */
  "beforeTrimRow",
  /**
   * Fired by {@link TrimRows} plugin after trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#afterTrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any non-trimmed rows, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.
   */
  "afterTrimRow",
  /**
   * Fired by {@link TrimRows} plugin before untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#beforeUntrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.
   */
  "beforeUntrimRow",
  /**
   * Fired by {@link TrimRows} plugin after untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#afterUntrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any trimmed rows, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.
   */
  "afterUntrimRow",
  /**
   * Fired by {@link DropdownMenu} plugin before opening the dropdown menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @event Hooks#beforeDropdownMenuShow
   * @param {DropdownMenu} dropdownMenu The DropdownMenu instance.
   */
  "beforeDropdownMenuShow",
  /**
   * Fired by {@link DropdownMenu} plugin after opening the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @event Hooks#afterDropdownMenuShow
   * @param {DropdownMenu} dropdownMenu The DropdownMenu instance.
   */
  "afterDropdownMenuShow",
  /**
   * Fired by {@link DropdownMenu} plugin after hiding the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @event Hooks#afterDropdownMenuHide
   * @param {DropdownMenu} instance The DropdownMenu instance.
   */
  "afterDropdownMenuHide",
  /**
   * Fired by {@link NestedRows} plugin before adding a children to the NestedRows structure. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#beforeAddChild
   * @param {object} parent The parent object.
   * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.
   * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
   */
  "beforeAddChild",
  /**
   * Fired by {@link NestedRows} plugin after adding a children to the NestedRows structure. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#afterAddChild
   * @param {object} parent The parent object.
   * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.
   * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
   */
  "afterAddChild",
  /**
   * Fired by {@link NestedRows} plugin before detaching a child from its parent. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#beforeDetachChild
   * @param {object} parent An object representing the parent from which the element is to be detached.
   * @param {object} element The detached element.
   */
  "beforeDetachChild",
  /**
   * Fired by {@link NestedRows} plugin after detaching a child from its parent. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#afterDetachChild
   * @param {object} parent An object representing the parent from which the element was detached.
   * @param {object} element The detached element.
   * @param {number} finalElementPosition The final row index of the detached element.
   */
  "afterDetachChild",
  /**
   * Fired after the editor is opened and rendered.
   *
   * @event Hooks#afterBeginEditing
   * @param {number} row Visual row index of the edited cell.
   * @param {number} column Visual column index of the edited cell.
   */
  "afterBeginEditing",
  /**
   * Fired by {@link MergeCells} plugin before cell merging. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#beforeMergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "beforeMergeCells",
  /**
   * Fired by {@link MergeCells} plugin after cell merging. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#afterMergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {object} mergeParent The parent collection of the provided cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "afterMergeCells",
  /**
   * Fired by {@link MergeCells} plugin before unmerging the cells. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#beforeUnmergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "beforeUnmergeCells",
  /**
   * Fired by {@link MergeCells} plugin after unmerging the cells. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#afterUnmergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "afterUnmergeCells",
  /**
   * Fired after the table was switched into listening mode. This allows Handsontable to capture keyboard events and
   * respond in the right way.
   *
   * @event Hooks#afterListen
   */
  "afterListen",
  /**
   * Fired after the table was switched off from the listening mode. This makes the Handsontable inert for any
   * keyboard events.
   *
   * @event Hooks#afterUnlisten
   */
  "afterUnlisten",
  /**
   * Fired after the window was resized.
   *
   * @event Hooks#afterRefreshDimensions
   * @param {object} previousDimensions Previous dimensions of the container.
   * @param {object} currentDimensions Current dimensions of the container.
   * @param {boolean} stateChanged `true`, if the container was re-render, `false` otherwise.
   */
  "afterRefreshDimensions",
  /**
   * Cancellable hook, called after resizing a window, but before redrawing a table.
   *
   * @event Hooks#beforeRefreshDimensions
   * @param {object} previousDimensions Previous dimensions of the container.
   * @param {object} currentDimensions Current dimensions of the container.
   * @param {boolean} actionPossible `true`, if current and previous dimensions are different, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the refresh action will not be completed.
   */
  "beforeRefreshDimensions",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#beforeColumnCollapse
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the collapsing action will not be completed.
   */
  "beforeColumnCollapse",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#afterColumnCollapse
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @param {boolean} successfullyCollapsed `true`, if the action affected any non-collapsible column, `false` otherwise.
   */
  "afterColumnCollapse",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#beforeColumnExpand
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the expanding action will not be completed.
   */
  "beforeColumnExpand",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#afterColumnExpand
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @param {boolean} successfullyExpanded `true`, if the action affected any non-collapsible column, `false` otherwise.
   */
  "afterColumnExpand",
  /**
   * Fired by {@link AutoColumnSize} plugin within SampleGenerator utility.
   *
   * @event Hooks#modifyAutoColumnSizeSeed
   * @since 8.4.0
   * @param {string|undefined} seed Seed ID, unique name to categorize samples.
   * @param {object} cellProperties Object containing the cell properties.
   * @param {*} cellValue Value of the cell.
   */
  "modifyAutoColumnSizeSeed"
];
var REMOVED_MESSAGE = toSingleLine(_templateObject$g || (_templateObject$g = _taggedTemplateLiteral$g(['The plugin hook "[hookName]" was removed in Handsontable [removedInVersion]. \n  Please consult release notes https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] to \n  learn about the migration path.'], ['The plugin hook "[hookName]" was removed in Handsontable [removedInVersion].\\x20\n  Please consult release notes https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] to\\x20\n  learn about the migration path.'])));
var REMOVED_HOOKS = /* @__PURE__ */ new Map([["modifyRow", "8.0.0"], ["modifyCol", "8.0.0"], ["unmodifyRow", "8.0.0"], ["unmodifyCol", "8.0.0"], ["skipLengthCache", "8.0.0"], ["hiddenColumn", "8.0.0"], ["hiddenRow", "8.0.0"]]);
var DEPRECATED_HOOKS = /* @__PURE__ */ new Map([["beforeAutofillInsidePopulate", 'The plugin hook "beforeAutofillInsidePopulate" is deprecated and will be removed in the next major release.']]);
var Hooks = /* @__PURE__ */ function() {
  function Hooks2() {
    _classCallCheck$2J(this, Hooks2);
    this.globalBucket = this.createEmptyBucket();
  }
  _createClass$2J(Hooks2, [{
    key: "createEmptyBucket",
    value: function createEmptyBucket() {
      var bucket = /* @__PURE__ */ Object.create(null);
      arrayEach(REGISTERED_HOOKS, function(hook2) {
        return bucket[hook2] = [];
      });
      return bucket;
    }
    /**
     * Get hook bucket based on the context of the object or if argument is `undefined`, get the global hook bucket.
     *
     * @param {object} [context=null] A Handsontable instance.
     * @returns {object} Returns a global or Handsontable instance bucket.
     */
  }, {
    key: "getBucket",
    value: function getBucket() {
      var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (context) {
        if (!context.pluginHookBucket) {
          context.pluginHookBucket = this.createEmptyBucket();
        }
        return context.pluginHookBucket;
      }
      return this.globalBucket;
    }
    /**
     * Adds a listener (globally or locally) to a specified hook name.
     * If the `context` parameter is provided, the hook will be added only to the instance it references.
     * Otherwise, the callback will be used everytime the hook fires on any Handsontable instance.
     * You can provide an array of callback functions as the `callback` argument, this way they will all be fired
     * once the hook is triggered.
     *
     * @see Core#addHook
     * @param {string} key Hook name.
     * @param {Function|Array} callback Callback function or an array of functions.
     * @param {object} [context=null] The context for the hook callback to be added - a Handsontable instance or leave empty.
     * @returns {Hooks} Instance of Hooks.
     *
     * @example
     * ```js
     * // single callback, added locally
     * Handsontable.hooks.add('beforeInit', myCallback, hotInstance);
     *
     * // single callback, added globally
     * Handsontable.hooks.add('beforeInit', myCallback);
     *
     * // multiple callbacks, added locally
     * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback], hotInstance);
     *
     * // multiple callbacks, added globally
     * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback]);
     * ```
     */
  }, {
    key: "add",
    value: function add(key, callback) {
      var _this = this;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (Array.isArray(callback)) {
        arrayEach(callback, function(c2) {
          return _this.add(key, c2, context);
        });
      } else {
        if (REMOVED_HOOKS.has(key)) {
          warn$1(substitute(REMOVED_MESSAGE, {
            hookName: key,
            removedInVersion: REMOVED_HOOKS.get(key)
          }));
        }
        if (DEPRECATED_HOOKS.has(key)) {
          warn$1(DEPRECATED_HOOKS.get(key));
        }
        var bucket = this.getBucket(context);
        if (typeof bucket[key] === "undefined") {
          this.register(key);
          bucket[key] = [];
        }
        callback.skip = false;
        if (bucket[key].indexOf(callback) === -1) {
          var foundInitialHook = false;
          if (callback.initialHook) {
            arrayEach(bucket[key], function(cb, i) {
              if (cb.initialHook) {
                bucket[key][i] = callback;
                foundInitialHook = true;
                return false;
              }
            });
          }
          if (!foundInitialHook) {
            bucket[key].push(callback);
          }
        }
      }
      return this;
    }
    /**
     * Adds a listener to a specified hook. After the hook runs this listener will be automatically removed from the bucket.
     *
     * @see Core#addHookOnce
     * @param {string} key Hook/Event name.
     * @param {Function|Array} callback Callback function.
     * @param {object} [context=null] A Handsontable instance.
     *
     * @example
     * ```js
     * Handsontable.hooks.once('beforeInit', myCallback, hotInstance);
     * ```
     */
  }, {
    key: "once",
    value: function once(key, callback) {
      var _this2 = this;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (Array.isArray(callback)) {
        arrayEach(callback, function(c2) {
          return _this2.once(key, c2, context);
        });
      } else {
        callback.runOnce = true;
        this.add(key, callback, context);
      }
    }
    /**
     * Removes a listener from a hook with a given name. If the `context` argument is provided, it removes a listener from a local hook assigned to the given Handsontable instance.
     *
     * @see Core#removeHook
     * @param {string} key Hook/Event name.
     * @param {Function} callback Callback function (needs the be the function that was previously added to the hook).
     * @param {object} [context=null] Handsontable instance.
     * @returns {boolean} Returns `true` if hook was removed, `false` otherwise.
     *
     * @example
     * ```js
     * Handsontable.hooks.remove('beforeInit', myCallback);
     * ```
     */
  }, {
    key: "remove",
    value: function remove(key, callback) {
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var bucket = this.getBucket(context);
      if (typeof bucket[key] !== "undefined") {
        if (bucket[key].indexOf(callback) >= 0) {
          callback.skip = true;
          return true;
        }
      }
      return false;
    }
    /**
     * Checks whether there are any registered listeners for the provided hook name.
     * If the `context` parameter is provided, it only checks for listeners assigned to the given Handsontable instance.
     *
     * @param {string} key Hook name.
     * @param {object} [context=null] A Handsontable instance.
     * @returns {boolean} `true` for success, `false` otherwise.
     */
  }, {
    key: "has",
    value: function has2(key) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var bucket = this.getBucket(context);
      return !!(bucket[key] !== void 0 && bucket[key].length);
    }
    /**
     * Runs all local and global callbacks assigned to the hook identified by the `key` parameter.
     * It returns either a return value from the last called callback or the first parameter (`p1`) passed to the `run` function.
     *
     * @see Core#runHooks
     * @param {object} context Handsontable instance.
     * @param {string} key Hook/Event name.
     * @param {*} [p1] Parameter to be passed as an argument to the callback function.
     * @param {*} [p2] Parameter to be passed as an argument to the callback function.
     * @param {*} [p3] Parameter to be passed as an argument to the callback function.
     * @param {*} [p4] Parameter to be passed as an argument to the callback function.
     * @param {*} [p5] Parameter to be passed as an argument to the callback function.
     * @param {*} [p6] Parameter to be passed as an argument to the callback function.
     * @returns {*} Either a return value from the last called callback or `p1`.
     *
     * @example
     * ```js
     * Handsontable.hooks.run(hot, 'beforeInit');
     * ```
     */
  }, {
    key: "run",
    value: function run2(context, key, p1, p2, p3, p4, p5, p6) {
      {
        var globalHandlers = this.globalBucket[key];
        var length = globalHandlers ? globalHandlers.length : 0;
        var index2 = 0;
        if (length) {
          while (index2 < length) {
            if (!globalHandlers[index2] || globalHandlers[index2].skip) {
              index2 += 1;
              continue;
            }
            var res = fastCall(globalHandlers[index2], context, p1, p2, p3, p4, p5, p6);
            if (res !== void 0) {
              p1 = res;
            }
            if (globalHandlers[index2] && globalHandlers[index2].runOnce) {
              this.remove(key, globalHandlers[index2]);
            }
            index2 += 1;
          }
        }
      }
      {
        var localHandlers = this.getBucket(context)[key];
        var _length = localHandlers ? localHandlers.length : 0;
        var _index = 0;
        if (_length) {
          while (_index < _length) {
            if (!localHandlers[_index] || localHandlers[_index].skip) {
              _index += 1;
              continue;
            }
            var _res = fastCall(localHandlers[_index], context, p1, p2, p3, p4, p5, p6);
            if (_res !== void 0) {
              p1 = _res;
            }
            if (localHandlers[_index] && localHandlers[_index].runOnce) {
              this.remove(key, localHandlers[_index], context);
            }
            _index += 1;
          }
        }
      }
      return p1;
    }
    /**
     * Destroy all listeners connected to the context. If no context is provided, the global listeners will be destroyed.
     *
     * @param {object} [context=null] A Handsontable instance.
     * @example
     * ```js
     * // destroy the global listeners
     * Handsontable.hooks.destroy();
     *
     * // destroy the local listeners
     * Handsontable.hooks.destroy(hotInstance);
     * ```
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      objectEach(this.getBucket(context), function(value, key, bucket) {
        return bucket[key].length = 0;
      });
    }
    /**
     * Registers a hook name (adds it to the list of the known hook names). Used by plugins.
     * It is not necessary to call register, but if you use it, your plugin hook will be used returned by
     * the `getRegistered` method. (which itself is used in the [demo](@/guides/getting-started/events-and-hooks.md)).
     *
     * @param {string} key The hook name.
     *
     * @example
     * ```js
     * Handsontable.hooks.register('myHook');
     * ```
     */
  }, {
    key: "register",
    value: function register2(key) {
      if (!this.isRegistered(key)) {
        REGISTERED_HOOKS.push(key);
      }
    }
    /**
     * Deregisters a hook name (removes it from the list of known hook names).
     *
     * @param {string} key The hook name.
     *
     * @example
     * ```js
     * Handsontable.hooks.deregister('myHook');
     * ```
     */
  }, {
    key: "deregister",
    value: function deregister(key) {
      if (this.isRegistered(key)) {
        REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);
      }
    }
    /**
     * Returns a boolean value depending on if a hook by such name has been removed or deprecated.
     *
     * @param {string} hookName The hook name to check.
     * @returns {boolean} Returns `true` if the provided hook name was marked as deprecated or
     * removed from API, `false` otherwise.
     * @example
     * ```js
     * Handsontable.hooks.isDeprecated('skipLengthCache');
     *
     * // Results:
     * true
     * ```
     */
  }, {
    key: "isDeprecated",
    value: function isDeprecated(hookName) {
      return DEPRECATED_HOOKS.has(hookName) || REMOVED_HOOKS.has(hookName);
    }
    /**
     * Returns a boolean depending on if a hook by such name has been registered.
     *
     * @param {string} hookName The hook name to check.
     * @returns {boolean} `true` for success, `false` otherwise.
     * @example
     * ```js
     * Handsontable.hooks.isRegistered('beforeInit');
     *
     * // Results:
     * true
     * ```
     */
  }, {
    key: "isRegistered",
    value: function isRegistered(hookName) {
      return REGISTERED_HOOKS.indexOf(hookName) >= 0;
    }
    /**
     * Returns an array of registered hooks.
     *
     * @returns {Array} An array of registered hooks.
     *
     * @example
     * ```js
     * Handsontable.hooks.getRegistered();
     *
     * // Results:
     * [
     * ...
     *   'beforeInit',
     *   'beforeRender',
     *   'beforeSetRangeEnd',
     *   'beforeDrawBorders',
     *   'beforeChange',
     * ...
     * ]
     * ```
     */
  }, {
    key: "getRegistered",
    value: function getRegistered() {
      return REGISTERED_HOOKS;
    }
  }], [{
    key: "getSingleton",
    value: function getSingleton() {
      return getGlobalSingleton();
    }
  }]);
  return Hooks2;
}();
var globalSingleton = new Hooks();
function getGlobalSingleton() {
  return globalSingleton;
}
const Hooks$1 = Hooks;
function _toConsumableArray$A(arr) {
  return _arrayWithoutHoles$A(arr) || _iterableToArray$C(arr) || _unsupportedIterableToArray$1c(arr) || _nonIterableSpread$A();
}
function _nonIterableSpread$A() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1c(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1c(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1c(o, minLen);
}
function _iterableToArray$C(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$A(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1c(arr);
}
function _arrayLikeToArray$1c(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var collection$1 = /* @__PURE__ */ new Map();
function staticRegister() {
  var namespace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "common";
  if (!collection$1.has(namespace)) {
    collection$1.set(namespace, /* @__PURE__ */ new Map());
  }
  var subCollection = collection$1.get(namespace);
  function register2(name, item) {
    subCollection.set(name, item);
  }
  function getItem2(name) {
    return subCollection.get(name);
  }
  function hasItem2(name) {
    return subCollection.has(name);
  }
  function getNames() {
    return _toConsumableArray$A(subCollection.keys());
  }
  function getValues() {
    return _toConsumableArray$A(subCollection.values());
  }
  return {
    register: register2,
    getItem: getItem2,
    hasItem: hasItem2,
    getNames,
    getValues
  };
}
var registeredEditorClasses = /* @__PURE__ */ new WeakMap();
var _staticRegister$7 = staticRegister("editors"), register$5 = _staticRegister$7.register, getItem$4 = _staticRegister$7.getItem, hasItem$3 = _staticRegister$7.hasItem;
_staticRegister$7.getNames;
_staticRegister$7.getValues;
function RegisteredEditor(editorClass) {
  var instances2 = {};
  var Clazz = editorClass;
  this.getConstructor = function() {
    return editorClass;
  };
  this.getInstance = function(hotInstance) {
    if (!(hotInstance.guid in instances2)) {
      instances2[hotInstance.guid] = new Clazz(hotInstance);
    }
    return instances2[hotInstance.guid];
  };
  Hooks$1.getSingleton().add("afterDestroy", function() {
    instances2[this.guid] = null;
  });
}
function _getEditorInstance(name, hotInstance) {
  var editor;
  if (typeof name === "function") {
    if (!registeredEditorClasses.get(name)) {
      _register$3(null, name);
    }
    editor = registeredEditorClasses.get(name);
  } else if (typeof name === "string") {
    editor = getItem$4(name);
  } else {
    throw Error('Only strings and functions can be passed as "editor" parameter');
  }
  if (!editor) {
    throw Error('No editor registered under name "'.concat(name, '"'));
  }
  return editor.getInstance(hotInstance);
}
function _register$3(name, editorClass) {
  if (name && typeof name !== "string") {
    editorClass = name;
    name = editorClass.EDITOR_TYPE;
  }
  var editorWrapper = new RegisteredEditor(editorClass);
  if (typeof name === "string") {
    register$5(name, editorWrapper);
  }
  registeredEditorClasses.set(editorClass, editorWrapper);
}
function _slicedToArray$M(arr, i) {
  return _arrayWithHoles$O(arr) || _iterableToArrayLimit$M(arr, i) || _unsupportedIterableToArray$1b(arr, i) || _nonIterableRest$O();
}
function _nonIterableRest$O() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1b(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1b(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1b(o, minLen);
}
function _arrayLikeToArray$1b(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$M(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$O(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2I(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2I(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2I(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2I(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2I(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var SHORTCUTS_GROUP_NAVIGATION = "editorManager.navigation";
var SHORTCUTS_GROUP_EDITOR$2 = "editorManager.handlingEditor";
var EditorManager = /* @__PURE__ */ function() {
  function EditorManager2(instance, tableMeta, selection) {
    var _this = this;
    _classCallCheck$2I(this, EditorManager2);
    this.instance = instance;
    this.tableMeta = tableMeta;
    this.selection = selection;
    this.eventManager = new EventManager$1(instance);
    this.destroyed = false;
    this.lock = false;
    this.activeEditor = void 0;
    this.cellProperties = void 0;
    var shortcutManager = this.instance.getShortcutManager();
    shortcutManager.addContext("editor");
    this.registerShortcuts();
    this.instance.addHook("afterDocumentKeyDown", function(event2) {
      return _this.onAfterDocumentKeyDown(event2);
    });
    this.eventManager.addEventListener(this.instance.rootDocument.documentElement, "compositionstart", function(event2) {
      if (!_this.destroyed && _this.instance.isListening()) {
        _this.openEditor("", event2);
      }
    });
    this.instance.view._wt.update("onCellDblClick", function(event2, coords, elem) {
      return _this.onCellDblClick(event2, coords, elem);
    });
  }
  _createClass$2I(EditorManager2, [{
    key: "registerShortcuts",
    value: function registerShortcuts() {
      var _this2 = this;
      var shortcutManager = this.instance.getShortcutManager();
      var gridContext = shortcutManager.getContext("grid");
      var editorContext = shortcutManager.getContext("editor");
      var config = {
        group: SHORTCUTS_GROUP_EDITOR$2
      };
      editorContext.addShortcuts([{
        keys: [["Enter"], ["Enter", "Shift"], ["Enter", "Control/Meta"], ["Enter", "Control/Meta", "Shift"]],
        callback: function callback(event2, keys3) {
          _this2.closeEditorAndSaveChanges(shortcutManager.isCtrlPressed());
          _this2.moveSelectionAfterEnter(keys3.includes("shift"));
        }
      }, {
        keys: [["Escape"], ["Escape", "Control/Meta"]],
        callback: function callback() {
          _this2.closeEditorAndRestoreOriginalValue(shortcutManager.isCtrlPressed());
          _this2.activeEditor.focus();
        }
      }], config);
      gridContext.addShortcuts([{
        keys: [["F2"]],
        callback: function callback(event2) {
          _this2.openEditor(null, event2, true);
        }
      }, {
        keys: [["Backspace"], ["Delete"]],
        callback: function callback() {
          _this2.instance.emptySelectedCells();
          _this2.prepareEditor();
        }
      }, {
        keys: [["Enter"], ["Enter", "Shift"]],
        callback: function callback(event2, keys3) {
          if (_this2.instance.getSettings().enterBeginsEditing) {
            if (_this2.cellProperties.readOnly) {
              _this2.moveSelectionAfterEnter();
            } else {
              _this2.openEditor(null, event2, true);
            }
          } else {
            _this2.moveSelectionAfterEnter(keys3.includes("shift"));
          }
          stopImmediatePropagation(event2);
        }
      }], config);
    }
    /**
     * Lock the editor from being prepared and closed. Locking the editor prevents its closing and
     * reinitialized after selecting the new cell. This feature is necessary for a mobile editor.
     */
  }, {
    key: "lockEditor",
    value: function lockEditor() {
      this.lock = true;
    }
    /**
     * Unlock the editor from being prepared and closed. This method restores the original behavior of
     * the editors where for every new selection its instances are closed.
     */
  }, {
    key: "unlockEditor",
    value: function unlockEditor() {
      this.lock = false;
    }
    /**
     * Destroy current editor, if exists.
     *
     * @param {boolean} revertOriginal If `false` and the cell using allowInvalid option,
     *                                 then an editor won't be closed until validation is passed.
     */
  }, {
    key: "destroyEditor",
    value: function destroyEditor(revertOriginal) {
      if (!this.lock) {
        this.closeEditor(revertOriginal);
      }
    }
    /**
     * Get active editor.
     *
     * @returns {BaseEditor}
     */
  }, {
    key: "getActiveEditor",
    value: function getActiveEditor() {
      return this.activeEditor;
    }
    /**
     * Prepare text input to be displayed at given grid cell.
     */
  }, {
    key: "prepareEditor",
    value: function prepareEditor() {
      var _this3 = this;
      if (this.lock) {
        return;
      }
      if (this.activeEditor && this.activeEditor.isWaiting()) {
        this.closeEditor(false, false, function(dataSaved) {
          if (dataSaved) {
            _this3.prepareEditor();
          }
        });
        return;
      }
      var _this$instance$getSel = this.instance.getSelectedRangeLast().highlight, row = _this$instance$getSel.row, col = _this$instance$getSel.col;
      var modifiedCellCoords = this.instance.runHooks("modifyGetCellCoords", row, col);
      var visualRowToCheck = row;
      var visualColumnToCheck = col;
      if (Array.isArray(modifiedCellCoords)) {
        var _modifiedCellCoords = _slicedToArray$M(modifiedCellCoords, 2);
        visualRowToCheck = _modifiedCellCoords[0];
        visualColumnToCheck = _modifiedCellCoords[1];
      }
      this.cellProperties = this.instance.getCellMeta(visualRowToCheck, visualColumnToCheck);
      var activeElement = this.instance.rootDocument.activeElement;
      if (activeElement) {
        activeElement.blur();
      }
      if (!this.isCellEditable()) {
        this.clearActiveEditor();
        return;
      }
      var td = this.instance.getCell(row, col, true);
      if (td) {
        var editorClass = this.instance.getCellEditor(this.cellProperties);
        var prop = this.instance.colToProp(visualColumnToCheck);
        var originalValue = this.instance.getSourceDataAtCell(this.instance.toPhysicalRow(visualRowToCheck), visualColumnToCheck);
        this.activeEditor = _getEditorInstance(editorClass, this.instance);
        this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);
      }
    }
    /**
     * Check is editor is opened/showed.
     *
     * @returns {boolean}
     */
  }, {
    key: "isEditorOpened",
    value: function isEditorOpened() {
      return this.activeEditor && this.activeEditor.isOpened();
    }
    /**
     * Open editor with initial value.
     *
     * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.
     * @param {Event} event The event object.
     * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor
     *                                             when arrow keys are pressed.
     */
  }, {
    key: "openEditor",
    value: function openEditor(newInitialValue, event2) {
      var enableFullEditMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (!this.isCellEditable()) {
        this.clearActiveEditor();
        return;
      }
      if (!this.activeEditor) {
        var _this$instance$getSel2 = this.instance.getSelectedRangeLast().highlight, row = _this$instance$getSel2.row, col = _this$instance$getSel2.col;
        var renderableRowIndex = this.instance.rowIndexMapper.getRenderableFromVisualIndex(row);
        var renderableColumnIndex = this.instance.columnIndexMapper.getRenderableFromVisualIndex(col);
        this.instance.view.scrollViewport(this.instance._createCellCoords(renderableRowIndex, renderableColumnIndex));
        this.instance.view.render();
        this.prepareEditor();
      }
      if (this.activeEditor) {
        if (enableFullEditMode) {
          this.activeEditor.enableFullEditMode();
        }
        this.activeEditor.beginEditing(newInitialValue, event2);
      }
    }
    /**
     * Close editor, finish editing cell.
     *
     * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.
     * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
     * @param {Function} callback The callback function, fired after editor closing.
     */
  }, {
    key: "closeEditor",
    value: function closeEditor(restoreOriginalValue, isCtrlPressed, callback) {
      if (this.activeEditor) {
        this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);
      } else if (callback) {
        callback(false);
      }
    }
    /**
     * Close editor and save changes.
     *
     * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
     */
  }, {
    key: "closeEditorAndSaveChanges",
    value: function closeEditorAndSaveChanges(isCtrlPressed) {
      this.closeEditor(false, isCtrlPressed);
    }
    /**
     * Close editor and restore original value.
     *
     * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.
     */
  }, {
    key: "closeEditorAndRestoreOriginalValue",
    value: function closeEditorAndRestoreOriginalValue(isCtrlPressed) {
      this.closeEditor(true, isCtrlPressed);
    }
    /**
     * Clears reference to an instance of the active editor.
     *
     * @private
     */
  }, {
    key: "clearActiveEditor",
    value: function clearActiveEditor() {
      this.activeEditor = void 0;
    }
    /**
     * Checks if the currently selected cell (pointed by selection highlight coords) is editable.
     * Editable cell is when:
     *   - the cell has defined an editor type;
     *   - the cell is not marked as read-only;
     *   - the cell is not hidden.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "isCellEditable",
    value: function isCellEditable() {
      var editorClass = this.instance.getCellEditor(this.cellProperties);
      var _this$instance$getSel3 = this.instance.getSelectedRangeLast().highlight, row = _this$instance$getSel3.row, col = _this$instance$getSel3.col;
      var _this$instance = this.instance, rowIndexMapper = _this$instance.rowIndexMapper, columnIndexMapper = _this$instance.columnIndexMapper;
      var isCellHidden = rowIndexMapper.isHidden(this.instance.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.instance.toPhysicalColumn(col));
      if (this.cellProperties.readOnly || !editorClass || isCellHidden) {
        return false;
      }
      return true;
    }
    /**
     * Controls selection's behaviour after clicking `Enter`.
     *
     * @private
     * @param {boolean} isShiftPressed If `true`, then the selection will move up after hit enter.
     */
  }, {
    key: "moveSelectionAfterEnter",
    value: function moveSelectionAfterEnter(isShiftPressed) {
      var enterMoves = typeof this.tableMeta.enterMoves === "function" ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;
      if (isShiftPressed) {
        this.selection.transformStart(-enterMoves.row, -enterMoves.col);
      } else {
        this.selection.transformStart(enterMoves.row, enterMoves.col, true);
      }
    }
    /**
     * OnAfterDocumentKeyDown callback.
     *
     * @private
     * @param {KeyboardEvent} event The keyboard event object.
     */
  }, {
    key: "onAfterDocumentKeyDown",
    value: function onAfterDocumentKeyDown(event2) {
      var _this4 = this;
      if (!this.instance.isListening()) {
        return;
      }
      var keyCode = event2.keyCode;
      if (!this.selection.isSelected()) {
        return;
      }
      var isCtrlPressed = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
      if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {
        if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {
          var shortcutManager = this.instance.getShortcutManager();
          var editorContext = shortcutManager.getContext("editor");
          var runOnlySelectedConfig = {
            runOnlyIf: function runOnlyIf() {
              return isDefined(_this4.instance.getSelected());
            },
            group: SHORTCUTS_GROUP_NAVIGATION
          };
          editorContext.addShortcuts([{
            keys: [["ArrowUp"]],
            callback: function callback() {
              _this4.instance.selection.transformStart(-1, 0);
            }
          }, {
            keys: [["ArrowDown"]],
            callback: function callback() {
              _this4.instance.selection.transformStart(1, 0);
            }
          }, {
            keys: [["ArrowLeft"]],
            callback: function callback() {
              _this4.instance.selection.transformStart(0, -1 * _this4.instance.getDirectionFactor());
            }
          }, {
            keys: [["ArrowRight"]],
            callback: function callback() {
              _this4.instance.selection.transformStart(0, _this4.instance.getDirectionFactor());
            }
          }], runOnlySelectedConfig);
          this.openEditor("", event2);
        }
      }
    }
    /**
     * OnCellDblClick callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     * @param {object} coords The cell coordinates.
     * @param {HTMLTableCellElement|HTMLTableHeaderCellElement} elem The element which triggers the action.
     */
  }, {
    key: "onCellDblClick",
    value: function onCellDblClick(event2, coords, elem) {
      if (elem.nodeName === "TD") {
        this.openEditor(null, event2, true);
      }
    }
    /**
     * Destroy the instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.eventManager.destroy();
    }
  }]);
  return EditorManager2;
}();
var instances = /* @__PURE__ */ new WeakMap();
EditorManager.getInstance = function(hotInstance, tableMeta, selection) {
  var editorManager = instances.get(hotInstance);
  if (!editorManager) {
    editorManager = new EditorManager(hotInstance, tableMeta, selection);
    instances.set(hotInstance, editorManager);
  }
  return editorManager;
};
const EditorManager$1 = EditorManager;
var isListeningKeyDownEvent = /* @__PURE__ */ new WeakMap();
var isCheckboxListenerAdded = /* @__PURE__ */ new WeakMap();
var BAD_VALUE_CLASS = "htBadValue";
var ATTR_ROW = "data-row";
var ATTR_COLUMN = "data-col";
var SHORTCUTS_GROUP$8 = "checkboxRenderer";
var RENDERER_TYPE$3 = "checkbox";
Hooks$1.getSingleton().add("modifyAutoColumnSizeSeed", function(bundleSeed, cellMeta, cellValue) {
  var label = cellMeta.label, type = cellMeta.type, row = cellMeta.row, column = cellMeta.column, prop = cellMeta.prop;
  if (type !== RENDERER_TYPE$3) {
    return;
  }
  if (label) {
    var labelValue = label.value, labelProperty = label.property;
    var labelText = cellValue;
    if (labelValue) {
      labelText = typeof labelValue === "function" ? labelValue(row, column, prop, cellValue) : labelValue;
    } else if (labelProperty) {
      var labelData = this.getDataAtRowProp(row, labelProperty);
      labelText = labelData !== null ? labelData : cellValue;
    }
    bundleSeed = labelText;
  }
  return bundleSeed;
});
function checkboxRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var rootDocument = instance.rootDocument;
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  registerEvents(instance);
  var input = createInput(rootDocument);
  var labelOptions = cellProperties.label;
  var badValue = false;
  if (typeof cellProperties.checkedTemplate === "undefined") {
    cellProperties.checkedTemplate = true;
  }
  if (typeof cellProperties.uncheckedTemplate === "undefined") {
    cellProperties.uncheckedTemplate = false;
  }
  empty(TD);
  if (value === cellProperties.checkedTemplate || stringify$1(value).toLocaleLowerCase(cellProperties.locale) === stringify$1(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.locale)) {
    input.checked = true;
  } else if (value === cellProperties.uncheckedTemplate || stringify$1(value).toLocaleLowerCase(cellProperties.locale) === stringify$1(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.locale)) {
    input.checked = false;
  } else if (isEmpty(value)) {
    addClass(input, "noValue");
  } else {
    input.style.display = "none";
    addClass(input, BAD_VALUE_CLASS);
    badValue = true;
  }
  input.setAttribute(ATTR_ROW, row);
  input.setAttribute(ATTR_COLUMN, col);
  if (!badValue && labelOptions) {
    var labelText = "";
    if (labelOptions.value) {
      labelText = typeof labelOptions.value === "function" ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;
    } else if (labelOptions.property) {
      var labelValue = instance.getDataAtRowProp(row, labelOptions.property);
      labelText = labelValue !== null ? labelValue : "";
    }
    var label = createLabel(rootDocument, labelText, labelOptions.separated !== true);
    if (labelOptions.position === "before") {
      if (labelOptions.separated) {
        TD.appendChild(label);
        TD.appendChild(input);
      } else {
        label.appendChild(input);
        input = label;
      }
    } else if (!labelOptions.position || labelOptions.position === "after") {
      if (labelOptions.separated) {
        TD.appendChild(input);
        TD.appendChild(label);
      } else {
        label.insertBefore(input, label.firstChild);
        input = label;
      }
    }
  }
  if (!labelOptions || labelOptions && !labelOptions.separated) {
    TD.appendChild(input);
  }
  if (badValue) {
    TD.appendChild(rootDocument.createTextNode("#bad-value#"));
  }
  if (!isListeningKeyDownEvent.has(instance)) {
    isListeningKeyDownEvent.set(instance, true);
    registerShortcuts();
  }
  function registerShortcuts() {
    var shortcutManager = instance.getShortcutManager();
    var gridContext = shortcutManager.getContext("grid");
    var config = {
      group: SHORTCUTS_GROUP$8
    };
    gridContext.addShortcuts([{
      keys: [["space"]],
      callback: function callback() {
        changeSelectedCheckboxesState();
        return !areSelectedCheckboxCells();
      }
    }, {
      keys: [["enter"]],
      callback: function callback() {
        changeSelectedCheckboxesState();
        return !areSelectedCheckboxCells();
      },
      runOnlyIf: function runOnlyIf() {
        return instance.getSettings().enterBeginsEditing;
      }
    }, {
      keys: [["delete"], ["backspace"]],
      callback: function callback() {
        changeSelectedCheckboxesState(true);
        return !areSelectedCheckboxCells();
      },
      relativeToGroup: SHORTCUTS_GROUP_EDITOR$2,
      position: "before"
    }], config);
  }
  function changeSelectedCheckboxesState() {
    var uncheckCheckbox = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var selRange = instance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (var key = 0; key < selRange.length; key++) {
      var _selRange$key$getTopS = selRange[key].getTopStartCorner(), startRow = _selRange$key$getTopS.row, startColumn = _selRange$key$getTopS.col;
      var _selRange$key$getBott = selRange[key].getBottomEndCorner(), endRow = _selRange$key$getBott.row, endColumn = _selRange$key$getBott.col;
      var changes = [];
      for (var visualRow = startRow; visualRow <= endRow; visualRow += 1) {
        for (var visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {
          var cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return;
          }
          if (cachedCellProperties.readOnly === true) {
            continue;
          }
          if (typeof cachedCellProperties.checkedTemplate === "undefined") {
            cachedCellProperties.checkedTemplate = true;
          }
          if (typeof cachedCellProperties.uncheckedTemplate === "undefined") {
            cachedCellProperties.uncheckedTemplate = false;
          }
          var dataAtCell = instance.getDataAtCell(visualRow, visualColumn);
          if (uncheckCheckbox === false) {
            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, void 0].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate]);
            }
          } else {
            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
          }
        }
      }
      if (changes.length > 0) {
        instance.setDataAtCell(changes);
      }
    }
  }
  function areSelectedCheckboxCells() {
    var selRange = instance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (var key = 0; key < selRange.length; key++) {
      var topLeft = selRange[key].getTopStartCorner();
      var bottomRight = selRange[key].getBottomEndCorner();
      for (var visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {
        for (var visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {
          var cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return false;
          }
          var cell = instance.getCell(visualRow, visualColumn);
          if (cell === null || cell === void 0) {
            return true;
          } else {
            var checkboxes = cell.querySelectorAll("input[type=checkbox]");
            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
}
checkboxRenderer.RENDERER_TYPE = RENDERER_TYPE$3;
function registerEvents(instance) {
  var eventManager = isCheckboxListenerAdded.get(instance);
  if (!eventManager) {
    var rootElement = instance.rootElement;
    eventManager = new EventManager$1(instance);
    eventManager.addEventListener(rootElement, "click", function(event2) {
      return onClick(event2, instance);
    });
    eventManager.addEventListener(rootElement, "mouseup", function(event2) {
      return onMouseUp(event2, instance);
    });
    eventManager.addEventListener(rootElement, "change", function(event2) {
      return onChange(event2, instance);
    });
    isCheckboxListenerAdded.set(instance, eventManager);
  }
  return eventManager;
}
function createInput(rootDocument) {
  var input = rootDocument.createElement("input");
  input.className = "htCheckboxRendererInput";
  input.type = "checkbox";
  input.setAttribute("autocomplete", "off");
  input.setAttribute("tabindex", "-1");
  return input.cloneNode(false);
}
function createLabel(rootDocument, text2, fullWidth) {
  var label = rootDocument.createElement("label");
  label.className = "htCheckboxRendererLabel ".concat(fullWidth ? "fullWidth" : "");
  label.appendChild(rootDocument.createTextNode(text2));
  return label.cloneNode(true);
}
function onMouseUp(event2, instance) {
  var target = event2.target;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  setTimeout(instance.listen, 10);
}
function onClick(event2, instance) {
  var target = event2.target;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  var row = parseInt(target.getAttribute(ATTR_ROW), 10);
  var col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  var cellProperties = instance.getCellMeta(row, col);
  if (cellProperties.readOnly) {
    event2.preventDefault();
  }
}
function onChange(event2, instance) {
  var target = event2.target;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  var row = parseInt(target.getAttribute(ATTR_ROW), 10);
  var col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  var cellProperties = instance.getCellMeta(row, col);
  if (!cellProperties.readOnly) {
    var newCheckboxValue = null;
    if (event2.target.checked) {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? true : cellProperties.checkedTemplate;
    } else {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? false : cellProperties.uncheckedTemplate;
    }
    instance.setDataAtCell(row, col, newCheckboxValue);
  }
}
function isCheckboxInput(element) {
  return element.tagName === "INPUT" && element.getAttribute("type") === "checkbox";
}
var numbro_minExports = {};
var numbro_min = {
  get exports() {
    return numbro_minExports;
  },
  set exports(v2) {
    numbro_minExports = v2;
  }
};
(function(module, exports) {
  !function(e2) {
    module.exports = e2();
  }(function() {
    return function a(o, u, c2) {
      function s(t2, e3) {
        if (!u[t2]) {
          if (!o[t2]) {
            var r2 = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e3 && r2)
              return r2(t2, true);
            if (l2)
              return l2(t2, true);
            var n2 = new Error("Cannot find module '" + t2 + "'");
            throw n2.code = "MODULE_NOT_FOUND", n2;
          }
          var i = u[t2] = { exports: {} };
          o[t2][0].call(i.exports, function(e4) {
            return s(o[t2][1][e4] || e4);
          }, i, i.exports, a, o, u, c2);
        }
        return u[t2].exports;
      }
      for (var l2 = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < c2.length; e2++)
        s(c2[e2]);
      return s;
    }({ 1: [function(e2, r2, t2) {
      !function(e3) {
        var t3, k2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, _ = Math.ceil, L = Math.floor, T = "[BigNumber Error] ", P = T + "Number primitive has more than 15 significant digits: ", U = 1e14, j = 14, C = 9007199254740991, R = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], I = 1e7, $2 = 1e9;
        function G(e4) {
          var t4 = 0 | e4;
          return 0 < e4 || e4 === t4 ? t4 : t4 - 1;
        }
        function V(e4) {
          for (var t4, r3, n2 = 1, i = e4.length, a = e4[0] + ""; n2 < i; ) {
            for (t4 = e4[n2++] + "", r3 = j - t4.length; r3--; t4 = "0" + t4)
              ;
            a += t4;
          }
          for (i = a.length; 48 === a.charCodeAt(--i); )
            ;
          return a.slice(0, i + 1 || 1);
        }
        function q2(e4, t4) {
          var r3, n2, i = e4.c, a = t4.c, o = e4.s, u = t4.s, c2 = e4.e, s = t4.e;
          if (!o || !u)
            return null;
          if (r3 = i && !i[0], n2 = a && !a[0], r3 || n2)
            return r3 ? n2 ? 0 : -u : o;
          if (o != u)
            return o;
          if (r3 = o < 0, n2 = c2 == s, !i || !a)
            return n2 ? 0 : !i ^ r3 ? 1 : -1;
          if (!n2)
            return s < c2 ^ r3 ? 1 : -1;
          for (u = (c2 = i.length) < (s = a.length) ? c2 : s, o = 0; o < u; o++)
            if (i[o] != a[o])
              return i[o] > a[o] ^ r3 ? 1 : -1;
          return c2 == s ? 0 : s < c2 ^ r3 ? 1 : -1;
        }
        function Z(e4, t4, r3, n2) {
          if (e4 < t4 || r3 < e4 || e4 !== (e4 < 0 ? _(e4) : L(e4)))
            throw Error(T + (n2 || "Argument") + ("number" == typeof e4 ? e4 < t4 || r3 < e4 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e4));
        }
        function z2(e4) {
          var t4 = e4.c.length - 1;
          return G(e4.e / j) == t4 && e4.c[t4] % 2 != 0;
        }
        function W(e4, t4) {
          return (1 < e4.length ? e4.charAt(0) + "." + e4.slice(1) : e4) + (t4 < 0 ? "e" : "e+") + t4;
        }
        function H(e4, t4, r3) {
          var n2, i;
          if (t4 < 0) {
            for (i = r3 + "."; ++t4; i += r3)
              ;
            e4 = i + e4;
          } else if (++t4 > (n2 = e4.length)) {
            for (i = r3, t4 -= n2; --t4; i += r3)
              ;
            e4 += i;
          } else
            t4 < n2 && (e4 = e4.slice(0, t4) + "." + e4.slice(t4));
          return e4;
        }
        (t3 = function e4(t4) {
          var y2, f2, p2, r3, s, o, u, c2, l2, g2, n2 = A2.prototype = { constructor: A2, toString: null, valueOf: null }, d2 = new A2(1), b2 = 20, w2 = 4, h2 = -7, v2 = 21, m2 = -1e7, O = 1e7, x2 = false, a = 1, S = 0, N = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "Â ", suffix: "" }, M = "0123456789abcdefghijklmnopqrstuvwxyz";
          function A2(e5, t5) {
            var r4, n3, i2, a2, o2, u2, c3, s2, l3 = this;
            if (!(l3 instanceof A2))
              return new A2(e5, t5);
            if (null == t5) {
              if (e5 instanceof A2)
                return l3.s = e5.s, l3.e = e5.e, void (l3.c = (e5 = e5.c) ? e5.slice() : e5);
              if ((u2 = "number" == typeof e5) && 0 * e5 == 0) {
                if (l3.s = 1 / e5 < 0 ? (e5 = -e5, -1) : 1, e5 === ~~e5) {
                  for (a2 = 0, o2 = e5; 10 <= o2; o2 /= 10, a2++)
                    ;
                  return l3.e = a2, void (l3.c = [e5]);
                }
                s2 = String(e5);
              } else {
                if (s2 = String(e5), !k2.test(s2))
                  return p2(l3, s2, u2);
                l3.s = 45 == s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
              }
              -1 < (a2 = s2.indexOf(".")) && (s2 = s2.replace(".", "")), 0 < (o2 = s2.search(/e/i)) ? (a2 < 0 && (a2 = o2), a2 += +s2.slice(o2 + 1), s2 = s2.substring(0, o2)) : a2 < 0 && (a2 = s2.length);
            } else {
              if (Z(t5, 2, M.length, "Base"), s2 = String(e5), 10 == t5)
                return E(l3 = new A2(e5 instanceof A2 ? e5 : s2), b2 + l3.e + 1, w2);
              if (u2 = "number" == typeof e5) {
                if (0 * e5 != 0)
                  return p2(l3, s2, u2, t5);
                if (l3.s = 1 / e5 < 0 ? (s2 = s2.slice(1), -1) : 1, A2.DEBUG && 15 < s2.replace(/^0\.0*|\./, "").length)
                  throw Error(P + e5);
                u2 = false;
              } else
                l3.s = 45 === s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
              for (r4 = M.slice(0, t5), a2 = o2 = 0, c3 = s2.length; o2 < c3; o2++)
                if (r4.indexOf(n3 = s2.charAt(o2)) < 0) {
                  if ("." == n3) {
                    if (a2 < o2) {
                      a2 = c3;
                      continue;
                    }
                  } else if (!i2 && (s2 == s2.toUpperCase() && (s2 = s2.toLowerCase()) || s2 == s2.toLowerCase() && (s2 = s2.toUpperCase()))) {
                    i2 = true, o2 = -1, a2 = 0;
                    continue;
                  }
                  return p2(l3, String(e5), u2, t5);
                }
              -1 < (a2 = (s2 = f2(s2, t5, 10, l3.s)).indexOf(".")) ? s2 = s2.replace(".", "") : a2 = s2.length;
            }
            for (o2 = 0; 48 === s2.charCodeAt(o2); o2++)
              ;
            for (c3 = s2.length; 48 === s2.charCodeAt(--c3); )
              ;
            if (s2 = s2.slice(o2, ++c3)) {
              if (c3 -= o2, u2 && A2.DEBUG && 15 < c3 && (C < e5 || e5 !== L(e5)))
                throw Error(P + l3.s * e5);
              if (O < (a2 = a2 - o2 - 1))
                l3.c = l3.e = null;
              else if (a2 < m2)
                l3.c = [l3.e = 0];
              else {
                if (l3.e = a2, l3.c = [], o2 = (a2 + 1) % j, a2 < 0 && (o2 += j), o2 < c3) {
                  for (o2 && l3.c.push(+s2.slice(0, o2)), c3 -= j; o2 < c3; )
                    l3.c.push(+s2.slice(o2, o2 += j));
                  s2 = s2.slice(o2), o2 = j - s2.length;
                } else
                  o2 -= c3;
                for (; o2--; s2 += "0")
                  ;
                l3.c.push(+s2);
              }
            } else
              l3.c = [l3.e = 0];
          }
          function i(e5, t5, r4, n3) {
            var i2, a2, o2, u2, c3;
            if (null == r4 ? r4 = w2 : Z(r4, 0, 8), !e5.c)
              return e5.toString();
            if (i2 = e5.c[0], o2 = e5.e, null == t5)
              c3 = V(e5.c), c3 = 1 == n3 || 2 == n3 && (o2 <= h2 || v2 <= o2) ? W(c3, o2) : H(c3, o2, "0");
            else if (a2 = (e5 = E(new A2(e5), t5, r4)).e, u2 = (c3 = V(e5.c)).length, 1 == n3 || 2 == n3 && (t5 <= a2 || a2 <= h2)) {
              for (; u2 < t5; c3 += "0", u2++)
                ;
              c3 = W(c3, a2);
            } else if (t5 -= o2, c3 = H(c3, a2, "0"), u2 < a2 + 1) {
              if (0 < --t5)
                for (c3 += "."; t5--; c3 += "0")
                  ;
            } else if (0 < (t5 += a2 - u2))
              for (a2 + 1 == u2 && (c3 += "."); t5--; c3 += "0")
                ;
            return e5.s < 0 && i2 ? "-" + c3 : c3;
          }
          function B(e5, t5) {
            for (var r4, n3 = 1, i2 = new A2(e5[0]); n3 < e5.length; n3++) {
              if (!(r4 = new A2(e5[n3])).s) {
                i2 = r4;
                break;
              }
              t5.call(i2, r4) && (i2 = r4);
            }
            return i2;
          }
          function D(e5, t5, r4) {
            for (var n3 = 1, i2 = t5.length; !t5[--i2]; t5.pop())
              ;
            for (i2 = t5[0]; 10 <= i2; i2 /= 10, n3++)
              ;
            return (r4 = n3 + r4 * j - 1) > O ? e5.c = e5.e = null : e5.c = r4 < m2 ? [e5.e = 0] : (e5.e = r4, t5), e5;
          }
          function E(e5, t5, r4, n3) {
            var i2, a2, o2, u2, c3, s2, l3, f3 = e5.c, p3 = R;
            if (f3) {
              e: {
                for (i2 = 1, u2 = f3[0]; 10 <= u2; u2 /= 10, i2++)
                  ;
                if ((a2 = t5 - i2) < 0)
                  a2 += j, o2 = t5, l3 = (c3 = f3[s2 = 0]) / p3[i2 - o2 - 1] % 10 | 0;
                else if ((s2 = _((a2 + 1) / j)) >= f3.length) {
                  if (!n3)
                    break e;
                  for (; f3.length <= s2; f3.push(0))
                    ;
                  c3 = l3 = 0, o2 = (a2 %= j) - j + (i2 = 1);
                } else {
                  for (c3 = u2 = f3[s2], i2 = 1; 10 <= u2; u2 /= 10, i2++)
                    ;
                  l3 = (o2 = (a2 %= j) - j + i2) < 0 ? 0 : c3 / p3[i2 - o2 - 1] % 10 | 0;
                }
                if (n3 = n3 || t5 < 0 || null != f3[s2 + 1] || (o2 < 0 ? c3 : c3 % p3[i2 - o2 - 1]), n3 = r4 < 4 ? (l3 || n3) && (0 == r4 || r4 == (e5.s < 0 ? 3 : 2)) : 5 < l3 || 5 == l3 && (4 == r4 || n3 || 6 == r4 && (0 < a2 ? 0 < o2 ? c3 / p3[i2 - o2] : 0 : f3[s2 - 1]) % 10 & 1 || r4 == (e5.s < 0 ? 8 : 7)), t5 < 1 || !f3[0])
                  return f3.length = 0, n3 ? (t5 -= e5.e + 1, f3[0] = p3[(j - t5 % j) % j], e5.e = -t5 || 0) : f3[0] = e5.e = 0, e5;
                if (0 == a2 ? (f3.length = s2, u2 = 1, s2--) : (f3.length = s2 + 1, u2 = p3[j - a2], f3[s2] = 0 < o2 ? L(c3 / p3[i2 - o2] % p3[o2]) * u2 : 0), n3)
                  for (; ; ) {
                    if (0 == s2) {
                      for (a2 = 1, o2 = f3[0]; 10 <= o2; o2 /= 10, a2++)
                        ;
                      for (o2 = f3[0] += u2, u2 = 1; 10 <= o2; o2 /= 10, u2++)
                        ;
                      a2 != u2 && (e5.e++, f3[0] == U && (f3[0] = 1));
                      break;
                    }
                    if (f3[s2] += u2, f3[s2] != U)
                      break;
                    f3[s2--] = 0, u2 = 1;
                  }
                for (a2 = f3.length; 0 === f3[--a2]; f3.pop())
                  ;
              }
              e5.e > O ? e5.c = e5.e = null : e5.e < m2 && (e5.c = [e5.e = 0]);
            }
            return e5;
          }
          function F(e5) {
            var t5, r4 = e5.e;
            return null === r4 ? e5.toString() : (t5 = V(e5.c), t5 = r4 <= h2 || v2 <= r4 ? W(t5, r4) : H(t5, r4, "0"), e5.s < 0 ? "-" + t5 : t5);
          }
          return A2.clone = e4, A2.ROUND_UP = 0, A2.ROUND_DOWN = 1, A2.ROUND_CEIL = 2, A2.ROUND_FLOOR = 3, A2.ROUND_HALF_UP = 4, A2.ROUND_HALF_DOWN = 5, A2.ROUND_HALF_EVEN = 6, A2.ROUND_HALF_CEIL = 7, A2.ROUND_HALF_FLOOR = 8, A2.EUCLID = 9, A2.config = A2.set = function(e5) {
            var t5, r4;
            if (null != e5) {
              if ("object" != typeof e5)
                throw Error(T + "Object expected: " + e5);
              if (e5.hasOwnProperty(t5 = "DECIMAL_PLACES") && (Z(r4 = e5[t5], 0, $2, t5), b2 = r4), e5.hasOwnProperty(t5 = "ROUNDING_MODE") && (Z(r4 = e5[t5], 0, 8, t5), w2 = r4), e5.hasOwnProperty(t5 = "EXPONENTIAL_AT") && ((r4 = e5[t5]) && r4.pop ? (Z(r4[0], -$2, 0, t5), Z(r4[1], 0, $2, t5), h2 = r4[0], v2 = r4[1]) : (Z(r4, -$2, $2, t5), h2 = -(v2 = r4 < 0 ? -r4 : r4))), e5.hasOwnProperty(t5 = "RANGE"))
                if ((r4 = e5[t5]) && r4.pop)
                  Z(r4[0], -$2, -1, t5), Z(r4[1], 1, $2, t5), m2 = r4[0], O = r4[1];
                else {
                  if (Z(r4, -$2, $2, t5), !r4)
                    throw Error(T + t5 + " cannot be zero: " + r4);
                  m2 = -(O = r4 < 0 ? -r4 : r4);
                }
              if (e5.hasOwnProperty(t5 = "CRYPTO")) {
                if ((r4 = e5[t5]) !== !!r4)
                  throw Error(T + t5 + " not true or false: " + r4);
                if (r4) {
                  if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                    throw x2 = !r4, Error(T + "crypto unavailable");
                  x2 = r4;
                } else
                  x2 = r4;
              }
              if (e5.hasOwnProperty(t5 = "MODULO_MODE") && (Z(r4 = e5[t5], 0, 9, t5), a = r4), e5.hasOwnProperty(t5 = "POW_PRECISION") && (Z(r4 = e5[t5], 0, $2, t5), S = r4), e5.hasOwnProperty(t5 = "FORMAT")) {
                if ("object" != typeof (r4 = e5[t5]))
                  throw Error(T + t5 + " not an object: " + r4);
                N = r4;
              }
              if (e5.hasOwnProperty(t5 = "ALPHABET")) {
                if ("string" != typeof (r4 = e5[t5]) || /^.$|[+-.\s]|(.).*\1/.test(r4))
                  throw Error(T + t5 + " invalid: " + r4);
                M = r4;
              }
            }
            return { DECIMAL_PLACES: b2, ROUNDING_MODE: w2, EXPONENTIAL_AT: [h2, v2], RANGE: [m2, O], CRYPTO: x2, MODULO_MODE: a, POW_PRECISION: S, FORMAT: N, ALPHABET: M };
          }, A2.isBigNumber = function(e5) {
            return e5 instanceof A2 || e5 && true === e5._isBigNumber || false;
          }, A2.maximum = A2.max = function() {
            return B(arguments, n2.lt);
          }, A2.minimum = A2.min = function() {
            return B(arguments, n2.gt);
          }, A2.random = (r3 = 9007199254740992, s = Math.random() * r3 & 2097151 ? function() {
            return L(Math.random() * r3);
          } : function() {
            return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
          }, function(e5) {
            var t5, r4, n3, i2, a2, o2 = 0, u2 = [], c3 = new A2(d2);
            if (null == e5 ? e5 = b2 : Z(e5, 0, $2), i2 = _(e5 / j), x2)
              if (crypto.getRandomValues) {
                for (t5 = crypto.getRandomValues(new Uint32Array(i2 *= 2)); o2 < i2; )
                  9e15 <= (a2 = 131072 * t5[o2] + (t5[o2 + 1] >>> 11)) ? (r4 = crypto.getRandomValues(new Uint32Array(2)), t5[o2] = r4[0], t5[o2 + 1] = r4[1]) : (u2.push(a2 % 1e14), o2 += 2);
                o2 = i2 / 2;
              } else {
                if (!crypto.randomBytes)
                  throw x2 = false, Error(T + "crypto unavailable");
                for (t5 = crypto.randomBytes(i2 *= 7); o2 < i2; )
                  9e15 <= (a2 = 281474976710656 * (31 & t5[o2]) + 1099511627776 * t5[o2 + 1] + 4294967296 * t5[o2 + 2] + 16777216 * t5[o2 + 3] + (t5[o2 + 4] << 16) + (t5[o2 + 5] << 8) + t5[o2 + 6]) ? crypto.randomBytes(7).copy(t5, o2) : (u2.push(a2 % 1e14), o2 += 7);
                o2 = i2 / 7;
              }
            if (!x2)
              for (; o2 < i2; )
                (a2 = s()) < 9e15 && (u2[o2++] = a2 % 1e14);
            for (i2 = u2[--o2], e5 %= j, i2 && e5 && (a2 = R[j - e5], u2[o2] = L(i2 / a2) * a2); 0 === u2[o2]; u2.pop(), o2--)
              ;
            if (o2 < 0)
              u2 = [n3 = 0];
            else {
              for (n3 = -1; 0 === u2[0]; u2.splice(0, 1), n3 -= j)
                ;
              for (o2 = 1, a2 = u2[0]; 10 <= a2; a2 /= 10, o2++)
                ;
              o2 < j && (n3 -= j - o2);
            }
            return c3.e = n3, c3.c = u2, c3;
          }), A2.sum = function() {
            for (var e5 = 1, t5 = arguments, r4 = new A2(t5[0]); e5 < t5.length; )
              r4 = r4.plus(t5[e5++]);
            return r4;
          }, f2 = function() {
            var v3 = "0123456789";
            function m3(e5, t5, r4, n3) {
              for (var i2, a2, o2 = [0], u2 = 0, c3 = e5.length; u2 < c3; ) {
                for (a2 = o2.length; a2--; o2[a2] *= t5)
                  ;
                for (o2[0] += n3.indexOf(e5.charAt(u2++)), i2 = 0; i2 < o2.length; i2++)
                  o2[i2] > r4 - 1 && (null == o2[i2 + 1] && (o2[i2 + 1] = 0), o2[i2 + 1] += o2[i2] / r4 | 0, o2[i2] %= r4);
              }
              return o2.reverse();
            }
            return function(e5, t5, r4, n3, i2) {
              var a2, o2, u2, c3, s2, l3, f3, p3, g3 = e5.indexOf("."), h3 = b2, d3 = w2;
              for (0 <= g3 && (c3 = S, S = 0, e5 = e5.replace(".", ""), l3 = (p3 = new A2(t5)).pow(e5.length - g3), S = c3, p3.c = m3(H(V(l3.c), l3.e, "0"), 10, r4, v3), p3.e = p3.c.length), u2 = c3 = (f3 = m3(e5, t5, r4, i2 ? (a2 = M, v3) : (a2 = v3, M))).length; 0 == f3[--c3]; f3.pop())
                ;
              if (!f3[0])
                return a2.charAt(0);
              if (g3 < 0 ? --u2 : (l3.c = f3, l3.e = u2, l3.s = n3, f3 = (l3 = y2(l3, p3, h3, d3, r4)).c, s2 = l3.r, u2 = l3.e), g3 = f3[o2 = u2 + h3 + 1], c3 = r4 / 2, s2 = s2 || o2 < 0 || null != f3[o2 + 1], s2 = d3 < 4 ? (null != g3 || s2) && (0 == d3 || d3 == (l3.s < 0 ? 3 : 2)) : c3 < g3 || g3 == c3 && (4 == d3 || s2 || 6 == d3 && 1 & f3[o2 - 1] || d3 == (l3.s < 0 ? 8 : 7)), o2 < 1 || !f3[0])
                e5 = s2 ? H(a2.charAt(1), -h3, a2.charAt(0)) : a2.charAt(0);
              else {
                if (f3.length = o2, s2)
                  for (--r4; ++f3[--o2] > r4; )
                    f3[o2] = 0, o2 || (++u2, f3 = [1].concat(f3));
                for (c3 = f3.length; !f3[--c3]; )
                  ;
                for (g3 = 0, e5 = ""; g3 <= c3; e5 += a2.charAt(f3[g3++]))
                  ;
                e5 = H(e5, u2, a2.charAt(0));
              }
              return e5;
            };
          }(), y2 = function() {
            function M2(e5, t5, r4) {
              var n3, i2, a2, o2, u2 = 0, c3 = e5.length, s2 = t5 % I, l3 = t5 / I | 0;
              for (e5 = e5.slice(); c3--; )
                u2 = ((i2 = s2 * (a2 = e5[c3] % I) + (n3 = l3 * a2 + (o2 = e5[c3] / I | 0) * s2) % I * I + u2) / r4 | 0) + (n3 / I | 0) + l3 * o2, e5[c3] = i2 % r4;
              return u2 && (e5 = [u2].concat(e5)), e5;
            }
            function B2(e5, t5, r4, n3) {
              var i2, a2;
              if (r4 != n3)
                a2 = n3 < r4 ? 1 : -1;
              else
                for (i2 = a2 = 0; i2 < r4; i2++)
                  if (e5[i2] != t5[i2]) {
                    a2 = e5[i2] > t5[i2] ? 1 : -1;
                    break;
                  }
              return a2;
            }
            function D2(e5, t5, r4, n3) {
              for (var i2 = 0; r4--; )
                e5[r4] -= i2, i2 = e5[r4] < t5[r4] ? 1 : 0, e5[r4] = i2 * n3 + e5[r4] - t5[r4];
              for (; !e5[0] && 1 < e5.length; e5.splice(0, 1))
                ;
            }
            return function(e5, t5, r4, n3, i2) {
              var a2, o2, u2, c3, s2, l3, f3, p3, g3, h3, d3, v3, m3, y3, b3, w3, O2, x3 = e5.s == t5.s ? 1 : -1, S2 = e5.c, N2 = t5.c;
              if (!(S2 && S2[0] && N2 && N2[0]))
                return new A2(e5.s && t5.s && (S2 ? !N2 || S2[0] != N2[0] : N2) ? S2 && 0 == S2[0] || !N2 ? 0 * x3 : x3 / 0 : NaN);
              for (g3 = (p3 = new A2(x3)).c = [], x3 = r4 + (o2 = e5.e - t5.e) + 1, i2 || (i2 = U, o2 = G(e5.e / j) - G(t5.e / j), x3 = x3 / j | 0), u2 = 0; N2[u2] == (S2[u2] || 0); u2++)
                ;
              if (N2[u2] > (S2[u2] || 0) && o2--, x3 < 0)
                g3.push(1), c3 = true;
              else {
                for (y3 = S2.length, w3 = N2.length, x3 += 2, 1 < (s2 = L(i2 / (N2[u2 = 0] + 1))) && (N2 = M2(N2, s2, i2), S2 = M2(S2, s2, i2), w3 = N2.length, y3 = S2.length), m3 = w3, d3 = (h3 = S2.slice(0, w3)).length; d3 < w3; h3[d3++] = 0)
                  ;
                O2 = N2.slice(), O2 = [0].concat(O2), b3 = N2[0], N2[1] >= i2 / 2 && b3++;
                do {
                  if (s2 = 0, (a2 = B2(N2, h3, w3, d3)) < 0) {
                    if (v3 = h3[0], w3 != d3 && (v3 = v3 * i2 + (h3[1] || 0)), 1 < (s2 = L(v3 / b3)))
                      for (i2 <= s2 && (s2 = i2 - 1), f3 = (l3 = M2(N2, s2, i2)).length, d3 = h3.length; 1 == B2(l3, h3, f3, d3); )
                        s2--, D2(l3, w3 < f3 ? O2 : N2, f3, i2), f3 = l3.length, a2 = 1;
                    else
                      0 == s2 && (a2 = s2 = 1), f3 = (l3 = N2.slice()).length;
                    if (f3 < d3 && (l3 = [0].concat(l3)), D2(h3, l3, d3, i2), d3 = h3.length, -1 == a2)
                      for (; B2(N2, h3, w3, d3) < 1; )
                        s2++, D2(h3, w3 < d3 ? O2 : N2, d3, i2), d3 = h3.length;
                  } else
                    0 === a2 && (s2++, h3 = [0]);
                  g3[u2++] = s2, h3[0] ? h3[d3++] = S2[m3] || 0 : (h3 = [S2[m3]], d3 = 1);
                } while ((m3++ < y3 || null != h3[0]) && x3--);
                c3 = null != h3[0], g3[0] || g3.splice(0, 1);
              }
              if (i2 == U) {
                for (u2 = 1, x3 = g3[0]; 10 <= x3; x3 /= 10, u2++)
                  ;
                E(p3, r4 + (p3.e = u2 + o2 * j - 1) + 1, n3, c3);
              } else
                p3.e = o2, p3.r = +c3;
              return p3;
            };
          }(), o = /^(-?)0([xbo])(?=\w[\w.]*$)/i, u = /^([^.]+)\.$/, c2 = /^\.([^.]+)$/, l2 = /^-?(Infinity|NaN)$/, g2 = /^\s*\+(?=[\w.])|^\s+|\s+$/g, p2 = function(e5, t5, r4, n3) {
            var i2, a2 = r4 ? t5 : t5.replace(g2, "");
            if (l2.test(a2))
              e5.s = isNaN(a2) ? null : a2 < 0 ? -1 : 1, e5.c = e5.e = null;
            else {
              if (!r4 && (a2 = a2.replace(o, function(e6, t6, r5) {
                return i2 = "x" == (r5 = r5.toLowerCase()) ? 16 : "b" == r5 ? 2 : 8, n3 && n3 != i2 ? e6 : t6;
              }), n3 && (i2 = n3, a2 = a2.replace(u, "$1").replace(c2, "0.$1")), t5 != a2))
                return new A2(a2, i2);
              if (A2.DEBUG)
                throw Error(T + "Not a" + (n3 ? " base " + n3 : "") + " number: " + t5);
              e5.c = e5.e = e5.s = null;
            }
          }, n2.absoluteValue = n2.abs = function() {
            var e5 = new A2(this);
            return e5.s < 0 && (e5.s = 1), e5;
          }, n2.comparedTo = function(e5, t5) {
            return q2(this, new A2(e5, t5));
          }, n2.decimalPlaces = n2.dp = function(e5, t5) {
            var r4, n3, i2;
            if (null != e5)
              return Z(e5, 0, $2), null == t5 ? t5 = w2 : Z(t5, 0, 8), E(new A2(this), e5 + this.e + 1, t5);
            if (!(r4 = this.c))
              return null;
            if (n3 = ((i2 = r4.length - 1) - G(this.e / j)) * j, i2 = r4[i2])
              for (; i2 % 10 == 0; i2 /= 10, n3--)
                ;
            return n3 < 0 && (n3 = 0), n3;
          }, n2.dividedBy = n2.div = function(e5, t5) {
            return y2(this, new A2(e5, t5), b2, w2);
          }, n2.dividedToIntegerBy = n2.idiv = function(e5, t5) {
            return y2(this, new A2(e5, t5), 0, 1);
          }, n2.exponentiatedBy = n2.pow = function(e5, t5) {
            var r4, n3, i2, a2, o2, u2, c3, s2, l3 = this;
            if ((e5 = new A2(e5)).c && !e5.isInteger())
              throw Error(T + "Exponent not an integer: " + F(e5));
            if (null != t5 && (t5 = new A2(t5)), o2 = 14 < e5.e, !l3.c || !l3.c[0] || 1 == l3.c[0] && !l3.e && 1 == l3.c.length || !e5.c || !e5.c[0])
              return s2 = new A2(Math.pow(+F(l3), o2 ? 2 - z2(e5) : +F(e5))), t5 ? s2.mod(t5) : s2;
            if (u2 = e5.s < 0, t5) {
              if (t5.c ? !t5.c[0] : !t5.s)
                return new A2(NaN);
              (n3 = !u2 && l3.isInteger() && t5.isInteger()) && (l3 = l3.mod(t5));
            } else {
              if (9 < e5.e && (0 < l3.e || l3.e < -1 || (0 == l3.e ? 1 < l3.c[0] || o2 && 24e7 <= l3.c[1] : l3.c[0] < 8e13 || o2 && l3.c[0] <= 9999975e7)))
                return a2 = l3.s < 0 && z2(e5) ? -0 : 0, -1 < l3.e && (a2 = 1 / a2), new A2(u2 ? 1 / a2 : a2);
              S && (a2 = _(S / j + 2));
            }
            for (c3 = o2 ? (r4 = new A2(0.5), u2 && (e5.s = 1), z2(e5)) : (i2 = Math.abs(+F(e5))) % 2, s2 = new A2(d2); ; ) {
              if (c3) {
                if (!(s2 = s2.times(l3)).c)
                  break;
                a2 ? s2.c.length > a2 && (s2.c.length = a2) : n3 && (s2 = s2.mod(t5));
              }
              if (i2) {
                if (0 === (i2 = L(i2 / 2)))
                  break;
                c3 = i2 % 2;
              } else if (E(e5 = e5.times(r4), e5.e + 1, 1), 14 < e5.e)
                c3 = z2(e5);
              else {
                if (0 == (i2 = +F(e5)))
                  break;
                c3 = i2 % 2;
              }
              l3 = l3.times(l3), a2 ? l3.c && l3.c.length > a2 && (l3.c.length = a2) : n3 && (l3 = l3.mod(t5));
            }
            return n3 ? s2 : (u2 && (s2 = d2.div(s2)), t5 ? s2.mod(t5) : a2 ? E(s2, S, w2, void 0) : s2);
          }, n2.integerValue = function(e5) {
            var t5 = new A2(this);
            return null == e5 ? e5 = w2 : Z(e5, 0, 8), E(t5, t5.e + 1, e5);
          }, n2.isEqualTo = n2.eq = function(e5, t5) {
            return 0 === q2(this, new A2(e5, t5));
          }, n2.isFinite = function() {
            return !!this.c;
          }, n2.isGreaterThan = n2.gt = function(e5, t5) {
            return 0 < q2(this, new A2(e5, t5));
          }, n2.isGreaterThanOrEqualTo = n2.gte = function(e5, t5) {
            return 1 === (t5 = q2(this, new A2(e5, t5))) || 0 === t5;
          }, n2.isInteger = function() {
            return !!this.c && G(this.e / j) > this.c.length - 2;
          }, n2.isLessThan = n2.lt = function(e5, t5) {
            return q2(this, new A2(e5, t5)) < 0;
          }, n2.isLessThanOrEqualTo = n2.lte = function(e5, t5) {
            return -1 === (t5 = q2(this, new A2(e5, t5))) || 0 === t5;
          }, n2.isNaN = function() {
            return !this.s;
          }, n2.isNegative = function() {
            return this.s < 0;
          }, n2.isPositive = function() {
            return 0 < this.s;
          }, n2.isZero = function() {
            return !!this.c && 0 == this.c[0];
          }, n2.minus = function(e5, t5) {
            var r4, n3, i2, a2, o2 = this, u2 = o2.s;
            if (t5 = (e5 = new A2(e5, t5)).s, !u2 || !t5)
              return new A2(NaN);
            if (u2 != t5)
              return e5.s = -t5, o2.plus(e5);
            var c3 = o2.e / j, s2 = e5.e / j, l3 = o2.c, f3 = e5.c;
            if (!c3 || !s2) {
              if (!l3 || !f3)
                return l3 ? (e5.s = -t5, e5) : new A2(f3 ? o2 : NaN);
              if (!l3[0] || !f3[0])
                return f3[0] ? (e5.s = -t5, e5) : new A2(l3[0] ? o2 : 3 == w2 ? -0 : 0);
            }
            if (c3 = G(c3), s2 = G(s2), l3 = l3.slice(), u2 = c3 - s2) {
              for ((i2 = (a2 = u2 < 0) ? (u2 = -u2, l3) : (s2 = c3, f3)).reverse(), t5 = u2; t5--; i2.push(0))
                ;
              i2.reverse();
            } else
              for (n3 = (a2 = (u2 = l3.length) < (t5 = f3.length)) ? u2 : t5, u2 = t5 = 0; t5 < n3; t5++)
                if (l3[t5] != f3[t5]) {
                  a2 = l3[t5] < f3[t5];
                  break;
                }
            if (a2 && (i2 = l3, l3 = f3, f3 = i2, e5.s = -e5.s), 0 < (t5 = (n3 = f3.length) - (r4 = l3.length)))
              for (; t5--; l3[r4++] = 0)
                ;
            for (t5 = U - 1; u2 < n3; ) {
              if (l3[--n3] < f3[n3]) {
                for (r4 = n3; r4 && !l3[--r4]; l3[r4] = t5)
                  ;
                --l3[r4], l3[n3] += U;
              }
              l3[n3] -= f3[n3];
            }
            for (; 0 == l3[0]; l3.splice(0, 1), --s2)
              ;
            return l3[0] ? D(e5, l3, s2) : (e5.s = 3 == w2 ? -1 : 1, e5.c = [e5.e = 0], e5);
          }, n2.modulo = n2.mod = function(e5, t5) {
            var r4, n3, i2 = this;
            return e5 = new A2(e5, t5), !i2.c || !e5.s || e5.c && !e5.c[0] ? new A2(NaN) : !e5.c || i2.c && !i2.c[0] ? new A2(i2) : (9 == a ? (n3 = e5.s, e5.s = 1, r4 = y2(i2, e5, 0, 3), e5.s = n3, r4.s *= n3) : r4 = y2(i2, e5, 0, a), (e5 = i2.minus(r4.times(e5))).c[0] || 1 != a || (e5.s = i2.s), e5);
          }, n2.multipliedBy = n2.times = function(e5, t5) {
            var r4, n3, i2, a2, o2, u2, c3, s2, l3, f3, p3, g3, h3, d3, v3, m3 = this, y3 = m3.c, b3 = (e5 = new A2(e5, t5)).c;
            if (!(y3 && b3 && y3[0] && b3[0]))
              return !m3.s || !e5.s || y3 && !y3[0] && !b3 || b3 && !b3[0] && !y3 ? e5.c = e5.e = e5.s = null : (e5.s *= m3.s, y3 && b3 ? (e5.c = [0], e5.e = 0) : e5.c = e5.e = null), e5;
            for (n3 = G(m3.e / j) + G(e5.e / j), e5.s *= m3.s, (c3 = y3.length) < (f3 = b3.length) && (h3 = y3, y3 = b3, b3 = h3, i2 = c3, c3 = f3, f3 = i2), i2 = c3 + f3, h3 = []; i2--; h3.push(0))
              ;
            for (d3 = U, v3 = I, i2 = f3; 0 <= --i2; ) {
              for (r4 = 0, p3 = b3[i2] % v3, g3 = b3[i2] / v3 | 0, a2 = i2 + (o2 = c3); i2 < a2; )
                r4 = ((s2 = p3 * (s2 = y3[--o2] % v3) + (u2 = g3 * s2 + (l3 = y3[o2] / v3 | 0) * p3) % v3 * v3 + h3[a2] + r4) / d3 | 0) + (u2 / v3 | 0) + g3 * l3, h3[a2--] = s2 % d3;
              h3[a2] = r4;
            }
            return r4 ? ++n3 : h3.splice(0, 1), D(e5, h3, n3);
          }, n2.negated = function() {
            var e5 = new A2(this);
            return e5.s = -e5.s || null, e5;
          }, n2.plus = function(e5, t5) {
            var r4, n3 = this, i2 = n3.s;
            if (t5 = (e5 = new A2(e5, t5)).s, !i2 || !t5)
              return new A2(NaN);
            if (i2 != t5)
              return e5.s = -t5, n3.minus(e5);
            var a2 = n3.e / j, o2 = e5.e / j, u2 = n3.c, c3 = e5.c;
            if (!a2 || !o2) {
              if (!u2 || !c3)
                return new A2(i2 / 0);
              if (!u2[0] || !c3[0])
                return c3[0] ? e5 : new A2(u2[0] ? n3 : 0 * i2);
            }
            if (a2 = G(a2), o2 = G(o2), u2 = u2.slice(), i2 = a2 - o2) {
              for ((r4 = 0 < i2 ? (o2 = a2, c3) : (i2 = -i2, u2)).reverse(); i2--; r4.push(0))
                ;
              r4.reverse();
            }
            for ((i2 = u2.length) - (t5 = c3.length) < 0 && (r4 = c3, c3 = u2, u2 = r4, t5 = i2), i2 = 0; t5; )
              i2 = (u2[--t5] = u2[t5] + c3[t5] + i2) / U | 0, u2[t5] = U === u2[t5] ? 0 : u2[t5] % U;
            return i2 && (u2 = [i2].concat(u2), ++o2), D(e5, u2, o2);
          }, n2.precision = n2.sd = function(e5, t5) {
            var r4, n3, i2;
            if (null != e5 && e5 !== !!e5)
              return Z(e5, 1, $2), null == t5 ? t5 = w2 : Z(t5, 0, 8), E(new A2(this), e5, t5);
            if (!(r4 = this.c))
              return null;
            if (n3 = (i2 = r4.length - 1) * j + 1, i2 = r4[i2]) {
              for (; i2 % 10 == 0; i2 /= 10, n3--)
                ;
              for (i2 = r4[0]; 10 <= i2; i2 /= 10, n3++)
                ;
            }
            return e5 && this.e + 1 > n3 && (n3 = this.e + 1), n3;
          }, n2.shiftedBy = function(e5) {
            return Z(e5, -C, C), this.times("1e" + e5);
          }, n2.squareRoot = n2.sqrt = function() {
            var e5, t5, r4, n3, i2, a2 = this, o2 = a2.c, u2 = a2.s, c3 = a2.e, s2 = b2 + 4, l3 = new A2("0.5");
            if (1 !== u2 || !o2 || !o2[0])
              return new A2(!u2 || u2 < 0 && (!o2 || o2[0]) ? NaN : o2 ? a2 : 1 / 0);
            if ((r4 = 0 == (u2 = Math.sqrt(+F(a2))) || u2 == 1 / 0 ? (((t5 = V(o2)).length + c3) % 2 == 0 && (t5 += "0"), u2 = Math.sqrt(+t5), c3 = G((c3 + 1) / 2) - (c3 < 0 || c3 % 2), new A2(t5 = u2 == 1 / 0 ? "1e" + c3 : (t5 = u2.toExponential()).slice(0, t5.indexOf("e") + 1) + c3)) : new A2(u2 + "")).c[0]) {
              for ((u2 = (c3 = r4.e) + s2) < 3 && (u2 = 0); ; )
                if (i2 = r4, r4 = l3.times(i2.plus(y2(a2, i2, s2, 1))), V(i2.c).slice(0, u2) === (t5 = V(r4.c)).slice(0, u2)) {
                  if (r4.e < c3 && --u2, "9999" != (t5 = t5.slice(u2 - 3, u2 + 1)) && (n3 || "4999" != t5)) {
                    +t5 && (+t5.slice(1) || "5" != t5.charAt(0)) || (E(r4, r4.e + b2 + 2, 1), e5 = !r4.times(r4).eq(a2));
                    break;
                  }
                  if (!n3 && (E(i2, i2.e + b2 + 2, 0), i2.times(i2).eq(a2))) {
                    r4 = i2;
                    break;
                  }
                  s2 += 4, u2 += 4, n3 = 1;
                }
            }
            return E(r4, r4.e + b2 + 1, w2, e5);
          }, n2.toExponential = function(e5, t5) {
            return null != e5 && (Z(e5, 0, $2), e5++), i(this, e5, t5, 1);
          }, n2.toFixed = function(e5, t5) {
            return null != e5 && (Z(e5, 0, $2), e5 = e5 + this.e + 1), i(this, e5, t5);
          }, n2.toFormat = function(e5, t5, r4) {
            var n3;
            if (null == r4)
              null != e5 && t5 && "object" == typeof t5 ? (r4 = t5, t5 = null) : e5 && "object" == typeof e5 ? (r4 = e5, e5 = t5 = null) : r4 = N;
            else if ("object" != typeof r4)
              throw Error(T + "Argument not an object: " + r4);
            if (n3 = this.toFixed(e5, t5), this.c) {
              var i2, a2 = n3.split("."), o2 = +r4.groupSize, u2 = +r4.secondaryGroupSize, c3 = r4.groupSeparator || "", s2 = a2[0], l3 = a2[1], f3 = this.s < 0, p3 = f3 ? s2.slice(1) : s2, g3 = p3.length;
              if (u2 && (i2 = o2, o2 = u2, g3 -= u2 = i2), 0 < o2 && 0 < g3) {
                for (i2 = g3 % o2 || o2, s2 = p3.substr(0, i2); i2 < g3; i2 += o2)
                  s2 += c3 + p3.substr(i2, o2);
                0 < u2 && (s2 += c3 + p3.slice(i2)), f3 && (s2 = "-" + s2);
              }
              n3 = l3 ? s2 + (r4.decimalSeparator || "") + ((u2 = +r4.fractionGroupSize) ? l3.replace(new RegExp("\\d{" + u2 + "}\\B", "g"), "$&" + (r4.fractionGroupSeparator || "")) : l3) : s2;
            }
            return (r4.prefix || "") + n3 + (r4.suffix || "");
          }, n2.toFraction = function(e5) {
            var t5, r4, n3, i2, a2, o2, u2, c3, s2, l3, f3, p3, g3 = this, h3 = g3.c;
            if (null != e5 && (!(u2 = new A2(e5)).isInteger() && (u2.c || 1 !== u2.s) || u2.lt(d2)))
              throw Error(T + "Argument " + (u2.isInteger() ? "out of range: " : "not an integer: ") + F(u2));
            if (!h3)
              return new A2(g3);
            for (t5 = new A2(d2), s2 = r4 = new A2(d2), n3 = c3 = new A2(d2), p3 = V(h3), a2 = t5.e = p3.length - g3.e - 1, t5.c[0] = R[(o2 = a2 % j) < 0 ? j + o2 : o2], e5 = !e5 || 0 < u2.comparedTo(t5) ? 0 < a2 ? t5 : s2 : u2, o2 = O, O = 1 / 0, u2 = new A2(p3), c3.c[0] = 0; l3 = y2(u2, t5, 0, 1), 1 != (i2 = r4.plus(l3.times(n3))).comparedTo(e5); )
              r4 = n3, n3 = i2, s2 = c3.plus(l3.times(i2 = s2)), c3 = i2, t5 = u2.minus(l3.times(i2 = t5)), u2 = i2;
            return i2 = y2(e5.minus(r4), n3, 0, 1), c3 = c3.plus(i2.times(s2)), r4 = r4.plus(i2.times(n3)), c3.s = s2.s = g3.s, f3 = y2(s2, n3, a2 *= 2, w2).minus(g3).abs().comparedTo(y2(c3, r4, a2, w2).minus(g3).abs()) < 1 ? [s2, n3] : [c3, r4], O = o2, f3;
          }, n2.toNumber = function() {
            return +F(this);
          }, n2.toPrecision = function(e5, t5) {
            return null != e5 && Z(e5, 1, $2), i(this, e5, t5, 2);
          }, n2.toString = function(e5) {
            var t5, r4 = this, n3 = r4.s, i2 = r4.e;
            return null === i2 ? n3 ? (t5 = "Infinity", n3 < 0 && (t5 = "-" + t5)) : t5 = "NaN" : (t5 = null == e5 ? i2 <= h2 || v2 <= i2 ? W(V(r4.c), i2) : H(V(r4.c), i2, "0") : 10 === e5 ? H(V((r4 = E(new A2(r4), b2 + i2 + 1, w2)).c), r4.e, "0") : (Z(e5, 2, M.length, "Base"), f2(H(V(r4.c), i2, "0"), 10, e5, n3, true)), n3 < 0 && r4.c[0] && (t5 = "-" + t5)), t5;
          }, n2.valueOf = n2.toJSON = function() {
            return F(this);
          }, n2._isBigNumber = true, "function" == typeof Symbol && "symbol" == typeof Symbol.iterator && (n2[Symbol.toStringTag] = "BigNumber", n2[Symbol.for("nodejs.util.inspect.custom")] = n2.valueOf), null != t4 && A2.set(t4), A2;
        }()).default = t3.BigNumber = t3, void 0 !== r2 && r2.exports ? r2.exports = t3 : (e3 || (e3 = "undefined" != typeof self && self ? self : window), e3.BigNumber = t3);
      }(this);
    }, {}], 2: [function(e2, t2, r2) {
      t2.exports = { languageTag: "en-US", delimiters: { thousands: ",", decimal: "." }, abbreviations: { thousand: "k", million: "m", billion: "b", trillion: "t" }, spaceSeparated: false, ordinal: function(e3) {
        var t3 = e3 % 10;
        return 1 == ~~(e3 % 100 / 10) ? "th" : 1 === t3 ? "st" : 2 === t3 ? "nd" : 3 === t3 ? "rd" : "th";
      }, currency: { symbol: "$", position: "prefix", code: "USD" }, currencyFormat: { thousandSeparated: true, totalLength: 4, spaceSeparated: true }, formats: { fourDigits: { totalLength: 4, spaceSeparated: true }, fullWithTwoDecimals: { output: "currency", thousandSeparated: true, mantissa: 2 }, fullWithTwoDecimalsNoCurrency: { thousandSeparated: true, mantissa: 2 }, fullWithNoDecimals: { output: "currency", thousandSeparated: true, mantissa: 0 } } };
    }, {}], 3: [function(e2, t2, r2) {
      function C(e3, t3) {
        return function(e4) {
          if (Array.isArray(e4))
            return e4;
        }(e3) || function(e4, t4) {
          var r3 = [], n3 = true, i2 = false, a = void 0;
          try {
            for (var o2, u2 = e4[Symbol.iterator](); !(n3 = (o2 = u2.next()).done) && (r3.push(o2.value), !t4 || r3.length !== t4); n3 = true)
              ;
          } catch (e5) {
            i2 = true, a = e5;
          } finally {
            try {
              n3 || null == u2.return || u2.return();
            } finally {
              if (i2)
                throw a;
            }
          }
          return r3;
        }(e3, t3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }();
      }
      var R = e2("./globalState"), o = e2("./validating"), u = e2("./parsing"), n2 = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], M = { general: { scale: 1024, suffixes: n2, marker: "bd" }, binary: { scale: 1024, suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], marker: "b" }, decimal: { scale: 1e3, suffixes: n2, marker: "d" } }, I = { totalLength: 0, characteristic: 0, forceAverage: false, average: false, mantissa: -1, optionalMantissa: true, thousandSeparated: false, spaceSeparated: false, negative: "sign", forceSign: false };
      function i(e3) {
        var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r3 = 2 < arguments.length ? arguments[2] : void 0;
        if ("string" == typeof t3 && (t3 = u.parseFormat(t3)), !o.validateFormat(t3))
          return "ERROR: invalid format";
        var n3 = t3.prefix || "", i2 = t3.postfix || "", a = function(e4, t4, r4) {
          switch (t4.output) {
            case "currency":
              return t4 = A2(t4, R.currentCurrencyDefaultFormat()), function(e5, t5, r5) {
                var n5 = r5.currentCurrency(), i4 = Object.assign({}, I, t5), a3 = void 0, o3 = "", u3 = !!i4.totalLength || !!i4.forceAverage || i4.average, c3 = t5.currencyPosition || n5.position, s2 = t5.currencySymbol || n5.symbol;
                i4.spaceSeparated && (o3 = " ");
                "infix" === c3 && (a3 = o3 + s2 + o3);
                var l3 = D({ instance: e5, providedFormat: t5, state: r5, decimalSeparator: a3 });
                "prefix" === c3 && (l3 = e5._value < 0 && "sign" === i4.negative ? "-".concat(o3).concat(s2).concat(l3.slice(1)) : s2 + o3 + l3);
                c3 && "postfix" !== c3 || (l3 = l3 + (o3 = u3 ? "" : o3) + s2);
                return l3;
              }(e4, t4, R);
            case "percent":
              return t4 = A2(t4, R.currentPercentageDefaultFormat()), function(e5, t5, r5, n5) {
                var i4 = t5.prefixSymbol, a3 = D({ instance: n5(100 * e5._value), providedFormat: t5, state: r5 }), o3 = Object.assign({}, I, t5);
                if (i4)
                  return "%".concat(o3.spaceSeparated ? " " : "").concat(a3);
                return "".concat(a3).concat(o3.spaceSeparated ? " " : "", "%");
              }(e4, t4, R, r4);
            case "byte":
              return t4 = A2(t4, R.currentByteDefaultFormat()), h2 = e4, v2 = R, m2 = r4, y2 = (d2 = t4).base || "binary", b2 = M[y2], w2 = B(h2._value, b2.suffixes, b2.scale), O = w2.value, x2 = w2.suffix, S = D({ instance: m2(O), providedFormat: d2, state: v2, defaults: v2.currentByteDefaultFormat() }), N = v2.currentAbbreviations(), "".concat(S).concat(N.spaced ? " " : "").concat(x2);
            case "time":
              return t4 = A2(t4, R.currentTimeDefaultFormat()), l2 = e4, f2 = Math.floor(l2._value / 60 / 60), p3 = Math.floor((l2._value - 60 * f2 * 60) / 60), g2 = Math.round(l2._value - 60 * f2 * 60 - 60 * p3), "".concat(f2, ":").concat(p3 < 10 ? "0" : "").concat(p3, ":").concat(g2 < 10 ? "0" : "").concat(g2);
            case "ordinal":
              return t4 = A2(t4, R.currentOrdinalDefaultFormat()), n4 = e4, i3 = t4, o2 = (a2 = R).currentOrdinal(), u2 = Object.assign({}, I, i3), c2 = D({ instance: n4, providedFormat: i3, state: a2 }), s = o2(n4._value), "".concat(c2).concat(u2.spaceSeparated ? " " : "").concat(s);
            case "number":
            default:
              return D({ instance: e4, providedFormat: t4, numbro: r4 });
          }
          var n4, i3, a2, o2, u2, c2, s;
          var l2, f2, p3, g2;
          var h2, d2, v2, m2, y2, b2, w2, O, x2, S, N;
        }(e3, t3, r3);
        return a = (a = n3 + a) + i2;
      }
      function B(e3, t3, r3) {
        var n3 = t3[0], i2 = Math.abs(e3);
        if (r3 <= i2) {
          for (var a = 1; a < t3.length; ++a) {
            var o2 = Math.pow(r3, a), u2 = Math.pow(r3, a + 1);
            if (o2 <= i2 && i2 < u2) {
              n3 = t3[a], e3 /= o2;
              break;
            }
          }
          n3 === t3[0] && (e3 /= Math.pow(r3, t3.length - 1), n3 = t3[t3.length - 1]);
        }
        return { value: e3, suffix: n3 };
      }
      function p2(e3) {
        for (var t3 = "", r3 = 0; r3 < e3; r3++)
          t3 += "0";
        return t3;
      }
      function $2(e3, t3) {
        return -1 !== e3.toString().indexOf("e") ? function(e4, t4) {
          var r3 = e4.toString(), n3 = C(r3.split("e"), 2), i2 = n3[0], a = n3[1], o2 = C(i2.split("."), 2), u2 = o2[0], c2 = o2[1], s = void 0 === c2 ? "" : c2;
          if (0 < +a)
            r3 = u2 + s + p2(a - s.length);
          else {
            var l2 = ".";
            l2 = +u2 < 0 ? "-0".concat(l2) : "0".concat(l2);
            var f2 = (p2(-a - 1) + Math.abs(u2) + s).substr(0, t4);
            f2.length < t4 && (f2 += p2(t4 - f2.length)), r3 = l2 + f2;
          }
          return 0 < +a && 0 < t4 && (r3 += ".".concat(p2(t4))), r3;
        }(e3, t3) : (Math.round(+"".concat(e3, "e+").concat(t3)) / Math.pow(10, t3)).toFixed(t3);
      }
      function D(e3) {
        var t3 = e3.instance, r3 = e3.providedFormat, n3 = e3.state, i2 = void 0 === n3 ? R : n3, a = e3.decimalSeparator, o2 = e3.defaults, u2 = void 0 === o2 ? i2.currentDefaults() : o2, c2 = t3._value;
        if (0 === c2 && i2.hasZeroFormat())
          return i2.getZeroFormat();
        if (!isFinite(c2))
          return c2.toString();
        var s, l2, f2, p3, g2, h2, d2, v2, m2 = Object.assign({}, I, u2, r3), y2 = m2.totalLength, b2 = y2 ? 0 : m2.characteristic, w2 = m2.optionalCharacteristic, O = m2.forceAverage, x2 = !!y2 || !!O || m2.average, S = y2 ? -1 : x2 && void 0 === r3.mantissa ? 0 : m2.mantissa, N = !y2 && (void 0 === r3.optionalMantissa ? -1 === S : m2.optionalMantissa), M2 = m2.trimMantissa, B2 = m2.thousandSeparated, D2 = m2.spaceSeparated, A3 = m2.negative, E = m2.forceSign, F = m2.exponential, k2 = "";
        if (x2) {
          var _ = function(e4) {
            var t4 = e4.value, r4 = e4.forceAverage, n4 = e4.abbreviations, i3 = e4.spaceSeparated, a2 = void 0 !== i3 && i3, o3 = e4.totalLength, u3 = void 0 === o3 ? 0 : o3, c3 = "", s2 = Math.abs(t4), l3 = -1;
            if (s2 >= Math.pow(10, 12) && !r4 || "trillion" === r4 ? (c3 = n4.trillion, t4 /= Math.pow(10, 12)) : s2 < Math.pow(10, 12) && s2 >= Math.pow(10, 9) && !r4 || "billion" === r4 ? (c3 = n4.billion, t4 /= Math.pow(10, 9)) : s2 < Math.pow(10, 9) && s2 >= Math.pow(10, 6) && !r4 || "million" === r4 ? (c3 = n4.million, t4 /= Math.pow(10, 6)) : (s2 < Math.pow(10, 6) && s2 >= Math.pow(10, 3) && !r4 || "thousand" === r4) && (c3 = n4.thousand, t4 /= Math.pow(10, 3)), c3 && (c3 = (a2 ? " " : "") + c3), u3) {
              var f3 = t4.toString().split(".")[0];
              l3 = Math.max(u3 - f3.length, 0);
            }
            return { value: t4, abbreviation: c3, mantissaPrecision: l3 };
          }({ value: c2, forceAverage: O, abbreviations: i2.currentAbbreviations(), spaceSeparated: D2, totalLength: y2 });
          c2 = _.value, k2 += _.abbreviation, y2 && (S = _.mantissaPrecision);
        }
        if (F) {
          var L = (l2 = (s = { value: c2, characteristicPrecision: b2 }).value, f2 = s.characteristicPrecision, p3 = void 0 === f2 ? 0 : f2, g2 = C(l2.toExponential().split("e"), 2), h2 = g2[0], d2 = g2[1], v2 = +h2, p3 && 1 < p3 && (v2 *= Math.pow(10, p3 - 1), d2 = 0 <= (d2 = +d2 - (p3 - 1)) ? "+".concat(d2) : d2), { value: v2, abbreviation: "e".concat(d2) });
          c2 = L.value, k2 = L.abbreviation + k2;
        }
        var T, P, U, j = function(e4, t4, r4, n4, i3) {
          if (-1 === n4)
            return e4;
          var a2 = $2(t4, n4), o3 = C(a2.toString().split("."), 2), u3 = o3[0], c3 = o3[1], s2 = void 0 === c3 ? "" : c3;
          if (s2.match(/^0+$/) && (r4 || i3))
            return u3;
          var l3 = s2.match(/0+$/);
          return i3 && l3 ? "".concat(u3, ".").concat(s2.toString().slice(0, l3.index)) : a2.toString();
        }(c2.toString(), c2, N, S, M2);
        return j = function(e4, t4, r4, n4, i3) {
          var a2 = n4.currentDelimiters(), o3 = a2.thousands;
          i3 = i3 || a2.decimal;
          var u3 = a2.thousandsSize || 3, c3 = e4.toString(), s2 = c3.split(".")[0], l3 = c3.split(".")[1];
          return r4 && (t4 < 0 && (s2 = s2.slice(1)), function(e5, t5) {
            for (var r5 = [], n5 = 0, i4 = e5; 0 < i4; i4--)
              n5 === t5 && (r5.unshift(i4), n5 = 0), n5++;
            return r5;
          }(s2.length, u3).forEach(function(e5, t5) {
            s2 = s2.slice(0, e5 + t5) + o3 + s2.slice(e5 + t5);
          }), t4 < 0 && (s2 = "-".concat(s2))), c3 = l3 ? s2 + i3 + l3 : s2;
        }(j = function(e4, t4, r4, n4) {
          var i3 = e4, a2 = C(i3.toString().split("."), 2), o3 = a2[0], u3 = a2[1];
          if (o3.match(/^-?0$/) && r4)
            return u3 ? "".concat(o3.replace("0", ""), ".").concat(u3) : o3.replace("0", "");
          if (o3.length < n4)
            for (var c3 = n4 - o3.length, s2 = 0; s2 < c3; s2++)
              i3 = "0".concat(i3);
          return i3.toString();
        }(j, 0, w2, b2), c2, B2, i2, a), (x2 || F) && (j = j + k2), (E || c2 < 0) && (T = j, U = A3, j = 0 === (P = c2) ? T : 0 == +T ? T.replace("-", "") : 0 < P ? "+".concat(T) : "sign" === U ? T : "(".concat(T.replace("-", ""), ")")), j;
      }
      function A2(e3, t3) {
        if (!e3)
          return t3;
        var r3 = Object.keys(e3);
        return 1 === r3.length && "output" === r3[0] ? t3 : e3;
      }
      t2.exports = function(n3) {
        return { format: function() {
          for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
            t3[r3] = arguments[r3];
          return i.apply(void 0, t3.concat([n3]));
        }, getByteUnit: function() {
          for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
            t3[r3] = arguments[r3];
          return function(e4) {
            var t4 = M.general;
            return B(e4._value, t4.suffixes, t4.scale).suffix;
          }.apply(void 0, t3.concat([n3]));
        }, getBinaryByteUnit: function() {
          for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
            t3[r3] = arguments[r3];
          return function(e4) {
            var t4 = M.binary;
            return B(e4._value, t4.suffixes, t4.scale).suffix;
          }.apply(void 0, t3.concat([n3]));
        }, getDecimalByteUnit: function() {
          for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
            t3[r3] = arguments[r3];
          return function(e4) {
            var t4 = M.decimal;
            return B(e4._value, t4.suffixes, t4.scale).suffix;
          }.apply(void 0, t3.concat([n3]));
        }, formatOrDefault: A2 };
      };
    }, { "./globalState": 4, "./parsing": 8, "./validating": 10 }], 4: [function(e2, t2, r2) {
      var i = e2("./en-US"), n2 = e2("./validating"), a = e2("./parsing"), o = {}, u = void 0, c2 = {}, s = null, l2 = {};
      function f2(e3) {
        u = e3;
      }
      function p2() {
        return c2[u];
      }
      o.languages = function() {
        return Object.assign({}, c2);
      }, o.currentLanguage = function() {
        return u;
      }, o.currentCurrency = function() {
        return p2().currency;
      }, o.currentAbbreviations = function() {
        return p2().abbreviations;
      }, o.currentDelimiters = function() {
        return p2().delimiters;
      }, o.currentOrdinal = function() {
        return p2().ordinal;
      }, o.currentDefaults = function() {
        return Object.assign({}, p2().defaults, l2);
      }, o.currentOrdinalDefaultFormat = function() {
        return Object.assign({}, o.currentDefaults(), p2().ordinalFormat);
      }, o.currentByteDefaultFormat = function() {
        return Object.assign({}, o.currentDefaults(), p2().byteFormat);
      }, o.currentPercentageDefaultFormat = function() {
        return Object.assign({}, o.currentDefaults(), p2().percentageFormat);
      }, o.currentCurrencyDefaultFormat = function() {
        return Object.assign({}, o.currentDefaults(), p2().currencyFormat);
      }, o.currentTimeDefaultFormat = function() {
        return Object.assign({}, o.currentDefaults(), p2().timeFormat);
      }, o.setDefaults = function(e3) {
        e3 = a.parseFormat(e3), n2.validateFormat(e3) && (l2 = e3);
      }, o.getZeroFormat = function() {
        return s;
      }, o.setZeroFormat = function(e3) {
        return s = "string" == typeof e3 ? e3 : null;
      }, o.hasZeroFormat = function() {
        return null !== s;
      }, o.languageData = function(e3) {
        if (e3) {
          if (c2[e3])
            return c2[e3];
          throw new Error('Unknown tag "'.concat(e3, '"'));
        }
        return p2();
      }, o.registerLanguage = function(e3) {
        var t3 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
        if (!n2.validateLanguage(e3))
          throw new Error("Invalid language data");
        c2[e3.languageTag] = e3, t3 && f2(e3.languageTag);
      }, o.setLanguage = function(e3) {
        var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : i.languageTag;
        if (!c2[e3]) {
          var r3 = e3.split("-")[0], n3 = Object.keys(c2).find(function(e4) {
            return e4.split("-")[0] === r3;
          });
          return c2[n3] ? void f2(n3) : void f2(t3);
        }
        f2(e3);
      }, o.registerLanguage(i), u = i.languageTag, t2.exports = o;
    }, { "./en-US": 2, "./parsing": 8, "./validating": 10 }], 5: [function(n2, e2, t2) {
      e2.exports = function(t3) {
        return { loadLanguagesInNode: function(e3) {
          return r2 = t3, void e3.forEach(function(t4) {
            var e4 = void 0;
            try {
              e4 = n2("../languages/".concat(t4));
            } catch (e5) {
              console.error('Unable to load "'.concat(t4, '". No matching language file found.'));
            }
            e4 && r2.registerLanguage(e4);
          });
          var r2;
        } };
      };
    }, {}], 6: [function(e2, t2, r2) {
      var c2 = e2("bignumber.js");
      function a(e3, t3, r3) {
        var n2 = new c2(e3._value), i = t3;
        return r3.isNumbro(t3) && (i = t3._value), i = new c2(i), e3._value = n2.minus(i).toNumber(), e3;
      }
      t2.exports = function(u) {
        return { add: function(e3, t3) {
          return n2 = t3, i = u, a2 = new c2((r3 = e3)._value), o = n2, i.isNumbro(n2) && (o = n2._value), o = new c2(o), r3._value = a2.plus(o).toNumber(), r3;
          var r3, n2, i, a2, o;
        }, subtract: function(e3, t3) {
          return a(e3, t3, u);
        }, multiply: function(e3, t3) {
          return n2 = t3, i = u, a2 = new c2((r3 = e3)._value), o = n2, i.isNumbro(n2) && (o = n2._value), o = new c2(o), r3._value = a2.times(o).toNumber(), r3;
          var r3, n2, i, a2, o;
        }, divide: function(e3, t3) {
          return n2 = t3, i = u, a2 = new c2((r3 = e3)._value), o = n2, i.isNumbro(n2) && (o = n2._value), o = new c2(o), r3._value = a2.dividedBy(o).toNumber(), r3;
          var r3, n2, i, a2, o;
        }, set: function(e3, t3) {
          return r3 = e3, i = n2 = t3, u.isNumbro(n2) && (i = n2._value), r3._value = i, r3;
          var r3, n2, i;
        }, difference: function(e3, t3) {
          return r3 = t3, a(i = (n2 = u)(e3._value), r3, n2), Math.abs(i._value);
          var r3, n2, i;
        } };
      };
    }, { "bignumber.js": 1 }], 7: [function(e2, t2, r2) {
      function i(e3, t3) {
        for (var r3 = 0; r3 < t3.length; r3++) {
          var n3 = t3[r3];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
        }
      }
      var a = e2("./globalState"), n2 = e2("./validating"), o = e2("./loading")(g2), u = e2("./unformatting"), c2 = e2("./formatting")(g2), s = e2("./manipulating")(g2), l2 = e2("./parsing"), f2 = function() {
        function t3(e4) {
          !function(e5, t4) {
            if (!(e5 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), this._value = e4;
        }
        var e3, r3;
        return e3 = t3, (r3 = [{ key: "clone", value: function() {
          return g2(this._value);
        } }, { key: "format", value: function() {
          var e4 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
          return c2.format(this, e4);
        } }, { key: "formatCurrency", value: function(e4) {
          return "string" == typeof e4 && (e4 = l2.parseFormat(e4)), (e4 = c2.formatOrDefault(e4, a.currentCurrencyDefaultFormat())).output = "currency", c2.format(this, e4);
        } }, { key: "formatTime", value: function() {
          var e4 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
          return e4.output = "time", c2.format(this, e4);
        } }, { key: "binaryByteUnits", value: function() {
          return c2.getBinaryByteUnit(this);
        } }, { key: "decimalByteUnits", value: function() {
          return c2.getDecimalByteUnit(this);
        } }, { key: "byteUnits", value: function() {
          return c2.getByteUnit(this);
        } }, { key: "difference", value: function(e4) {
          return s.difference(this, e4);
        } }, { key: "add", value: function(e4) {
          return s.add(this, e4);
        } }, { key: "subtract", value: function(e4) {
          return s.subtract(this, e4);
        } }, { key: "multiply", value: function(e4) {
          return s.multiply(this, e4);
        } }, { key: "divide", value: function(e4) {
          return s.divide(this, e4);
        } }, { key: "set", value: function(e4) {
          return s.set(this, p2(e4));
        } }, { key: "value", value: function() {
          return this._value;
        } }, { key: "valueOf", value: function() {
          return this._value;
        } }]) && i(e3.prototype, r3), t3;
      }();
      function p2(e3) {
        var t3 = e3;
        return g2.isNumbro(e3) ? t3 = e3._value : "string" == typeof e3 ? t3 = g2.unformat(e3) : isNaN(e3) && (t3 = NaN), t3;
      }
      function g2(e3) {
        return new f2(p2(e3));
      }
      g2.version = "2.1.2", g2.isNumbro = function(e3) {
        return e3 instanceof f2;
      }, g2.language = a.currentLanguage, g2.registerLanguage = a.registerLanguage, g2.setLanguage = a.setLanguage, g2.languages = a.languages, g2.languageData = a.languageData, g2.zeroFormat = a.setZeroFormat, g2.defaultFormat = a.currentDefaults, g2.setDefaults = a.setDefaults, g2.defaultCurrencyFormat = a.currentCurrencyDefaultFormat, g2.validate = n2.validate, g2.loadLanguagesInNode = o.loadLanguagesInNode, g2.unformat = u.unformat, t2.exports = g2;
    }, { "./formatting": 3, "./globalState": 4, "./loading": 5, "./manipulating": 6, "./parsing": 8, "./unformatting": 9, "./validating": 10 }], 8: [function(e2, t2, r2) {
      t2.exports = { parseFormat: function(e3) {
        var t3, r3, n2, i, a, o, u, c2, s, l2, f2, p2, g2, h2, d2, v2, m2, y2, b2, w2, O = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
        return "string" != typeof e3 ? e3 : (r3 = O, e3 = (n2 = (t3 = e3).match(/^{([^}]*)}/)) ? (r3.prefix = n2[1], t3.slice(n2[0].length)) : t3, a = O, function(e4, t4) {
          if (-1 === e4.indexOf("$")) {
            if (-1 === e4.indexOf("%"))
              return -1 !== e4.indexOf("bd") ? (t4.output = "byte", t4.base = "general") : -1 !== e4.indexOf("b") ? (t4.output = "byte", t4.base = "binary") : -1 !== e4.indexOf("d") ? (t4.output = "byte", t4.base = "decimal") : -1 === e4.indexOf(":") ? -1 !== e4.indexOf("o") && (t4.output = "ordinal") : t4.output = "time";
            t4.output = "percent";
          } else
            t4.output = "currency";
        }(e3 = (o = (i = e3).match(/{([^}]*)}$/)) ? (a.postfix = o[1], i.slice(0, -o[0].length)) : i, O), u = O, (c2 = e3.match(/[1-9]+[0-9]*/)) && (u.totalLength = +c2[0]), s = O, (l2 = e3.split(".")[0].match(/0+/)) && (s.characteristic = l2[0].length), function(e4, t4) {
          if (-1 !== e4.indexOf(".")) {
            var r4 = e4.split(".")[0];
            t4.optionalCharacteristic = -1 === r4.indexOf("0");
          }
        }(e3, O), f2 = O, -1 !== e3.indexOf("a") && (f2.average = true), g2 = O, -1 !== (p2 = e3).indexOf("K") ? g2.forceAverage = "thousand" : -1 !== p2.indexOf("M") ? g2.forceAverage = "million" : -1 !== p2.indexOf("B") ? g2.forceAverage = "billion" : -1 !== p2.indexOf("T") && (g2.forceAverage = "trillion"), function(e4, t4) {
          var r4 = e4.split(".")[1];
          if (r4) {
            var n3 = r4.match(/0+/);
            n3 && (t4.mantissa = n3[0].length);
          }
        }(e3, O), d2 = O, (h2 = e3).match(/\[\.]/) ? d2.optionalMantissa = true : h2.match(/\./) && (d2.optionalMantissa = false), v2 = O, -1 !== e3.indexOf(",") && (v2.thousandSeparated = true), m2 = O, -1 !== e3.indexOf(" ") && (m2.spaceSeparated = true), b2 = O, (y2 = e3).match(/^\+?\([^)]*\)$/) && (b2.negative = "parenthesis"), y2.match(/^\+?-/) && (b2.negative = "sign"), w2 = O, e3.match(/^\+/) && (w2.forceSign = true), O);
      } };
    }, {}], 9: [function(p2, e2, t2) {
      var O = [{ key: "ZiB", factor: Math.pow(1024, 7) }, { key: "ZB", factor: Math.pow(1e3, 7) }, { key: "YiB", factor: Math.pow(1024, 8) }, { key: "YB", factor: Math.pow(1e3, 8) }, { key: "TiB", factor: Math.pow(1024, 4) }, { key: "TB", factor: Math.pow(1e3, 4) }, { key: "PiB", factor: Math.pow(1024, 5) }, { key: "PB", factor: Math.pow(1e3, 5) }, { key: "MiB", factor: Math.pow(1024, 2) }, { key: "MB", factor: Math.pow(1e3, 2) }, { key: "KiB", factor: Math.pow(1024, 1) }, { key: "KB", factor: Math.pow(1e3, 1) }, { key: "GiB", factor: Math.pow(1024, 3) }, { key: "GB", factor: Math.pow(1e3, 3) }, { key: "EiB", factor: Math.pow(1024, 6) }, { key: "EB", factor: Math.pow(1e3, 6) }, { key: "B", factor: 1 }];
      function x2(e3) {
        return e3.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function g2(e3, t3) {
        var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", n2 = 3 < arguments.length ? arguments[3] : void 0, i = 4 < arguments.length ? arguments[4] : void 0, a = 5 < arguments.length ? arguments[5] : void 0, o = 6 < arguments.length ? arguments[6] : void 0;
        if ("" !== e3)
          return e3 === i ? 0 : function e4(t4, r3) {
            var n3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", i2 = 3 < arguments.length ? arguments[3] : void 0, a2 = 4 < arguments.length ? arguments[4] : void 0, o2 = 5 < arguments.length ? arguments[5] : void 0, u = 6 < arguments.length ? arguments[6] : void 0;
            if (!isNaN(+t4))
              return +t4;
            var c2 = "", s = t4.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
            if (s !== t4)
              return -1 * e4(s, r3, n3, i2, a2, o2, u);
            for (var l2 = 0; l2 < O.length; l2++) {
              var f2 = O[l2];
              if ((c2 = t4.replace(f2.key, "")) !== t4)
                return e4(c2, r3, n3, i2, a2, o2, u) * f2.factor;
            }
            if ((c2 = t4.replace("%", "")) !== t4)
              return e4(c2, r3, n3, i2, a2, o2, u) / 100;
            var p3 = parseFloat(t4);
            if (!isNaN(p3)) {
              var g3 = i2(p3);
              if (g3 && "." !== g3 && (c2 = t4.replace(new RegExp("".concat(x2(g3), "$")), "")) !== t4)
                return e4(c2, r3, n3, i2, a2, o2, u);
              var h2 = {};
              Object.keys(o2).forEach(function(e5) {
                h2[o2[e5]] = e5;
              });
              for (var d2 = Object.keys(h2).sort().reverse(), v2 = d2.length, m2 = 0; m2 < v2; m2++) {
                var y2 = d2[m2], b2 = h2[y2];
                if ((c2 = t4.replace(y2, "")) !== t4) {
                  var w2 = void 0;
                  switch (b2) {
                    case "thousand":
                      w2 = Math.pow(10, 3);
                      break;
                    case "million":
                      w2 = Math.pow(10, 6);
                      break;
                    case "billion":
                      w2 = Math.pow(10, 9);
                      break;
                    case "trillion":
                      w2 = Math.pow(10, 12);
                  }
                  return e4(c2, r3, n3, i2, a2, o2, u) * w2;
                }
              }
            }
          }(function(e4, t4) {
            var r3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", n3 = e4.replace(r3, "");
            return n3 = (n3 = n3.replace(new RegExp("([0-9])".concat(x2(t4.thousands), "([0-9])"), "g"), "$1$2")).replace(t4.decimal, ".");
          }(e3, t3, r2), t3, r2, n2, i, a, o);
      }
      e2.exports = { unformat: function(e3, t3) {
        var r2, n2, i, a = p2("./globalState"), o = a.currentDelimiters(), u = a.currentCurrency().symbol, c2 = a.currentOrdinal(), s = a.getZeroFormat(), l2 = a.currentAbbreviations(), f2 = void 0;
        if ("string" == typeof e3)
          f2 = function(e4, t4) {
            if (!e4.indexOf(":") || ":" === t4.thousands)
              return false;
            var r3 = e4.split(":");
            if (3 !== r3.length)
              return false;
            var n3 = +r3[0], i2 = +r3[1], a2 = +r3[2];
            return !isNaN(n3) && !isNaN(i2) && !isNaN(a2);
          }(e3, o) ? (r2 = e3.split(":"), n2 = +r2[0], i = +r2[1], +r2[2] + 60 * i + 3600 * n2) : g2(e3, o, u, c2, s, l2, t3);
        else {
          if ("number" != typeof e3)
            return;
          f2 = e3;
        }
        if (void 0 !== f2)
          return f2;
      } };
    }, { "./globalState": 4 }], 10: [function(e2, t2, r2) {
      function n2(e3) {
        return function(e4) {
          if (Array.isArray(e4)) {
            for (var t3 = 0, r3 = new Array(e4.length); t3 < e4.length; t3++)
              r3[t3] = e4[t3];
            return r3;
          }
        }(e3) || function(e4) {
          if (Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))
            return Array.from(e4);
        }(e3) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
      }
      function f2(e3) {
        return (f2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        })(e3);
      }
      var i = e2("./unformatting"), a = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/, p2 = { output: { type: "string", validValues: ["currency", "percent", "byte", "time", "ordinal", "number"] }, base: { type: "string", validValues: ["decimal", "binary", "general"], restriction: function(e3, t3) {
        return "byte" === t3.output;
      }, message: "`base` must be provided only when the output is `byte`", mandatory: function(e3) {
        return "byte" === e3.output;
      } }, characteristic: { type: "number", restriction: function(e3) {
        return 0 <= e3;
      }, message: "value must be positive" }, prefix: "string", postfix: "string", forceAverage: { type: "string", validValues: ["trillion", "billion", "million", "thousand"] }, average: "boolean", currencyPosition: { type: "string", validValues: ["prefix", "infix", "postfix"] }, currencySymbol: "string", totalLength: { type: "number", restrictions: [{ restriction: function(e3) {
        return 0 <= e3;
      }, message: "value must be positive" }, { restriction: function(e3, t3) {
        return !t3.exponential;
      }, message: "`totalLength` is incompatible with `exponential`" }] }, mantissa: { type: "number", restriction: function(e3) {
        return 0 <= e3;
      }, message: "value must be positive" }, optionalMantissa: "boolean", trimMantissa: "boolean", optionalCharacteristic: "boolean", thousandSeparated: "boolean", spaceSeparated: "boolean", abbreviations: { type: "object", children: { thousand: "string", million: "string", billion: "string", trillion: "string" } }, negative: { type: "string", validValues: ["sign", "parenthesis"] }, forceSign: "boolean", exponential: { type: "boolean" }, prefixSymbol: { type: "boolean", restriction: function(e3, t3) {
        return "percent" === t3.output;
      }, message: "`prefixSymbol` can be provided only when the output is `percent`" } }, o = { languageTag: { type: "string", mandatory: true, restriction: function(e3) {
        return e3.match(a);
      }, message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)" }, delimiters: { type: "object", children: { thousands: "string", decimal: "string", thousandsSize: "number" }, mandatory: true }, abbreviations: { type: "object", children: { thousand: { type: "string", mandatory: true }, million: { type: "string", mandatory: true }, billion: { type: "string", mandatory: true }, trillion: { type: "string", mandatory: true } }, mandatory: true }, spaceSeparated: "boolean", ordinal: { type: "function", mandatory: true }, currency: { type: "object", children: { symbol: "string", position: "string", code: "string" }, mandatory: true }, defaults: "format", ordinalFormat: "format", byteFormat: "format", percentageFormat: "format", currencyFormat: "format", timeDefaults: "format", formats: { type: "object", children: { fourDigits: { type: "format", mandatory: true }, fullWithTwoDecimals: { type: "format", mandatory: true }, fullWithTwoDecimalsNoCurrency: { type: "format", mandatory: true }, fullWithNoDecimals: { type: "format", mandatory: true } } } };
      function u(e3) {
        return !!i.unformat(e3);
      }
      function g2(c3, s, l2) {
        var e3 = 3 < arguments.length && void 0 !== arguments[3] && arguments[3], t3 = Object.keys(c3).map(function(e4) {
          if (!s[e4])
            return console.error("".concat(l2, " Invalid key: ").concat(e4)), false;
          var t4 = c3[e4], r3 = s[e4];
          if ("string" == typeof r3 && (r3 = { type: r3 }), "format" === r3.type) {
            if (!g2(t4, p2, "[Validate ".concat(e4, "]"), true))
              return false;
          } else if (f2(t4) !== r3.type)
            return console.error("".concat(l2, " ").concat(e4, ' type mismatched: "').concat(r3.type, '" expected, "').concat(f2(t4), '" provided')), false;
          if (r3.restrictions && r3.restrictions.length)
            for (var n3 = r3.restrictions.length, i2 = 0; i2 < n3; i2++) {
              var a2 = r3.restrictions[i2], o2 = a2.restriction, u2 = a2.message;
              if (!o2(t4, c3))
                return console.error("".concat(l2, " ").concat(e4, " invalid value: ").concat(u2)), false;
            }
          if (r3.restriction && !r3.restriction(t4, c3))
            return console.error("".concat(l2, " ").concat(e4, " invalid value: ").concat(r3.message)), false;
          if (r3.validValues && -1 === r3.validValues.indexOf(t4))
            return console.error("".concat(l2, " ").concat(e4, " invalid value: must be among ").concat(JSON.stringify(r3.validValues), ', "').concat(t4, '" provided')), false;
          if (r3.children && !g2(t4, r3.children, "[Validate ".concat(e4, "]")))
            return false;
          return true;
        });
        return e3 || t3.push.apply(t3, n2(Object.keys(s).map(function(e4) {
          var t4 = s[e4];
          if ("string" == typeof t4 && (t4 = { type: t4 }), t4.mandatory) {
            var r3 = t4.mandatory;
            if ("function" == typeof r3 && (r3 = r3(c3)), r3 && void 0 === c3[e4])
              return console.error("".concat(l2, ' Missing mandatory key "').concat(e4, '"')), false;
          }
          return true;
        }))), t3.reduce(function(e4, t4) {
          return e4 && t4;
        }, true);
      }
      function c2(e3) {
        return g2(e3, p2, "[Validate format]");
      }
      t2.exports = { validate: function(e3, t3) {
        var r3 = u(e3), n3 = c2(t3);
        return r3 && n3;
      }, validateFormat: c2, validateInput: u, validateLanguage: function(e3) {
        return g2(e3, o, "[Validate language]");
      } };
    }, { "./unformatting": 9 }] }, {}, [7])(7);
  });
})(numbro_min);
const numbro = numbro_minExports;
var $$l = _export;
var $map = arrayIteration.map;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
$$l({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
function _toConsumableArray$z(arr) {
  return _arrayWithoutHoles$z(arr) || _iterableToArray$B(arr) || _unsupportedIterableToArray$1a(arr) || _nonIterableSpread$z();
}
function _nonIterableSpread$z() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1a(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1a(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1a(o, minLen);
}
function _iterableToArray$B(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$z(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1a(arr);
}
function _arrayLikeToArray$1a(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _typeof$1z(obj) {
  "@babel/helpers - typeof";
  return _typeof$1z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1z(obj);
}
function isNumeric(value) {
  var additionalDelimiters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var type = _typeof$1z(value);
  if (type === "number") {
    return !isNaN(value) && isFinite(value);
  } else if (type === "string") {
    if (value.length === 0) {
      return false;
    } else if (value.length === 1) {
      return /\d/.test(value);
    }
    var delimiter = Array.from(new Set(["."].concat(_toConsumableArray$z(additionalDelimiters)))).map(function(d2) {
      return "\\".concat(d2);
    }).join("|");
    return new RegExp("^[+-]?\\s*(((".concat(delimiter, ")?\\d+((").concat(delimiter, ")\\d+)?(e[+-]?\\d+)?)|(0x[a-f\\d]+))$"), "i").test(value.trim());
  } else if (type === "object") {
    return !!value && typeof value.valueOf() === "number" && !(value instanceof Date);
  }
  return false;
}
function isNumericLike(value) {
  return isNumeric(value, [","]);
}
function rangeEach(rangeFrom, rangeTo, iteratee) {
  var index2 = -1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = rangeFrom;
  } else {
    index2 = rangeFrom - 1;
  }
  while (++index2 <= rangeTo) {
    if (iteratee(index2) === false) {
      break;
    }
  }
}
function rangeEachReverse(rangeFrom, rangeTo, iteratee) {
  var index2 = rangeFrom + 1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = 0;
  }
  while (--index2 >= rangeTo) {
    if (iteratee(index2) === false) {
      break;
    }
  }
}
function valueAccordingPercent(value, percent) {
  percent = parseInt(percent.toString().replace("%", ""), 10);
  percent = isNaN(percent) ? 0 : percent;
  return parseInt(value * percent / 100, 10);
}
var RENDERER_TYPE$2 = "numeric";
function numericRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var newValue = value;
  if (isNumeric(newValue)) {
    var numericFormat = cellProperties.numericFormat;
    var cellCulture = numericFormat && numericFormat.culture || "-";
    var cellFormatPattern = numericFormat && numericFormat.pattern;
    var className = cellProperties.className || "";
    var classArr = className.length ? className.split(" ") : [];
    if (typeof cellCulture !== "undefined" && !numbro.languages()[cellCulture]) {
      var shortTag = cellCulture.replace("-", "");
      var langData = numbro.allLanguages ? numbro.allLanguages[cellCulture] : numbro[shortTag];
      if (langData) {
        numbro.registerLanguage(langData);
      }
    }
    numbro.setLanguage(cellCulture);
    newValue = numbro(newValue).format(cellFormatPattern || "0");
    if (classArr.indexOf("htLeft") < 0 && classArr.indexOf("htCenter") < 0 && classArr.indexOf("htRight") < 0 && classArr.indexOf("htJustify") < 0) {
      classArr.push("htRight");
    }
    if (classArr.indexOf("htNumeric") < 0) {
      classArr.push("htNumeric");
    }
    cellProperties.className = classArr.join(" ");
    TD.dir = "ltr";
  }
  textRenderer(instance, TD, row, col, prop, newValue, cellProperties);
}
numericRenderer.RENDERER_TYPE = RENDERER_TYPE$2;
var RENDERER_TYPE$1 = "password";
function passwordRenderer(instance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  var hashLength = cellProperties.hashLength || TD.innerHTML.length;
  var hashSymbol = cellProperties.hashSymbol || "*";
  var hash = "";
  rangeEach(hashLength - 1, function() {
    hash += hashSymbol;
  });
  fastInnerHTML(TD, hash);
}
passwordRenderer.RENDERER_TYPE = RENDERER_TYPE$1;
var RENDERER_TYPE = "time";
function timeRenderer(instance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  TD.dir = "ltr";
}
timeRenderer.RENDERER_TYPE = RENDERER_TYPE;
var _staticRegister$6 = staticRegister("renderers"), register$4 = _staticRegister$6.register, getItem$3 = _staticRegister$6.getItem, hasItem$2 = _staticRegister$6.hasItem;
_staticRegister$6.getNames;
_staticRegister$6.getValues;
function _getItem$2(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem$2(name)) {
    throw Error('No registered renderer found under "'.concat(name, '" name'));
  }
  return getItem$3(name);
}
function _register$2(name, renderer) {
  if (typeof name !== "string") {
    renderer = name;
    name = renderer.RENDERER_TYPE;
  }
  register$4(name, renderer);
}
function registerAllRenderers() {
  _register$2(autocompleteRenderer);
  _register$2(baseRenderer);
  _register$2(checkboxRenderer);
  _register$2(htmlRenderer);
  _register$2(numericRenderer);
  _register$2(passwordRenderer);
  _register$2(textRenderer);
  _register$2(timeRenderer);
}
var arraySlice$3 = arraySliceSimple;
var floor$2 = Math.floor;
var mergeSort = function(array, comparefn) {
  var length = array.length;
  var middle = floor$2(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice$3(array, 0, middle), comparefn),
    mergeSort(arraySlice$3(array, middle), comparefn),
    comparefn
  );
};
var insertionSort = function(array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;
  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++)
      array[j] = element;
  }
  return array;
};
var merge = function(array, left2, right2, comparefn) {
  var llength = left2.length;
  var rlength = right2.length;
  var lindex = 0;
  var rindex = 0;
  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left2[lindex], right2[rindex]) <= 0 ? left2[lindex++] : right2[rindex++] : lindex < llength ? left2[lindex++] : right2[rindex++];
  }
  return array;
};
var arraySort = mergeSort;
var userAgent$2 = engineUserAgent;
var firefox = userAgent$2.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];
var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent$1 = engineUserAgent;
var webkit = userAgent$1.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];
var $$k = _export;
var uncurryThis$9 = functionUncurryThis;
var aCallable$2 = aCallable$6;
var toObject$5 = toObject$f;
var lengthOfArrayLike$3 = lengthOfArrayLike$c;
var deletePropertyOrThrow = deletePropertyOrThrow$2;
var toString$5 = toString$j;
var fails$8 = fails$G;
var internalSort = arraySort;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$6;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test = [];
var nativeSort = uncurryThis$9(test.sort);
var push$2 = uncurryThis$9(test.push);
var FAILS_ON_UNDEFINED = fails$8(function() {
  test.sort(void 0);
});
var FAILS_ON_NULL = fails$8(function() {
  test.sort(null);
});
var STRICT_METHOD$2 = arrayMethodIsStrict$2("sort");
var STABLE_SORT = !fails$8(function() {
  if (V8)
    return V8 < 70;
  if (FF && FF > 3)
    return;
  if (IE_OR_EDGE)
    return true;
  if (WEBKIT)
    return WEBKIT < 603;
  var result = "";
  var code, chr, value, index2;
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);
    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index2 = 0; index2 < 47; index2++) {
      test.push({ k: chr + index2, v: value });
    }
  }
  test.sort(function(a, b2) {
    return b2.v - a.v;
  });
  for (index2 = 0; index2 < test.length; index2++) {
    chr = test[index2].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr)
      result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED$4 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$2 || !STABLE_SORT;
var getSortCompare = function(comparefn) {
  return function(x2, y2) {
    if (y2 === void 0)
      return -1;
    if (x2 === void 0)
      return 1;
    if (comparefn !== void 0)
      return +comparefn(x2, y2) || 0;
    return toString$5(x2) > toString$5(y2) ? 1 : -1;
  };
};
$$k({ target: "Array", proto: true, forced: FORCED$4 }, {
  sort: function sort(comparefn) {
    if (comparefn !== void 0)
      aCallable$2(comparefn);
    var array = toObject$5(this);
    if (STABLE_SORT)
      return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike$3(array);
    var itemsLength, index2;
    for (index2 = 0; index2 < arrayLength; index2++) {
      if (index2 in array)
        push$2(items, array[index2]);
    }
    internalSort(items, getSortCompare(comparefn));
    itemsLength = lengthOfArrayLike$3(items);
    index2 = 0;
    while (index2 < itemsLength)
      array[index2] = items[index2++];
    while (index2 < arrayLength)
      deletePropertyOrThrow(array, index2++);
    return array;
  }
});
var isObject$3 = isObject$n;
var floor$1 = Math.floor;
var isIntegralNumber$1 = Number.isInteger || function isInteger(it) {
  return !isObject$3(it) && isFinite(it) && floor$1(it) === it;
};
var $$j = _export;
var isIntegralNumber = isIntegralNumber$1;
$$j({ target: "Number", stat: true }, {
  isInteger: isIntegralNumber
});
var uncurryThis$8 = functionUncurryThis;
var thisNumberValue$2 = uncurryThis$8(1 .valueOf);
var DESCRIPTORS$4 = descriptors;
var global$4 = global$s;
var uncurryThis$7 = functionUncurryThis;
var isForced = isForced_1;
var defineBuiltIn = defineBuiltIn$c;
var hasOwn$3 = hasOwnProperty_1;
var inheritIfRequired = inheritIfRequired$3;
var isPrototypeOf = objectIsPrototypeOf;
var isSymbol = isSymbol$5;
var toPrimitive = toPrimitive$2;
var fails$7 = fails$G;
var getOwnPropertyNames4 = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var defineProperty$1 = objectDefineProperty.f;
var thisNumberValue$1 = thisNumberValue$2;
var trim2 = stringTrim$1.trim;
var NUMBER = "Number";
var NativeNumber = global$4[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError$1 = global$4.TypeError;
var arraySlice$2 = uncurryThis$7("".slice);
var charCodeAt = uncurryThis$7("".charCodeAt);
var toNumeric = function(value) {
  var primValue = toPrimitive(value, "number");
  return typeof primValue == "bigint" ? primValue : toNumber(primValue);
};
var toNumber = function(argument) {
  var it = toPrimitive(argument, "number");
  var first, third, radix, maxCode, digits, length, index2, code;
  if (isSymbol(it))
    throw TypeError$1("Cannot convert a Symbol value to a number");
  if (typeof it == "string" && it.length > 2) {
    it = trim2(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120)
        return NaN;
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        default:
          return +it;
      }
      digits = arraySlice$2(it, 2);
      length = digits.length;
      for (index2 = 0; index2 < length; index2++) {
        code = charCodeAt(digits, index2);
        if (code < 48 || code > maxCode)
          return NaN;
      }
      return parseInt(digits, radix);
    }
  }
  return +it;
};
if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
  var NumberWrapper = function Number2(value) {
    var n2 = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
    var dummy = this;
    return isPrototypeOf(NumberPrototype, dummy) && fails$7(function() {
      thisNumberValue$1(dummy);
    }) ? inheritIfRequired(Object(n2), dummy, NumberWrapper) : n2;
  };
  for (var keys3 = DESCRIPTORS$4 ? getOwnPropertyNames4(NativeNumber) : (
    // ES3:
    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
  ), j = 0, key; keys3.length > j; j++) {
    if (hasOwn$3(NativeNumber, key = keys3[j]) && !hasOwn$3(NumberWrapper, key)) {
      defineProperty$1(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  defineBuiltIn(global$4, NUMBER, NumberWrapper, { constructor: true });
}
var toObject$4 = toObject$f;
var toAbsoluteIndex = toAbsoluteIndex$5;
var lengthOfArrayLike$2 = lengthOfArrayLike$c;
var arrayFill = function fill(value) {
  var O = toObject$4(this);
  var length = lengthOfArrayLike$2(O);
  var argumentsLength = arguments.length;
  var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
  var end = argumentsLength > 2 ? arguments[2] : void 0;
  var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
  while (endPos > index2)
    O[index2++] = value;
  return O;
};
var $$i = _export;
var fill2 = arrayFill;
var addToUnscopables$2 = addToUnscopables$5;
$$i({ target: "Array", proto: true }, {
  fill: fill2
});
addToUnscopables$2("fill");
var userAgent = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
var classof = classofRaw$2;
var global$3 = global$s;
var engineIsNode = classof(global$3.process) == "process";
var global$2 = global$s;
var apply$2 = functionApply;
var bind$1 = functionBindContext;
var isCallable = isCallable$o;
var hasOwn$2 = hasOwnProperty_1;
var fails$6 = fails$G;
var html = html$4;
var arraySlice$1 = arraySlice$8;
var createElement$1 = documentCreateElement$2;
var validateArgumentsLength = validateArgumentsLength$2;
var IS_IOS = engineIsIos;
var IS_NODE$1 = engineIsNode;
var set = global$2.setImmediate;
var clear = global$2.clearImmediate;
var process$1 = global$2.process;
var Dispatch = global$2.Dispatch;
var Function$1 = global$2.Function;
var MessageChannel = global$2.MessageChannel;
var String$1 = global$2.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var $location, defer, channel, port;
try {
  $location = global$2.location;
} catch (error2) {
}
var run = function(id2) {
  if (hasOwn$2(queue, id2)) {
    var fn = queue[id2];
    delete queue[id2];
    fn();
  }
};
var runner = function(id2) {
  return function() {
    run(id2);
  };
};
var listener = function(event2) {
  run(event2.data);
};
var post = function(id2) {
  global$2.postMessage(String$1(id2), $location.protocol + "//" + $location.host);
};
if (!set || !clear) {
  set = function setImmediate2(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function$1(handler);
    var args = arraySlice$1(arguments, 1);
    queue[++counter] = function() {
      apply$2(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate2(id2) {
    delete queue[id2];
  };
  if (IS_NODE$1) {
    defer = function(id2) {
      process$1.nextTick(runner(id2));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id2) {
      Dispatch.now(runner(id2));
    };
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind$1(port.postMessage, port);
  } else if (global$2.addEventListener && isCallable(global$2.postMessage) && !global$2.importScripts && $location && $location.protocol !== "file:" && !fails$6(post)) {
    defer = post;
    global$2.addEventListener("message", listener, false);
  } else if (ONREADYSTATECHANGE in createElement$1("script")) {
    defer = function(id2) {
      html.appendChild(createElement$1("script"))[ONREADYSTATECHANGE] = function() {
        html.removeChild(this);
        run(id2);
      };
    };
  } else {
    defer = function(id2) {
      setTimeout(runner(id2), 0);
    };
  }
}
var task = {
  set,
  clear
};
var $$h = _export;
var global$1 = global$s;
var clearImmediate$1 = task.clear;
$$h({ global: true, bind: true, enumerable: true, forced: global$1.clearImmediate !== clearImmediate$1 }, {
  clearImmediate: clearImmediate$1
});
var $$g = _export;
var global = global$s;
var setImmediate$1 = task.set;
$$g({ global: true, bind: true, enumerable: true, forced: global.setImmediate !== setImmediate$1 }, {
  setImmediate: setImmediate$1
});
var $$f = _export;
var toObject$3 = toObject$f;
var nativeKeys = objectKeys$4;
var fails$5 = fails$G;
var FAILS_ON_PRIMITIVES$1 = fails$5(function() {
  nativeKeys(1);
});
$$f({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$1 }, {
  keys: function keys2(it) {
    return nativeKeys(toObject$3(it));
  }
});
var call$3 = functionCall;
var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
var anObject$3 = anObject$l;
var isNullOrUndefined$1 = isNullOrUndefined$b;
var toLength$2 = toLength$7;
var toString$4 = toString$j;
var requireObjectCoercible$4 = requireObjectCoercible$e;
var getMethod$1 = getMethod$7;
var advanceStringIndex = advanceStringIndex$3;
var regExpExec$1 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$1("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match2(regexp) {
      var O = requireObjectCoercible$4(this);
      var matcher = isNullOrUndefined$1(regexp) ? void 0 : getMethod$1(regexp, MATCH2);
      return matcher ? call$3(matcher, regexp, O) : new RegExp(regexp)[MATCH2](toString$4(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function(string) {
      var rx = anObject$3(this);
      var S = toString$4(string);
      var res = maybeCallNative(nativeMatch, rx, S);
      if (res.done)
        return res.value;
      if (!rx.global)
        return regExpExec$1(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A2 = [];
      var n2 = 0;
      var result;
      while ((result = regExpExec$1(rx, S)) !== null) {
        var matchStr = toString$4(result[0]);
        A2[n2] = matchStr;
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex(S, toLength$2(rx.lastIndex), fullUnicode);
        n2++;
      }
      return n2 === 0 ? null : A2;
    }
  ];
});
var apply$1 = functionApply;
var toIndexedObject$3 = toIndexedObject$d;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$8;
var lengthOfArrayLike$1 = lengthOfArrayLike$c;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$6;
var min$2 = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD$1 = arrayMethodIsStrict$1("lastIndexOf");
var FORCED$3 = NEGATIVE_ZERO || !STRICT_METHOD$1;
var arrayLastIndexOf = FORCED$3 ? function lastIndexOf(searchElement) {
  if (NEGATIVE_ZERO)
    return apply$1($lastIndexOf, this, arguments) || 0;
  var O = toIndexedObject$3(this);
  var length = lengthOfArrayLike$1(O);
  var index2 = length - 1;
  if (arguments.length > 1)
    index2 = min$2(index2, toIntegerOrInfinity$1(arguments[1]));
  if (index2 < 0)
    index2 = length + index2;
  for (; index2 >= 0; index2--)
    if (index2 in O && O[index2] === searchElement)
      return index2 || 0;
  return -1;
} : $lastIndexOf;
var $$e = _export;
var lastIndexOf2 = arrayLastIndexOf;
$$e({ target: "Array", proto: true, forced: lastIndexOf2 !== [].lastIndexOf }, {
  lastIndexOf: lastIndexOf2
});
var aCallable$1 = aCallable$6;
var toObject$2 = toObject$f;
var IndexedObject$1 = indexedObject;
var lengthOfArrayLike = lengthOfArrayLike$c;
var $TypeError = TypeError;
var createMethod$1 = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable$1(callbackfn);
    var O = toObject$2(that);
    var self2 = IndexedObject$1(O);
    var length = lengthOfArrayLike(O);
    var index2 = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index2 in self2) {
          memo = self2[index2];
          index2 += i;
          break;
        }
        index2 += i;
        if (IS_RIGHT ? index2 < 0 : length <= index2) {
          throw $TypeError("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i)
      if (index2 in self2) {
        memo = callbackfn(memo, self2[index2], index2, O);
      }
    return memo;
  };
};
var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod$1(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod$1(true)
};
var $$d = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict = arrayMethodIsStrict$6;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var STRICT_METHOD = arrayMethodIsStrict("reduce");
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
$$d({ target: "Array", proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
  reduce: function reduce(callbackfn) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
  }
});
var $$c = _export;
var $findIndex = arrayIteration.findIndex;
var addToUnscopables$1 = addToUnscopables$5;
var FIND_INDEX = "findIndex";
var SKIPS_HOLES$1 = true;
if (FIND_INDEX in [])
  Array(1)[FIND_INDEX](function() {
    SKIPS_HOLES$1 = false;
  });
$$c({ target: "Array", proto: true, forced: SKIPS_HOLES$1 }, {
  findIndex: function findIndex2(callbackfn) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$1(FIND_INDEX);
function _toConsumableArray$y(arr) {
  return _arrayWithoutHoles$y(arr) || _iterableToArray$A(arr) || _unsupportedIterableToArray$19(arr) || _nonIterableSpread$y();
}
function _nonIterableSpread$y() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$19(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$19(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$19(o, minLen);
}
function _iterableToArray$A(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$y(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$19(arr);
}
function _arrayLikeToArray$19(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var ESCAPED_HTML_CHARS = {
  "&nbsp;": " ",
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">"
};
var regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map(function(key) {
  return "(".concat(key, ")");
}).join("|"), "gi");
function isHTMLTable(element) {
  return (element && element.nodeName || "") === "TABLE";
}
function instanceToHTML(instance) {
  var hasColumnHeaders = instance.hasColHeaders();
  var hasRowHeaders = instance.hasRowHeaders();
  var coords = [hasColumnHeaders ? -1 : 0, hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - 1];
  var data2 = instance.getData.apply(instance, coords);
  var countRows = data2.length;
  var countCols = countRows > 0 ? data2[0].length : 0;
  var TABLE = ["<table>", "</table>"];
  var THEAD = hasColumnHeaders ? ["<thead>", "</thead>"] : [];
  var TBODY = ["<tbody>", "</tbody>"];
  var rowModifier = hasRowHeaders ? 1 : 0;
  var columnModifier = hasColumnHeaders ? 1 : 0;
  for (var row = 0; row < countRows; row += 1) {
    var isColumnHeadersRow = hasColumnHeaders && row === 0;
    var CELLS = [];
    for (var column = 0; column < countCols; column += 1) {
      var isRowHeadersColumn = !isColumnHeadersRow && hasRowHeaders && column === 0;
      var cell = "";
      if (isColumnHeadersRow) {
        cell = "<th>".concat(instance.getColHeader(column - rowModifier), "</th>");
      } else if (isRowHeadersColumn) {
        cell = "<th>".concat(instance.getRowHeader(row - columnModifier), "</th>");
      } else {
        var cellData = data2[row][column];
        var _instance$getCellMeta = instance.getCellMeta(row - columnModifier, column - rowModifier), hidden = _instance$getCellMeta.hidden, rowspan = _instance$getCellMeta.rowspan, colspan = _instance$getCellMeta.colspan;
        if (!hidden) {
          var attrs = [];
          if (rowspan) {
            attrs.push('rowspan="'.concat(rowspan, '"'));
          }
          if (colspan) {
            attrs.push('colspan="'.concat(colspan, '"'));
          }
          if (isEmpty(cellData)) {
            cell = "<td ".concat(attrs.join(" "), "></td>");
          } else {
            var value = cellData.toString().replace("<", "&lt;").replace(">", "&gt;").replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, "<br>\r\n").replace(/\x20/gi, "&nbsp;").replace(/\t/gi, "&#9;");
            cell = "<td ".concat(attrs.join(" "), ">").concat(value, "</td>");
          }
        }
      }
      CELLS.push(cell);
    }
    var TR = ["<tr>"].concat(CELLS, ["</tr>"]).join("");
    if (isColumnHeadersRow) {
      THEAD.splice(1, 0, TR);
    } else {
      TBODY.splice(-1, 0, TR);
    }
  }
  TABLE.splice(1, 0, THEAD.join(""), TBODY.join(""));
  return TABLE.join("");
}
function _dataToHTML(input) {
  var inputLen = input.length;
  var result = ["<table>"];
  for (var row = 0; row < inputLen; row += 1) {
    var rowData = input[row];
    var columnsLen = rowData.length;
    var columnsResult = [];
    if (row === 0) {
      result.push("<tbody>");
    }
    for (var column = 0; column < columnsLen; column += 1) {
      var cellData = rowData[column];
      var parsedCellData = isEmpty(cellData) ? "" : cellData.toString().replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, "<br>\r\n").replace(/\x20/gi, "&nbsp;").replace(/\t/gi, "&#9;");
      columnsResult.push("<td>".concat(parsedCellData, "</td>"));
    }
    result.push.apply(result, ["<tr>"].concat(columnsResult, ["</tr>"]));
    if (row + 1 === inputLen) {
      result.push("</tbody>");
    }
  }
  result.push("</table>");
  return result.join("");
}
function htmlToGridSettings(element) {
  var rootDocument = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document;
  var settingsObj = {};
  var fragment = rootDocument.createDocumentFragment();
  var tempElem = rootDocument.createElement("div");
  fragment.appendChild(tempElem);
  var checkElement = element;
  if (typeof checkElement === "string") {
    var escapedAdjacentHTML = checkElement.replace(/<td\b[^>]*?>([\s\S]*?)<\/\s*td>/g, function(cellFragment) {
      var openingTag = cellFragment.match(/<td\b[^>]*?>/g)[0];
      var cellValue2 = cellFragment.substring(openingTag.length, cellFragment.lastIndexOf("<")).replace(/(<(?!br)([^>]+)>)/gi, "");
      var closingTag = "</td>";
      return "".concat(openingTag).concat(cellValue2).concat(closingTag);
    });
    tempElem.insertAdjacentHTML("afterbegin", "".concat(escapedAdjacentHTML));
    checkElement = tempElem.querySelector("table");
  }
  if (!checkElement || !isHTMLTable(checkElement)) {
    return;
  }
  var generator = tempElem.querySelector('meta[name$="enerator"]');
  var hasRowHeaders = checkElement.querySelector("tbody th") !== null;
  var trElement = checkElement.querySelector("tr");
  var countCols = !trElement ? 0 : Array.from(trElement.cells).reduce(function(cols, cell2) {
    return cols + cell2.colSpan;
  }, 0) - (hasRowHeaders ? 1 : 0);
  var fixedRowsBottom = checkElement.tFoot && Array.from(checkElement.tFoot.rows) || [];
  var fixedRowsTop = [];
  var hasColHeaders = false;
  var thRowsLen = 0;
  var countRows = 0;
  if (checkElement.tHead) {
    var thRows = Array.from(checkElement.tHead.rows).filter(function(tr2) {
      var isDataRow = tr2.querySelector("td") !== null;
      if (isDataRow) {
        fixedRowsTop.push(tr2);
      }
      return !isDataRow;
    });
    thRowsLen = thRows.length;
    hasColHeaders = thRowsLen > 0;
    if (thRowsLen > 1) {
      settingsObj.nestedHeaders = Array.from(thRows).reduce(function(rows, row2) {
        var headersRow = Array.from(row2.cells).reduce(function(headers, header, currentIndex) {
          if (hasRowHeaders && currentIndex === 0) {
            return headers;
          }
          var colspan2 = header.colSpan, innerHTML2 = header.innerHTML;
          var nextHeader = colspan2 > 1 ? {
            label: innerHTML2,
            colspan: colspan2
          } : innerHTML2;
          headers.push(nextHeader);
          return headers;
        }, []);
        rows.push(headersRow);
        return rows;
      }, []);
    } else if (hasColHeaders) {
      settingsObj.colHeaders = Array.from(thRows[0].children).reduce(function(headers, header, index2) {
        if (hasRowHeaders && index2 === 0) {
          return headers;
        }
        headers.push(header.innerHTML);
        return headers;
      }, []);
    }
  }
  if (fixedRowsTop.length) {
    settingsObj.fixedRowsTop = fixedRowsTop.length;
  }
  if (fixedRowsBottom.length) {
    settingsObj.fixedRowsBottom = fixedRowsBottom.length;
  }
  var dataRows = [].concat(fixedRowsTop, _toConsumableArray$y(Array.from(checkElement.tBodies).reduce(function(sections, section) {
    sections.push.apply(sections, _toConsumableArray$y(Array.from(section.rows)));
    return sections;
  }, [])), _toConsumableArray$y(fixedRowsBottom));
  countRows = dataRows.length;
  var dataArr = new Array(countRows);
  for (var r2 = 0; r2 < countRows; r2++) {
    dataArr[r2] = new Array(countCols);
  }
  var mergeCells = [];
  var rowHeaders = [];
  for (var row = 0; row < countRows; row++) {
    var tr = dataRows[row];
    var cells = Array.from(tr.cells);
    var cellsLen = cells.length;
    for (var cellId = 0; cellId < cellsLen; cellId++) {
      var cell = cells[cellId];
      var nodeName = cell.nodeName, innerHTML = cell.innerHTML, rowspan = cell.rowSpan, colspan = cell.colSpan;
      var col = dataArr[row].findIndex(function(value) {
        return value === void 0;
      });
      if (nodeName === "TD") {
        if (rowspan > 1 || colspan > 1) {
          for (var rstart = row; rstart < row + rowspan; rstart++) {
            if (rstart < countRows) {
              for (var cstart = col; cstart < col + colspan; cstart++) {
                dataArr[rstart][cstart] = null;
              }
            }
          }
          var styleAttr = cell.getAttribute("style");
          var ignoreMerge = styleAttr && styleAttr.includes("mso-ignore:colspan");
          if (!ignoreMerge) {
            mergeCells.push({
              col,
              row,
              rowspan,
              colspan
            });
          }
        }
        var cellValue = "";
        if (generator && /excel/gi.test(generator.content)) {
          cellValue = innerHTML.replace(/[\r\n][\x20]{0,2}/g, " ").replace(/<br(\s*|\/)>[\r\n]?[\x20]{0,3}/gim, "\r\n");
        } else {
          cellValue = innerHTML.replace(/<br(\s*|\/)>[\r\n]?/gim, "\r\n");
        }
        dataArr[row][col] = cellValue.replace(regEscapedChars, function(match2) {
          return ESCAPED_HTML_CHARS[match2];
        });
      } else {
        rowHeaders.push(innerHTML);
      }
    }
  }
  if (mergeCells.length) {
    settingsObj.mergeCells = mergeCells;
  }
  if (rowHeaders.length) {
    settingsObj.rowHeaders = rowHeaders;
  }
  if (dataArr.length) {
    settingsObj.data = dataArr;
  }
  return settingsObj;
}
function _toConsumableArray$x(arr) {
  return _arrayWithoutHoles$x(arr) || _iterableToArray$z(arr) || _unsupportedIterableToArray$18(arr) || _nonIterableSpread$x();
}
function _nonIterableSpread$x() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$z(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$x(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$18(arr);
}
function _slicedToArray$L(arr, i) {
  return _arrayWithHoles$N(arr) || _iterableToArrayLimit$L(arr, i) || _unsupportedIterableToArray$18(arr, i) || _nonIterableRest$N();
}
function _nonIterableRest$N() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$18(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$18(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$18(o, minLen);
}
function _arrayLikeToArray$18(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$L(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$N(arr) {
  if (Array.isArray(arr))
    return arr;
}
var ASC = "asc";
var DESC = "desc";
var ORDER_MAP = /* @__PURE__ */ new Map([[ASC, [-1, 1]], [DESC, [1, -1]]]);
var DEFAULT_ERROR_PRIORITY_EXISTS = function DEFAULT_ERROR_PRIORITY_EXISTS2(priority) {
  return "The priority '".concat(priority, "' is already declared in a map.");
};
var DEFAULT_ERROR_PRIORITY_NAN = function DEFAULT_ERROR_PRIORITY_NAN2(priority) {
  return "The priority '".concat(priority, "' is not a number.");
};
function createPriorityMap() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, errorPriorityExists = _ref2.errorPriorityExists, errorPriorityNaN = _ref2.errorPriorityNaN;
  var priorityMap = /* @__PURE__ */ new Map();
  errorPriorityExists = isFunction(errorPriorityExists) ? errorPriorityExists : DEFAULT_ERROR_PRIORITY_EXISTS;
  errorPriorityNaN = isFunction(errorPriorityNaN) ? errorPriorityNaN : DEFAULT_ERROR_PRIORITY_NAN;
  function addItem(priority, item) {
    if (!isNumeric(priority)) {
      throw new Error(errorPriorityNaN(priority));
    }
    if (priorityMap.has(priority)) {
      throw new Error(errorPriorityExists(priority));
    }
    priorityMap.set(priority, item);
  }
  function getItems() {
    var order = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ASC;
    var _ref22 = ORDER_MAP.get(order) || ORDER_MAP.get(ASC), _ref3 = _slicedToArray$L(_ref22, 2), left2 = _ref3[0], right2 = _ref3[1];
    return _toConsumableArray$x(priorityMap).sort(function(a, b2) {
      return a[0] < b2[0] ? left2 : right2;
    }).map(function(item) {
      return item[1];
    });
  }
  return {
    addItem,
    getItems
  };
}
var $$b = _export;
var $find = arrayIteration.find;
var addToUnscopables = addToUnscopables$5;
var FIND = "find";
var SKIPS_HOLES = true;
if (FIND in [])
  Array(1)[FIND](function() {
    SKIPS_HOLES = false;
  });
$$b({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
  find: function find2(callbackfn) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables(FIND);
function _toConsumableArray$w(arr) {
  return _arrayWithoutHoles$w(arr) || _iterableToArray$y(arr) || _unsupportedIterableToArray$17(arr) || _nonIterableSpread$w();
}
function _nonIterableSpread$w() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$y(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$w(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$17(arr);
}
function _slicedToArray$K(arr, i) {
  return _arrayWithHoles$M(arr) || _iterableToArrayLimit$K(arr, i) || _unsupportedIterableToArray$17(arr, i) || _nonIterableRest$M();
}
function _nonIterableRest$M() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$17(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$17(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$17(o, minLen);
}
function _arrayLikeToArray$17(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$K(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$M(arr) {
  if (Array.isArray(arr))
    return arr;
}
var DEFAULT_ERROR_ID_EXISTS = function DEFAULT_ERROR_ID_EXISTS2(id2) {
  return "The id '".concat(id2, "' is already declared in a map.");
};
function createUniqueMap() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, errorIdExists = _ref2.errorIdExists;
  var uniqueMap = /* @__PURE__ */ new Map();
  errorIdExists = isFunction(errorIdExists) ? errorIdExists : DEFAULT_ERROR_ID_EXISTS;
  function addItem(id2, item) {
    if (hasItem2(id2)) {
      throw new Error(errorIdExists(id2));
    }
    uniqueMap.set(id2, item);
  }
  function removeItem(id2) {
    return uniqueMap.delete(id2);
  }
  function clear2() {
    uniqueMap.clear();
  }
  function getId(item) {
    var _ref22 = getItems().find(function(_ref4) {
      var _ref5 = _slicedToArray$K(_ref4, 2), id2 = _ref5[0], element = _ref5[1];
      if (item === element) {
        return id2;
      }
      return false;
    }) || [null], _ref3 = _slicedToArray$K(_ref22, 1), itemId = _ref3[0];
    return itemId;
  }
  function getItem2(id2) {
    return uniqueMap.get(id2);
  }
  function getItems() {
    return _toConsumableArray$w(uniqueMap);
  }
  function hasItem2(id2) {
    return uniqueMap.has(id2);
  }
  return {
    addItem,
    clear: clear2,
    getId,
    getItem: getItem2,
    getItems,
    hasItem: hasItem2,
    removeItem
  };
}
function _toConsumableArray$v(arr) {
  return _arrayWithoutHoles$v(arr) || _iterableToArray$x(arr) || _unsupportedIterableToArray$16(arr) || _nonIterableSpread$v();
}
function _nonIterableSpread$v() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$16(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$16(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$16(o, minLen);
}
function _iterableToArray$x(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$v(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$16(arr);
}
function _arrayLikeToArray$16(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var DEFAULT_ERROR_ITEM_EXISTS = function DEFAULT_ERROR_ITEM_EXISTS2(item) {
  return "'".concat(item, "' value is already declared in a unique set.");
};
function createUniqueSet() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, errorItemExists = _ref2.errorItemExists;
  var uniqueSet = /* @__PURE__ */ new Set();
  errorItemExists = isFunction(errorItemExists) ? errorItemExists : DEFAULT_ERROR_ITEM_EXISTS;
  function addItem(item) {
    if (uniqueSet.has(item)) {
      throw new Error(errorItemExists(item));
    }
    uniqueSet.add(item);
  }
  function getItems() {
    return _toConsumableArray$v(uniqueSet);
  }
  function clear2() {
    uniqueSet.clear();
  }
  return {
    addItem,
    clear: clear2,
    getItems
  };
}
function _slicedToArray$J(arr, i) {
  return _arrayWithHoles$L(arr) || _iterableToArrayLimit$J(arr, i) || _unsupportedIterableToArray$15(arr, i) || _nonIterableRest$L();
}
function _nonIterableRest$L() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$J(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$L(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$u(arr) {
  return _arrayWithoutHoles$u(arr) || _iterableToArray$w(arr) || _unsupportedIterableToArray$15(arr) || _nonIterableSpread$u();
}
function _nonIterableSpread$u() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$15(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$15(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$15(o, minLen);
}
function _iterableToArray$w(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$u(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$15(arr);
}
function _arrayLikeToArray$15(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var ERROR_PLUGIN_REGISTERED = function ERROR_PLUGIN_REGISTERED2(pluginName) {
  return 'There is already registered "'.concat(pluginName, '" plugin.');
};
var ERROR_PRIORITY_REGISTERED = function ERROR_PRIORITY_REGISTERED2(priority) {
  return 'There is already registered plugin on priority "'.concat(priority, '".');
};
var ERROR_PRIORITY_NAN = function ERROR_PRIORITY_NAN2(priority) {
  return 'The priority "'.concat(priority, '" is not a number.');
};
var priorityPluginsQueue = createPriorityMap({
  errorPriorityExists: ERROR_PRIORITY_REGISTERED,
  errorPriorityNaN: ERROR_PRIORITY_NAN
});
var uniquePluginsQueue = createUniqueSet({
  errorItemExists: ERROR_PLUGIN_REGISTERED
});
var uniquePluginsList = createUniqueMap({
  errorIdExists: ERROR_PLUGIN_REGISTERED
});
function getPluginsNames() {
  return [].concat(_toConsumableArray$u(priorityPluginsQueue.getItems()), _toConsumableArray$u(uniquePluginsQueue.getItems()));
}
function getPlugin(pluginName) {
  var unifiedPluginName = toUpperCaseFirst(pluginName);
  return uniquePluginsList.getItem(unifiedPluginName);
}
function hasPlugin(pluginName) {
  return getPlugin(pluginName) ? true : false;
}
function registerPlugin(pluginName, pluginClass, priority) {
  var _unifyPluginArguments = unifyPluginArguments(pluginName, pluginClass, priority);
  var _unifyPluginArguments2 = _slicedToArray$J(_unifyPluginArguments, 3);
  pluginName = _unifyPluginArguments2[0];
  pluginClass = _unifyPluginArguments2[1];
  priority = _unifyPluginArguments2[2];
  if (getPlugin(pluginName) === void 0) {
    _registerPlugin(pluginName, pluginClass, priority);
  }
}
function _registerPlugin(pluginName, pluginClass, priority) {
  var unifiedPluginName = toUpperCaseFirst(pluginName);
  if (uniquePluginsList.hasItem(unifiedPluginName)) {
    throw new Error(ERROR_PLUGIN_REGISTERED(unifiedPluginName));
  }
  if (priority === void 0) {
    uniquePluginsQueue.addItem(unifiedPluginName);
  } else {
    priorityPluginsQueue.addItem(priority, unifiedPluginName);
  }
  uniquePluginsList.addItem(unifiedPluginName, pluginClass);
}
function unifyPluginArguments(pluginName, pluginClass, priority) {
  if (typeof pluginName === "function") {
    pluginClass = pluginName;
    pluginName = pluginClass.PLUGIN_KEY;
    priority = pluginClass.PLUGIN_PRIORITY;
  }
  return [pluginName, pluginClass, priority];
}
var _staticRegister$5 = staticRegister("validators"), register$3 = _staticRegister$5.register, getItem$2 = _staticRegister$5.getItem, hasItem$1 = _staticRegister$5.hasItem;
_staticRegister$5.getNames;
_staticRegister$5.getValues;
function _getItem$1(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem$1(name)) {
    throw Error('No registered validator found under "'.concat(name, '" name'));
  }
  return getItem$2(name);
}
function _register$1(name, validator) {
  if (typeof name !== "string") {
    validator = name;
    name = validator.VALIDATOR_TYPE;
  }
  register$3(name, validator);
}
var RENDER_TYPE = 1;
var FULLY_VISIBLE_TYPE = 2;
function _classCallCheck$2H(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2H(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2H(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2H(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2H(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var privatePool$l = /* @__PURE__ */ new WeakMap();
var ViewportColumnsCalculator = /* @__PURE__ */ function() {
  function ViewportColumnsCalculator2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, viewportSize = _ref2.viewportSize, scrollOffset = _ref2.scrollOffset, totalItems = _ref2.totalItems, itemSizeFn = _ref2.itemSizeFn, overrideFn = _ref2.overrideFn, calculationType = _ref2.calculationType, stretchMode = _ref2.stretchMode, _ref$stretchingItemWi = _ref2.stretchingItemWidthFn, stretchingItemWidthFn = _ref$stretchingItemWi === void 0 ? function(width) {
      return width;
    } : _ref$stretchingItemWi;
    _classCallCheck$2H(this, ViewportColumnsCalculator2);
    privatePool$l.set(this, {
      viewportWidth: viewportSize,
      scrollOffset,
      totalColumns: totalItems,
      columnWidthFn: itemSizeFn,
      overrideFn,
      calculationType,
      stretchingColumnWidthFn: stretchingItemWidthFn
    });
    this.count = 0;
    this.startColumn = null;
    this.endColumn = null;
    this.startPosition = null;
    this.stretchAllRatio = 0;
    this.stretchLastWidth = 0;
    this.stretch = stretchMode;
    this.totalTargetWidth = 0;
    this.needVerifyLastColumnWidth = true;
    this.stretchAllColumnsWidth = [];
    this.calculate();
  }
  _createClass$2H(ViewportColumnsCalculator2, [{
    key: "calculate",
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];
      var columnWidth;
      var priv = privatePool$l.get(this);
      var calculationType = priv.calculationType;
      var overrideFn = priv.overrideFn;
      var scrollOffset = priv.scrollOffset;
      var totalColumns = priv.totalColumns;
      var viewportWidth = priv.viewportWidth;
      for (var i = 0; i < totalColumns; i++) {
        columnWidth = this._getColumnWidth(i);
        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {
          this.startColumn = i;
        }
        var compensatedViewportWidth = scrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? columnWidth : 0) <= scrollOffset + compensatedViewportWidth) {
          if (this.startColumn === null || this.startColumn === void 0) {
            this.startColumn = i;
          }
          this.endColumn = i;
        }
        startPositions.push(sum);
        sum += columnWidth;
        if (calculationType !== FULLY_VISIBLE_TYPE) {
          this.endColumn = i;
        }
        if (sum >= scrollOffset + viewportWidth) {
          needReverse = false;
          break;
        }
      }
      if (this.endColumn === totalColumns - 1 && needReverse) {
        this.startColumn = this.endColumn;
        while (this.startColumn > 0) {
          var viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
          if (viewportSum <= viewportWidth || calculationType !== FULLY_VISIBLE_TYPE) {
            this.startColumn -= 1;
          }
          if (viewportSum > viewportWidth) {
            break;
          }
        }
      }
      if (calculationType === RENDER_TYPE && this.startColumn !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startColumn];
      if (this.startPosition === void 0) {
        this.startPosition = null;
      }
      if (totalColumns < this.endColumn) {
        this.endColumn = totalColumns - 1;
      }
      if (this.startColumn !== null) {
        this.count = this.endColumn - this.startColumn + 1;
      }
    }
    /**
     * Recalculate columns stretching.
     *
     * @param {number} totalWidth The total width of the table.
     */
  }, {
    key: "refreshStretching",
    value: function refreshStretching(totalWidth) {
      if (this.stretch === "none") {
        return;
      }
      var totalColumnsWidth = totalWidth;
      this.totalTargetWidth = totalColumnsWidth;
      var priv = privatePool$l.get(this);
      var totalColumns = priv.totalColumns;
      var sumAll = 0;
      for (var i = 0; i < totalColumns; i++) {
        var columnWidth = this._getColumnWidth(i);
        var permanentColumnWidth = priv.stretchingColumnWidthFn(void 0, i);
        if (typeof permanentColumnWidth === "number") {
          totalColumnsWidth -= permanentColumnWidth;
        } else {
          sumAll += columnWidth;
        }
      }
      var remainingSize = totalColumnsWidth - sumAll;
      if (this.stretch === "all" && remainingSize > 0) {
        this.stretchAllRatio = totalColumnsWidth / sumAll;
        this.stretchAllColumnsWidth = [];
        this.needVerifyLastColumnWidth = true;
      } else if (this.stretch === "last" && totalColumnsWidth !== Infinity) {
        var _columnWidth = this._getColumnWidth(totalColumns - 1);
        var lastColumnWidth = remainingSize + _columnWidth;
        this.stretchLastWidth = lastColumnWidth >= 0 ? lastColumnWidth : _columnWidth;
      }
    }
    /**
     * Get stretched column width based on stretchH (all or last) setting passed in handsontable instance.
     *
     * @param {number} column The visual column index.
     * @param {number} baseWidth The default column width.
     * @returns {number|null}
     */
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(column, baseWidth) {
      var result = null;
      if (this.stretch === "all" && this.stretchAllRatio !== 0) {
        result = this._getStretchedAllColumnWidth(column, baseWidth);
      } else if (this.stretch === "last" && this.stretchLastWidth !== 0) {
        result = this._getStretchedLastColumnWidth(column);
      }
      return result;
    }
    /**
     * @param {number} column The visual column index.
     * @param {number} baseWidth The default column width.
     * @returns {number}
     * @private
     */
  }, {
    key: "_getStretchedAllColumnWidth",
    value: function _getStretchedAllColumnWidth(column, baseWidth) {
      var sumRatioWidth = 0;
      var priv = privatePool$l.get(this);
      var totalColumns = priv.totalColumns;
      if (!this.stretchAllColumnsWidth[column]) {
        var stretchedWidth = Math.round(baseWidth * this.stretchAllRatio);
        var newStretchedWidth = priv.stretchingColumnWidthFn(stretchedWidth, column);
        if (newStretchedWidth === void 0) {
          this.stretchAllColumnsWidth[column] = stretchedWidth;
        } else {
          this.stretchAllColumnsWidth[column] = isNaN(newStretchedWidth) ? this._getColumnWidth(column) : newStretchedWidth;
        }
      }
      if (this.stretchAllColumnsWidth.length === totalColumns && this.needVerifyLastColumnWidth) {
        this.needVerifyLastColumnWidth = false;
        for (var i = 0; i < this.stretchAllColumnsWidth.length; i++) {
          sumRatioWidth += this.stretchAllColumnsWidth[i];
        }
        if (sumRatioWidth !== this.totalTargetWidth) {
          this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += this.totalTargetWidth - sumRatioWidth;
        }
      }
      return this.stretchAllColumnsWidth[column];
    }
    /**
     * @param {number} column The visual column index.
     * @returns {number|null}
     * @private
     */
  }, {
    key: "_getStretchedLastColumnWidth",
    value: function _getStretchedLastColumnWidth(column) {
      var priv = privatePool$l.get(this);
      var totalColumns = priv.totalColumns;
      if (column === totalColumns - 1) {
        return this.stretchLastWidth;
      }
      return null;
    }
    /**
     * @param {number} column The visual column index.
     * @returns {number}
     * @private
     */
  }, {
    key: "_getColumnWidth",
    value: function _getColumnWidth(column) {
      var width = privatePool$l.get(this).columnWidthFn(column);
      if (isNaN(width)) {
        width = ViewportColumnsCalculator2.DEFAULT_WIDTH;
      }
      return width;
    }
  }], [{
    key: "DEFAULT_WIDTH",
    get: (
      /**
       * Default column width.
       *
       * @type {number}
       */
      function get2() {
        return 50;
      }
    )
  }]);
  return ViewportColumnsCalculator2;
}();
const ViewportColumnsCalculator$1 = ViewportColumnsCalculator;
function _classCallCheck$2G(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2G(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2G(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2G(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2G(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var privatePool$k = /* @__PURE__ */ new WeakMap();
var ViewportRowsCalculator = /* @__PURE__ */ function() {
  function ViewportRowsCalculator2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, viewportSize = _ref2.viewportSize, scrollOffset = _ref2.scrollOffset, totalItems = _ref2.totalItems, itemSizeFn = _ref2.itemSizeFn, overrideFn = _ref2.overrideFn, calculationType = _ref2.calculationType, scrollbarHeight = _ref2.scrollbarHeight;
    _classCallCheck$2G(this, ViewportRowsCalculator2);
    privatePool$k.set(this, {
      viewportHeight: viewportSize,
      scrollOffset,
      totalRows: totalItems,
      rowHeightFn: itemSizeFn,
      overrideFn,
      calculationType,
      horizontalScrollbarHeight: scrollbarHeight
    });
    this.count = 0;
    this.startRow = null;
    this.endRow = null;
    this.startPosition = null;
    this.calculate();
  }
  _createClass$2G(ViewportRowsCalculator2, [{
    key: "calculate",
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];
      var priv = privatePool$k.get(this);
      var calculationType = priv.calculationType;
      var overrideFn = priv.overrideFn;
      var rowHeightFn = priv.rowHeightFn;
      var scrollOffset = priv.scrollOffset;
      var totalRows = priv.totalRows;
      var viewportHeight = priv.viewportHeight;
      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;
      var rowHeight;
      for (var i = 0; i < totalRows; i++) {
        rowHeight = rowHeightFn(i);
        if (isNaN(rowHeight)) {
          rowHeight = ViewportRowsCalculator2.DEFAULT_HEIGHT;
        }
        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {
          this.startRow = i;
        }
        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          if (this.startRow === null) {
            this.startRow = i;
          }
          this.endRow = i;
        }
        startPositions.push(sum);
        sum += rowHeight;
        if (calculationType !== FULLY_VISIBLE_TYPE) {
          this.endRow = i;
        }
        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          needReverse = false;
          break;
        }
      }
      if (this.endRow === totalRows - 1 && needReverse) {
        this.startRow = this.endRow;
        while (this.startRow > 0) {
          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {
            this.startRow -= 1;
          }
          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {
            break;
          }
        }
      }
      if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startRow];
      if (this.startPosition === void 0) {
        this.startPosition = null;
      }
      if (totalRows < this.endRow) {
        this.endRow = totalRows - 1;
      }
      if (this.startRow !== null) {
        this.count = this.endRow - this.startRow + 1;
      }
    }
  }], [{
    key: "DEFAULT_HEIGHT",
    get: (
      /**
       * Default row height.
       *
       * @type {number}
       */
      function get2() {
        return 23;
      }
    )
  }]);
  return ViewportRowsCalculator2;
}();
const ViewportRowsCalculator$1 = ViewportRowsCalculator;
function _classCallCheck$2F(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2F(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2F(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2F(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2F(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateFieldInitSpec$b(obj, privateMap, value) {
  _checkPrivateRedeclaration$c(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$c(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty$G(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldGet$b(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$b(receiver, privateMap, "get");
  return _classApplyDescriptorGet$b(receiver, descriptor);
}
function _classApplyDescriptorGet$b(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$b(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$b(receiver, privateMap, "set");
  _classApplyDescriptorSet$b(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$b(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$b(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _isRtl$1 = /* @__PURE__ */ new WeakMap();
var CellCoords = /* @__PURE__ */ function() {
  function CellCoords2(row, column) {
    var isRtl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    _classCallCheck$2F(this, CellCoords2);
    _defineProperty$G(this, "row", null);
    _defineProperty$G(this, "col", null);
    _classPrivateFieldInitSpec$b(this, _isRtl$1, {
      writable: true,
      value: false
    });
    _classPrivateFieldSet$b(this, _isRtl$1, isRtl);
    if (typeof row !== "undefined" && typeof column !== "undefined") {
      this.row = row;
      this.col = column;
    }
  }
  _createClass$2F(CellCoords2, [{
    key: "isValid",
    value: function isValid(wot) {
      if (this.row < 0 || this.col < 0) {
        return false;
      }
      if (this.row >= wot.getSetting("totalRows") || this.col >= wot.getSetting("totalColumns")) {
        return false;
      }
      return true;
    }
    /**
     * Checks if this cell coordinates are the same as cell coordinates given as an argument.
     *
     * @param {CellCoords} cellCoords Cell coordinates to equal.
     * @returns {boolean}
     */
  }, {
    key: "isEqual",
    value: function isEqual(cellCoords) {
      if (cellCoords === this) {
        return true;
      }
      return this.row === cellCoords.row && this.col === cellCoords.col;
    }
    /**
     * Checks if tested coordinates are positioned in south-east from this cell coordinates.
     *
     * @param {object} testedCoords Cell coordinates to check.
     * @returns {boolean}
     */
  }, {
    key: "isSouthEastOf",
    value: function isSouthEastOf(testedCoords) {
      return this.row >= testedCoords.row && (_classPrivateFieldGet$b(this, _isRtl$1) ? this.col <= testedCoords.col : this.col >= testedCoords.col);
    }
    /**
     * Checks if tested coordinates are positioned in north-east from this cell coordinates.
     *
     * @param {object} testedCoords Cell coordinates to check.
     * @returns {boolean}
     */
  }, {
    key: "isNorthWestOf",
    value: function isNorthWestOf(testedCoords) {
      return this.row <= testedCoords.row && (_classPrivateFieldGet$b(this, _isRtl$1) ? this.col >= testedCoords.col : this.col <= testedCoords.col);
    }
    /**
     * Checks if tested coordinates are positioned in south-west from this cell coordinates.
     *
     * @param {object} testedCoords Cell coordinates to check.
     * @returns {boolean}
     */
  }, {
    key: "isSouthWestOf",
    value: function isSouthWestOf(testedCoords) {
      return this.row >= testedCoords.row && (_classPrivateFieldGet$b(this, _isRtl$1) ? this.col >= testedCoords.col : this.col <= testedCoords.col);
    }
    /**
     * Checks if tested coordinates are positioned in north-east from this cell coordinates.
     *
     * @param {object} testedCoords Cell coordinates to check.
     * @returns {boolean}
     */
  }, {
    key: "isNorthEastOf",
    value: function isNorthEastOf(testedCoords) {
      return this.row <= testedCoords.row && (_classPrivateFieldGet$b(this, _isRtl$1) ? this.col <= testedCoords.col : this.col >= testedCoords.col);
    }
    /**
     * Normalizes the coordinates to the nearest valid position. The coordinates that point
     * to the headers (negative values) are normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "normalize",
    value: function normalize2() {
      this.row = this.row === null ? this.row : Math.max(this.row, 0);
      this.col = this.col === null ? this.col : Math.max(this.col, 0);
      return this;
    }
    /**
     * Clones the coordinates.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "clone",
    value: function clone2() {
      return new CellCoords2(this.row, this.col, _classPrivateFieldGet$b(this, _isRtl$1));
    }
    /**
     * Converts CellCoords to literal object with `row` and `col` properties.
     *
     * @returns {object} Returns a literal object with `row` and `col` properties.
     */
  }, {
    key: "toObject",
    value: function toObject2() {
      return {
        row: this.row,
        col: this.col
      };
    }
  }]);
  return CellCoords2;
}();
const CellCoords$1 = CellCoords;
function _classCallCheck$2E(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2E(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2E(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2E(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2E(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateFieldInitSpec$a(obj, privateMap, value) {
  _checkPrivateRedeclaration$b(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$b(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty$F(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldGet$a(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$a(receiver, privateMap, "get");
  return _classApplyDescriptorGet$a(receiver, descriptor);
}
function _classApplyDescriptorGet$a(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$a(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$a(receiver, privateMap, "set");
  _classApplyDescriptorSet$a(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$a(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$a(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _isRtl = /* @__PURE__ */ new WeakMap();
var CellRange = /* @__PURE__ */ function() {
  function CellRange2(highlight) {
    var from3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : highlight;
    var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : highlight;
    var isRtl = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    _classCallCheck$2E(this, CellRange2);
    _defineProperty$F(this, "highlight", null);
    _defineProperty$F(this, "from", null);
    _defineProperty$F(this, "to", null);
    _classPrivateFieldInitSpec$a(this, _isRtl, {
      writable: true,
      value: false
    });
    this.highlight = highlight.clone().normalize();
    this.from = from3.clone();
    this.to = to.clone();
    _classPrivateFieldSet$a(this, _isRtl, isRtl);
  }
  _createClass$2E(CellRange2, [{
    key: "setHighlight",
    value: function setHighlight(coords) {
      this.highlight = coords.clone().normalize();
      return this;
    }
    /**
     * Set the new coordinates where selection starts from.
     *
     * @param {CellCoords} coords Coordinates to use.
     * @returns {CellRange}
     */
  }, {
    key: "setFrom",
    value: function setFrom(coords) {
      this.from = coords.clone();
      return this;
    }
    /**
     * Set new coordinates where selection ends from.
     *
     * @param {CellCoords} coords Coordinates to use.
     * @returns {CellRange}
     */
  }, {
    key: "setTo",
    value: function setTo(coords) {
      this.to = coords.clone();
      return this;
    }
    /**
     * Checks if given coordinates are valid in context of a given Walkontable instance.
     *
     * @param {Walkontable} wot The Walkontable instance.
     * @returns {boolean}
     */
  }, {
    key: "isValid",
    value: function isValid(wot) {
      return this.from.isValid(wot) && this.to.isValid(wot);
    }
    /**
     * Checks if this cell range is restricted to one cell.
     *
     * @returns {boolean}
     */
  }, {
    key: "isSingle",
    value: function isSingle() {
      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;
    }
    /**
     * Returns selected range height (in number of rows including rows' headers).
     *
     * @returns {number}
     */
  }, {
    key: "getOuterHeight",
    value: function getOuterHeight() {
      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
    }
    /**
     * Returns selected range width (in number of columns including columns' headers).
     *
     * @returns {number}
     */
  }, {
    key: "getOuterWidth",
    value: function getOuterWidth() {
      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
    }
    /**
     * Returns selected range height (in number of rows excluding rows' headers).
     *
     * @returns {number}
     */
  }, {
    key: "getHeight",
    value: function getHeight() {
      var fromRow = Math.max(this.from.row, 0);
      var toRow = Math.max(this.to.row, 0);
      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;
    }
    /**
     * Returns selected range width (in number of columns excluding columns' headers).
     *
     * @returns {number}
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      var fromCol = Math.max(this.from.col, 0);
      var toCol = Math.max(this.to.col, 0);
      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;
    }
    /**
     * Returns the number of cells within the range (excluding the column and row headers, if selected).
     *
     * @returns {number}
     */
  }, {
    key: "getCellsCount",
    value: function getCellsCount() {
      return this.getWidth() * this.getHeight();
    }
    /**
     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.
     *
     * @param {CellCoords} cellCoords The cell coordinates to check.
     * @returns {boolean}
     */
  }, {
    key: "includes",
    value: function includes3(cellCoords) {
      var row = cellCoords.row, col = cellCoords.col;
      var topStart = this.getOuterTopStartCorner();
      var bottomEnd = this.getOuterBottomEndCorner();
      return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;
    }
    /**
     * Checks if given range is within of this range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {boolean}
     */
  }, {
    key: "includesRange",
    value: function includesRange(cellRange) {
      return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());
    }
    /**
     * Checks if given range is equal to this range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {boolean}
     */
  }, {
    key: "isEqual",
    value: function isEqual(cellRange) {
      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);
    }
    /**
     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B
     * if intersection of A and B or B and A is not empty.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {boolean}
     */
  }, {
    key: "overlaps",
    value: function overlaps(cellRange) {
      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());
    }
    /**
     * Checks if tested coordinates are positioned in south-east from this cell range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {boolean}
     */
  }, {
    key: "isSouthEastOf",
    value: function isSouthEastOf(cellRange) {
      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);
    }
    /**
     * Checks if tested coordinates are positioned in north-west from this cell range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {boolean}
     */
  }, {
    key: "isNorthWestOf",
    value: function isNorthWestOf(cellRange) {
      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);
    }
    /**
     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. The current range's last
     * column is 5 and the provided range's first column is 3).
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {boolean}
     */
  }, {
    key: "isOverlappingHorizontally",
    value: function isOverlappingHorizontally(cellRange) {
      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;
    }
    /**
     * Returns `true` if the provided range is overlapping the current range vertically (e.g. The current range's last
     *  row is 5 and the provided range's first row is 3).
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {boolean}
     */
  }, {
    key: "isOverlappingVertically",
    value: function isOverlappingVertically(cellRange) {
      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;
    }
    /**
     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.
     *
     * @param {CellCoords} cellCoords The cell coordinates.
     * @returns {boolean}
     */
  }, {
    key: "expand",
    value: function expand(cellCoords) {
      var topStart = this.getOuterTopStartCorner();
      var bottomEnd = this.getOuterBottomEndCorner();
      if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {
        this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));
        this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));
        return true;
      }
      return false;
    }
    /**
     * Expand the current object by the range passed in the first argument.
     *
     * @param {CellRange} expandingRange Object extending the range.
     * @returns {boolean}
     */
  }, {
    key: "expandByRange",
    value: function expandByRange(expandingRange) {
      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
        return false;
      }
      var topStart = this.getOuterTopStartCorner();
      var bottomEnd = this.getOuterBottomEndCorner();
      var initialDirection = this.getDirection();
      var expandingTopStart = expandingRange.getOuterTopStartCorner();
      var expandingBottomEnd = expandingRange.getOuterBottomEndCorner();
      var resultTopRow = Math.min(topStart.row, expandingTopStart.row);
      var resultTopCol = Math.min(topStart.col, expandingTopStart.col);
      var resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);
      var resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);
      var finalFrom = this._createCellCoords(resultTopRow, resultTopCol);
      var finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);
      this.from = finalFrom;
      this.to = finalTo;
      this.setDirection(initialDirection);
      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === "N-S") {
        this.flipDirectionVertically();
      }
      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === "W-E") {
        this.flipDirectionHorizontally();
      }
      return true;
    }
    /**
     * Gets the direction of the selection.
     *
     * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
     */
  }, {
    key: "getDirection",
    value: function getDirection() {
      if (this.from.isNorthWestOf(this.to)) {
        return "NW-SE";
      } else if (this.from.isNorthEastOf(this.to)) {
        return "NE-SW";
      } else if (this.from.isSouthEastOf(this.to)) {
        return "SE-NW";
      } else if (this.from.isSouthWestOf(this.to)) {
        return "SW-NE";
      }
    }
    /**
     * Sets the direction of the selection.
     *
     * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
     */
  }, {
    key: "setDirection",
    value: function setDirection(direction) {
      switch (direction) {
        case "NW-SE":
          var _ref2 = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];
          this.from = _ref2[0];
          this.to = _ref2[1];
          break;
        case "NE-SW":
          var _ref22 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];
          this.from = _ref22[0];
          this.to = _ref22[1];
          break;
        case "SE-NW":
          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];
          this.from = _ref3[0];
          this.to = _ref3[1];
          break;
        case "SW-NE":
          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];
          this.from = _ref4[0];
          this.to = _ref4[1];
          break;
      }
    }
    /**
     * Gets the vertical direction of the range.
     *
     * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).
     */
  }, {
    key: "getVerticalDirection",
    value: function getVerticalDirection() {
      return ["NE-SW", "NW-SE"].indexOf(this.getDirection()) > -1 ? "N-S" : "S-N";
    }
    /**
     * Gets the horizontal direction of the range.
     *
     * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).
     */
  }, {
    key: "getHorizontalDirection",
    value: function getHorizontalDirection() {
      return ["NW-SE", "SW-NE"].indexOf(this.getDirection()) > -1 ? "W-E" : "E-W";
    }
    /**
     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).
     */
  }, {
    key: "flipDirectionVertically",
    value: function flipDirectionVertically() {
      var direction = this.getDirection();
      switch (direction) {
        case "NW-SE":
          this.setDirection("SW-NE");
          break;
        case "NE-SW":
          this.setDirection("SE-NW");
          break;
        case "SE-NW":
          this.setDirection("NE-SW");
          break;
        case "SW-NE":
          this.setDirection("NW-SE");
          break;
      }
    }
    /**
     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).
     */
  }, {
    key: "flipDirectionHorizontally",
    value: function flipDirectionHorizontally() {
      var direction = this.getDirection();
      switch (direction) {
        case "NW-SE":
          this.setDirection("NE-SW");
          break;
        case "NE-SW":
          this.setDirection("NW-SE");
          break;
        case "SE-NW":
          this.setDirection("SW-NE");
          break;
        case "SW-NE":
          this.setDirection("SE-NW");
          break;
      }
    }
    /**
     * Gets the top left (in LTR) or top right (in RTL) corner coordinates of this range. If the corner contains
     * header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getTopStartCorner",
    value: function getTopStartCorner() {
      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
    }
    /**
     * Gets the top left corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getTopLeftCorner",
    value: function getTopLeftCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getTopEndCorner() : this.getTopStartCorner();
    }
    /**
     * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of this range. If the corner contains
     * header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getBottomEndCorner",
    value: function getBottomEndCorner() {
      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
    }
    /**
     * Gets the bottom right corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getBottomRightCorner",
    value: function getBottomRightCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getBottomStartCorner() : this.getBottomEndCorner();
    }
    /**
     * Gets the top right (in LTR) or top left (in RTL) corner coordinates of this range. If the corner contains
     * header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getTopEndCorner",
    value: function getTopEndCorner() {
      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
    }
    /**
     * Gets the top right corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getTopRightCorner",
    value: function getTopRightCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getTopStartCorner() : this.getTopEndCorner();
    }
    /**
     * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of this range. If the corner
     * contains header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getBottomStartCorner",
    value: function getBottomStartCorner() {
      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
    }
    /**
     * Gets the bottom left corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), the corner coordinates will be normalized to 0.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getBottomLeftCorner",
    value: function getBottomLeftCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getBottomEndCorner() : this.getBottomStartCorner();
    }
    /**
     * Gets the top left (in LTR) or top right (in RTL) corner coordinates of this range. If the corner
     * contains header coordinates (negative values), then the top and start coordinates will be pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterTopStartCorner",
    value: function getOuterTopStartCorner() {
      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }
    /**
     * Gets the top left corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), then the top and left coordinates will be
     * pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterTopLeftCorner",
    value: function getOuterTopLeftCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();
    }
    /**
     * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of this range. If the corner
     * contains header coordinates (negative values), then the top and start coordinates will be pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterBottomEndCorner",
    value: function getOuterBottomEndCorner() {
      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }
    /**
     * Gets the bottom right corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), then the top and left coordinates will be
     * pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterBottomRightCorner",
    value: function getOuterBottomRightCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();
    }
    /**
     * Gets the top right (in LTR) or top left (in RTL) corner coordinates of this range. If the corner
     * contains header coordinates (negative values), then the top and start coordinates will be pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterTopEndCorner",
    value: function getOuterTopEndCorner() {
      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }
    /**
     * Gets the top right corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), then the top and left coordinates will be
     * pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterTopRightCorner",
    value: function getOuterTopRightCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();
    }
    /**
     * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of this range. If the corner
     * contains header coordinates (negative values), then the top and start coordinates will be pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterBottomStartCorner",
    value: function getOuterBottomStartCorner() {
      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }
    /**
     * Gets the bottom left corner coordinates of this range, no matter if the code runs in LTR or RTL document mode.
     * If the corner contains header coordinates (negative values), then the top and left coordinates will be
     * pointed to that header.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getOuterBottomLeftCorner",
    value: function getOuterBottomLeftCorner() {
      return _classPrivateFieldGet$a(this, _isRtl) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();
    }
    /**
     * Checks if coordinates match to one of the 4th corners of this range.
     *
     * @param {CellCoords} coords Cell coordinates to check.
     * @param {CellRange} [expandedRange] The cells range to compare with.
     * @returns {boolean}
     */
  }, {
    key: "isCorner",
    value: function isCorner(coords, expandedRange) {
      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.to.col)))) {
        return true;
      }
      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());
    }
    /**
     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the
     * bottom-right corner of this range then the coordinates for top-left will be returned.
     *
     * @param {CellCoords} coords Cell coordinates to check.
     * @param {CellRange} [expandedRange] The cells range to compare with.
     * @returns {CellCoords}
     */
  }, {
    key: "getOppositeCorner",
    value: function getOppositeCorner(coords, expandedRange) {
      if (!(coords instanceof CellCoords$1)) {
        return false;
      }
      if (expandedRange) {
        var from3 = expandedRange.from, to = expandedRange.to;
        if (expandedRange.includes(coords)) {
          if (this.getOuterTopStartCorner().isEqual(this._createCellCoords(from3.row, from3.col))) {
            return this.getOuterBottomEndCorner();
          }
          if (this.getOuterTopEndCorner().isEqual(this._createCellCoords(from3.row, to.col))) {
            return this.getOuterBottomStartCorner();
          }
          if (this.getOuterBottomStartCorner().isEqual(this._createCellCoords(to.row, from3.col))) {
            return this.getOuterTopEndCorner();
          }
          if (this.getOuterBottomEndCorner().isEqual(this._createCellCoords(to.row, to.col))) {
            return this.getOuterTopStartCorner();
          }
        }
      }
      if (coords.isEqual(this.getOuterBottomEndCorner())) {
        return this.getOuterTopStartCorner();
      } else if (coords.isEqual(this.getOuterTopStartCorner())) {
        return this.getOuterBottomEndCorner();
      } else if (coords.isEqual(this.getOuterTopEndCorner())) {
        return this.getOuterBottomStartCorner();
      } else if (coords.isEqual(this.getOuterBottomStartCorner())) {
        return this.getOuterTopEndCorner();
      }
    }
    /**
     * @param {CellRange} range The cells range to compare with.
     * @returns {Array}
     */
  }, {
    key: "getBordersSharedWith",
    value: function getBordersSharedWith(range) {
      if (!this.includesRange(range)) {
        return [];
      }
      var thisBorders = {
        top: Math.min(this.from.row, this.to.row),
        bottom: Math.max(this.from.row, this.to.row),
        left: Math.min(this.from.col, this.to.col),
        right: Math.max(this.from.col, this.to.col)
      };
      var rangeBorders = {
        top: Math.min(range.from.row, range.to.row),
        bottom: Math.max(range.from.row, range.to.row),
        left: Math.min(range.from.col, range.to.col),
        right: Math.max(range.from.col, range.to.col)
      };
      var result = [];
      if (thisBorders.top === rangeBorders.top) {
        result.push("top");
      }
      if (thisBorders.right === rangeBorders.right) {
        result.push("right");
      }
      if (thisBorders.bottom === rangeBorders.bottom) {
        result.push("bottom");
      }
      if (thisBorders.left === rangeBorders.left) {
        result.push("left");
      }
      return result;
    }
    /**
     * Get inner selected cell coords defined by this range.
     *
     * @returns {Array}
     */
  }, {
    key: "getInner",
    value: function getInner() {
      var topStart = this.getOuterTopStartCorner();
      var bottomEnd = this.getOuterBottomEndCorner();
      var out = [];
      for (var r2 = topStart.row; r2 <= bottomEnd.row; r2++) {
        for (var c2 = topStart.col; c2 <= bottomEnd.col; c2++) {
          if (!(this.from.row === r2 && this.from.col === c2) && !(this.to.row === r2 && this.to.col === c2)) {
            out.push(this._createCellCoords(r2, c2));
          }
        }
      }
      return out;
    }
    /**
     * Get all selected cell coords defined by this range.
     *
     * @returns {Array}
     */
  }, {
    key: "getAll",
    value: function getAll2() {
      var topStart = this.getOuterTopStartCorner();
      var bottomEnd = this.getOuterBottomEndCorner();
      var out = [];
      for (var r2 = topStart.row; r2 <= bottomEnd.row; r2++) {
        for (var c2 = topStart.col; c2 <= bottomEnd.col; c2++) {
          if (topStart.row === r2 && topStart.col === c2) {
            out.push(topStart);
          } else if (bottomEnd.row === r2 && bottomEnd.col === c2) {
            out.push(bottomEnd);
          } else {
            out.push(this._createCellCoords(r2, c2));
          }
        }
      }
      return out;
    }
    /**
     * Runs a callback function against all cells in the range. You can break the iteration by returning
     * `false` in the callback function.
     *
     * @param {Function} callback The callback function.
     */
  }, {
    key: "forAll",
    value: function forAll(callback) {
      var topStart = this.getOuterTopStartCorner();
      var bottomEnd = this.getOuterBottomEndCorner();
      for (var r2 = topStart.row; r2 <= bottomEnd.row; r2++) {
        for (var c2 = topStart.col; c2 <= bottomEnd.col; c2++) {
          var breakIteration = callback(r2, c2);
          if (breakIteration === false) {
            return;
          }
        }
      }
    }
    /**
     * Clones the range coordinates.
     *
     * @returns {CellRange}
     */
  }, {
    key: "clone",
    value: function clone2() {
      return new CellRange2(this.highlight, this.from, this.to, _classPrivateFieldGet$a(this, _isRtl));
    }
    /**
     * Convert CellRange to literal object.
     *
     * @returns {object} Returns a literal object with `from` and `to` properties which each of that object
     *                  contains `row` and `col` keys.
     */
  }, {
    key: "toObject",
    value: function toObject2() {
      return {
        from: this.from.toObject(),
        to: this.to.toObject()
      };
    }
    /**
     * Creates and returns a new instance of the CellCoords object. The object automatically inherits
     * the LTR/RTL flag from this CellRange instance.
     *
     * @private
     * @param {number} row The row index.
     * @param {number} column The column index.
     * @returns {CellCoords}
     */
  }, {
    key: "_createCellCoords",
    value: function _createCellCoords(row, column) {
      return new CellCoords$1(row, column, _classPrivateFieldGet$a(this, _isRtl));
    }
  }]);
  return CellRange2;
}();
const CellRange$1 = CellRange;
var $$a = _export;
var setPrototypeOf = objectSetPrototypeOf;
$$a({ target: "Object", stat: true }, {
  setPrototypeOf
});
var uncurryThis$6 = functionUncurryThis;
var aCallable = aCallable$6;
var isObject$2 = isObject$n;
var hasOwn$1 = hasOwnProperty_1;
var arraySlice = arraySlice$8;
var NATIVE_BIND = functionBindNative;
var $Function = Function;
var concat$1 = uncurryThis$6([].concat);
var join2 = uncurryThis$6([].join);
var factories = {};
var construct = function(C, argsLength, args) {
  if (!hasOwn$1(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++)
      list[i] = "a[" + i + "]";
    factories[argsLength] = $Function("C,a", "return new C(" + join2(list, ",") + ")");
  }
  return factories[argsLength](C, args);
};
var functionBind = NATIVE_BIND ? $Function.bind : function bind(that) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound() {
    var args = concat$1(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject$2(Prototype))
    boundFunction.prototype = Prototype;
  return boundFunction;
};
var $$9 = _export;
var getBuiltIn = getBuiltIn$a;
var apply = functionApply;
var bind2 = functionBind;
var aConstructor = aConstructor$2;
var anObject$2 = anObject$l;
var isObject$1 = isObject$n;
var create3 = objectCreate;
var fails$4 = fails$G;
var nativeConstruct = getBuiltIn("Reflect", "construct");
var ObjectPrototype = Object.prototype;
var push$1 = [].push;
var NEW_TARGET_BUG = fails$4(function() {
  function F() {
  }
  return !(nativeConstruct(function() {
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails$4(function() {
  nativeConstruct(function() {
  });
});
var FORCED$2 = NEW_TARGET_BUG || ARGS_BUG;
$$9({ target: "Reflect", stat: true, forced: FORCED$2, sham: FORCED$2 }, {
  construct: function construct2(Target, args) {
    aConstructor(Target);
    anObject$2(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG)
      return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      var $args = [null];
      apply(push$1, $args, args);
      return new (apply(bind2, Target, $args))();
    }
    var proto = newTarget.prototype;
    var instance = create3(isObject$1(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject$1(result) ? result : instance;
  }
});
function _classCallCheck$2D(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2D(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2D(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2D(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2D(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var privatePool$j = /* @__PURE__ */ new WeakMap();
var Event$1 = /* @__PURE__ */ function() {
  function Event2(facadeGetter, domBindings, wtSettings, eventManager, wtTable, selections) {
    var parent = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
    _classCallCheck$2D(this, Event2);
    this.wtSettings = wtSettings;
    this.domBindings = domBindings;
    this.wtTable = wtTable;
    this.selections = selections;
    this.parent = parent;
    this.eventManager = eventManager;
    this.facadeGetter = facadeGetter;
    privatePool$j.set(this, {
      selectedCellBeforeTouchEnd: void 0,
      dblClickTimeout: [null, null],
      dblClickOrigin: [null, null]
    });
    this.registerEvents();
  }
  _createClass$2D(Event2, [{
    key: "registerEvents",
    value: function registerEvents2() {
      var _this = this;
      this.eventManager.addEventListener(this.wtTable.holder, "contextmenu", function(event2) {
        return _this.onContextMenu(event2);
      });
      this.eventManager.addEventListener(this.wtTable.TABLE, "mouseover", function(event2) {
        return _this.onMouseOver(event2);
      });
      this.eventManager.addEventListener(this.wtTable.TABLE, "mouseout", function(event2) {
        return _this.onMouseOut(event2);
      });
      var initTouchEvents = function initTouchEvents2() {
        _this.eventManager.addEventListener(_this.wtTable.holder, "touchstart", function(event2) {
          return _this.onTouchStart(event2);
        });
        _this.eventManager.addEventListener(_this.wtTable.holder, "touchend", function(event2) {
          return _this.onTouchEnd(event2);
        });
        if (!_this.momentumScrolling) {
          _this.momentumScrolling = {};
        }
        _this.eventManager.addEventListener(_this.wtTable.holder, "scroll", function() {
          clearTimeout(_this.momentumScrolling._timeout);
          if (!_this.momentumScrolling.ongoing) {
            _this.wtSettings.getSetting("onBeforeTouchScroll");
          }
          _this.momentumScrolling.ongoing = true;
          _this.momentumScrolling._timeout = setTimeout(function() {
            if (!_this.touchApplied) {
              _this.momentumScrolling.ongoing = false;
              _this.wtSettings.getSetting("onAfterMomentumScroll");
            }
          }, 200);
        });
      };
      var initMouseEvents = function initMouseEvents2() {
        _this.eventManager.addEventListener(_this.wtTable.holder, "mouseup", function(event2) {
          return _this.onMouseUp(event2);
        });
        _this.eventManager.addEventListener(_this.wtTable.holder, "mousedown", function(event2) {
          return _this.onMouseDown(event2);
        });
      };
      if (isMobileBrowser()) {
        initTouchEvents();
      } else {
        if (isTouchSupported()) {
          initTouchEvents();
        }
        initMouseEvents();
      }
    }
    /**
     * Checks if an element is already selected.
     *
     * @private
     * @param {Element} touchTarget An element to check.
     * @returns {boolean}
     */
  }, {
    key: "selectedCellWasTouched",
    value: function selectedCellWasTouched(touchTarget) {
      var priv = privatePool$j.get(this);
      var cellUnderFinger = this.parentCell(touchTarget);
      var coordsOfCellUnderFinger = cellUnderFinger.coords;
      if (priv.selectedCellBeforeTouchEnd && coordsOfCellUnderFinger) {
        var _ref2 = [coordsOfCellUnderFinger.row, priv.selectedCellBeforeTouchEnd.from.row], rowTouched = _ref2[0], rowSelected = _ref2[1];
        var _ref22 = [coordsOfCellUnderFinger.col, priv.selectedCellBeforeTouchEnd.from.col], colTouched = _ref22[0], colSelected = _ref22[1];
        return rowTouched === rowSelected && colTouched === colSelected;
      }
      return false;
    }
    /**
     * Gets closest TD or TH element.
     *
     * @private
     * @param {Element} elem An element from the traversing starts.
     * @returns {object} Contains coordinates and reference to TD or TH if it exists. Otherwise it's empty object.
     */
  }, {
    key: "parentCell",
    value: function parentCell(elem) {
      var cell = {};
      var TABLE = this.wtTable.TABLE;
      var TD = closestDown(elem, ["TD", "TH"], TABLE);
      if (TD) {
        cell.coords = this.wtTable.getCoords(TD);
        cell.TD = TD;
      } else if (hasClass(elem, "wtBorder") && hasClass(elem, "current")) {
        cell.coords = this.selections.getCell().cellRange.highlight;
        cell.TD = this.wtTable.getCell(cell.coords);
      } else if (hasClass(elem, "wtBorder") && hasClass(elem, "area")) {
        if (this.selections.createOrGetArea().cellRange) {
          cell.coords = this.selections.createOrGetArea().cellRange.to;
          cell.TD = this.wtTable.getCell(cell.coords);
        }
      }
      return cell;
    }
    /**
     * OnMouseDown callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      var priv = privatePool$j.get(this);
      var activeElement = this.domBindings.rootDocument.activeElement;
      var getParentNode = partial(getParent, event2.target);
      var realTarget = event2.target;
      if (realTarget === activeElement || getParentNode(0) === activeElement || getParentNode(1) === activeElement) {
        return;
      }
      var cell = this.parentCell(realTarget);
      if (hasClass(realTarget, "corner")) {
        this.wtSettings.getSetting("onCellCornerMouseDown", event2, realTarget);
      } else if (cell.TD && this.wtSettings.has("onCellMouseDown")) {
        this.callListener("onCellMouseDown", event2, cell.coords, cell.TD);
      }
      if ((event2.button === 0 || this.touchApplied) && cell.TD) {
        priv.dblClickOrigin[0] = cell.TD;
        clearTimeout(priv.dblClickTimeout[0]);
        priv.dblClickTimeout[0] = setTimeout(function() {
          priv.dblClickOrigin[0] = null;
        }, 1e3);
      }
    }
    /**
     * OnContextMenu callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onContextMenu",
    value: function onContextMenu(event2) {
      if (this.wtSettings.has("onCellContextMenu")) {
        var cell = this.parentCell(event2.target);
        if (cell.TD) {
          this.callListener("onCellContextMenu", event2, cell.coords, cell.TD);
        }
      }
    }
    /**
     * OnMouseOver callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      if (!this.wtSettings.has("onCellMouseOver")) {
        return;
      }
      var table = this.wtTable.TABLE;
      var td = closestDown(event2.target, ["TD", "TH"], table);
      var parent = this.parent || this;
      if (td && td !== parent.lastMouseOver && isChildOf(td, table)) {
        parent.lastMouseOver = td;
        this.callListener("onCellMouseOver", event2, this.wtTable.getCoords(td), td);
      }
    }
    /**
     * OnMouseOut callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onMouseOut",
    value: function onMouseOut(event2) {
      if (!this.wtSettings.has("onCellMouseOut")) {
        return;
      }
      var table = this.wtTable.TABLE;
      var lastTD = closestDown(event2.target, ["TD", "TH"], table);
      var nextTD = closestDown(event2.relatedTarget, ["TD", "TH"], table);
      if (lastTD && lastTD !== nextTD && isChildOf(lastTD, table)) {
        this.callListener("onCellMouseOut", event2, this.wtTable.getCoords(lastTD), lastTD);
      }
    }
    /**
     * OnMouseUp callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2(event2) {
      var priv = privatePool$j.get(this);
      var cell = this.parentCell(event2.target);
      if (cell.TD && this.wtSettings.has("onCellMouseUp")) {
        this.callListener("onCellMouseUp", event2, cell.coords, cell.TD);
      }
      if (event2.button !== 0 && !this.touchApplied) {
        return;
      }
      if (cell.TD === priv.dblClickOrigin[0] && cell.TD === priv.dblClickOrigin[1]) {
        if (hasClass(event2.target, "corner")) {
          this.callListener("onCellCornerDblClick", event2, cell.coords, cell.TD);
        } else {
          this.callListener("onCellDblClick", event2, cell.coords, cell.TD);
        }
        priv.dblClickOrigin[0] = null;
        priv.dblClickOrigin[1] = null;
      } else if (cell.TD === priv.dblClickOrigin[0]) {
        priv.dblClickOrigin[1] = cell.TD;
        clearTimeout(priv.dblClickTimeout[1]);
        priv.dblClickTimeout[1] = setTimeout(function() {
          priv.dblClickOrigin[1] = null;
        }, 500);
      }
    }
    /**
     * OnTouchStart callback. Simulates mousedown event.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onTouchStart",
    value: function onTouchStart(event2) {
      var priv = privatePool$j.get(this);
      priv.selectedCellBeforeTouchEnd = this.selections.getCell().cellRange;
      this.touchApplied = true;
      this.onMouseDown(event2);
    }
    /**
     * OnTouchEnd callback. Simulates mouseup event.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd(event2) {
      var _this$parentCell;
      var target = event2.target;
      var parentCellCoords = (_this$parentCell = this.parentCell(target)) === null || _this$parentCell === void 0 ? void 0 : _this$parentCell.coords;
      var isCellsRange = isDefined(parentCellCoords) && parentCellCoords.row >= 0 && parentCellCoords.col >= 0;
      var isEventCancelable = event2.cancelable && isCellsRange && this.wtSettings.getSetting("isDataViewInstance");
      if (isEventCancelable) {
        var interactiveElements = ["A", "BUTTON", "INPUT"];
        if (isIOS() && (isChromeWebKit() || isFirefoxWebKit()) && this.selectedCellWasTouched(target) && !interactiveElements.includes(target.tagName)) {
          event2.preventDefault();
        } else if (!this.selectedCellWasTouched(target)) {
          event2.preventDefault();
        }
      }
      this.onMouseUp(event2);
      this.touchApplied = false;
    }
    /**
     * Call listener with backward compatibility.
     *
     * @private
     * @param {string} name Name of listener.
     * @param {MouseEvent} event The event object.
     * @param {CellCoords} coords Coordinates.
     * @param {HTMLElement} target Event target.
     */
  }, {
    key: "callListener",
    value: function callListener(name, event2, coords, target) {
      var listener2 = this.wtSettings.getSettingPure(name);
      if (listener2) {
        listener2(event2, coords, target, this.facadeGetter());
      }
    }
    /**
     * Clears double-click timeouts and destroys the internal eventManager instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var priv = privatePool$j.get(this);
      clearTimeout(priv.dblClickTimeout[0]);
      clearTimeout(priv.dblClickTimeout[1]);
      this.eventManager.destroy();
    }
  }]);
  return Event2;
}();
const Event$2 = Event$1;
function _classCallCheck$2C(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2C(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2C(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2C(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2C(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ColumnFilter = /* @__PURE__ */ function() {
  function ColumnFilter2(offset2, total, countTH) {
    _classCallCheck$2C(this, ColumnFilter2);
    this.offset = offset2;
    this.total = total;
    this.countTH = countTH;
  }
  _createClass$2C(ColumnFilter2, [{
    key: "offsetted",
    value: function offsetted(index2) {
      return index2 + this.offset;
    }
    /**
     * @param {number} index The visual column index.
     * @returns {number}
     */
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index2) {
      return index2 - this.offset;
    }
    /**
     * @param {number} index The visual column index.
     * @returns {number}
     */
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index2) {
      return this.offsetted(index2);
    }
    /**
     * @param {number} index The visual column index.
     * @returns {number}
     */
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index2) {
      return this.unOffsetted(index2);
    }
    /**
     * @param {number} index The visual column index.
     * @returns {number}
     */
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index2) {
      return index2 - this.countTH;
    }
    /**
     * @param {number} index The visual column index.
     * @returns {number}
     */
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index2) {
      return index2 + this.countTH;
    }
    /**
     * @param {number} index The visual column index.
     * @returns {number}
     */
  }, {
    key: "visibleRowHeadedColumnToSourceColumn",
    value: function visibleRowHeadedColumnToSourceColumn(index2) {
      return this.renderedToSource(this.offsettedTH(index2));
    }
    /**
     * @param {number} index The visual column index.
     * @returns {number}
     */
  }, {
    key: "sourceColumnToVisibleRowHeadedColumn",
    value: function sourceColumnToVisibleRowHeadedColumn(index2) {
      return this.unOffsettedTH(this.sourceToRendered(index2));
    }
  }]);
  return ColumnFilter2;
}();
const ColumnFilter$1 = ColumnFilter;
function _classCallCheck$2B(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2B(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2B(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2B(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2B(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var RowFilter = /* @__PURE__ */ function() {
  function RowFilter2(offset2, total, countTH) {
    _classCallCheck$2B(this, RowFilter2);
    this.offset = offset2;
    this.total = total;
    this.countTH = countTH;
  }
  _createClass$2B(RowFilter2, [{
    key: "offsetted",
    value: function offsetted(index2) {
      return index2 + this.offset;
    }
    /**
     * @param {number} index The visual row index.
     * @returns {number}
     */
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index2) {
      return index2 - this.offset;
    }
    /**
     * @param {number} index The visual row index.
     * @returns {number}
     */
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index2) {
      return this.offsetted(index2);
    }
    /**
     * @param {number} index The visual row index.
     * @returns {number}
     */
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index2) {
      return this.unOffsetted(index2);
    }
    /**
     * @param {number} index The visual row index.
     * @returns {number}
     */
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index2) {
      return index2 - this.countTH;
    }
    /**
     * @param {number} index The visual row index.
     * @returns {number}
     */
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index2) {
      return index2 + this.countTH;
    }
    /**
     * @param {number} index The visual row index.
     * @returns {number}
     */
  }, {
    key: "visibleColHeadedRowToSourceRow",
    value: function visibleColHeadedRowToSourceRow(index2) {
      return this.renderedToSource(this.offsettedTH(index2));
    }
    /**
     * @param {number} index The visual row index.
     * @returns {number}
     */
  }, {
    key: "sourceRowToVisibleColHeadedRow",
    value: function sourceRowToVisibleColHeadedRow(index2) {
      return this.unOffsettedTH(this.sourceToRendered(index2));
    }
  }]);
  return RowFilter2;
}();
const RowFilter$1 = RowFilter;
var WORKING_SPACE_ALL = 0;
var WORKING_SPACE_TOP = 1;
var WORKING_SPACE_BOTTOM = 2;
function _classCallCheck$2A(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2A(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2A(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2A(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2A(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ViewSize = /* @__PURE__ */ function() {
  function ViewSize2() {
    _classCallCheck$2A(this, ViewSize2);
    this.currentSize = 0;
    this.nextSize = 0;
    this.currentOffset = 0;
    this.nextOffset = 0;
  }
  _createClass$2A(ViewSize2, [{
    key: "setSize",
    value: function setSize(size) {
      this.currentSize = this.nextSize;
      this.nextSize = size;
    }
    /**
     * Sets new offset.
     *
     * @param {number} offset The offset.
     */
  }, {
    key: "setOffset",
    value: function setOffset(offset2) {
      this.currentOffset = this.nextOffset;
      this.nextOffset = offset2;
    }
  }]);
  return ViewSize2;
}();
function _classCallCheck$2z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2z(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ViewSizeSet = /* @__PURE__ */ function() {
  function ViewSizeSet2() {
    _classCallCheck$2z(this, ViewSizeSet2);
    this.size = new ViewSize();
    this.workingSpace = WORKING_SPACE_ALL;
    this.sharedSize = null;
  }
  _createClass$2z(ViewSizeSet2, [{
    key: "setSize",
    value: function setSize(size) {
      this.size.setSize(size);
    }
    /**
     * Sets the offset for rendered elements. The offset describes the shift between 0 and
     * the first rendered element according to the scroll position.
     *
     * @param {number} offset The offset.
     */
  }, {
    key: "setOffset",
    value: function setOffset(offset2) {
      this.size.setOffset(offset2);
    }
    /**
     * Returns ViewSize instance.
     *
     * @returns {ViewSize}
     */
  }, {
    key: "getViewSize",
    value: function getViewSize() {
      return this.size;
    }
    /**
     * Checks if this ViewSizeSet is sharing the size with another instance.
     *
     * @returns {boolean}
     */
  }, {
    key: "isShared",
    value: function isShared() {
      return this.sharedSize instanceof ViewSize;
    }
    /**
     * Checks what working space describes this size instance.
     *
     * @param {number} workingSpace The number which describes the type of the working space (see constants.js).
     * @returns {boolean}
     */
  }, {
    key: "isPlaceOn",
    value: function isPlaceOn(workingSpace) {
      return this.workingSpace === workingSpace;
    }
    /**
     * Appends the ViewSizeSet instance to this instance that turns it into a shared mode.
     *
     * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet class.
     */
  }, {
    key: "append",
    value: function append(viewSize) {
      this.workingSpace = WORKING_SPACE_TOP;
      viewSize.workingSpace = WORKING_SPACE_BOTTOM;
      this.sharedSize = viewSize.getViewSize();
    }
    /**
     * Prepends the ViewSize instance to this instance that turns it into a shared mode.
     *
     * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet class.
     */
  }, {
    key: "prepend",
    value: function prepend(viewSize) {
      this.workingSpace = WORKING_SPACE_BOTTOM;
      viewSize.workingSpace = WORKING_SPACE_TOP;
      this.sharedSize = viewSize.getViewSize();
    }
  }]);
  return ViewSizeSet2;
}();
function _classCallCheck$2y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2y(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var OrderView = /* @__PURE__ */ function() {
  function OrderView2(rootNode, nodesPool, childNodeType) {
    _classCallCheck$2y(this, OrderView2);
    this.rootNode = rootNode;
    this.nodesPool = nodesPool;
    this.sizeSet = new ViewSizeSet();
    this.childNodeType = childNodeType.toUpperCase();
    this.visualIndex = 0;
    this.collectedNodes = [];
  }
  _createClass$2y(OrderView2, [{
    key: "setSize",
    value: function setSize(size) {
      this.sizeSet.setSize(size);
      return this;
    }
    /**
     * Sets the offset for rendered elements. The offset describes the shift between 0 and
     * the first rendered element according to the scroll position.
     *
     * @param {number} offset The offset.
     * @returns {OrderView}
     */
  }, {
    key: "setOffset",
    value: function setOffset(offset2) {
      this.sizeSet.setOffset(offset2);
      return this;
    }
    /**
     * Checks if this instance of the view shares the root node with another instance. This happens only once when
     * a row (TR) as a root node is managed by two OrderView instances. If this happens another DOM injection
     * algorithm is performed to achieve consistent order.
     *
     * @returns {boolean}
     */
  }, {
    key: "isSharedViewSet",
    value: function isSharedViewSet() {
      return this.sizeSet.isShared();
    }
    /**
     * Returns rendered DOM element based on visual index.
     *
     * @param {number} visualIndex The visual index.
     * @returns {HTMLElement}
     */
  }, {
    key: "getNode",
    value: function getNode(visualIndex) {
      return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;
    }
    /**
     * Returns currently processed DOM element.
     *
     * @returns {HTMLElement}
     */
  }, {
    key: "getCurrentNode",
    value: function getCurrentNode() {
      var length = this.collectedNodes.length;
      return length > 0 ? this.collectedNodes[length - 1] : null;
    }
    /**
     * Returns rendered child count for this instance.
     *
     * @returns {number}
     */
  }, {
    key: "getRenderedChildCount",
    value: function getRenderedChildCount() {
      var rootNode = this.rootNode, sizeSet = this.sizeSet;
      var childElementCount = 0;
      if (this.isSharedViewSet()) {
        var element = rootNode.firstElementChild;
        while (element) {
          if (element.tagName === this.childNodeType) {
            childElementCount += 1;
          } else if (sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {
            break;
          }
          element = element.nextElementSibling;
        }
      } else {
        childElementCount = rootNode.childElementCount;
      }
      return childElementCount;
    }
    /**
     * Setups and prepares all necessary properties and start the rendering process.
     * This method has to be called only once (at the start) for the render cycle.
     */
  }, {
    key: "start",
    value: function start() {
      this.collectedNodes.length = 0;
      this.visualIndex = 0;
      var rootNode = this.rootNode, sizeSet = this.sizeSet;
      var isShared = this.isSharedViewSet();
      var _sizeSet$getViewSize = sizeSet.getViewSize(), nextSize = _sizeSet$getViewSize.nextSize;
      var childElementCount = this.getRenderedChildCount();
      while (childElementCount < nextSize) {
        var newNode = this.nodesPool();
        if (!isShared || isShared && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {
          rootNode.appendChild(newNode);
        } else {
          rootNode.insertBefore(newNode, rootNode.firstChild);
        }
        childElementCount += 1;
      }
      var isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(WORKING_SPACE_TOP);
      while (childElementCount > nextSize) {
        rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);
        childElementCount -= 1;
      }
    }
    /**
     * Renders the DOM element based on visual index (which is calculated internally).
     * This method has to be called as many times as the size count is met (to cover all previously rendered DOM elements).
     */
  }, {
    key: "render",
    value: function render() {
      var rootNode = this.rootNode, sizeSet = this.sizeSet;
      var visualIndex = this.visualIndex;
      if (this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {
        visualIndex += sizeSet.sharedSize.nextSize;
      }
      var node = rootNode.childNodes[visualIndex];
      if (node.tagName !== this.childNodeType) {
        var newNode = this.nodesPool();
        rootNode.replaceChild(newNode, node);
        node = newNode;
      }
      this.collectedNodes.push(node);
      this.visualIndex += 1;
    }
    /**
     * Ends the render process.
     * This method has to be called only once (at the end) for the render cycle.
     */
  }, {
    key: "end",
    value: function end() {
    }
  }]);
  return OrderView2;
}();
function _typeof$1y(obj) {
  "@babel/helpers - typeof";
  return _typeof$1y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1y(obj);
}
function _classCallCheck$2x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2x(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2x(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2x(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1q(subClass, superClass);
}
function _setPrototypeOf$1q(o, p2) {
  _setPrototypeOf$1q = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1q(o, p2);
}
function _createSuper$1p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1p(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1p(this, result);
  };
}
function _possibleConstructorReturn$1p(self2, call2) {
  if (call2 && (_typeof$1y(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1p(self2);
}
function _assertThisInitialized$1p(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1p(o) {
  _getPrototypeOf$1p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1p(o);
}
var SharedOrderView = /* @__PURE__ */ function(_OrderView) {
  _inherits$1p(SharedOrderView2, _OrderView);
  var _super = _createSuper$1p(SharedOrderView2);
  function SharedOrderView2() {
    _classCallCheck$2x(this, SharedOrderView2);
    return _super.apply(this, arguments);
  }
  _createClass$2x(SharedOrderView2, [{
    key: "prependView",
    value: (
      /**
       * The method results in merging external order view into the current order. This happens only for order views which
       * operate on the same root node.
       *
       * In the table, there is only one scenario when this happens. TR root element
       * has a common root node with cells order view and row headers order view. Both classes have to share
       * information about their order sizes to make proper diff calculations.
       *
       * @param {OrderView} orderView The order view to merging with. The view will be added at the beginning of the list.
       * @returns {SharedOrderView}
       */
      function prependView(orderView) {
        this.sizeSet.prepend(orderView.sizeSet);
        orderView.sizeSet.append(this.sizeSet);
        return this;
      }
    )
    /**
     * The method results in merging external order view into the current order. This happens only for order views which
     * operate on the same root node.
     *
     * In the table, there is only one scenario when this happens. TR root element
     * has a common root node with cells order view and row headers order view. Both classes have to share
     * information about their order sizes to make proper diff calculations.
     *
     * @param {OrderView} orderView The order view to merging with. The view will be added at the end of the list.
     * @returns {SharedOrderView}
     */
  }, {
    key: "appendView",
    value: function appendView(orderView) {
      this.sizeSet.append(orderView.sizeSet);
      orderView.sizeSet.prepend(this.sizeSet);
      return this;
    }
  }]);
  return SharedOrderView2;
}(OrderView);
function _classCallCheck$2w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2w(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var NodesPool = /* @__PURE__ */ function() {
  function NodesPool2(nodeType) {
    _classCallCheck$2w(this, NodesPool2);
    this.nodeType = nodeType.toUpperCase();
  }
  _createClass$2w(NodesPool2, [{
    key: "setRootDocument",
    value: function setRootDocument(rootDocument) {
      this.rootDocument = rootDocument;
    }
    /**
     * Obtains an element. The returned elements in the feature can be cached.
     *
     * @returns {HTMLElement}
     */
  }, {
    key: "obtain",
    value: function obtain() {
      return this.rootDocument.createElement(this.nodeType);
    }
  }]);
  return NodesPool2;
}();
function _classCallCheck$2v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2v(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var BaseRenderer = /* @__PURE__ */ function() {
  function BaseRenderer2(nodeType, rootNode) {
    _classCallCheck$2v(this, BaseRenderer2);
    this.nodesPool = typeof nodeType === "string" ? new NodesPool(nodeType) : null;
    this.nodeType = nodeType;
    this.rootNode = rootNode;
    this.table = null;
    this.renderedNodes = 0;
  }
  _createClass$2v(BaseRenderer2, [{
    key: "setTable",
    value: function setTable(table) {
      if (this.nodesPool) {
        this.nodesPool.setRootDocument(table.rootDocument);
      }
      this.table = table;
    }
    /**
     * Adjusts the number of rendered nodes.
     */
  }, {
    key: "adjust",
    value: function adjust() {
    }
    /**
     * Renders the contents to the elements.
     */
  }, {
    key: "render",
    value: function render() {
    }
  }]);
  return BaseRenderer2;
}();
function _typeof$1x(obj) {
  "@babel/helpers - typeof";
  return _typeof$1x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1x(obj);
}
function _classCallCheck$2u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2u(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1p(subClass, superClass);
}
function _setPrototypeOf$1p(o, p2) {
  _setPrototypeOf$1p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1p(o, p2);
}
function _createSuper$1o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1o(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1o(this, result);
  };
}
function _possibleConstructorReturn$1o(self2, call2) {
  if (call2 && (_typeof$1x(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1o(self2);
}
function _assertThisInitialized$1o(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1o(o) {
  _getPrototypeOf$1o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1o(o);
}
var RowHeadersRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$1o(RowHeadersRenderer2, _BaseRenderer);
  var _super = _createSuper$1o(RowHeadersRenderer2);
  function RowHeadersRenderer2() {
    var _this;
    _classCallCheck$2u(this, RowHeadersRenderer2);
    _this = _super.call(this, "TH");
    _this.orderViews = /* @__PURE__ */ new WeakMap();
    _this.sourceRowIndex = 0;
    return _this;
  }
  _createClass$2u(RowHeadersRenderer2, [{
    key: "obtainOrderView",
    value: function obtainOrderView(rootNode) {
      var _this2 = this;
      var orderView;
      if (this.orderViews.has(rootNode)) {
        orderView = this.orderViews.get(rootNode);
      } else {
        orderView = new SharedOrderView(rootNode, function(sourceColumnIndex) {
          return _this2.nodesPool.obtain(_this2.sourceRowIndex, sourceColumnIndex);
        }, this.nodeType);
        this.orderViews.set(rootNode, orderView);
      }
      return orderView;
    }
    /**
     * Renders the cells.
     */
  }, {
    key: "render",
    value: function render() {
      var _this$table = this.table, rowsToRender = _this$table.rowsToRender, rowHeaderFunctions = _this$table.rowHeaderFunctions, rowHeadersCount = _this$table.rowHeadersCount, rows = _this$table.rows, cells = _this$table.cells;
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        var sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
        var TR = rows.getRenderedNode(visibleRowIndex);
        this.sourceRowIndex = sourceRowIndex;
        var orderView = this.obtainOrderView(TR);
        var cellsView = cells.obtainOrderView(TR);
        orderView.appendView(cellsView).setSize(rowHeadersCount).setOffset(this.table.renderedColumnToSource(0)).start();
        for (var visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
          orderView.render();
          var TH = orderView.getCurrentNode();
          TH.className = "";
          TH.removeAttribute("style");
          rowHeaderFunctions[visibleColumnIndex](sourceRowIndex, TH, visibleColumnIndex);
        }
        orderView.end();
      }
    }
  }]);
  return RowHeadersRenderer2;
}(BaseRenderer);
function _typeof$1w(obj) {
  "@babel/helpers - typeof";
  return _typeof$1w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1w(obj);
}
function _classCallCheck$2t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2t(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1o(subClass, superClass);
}
function _setPrototypeOf$1o(o, p2) {
  _setPrototypeOf$1o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1o(o, p2);
}
function _createSuper$1n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1n(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1n(this, result);
  };
}
function _possibleConstructorReturn$1n(self2, call2) {
  if (call2 && (_typeof$1w(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1n(self2);
}
function _assertThisInitialized$1n(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1n(o) {
  _getPrototypeOf$1n = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1n(o);
}
var ColumnHeadersRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$1n(ColumnHeadersRenderer2, _BaseRenderer);
  var _super = _createSuper$1n(ColumnHeadersRenderer2);
  function ColumnHeadersRenderer2(rootNode) {
    _classCallCheck$2t(this, ColumnHeadersRenderer2);
    return _super.call(this, null, rootNode);
  }
  _createClass$2t(ColumnHeadersRenderer2, [{
    key: "adjust",
    value: function adjust() {
      var _this$table = this.table, columnHeadersCount = _this$table.columnHeadersCount, rowHeadersCount = _this$table.rowHeadersCount;
      var TR = this.rootNode.firstChild;
      if (columnHeadersCount) {
        var columnsToRender = this.table.columnsToRender;
        var allColumnsToRender = columnsToRender + rowHeadersCount;
        for (var i = 0, len = columnHeadersCount; i < len; i++) {
          TR = this.rootNode.childNodes[i];
          if (!TR) {
            TR = this.table.rootDocument.createElement("tr");
            this.rootNode.appendChild(TR);
          }
          this.renderedNodes = TR.childNodes.length;
          while (this.renderedNodes < allColumnsToRender) {
            TR.appendChild(this.table.rootDocument.createElement("th"));
            this.renderedNodes += 1;
          }
          while (this.renderedNodes > allColumnsToRender) {
            TR.removeChild(TR.lastChild);
            this.renderedNodes -= 1;
          }
        }
        var theadChildrenLength = this.rootNode.childNodes.length;
        if (theadChildrenLength > columnHeadersCount) {
          for (var _i = columnHeadersCount; _i < theadChildrenLength; _i++) {
            this.rootNode.removeChild(this.rootNode.lastChild);
          }
        }
      } else if (TR) {
        empty(TR);
      }
    }
    /**
     * Renders the TH elements.
     */
  }, {
    key: "render",
    value: function render() {
      var columnHeadersCount = this.table.columnHeadersCount;
      for (var rowHeaderIndex = 0; rowHeaderIndex < columnHeadersCount; rowHeaderIndex += 1) {
        var _this$table2 = this.table, columnHeaderFunctions = _this$table2.columnHeaderFunctions, columnsToRender = _this$table2.columnsToRender, rowHeadersCount = _this$table2.rowHeadersCount;
        var TR = this.rootNode.childNodes[rowHeaderIndex];
        for (var renderedColumnIndex = -1 * rowHeadersCount; renderedColumnIndex < columnsToRender; renderedColumnIndex += 1) {
          var sourceColumnIndex = this.table.renderedColumnToSource(renderedColumnIndex);
          var TH = TR.childNodes[renderedColumnIndex + rowHeadersCount];
          TH.className = "";
          TH.removeAttribute("style");
          columnHeaderFunctions[rowHeaderIndex](sourceColumnIndex, TH, rowHeaderIndex);
        }
      }
    }
  }]);
  return ColumnHeadersRenderer2;
}(BaseRenderer);
function _typeof$1v(obj) {
  "@babel/helpers - typeof";
  return _typeof$1v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1v(obj);
}
function _classCallCheck$2s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2s(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1n(subClass, superClass);
}
function _setPrototypeOf$1n(o, p2) {
  _setPrototypeOf$1n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1n(o, p2);
}
function _createSuper$1m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1m(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1m(this, result);
  };
}
function _possibleConstructorReturn$1m(self2, call2) {
  if (call2 && (_typeof$1v(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1m(self2);
}
function _assertThisInitialized$1m(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1m(o) {
  _getPrototypeOf$1m = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1m(o);
}
var ColGroupRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$1m(ColGroupRenderer2, _BaseRenderer);
  var _super = _createSuper$1m(ColGroupRenderer2);
  function ColGroupRenderer2(rootNode) {
    _classCallCheck$2s(this, ColGroupRenderer2);
    return _super.call(this, null, rootNode);
  }
  _createClass$2s(ColGroupRenderer2, [{
    key: "adjust",
    value: function adjust() {
      var _this$table = this.table, columnsToRender = _this$table.columnsToRender, rowHeadersCount = _this$table.rowHeadersCount;
      var allColumnsToRender = columnsToRender + rowHeadersCount;
      while (this.renderedNodes < allColumnsToRender) {
        this.rootNode.appendChild(this.table.rootDocument.createElement("col"));
        this.renderedNodes += 1;
      }
      while (this.renderedNodes > allColumnsToRender) {
        this.rootNode.removeChild(this.rootNode.lastChild);
        this.renderedNodes -= 1;
      }
    }
    /**
     * Renders the col group elements.
     */
  }, {
    key: "render",
    value: function render() {
      this.adjust();
      var _this$table2 = this.table, columnsToRender = _this$table2.columnsToRender, rowHeadersCount = _this$table2.rowHeadersCount;
      for (var visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
        var sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
        var width = this.table.columnUtils.getHeaderWidth(sourceColumnIndex);
        this.rootNode.childNodes[visibleColumnIndex].style.width = "".concat(width, "px");
      }
      for (var _visibleColumnIndex = 0; _visibleColumnIndex < columnsToRender; _visibleColumnIndex++) {
        var _sourceColumnIndex = this.table.renderedColumnToSource(_visibleColumnIndex);
        var _width = this.table.columnUtils.getStretchedColumnWidth(_sourceColumnIndex);
        this.rootNode.childNodes[_visibleColumnIndex + rowHeadersCount].style.width = "".concat(_width, "px");
      }
      var firstChild = this.rootNode.firstChild;
      if (firstChild) {
        addClass(firstChild, "rowHeader");
      }
    }
  }]);
  return ColGroupRenderer2;
}(BaseRenderer);
function _typeof$1u(obj) {
  "@babel/helpers - typeof";
  return _typeof$1u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1u(obj);
}
var _templateObject$f;
function _taggedTemplateLiteral$f(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$2r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2r(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1m(subClass, superClass);
}
function _setPrototypeOf$1m(o, p2) {
  _setPrototypeOf$1m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1m(o, p2);
}
function _createSuper$1l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1l(this, result);
  };
}
function _possibleConstructorReturn$1l(self2, call2) {
  if (call2 && (_typeof$1u(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1l(self2);
}
function _assertThisInitialized$1l(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1l(o) {
  _getPrototypeOf$1l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1l(o);
}
var performanceWarningAppeared = false;
var RowsRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$1l(RowsRenderer2, _BaseRenderer);
  var _super = _createSuper$1l(RowsRenderer2);
  function RowsRenderer2(rootNode) {
    var _this;
    _classCallCheck$2r(this, RowsRenderer2);
    _this = _super.call(this, "TR", rootNode);
    _this.orderView = new OrderView(rootNode, function(sourceRowIndex) {
      return _this.nodesPool.obtain(sourceRowIndex);
    }, _this.nodeType);
    return _this;
  }
  _createClass$2r(RowsRenderer2, [{
    key: "getRenderedNode",
    value: function getRenderedNode(visualIndex) {
      return this.orderView.getNode(visualIndex);
    }
    /**
     * Renders the cells.
     */
  }, {
    key: "render",
    value: function render() {
      var rowsToRender = this.table.rowsToRender;
      if (!performanceWarningAppeared && rowsToRender > 1e3) {
        performanceWarningAppeared = true;
        warn$1(toSingleLine(_templateObject$f || (_templateObject$f = _taggedTemplateLiteral$f(['Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting \n        the number of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.'], ['Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting\\x20\n        the number of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.']))));
      }
      this.orderView.setSize(rowsToRender).setOffset(this.table.renderedRowToSource(0)).start();
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        this.orderView.render();
      }
      this.orderView.end();
    }
  }]);
  return RowsRenderer2;
}(BaseRenderer);
function _typeof$1t(obj) {
  "@babel/helpers - typeof";
  return _typeof$1t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1t(obj);
}
function _classCallCheck$2q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2q(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1l(subClass, superClass);
}
function _setPrototypeOf$1l(o, p2) {
  _setPrototypeOf$1l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1l(o, p2);
}
function _createSuper$1k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1k(this, result);
  };
}
function _possibleConstructorReturn$1k(self2, call2) {
  if (call2 && (_typeof$1t(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1k(self2);
}
function _assertThisInitialized$1k(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1k(o) {
  _getPrototypeOf$1k = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1k(o);
}
var CellsRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$1k(CellsRenderer2, _BaseRenderer);
  var _super = _createSuper$1k(CellsRenderer2);
  function CellsRenderer2() {
    var _this;
    _classCallCheck$2q(this, CellsRenderer2);
    _this = _super.call(this, "TD");
    _this.orderViews = /* @__PURE__ */ new WeakMap();
    _this.sourceRowIndex = 0;
    return _this;
  }
  _createClass$2q(CellsRenderer2, [{
    key: "obtainOrderView",
    value: function obtainOrderView(rootNode) {
      var _this2 = this;
      var orderView;
      if (this.orderViews.has(rootNode)) {
        orderView = this.orderViews.get(rootNode);
      } else {
        orderView = new SharedOrderView(rootNode, function(sourceColumnIndex) {
          return _this2.nodesPool.obtain(_this2.sourceRowIndex, sourceColumnIndex);
        }, this.nodeType);
        this.orderViews.set(rootNode, orderView);
      }
      return orderView;
    }
    /**
     * Renders the cells.
     */
  }, {
    key: "render",
    value: function render() {
      var _this$table = this.table, rowsToRender = _this$table.rowsToRender, columnsToRender = _this$table.columnsToRender, rows = _this$table.rows, rowHeaders = _this$table.rowHeaders;
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        var sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
        var TR = rows.getRenderedNode(visibleRowIndex);
        this.sourceRowIndex = sourceRowIndex;
        var orderView = this.obtainOrderView(TR);
        var rowHeadersView = rowHeaders.obtainOrderView(TR);
        orderView.prependView(rowHeadersView).setSize(columnsToRender).setOffset(this.table.renderedColumnToSource(0)).start();
        for (var visibleColumnIndex = 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {
          orderView.render();
          var TD = orderView.getCurrentNode();
          var sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
          if (!hasClass(TD, "hide")) {
            TD.className = "";
          }
          TD.removeAttribute("style");
          TD.removeAttribute("dir");
          this.table.cellRenderer(sourceRowIndex, sourceColumnIndex, TD);
        }
        orderView.end();
      }
    }
  }]);
  return CellsRenderer2;
}(BaseRenderer);
function _classCallCheck$2p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2p(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var TableRenderer = /* @__PURE__ */ function() {
  function TableRenderer2(rootNode) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, cellRenderer = _ref2.cellRenderer;
    _classCallCheck$2p(this, TableRenderer2);
    this.rootNode = rootNode;
    this.rootDocument = this.rootNode.ownerDocument;
    this.rowHeaders = null;
    this.columnHeaders = null;
    this.colGroup = null;
    this.rows = null;
    this.cells = null;
    this.rowFilter = null;
    this.columnFilter = null;
    this.rowUtils = null;
    this.columnUtils = null;
    this.rowsToRender = 0;
    this.columnsToRender = 0;
    this.rowHeaderFunctions = [];
    this.rowHeadersCount = 0;
    this.columnHeaderFunctions = [];
    this.columnHeadersCount = 0;
    this.cellRenderer = cellRenderer;
  }
  _createClass$2p(TableRenderer2, [{
    key: "setAxisUtils",
    value: function setAxisUtils(rowUtils, columnUtils) {
      this.rowUtils = rowUtils;
      this.columnUtils = columnUtils;
    }
    /**
     * Sets viewport size of the table.
     *
     * @param {number} rowsCount An amount of rows to render.
     * @param {number} columnsCount An amount of columns to render.
     */
  }, {
    key: "setViewportSize",
    value: function setViewportSize(rowsCount, columnsCount) {
      this.rowsToRender = rowsCount;
      this.columnsToRender = columnsCount;
    }
    /**
     * Sets row and column filter instances.
     *
     * @param {RowFilter} rowFilter Row filter instance which contains all necessary information about row index transformation.
     * @param {ColumnFilter} columnFilter Cokumn filter instance  which contains all necessary information about row index transformation.
     */
  }, {
    key: "setFilters",
    value: function setFilters(rowFilter, columnFilter) {
      this.rowFilter = rowFilter;
      this.columnFilter = columnFilter;
    }
    /**
     * Sets row and column header functions.
     *
     * @param {Function[]} rowHeaders Row header functions. Factories for creating content for row headers.
     * @param {Function[]} columnHeaders Column header functions. Factories for creating content for column headers.
     */
  }, {
    key: "setHeaderContentRenderers",
    value: function setHeaderContentRenderers(rowHeaders, columnHeaders) {
      this.rowHeaderFunctions = rowHeaders;
      this.rowHeadersCount = rowHeaders.length;
      this.columnHeaderFunctions = columnHeaders;
      this.columnHeadersCount = columnHeaders.length;
    }
    /**
     * Sets table renderers.
     *
     * @param {renderers} renderers The renderer units.
     * @param {RowHeadersRenderer} renderers.rowHeaders Row headers renderer.
     * @param {ColumnHeadersRenderer} renderers.columnHeaders Column headers renderer.
     * @param {ColGroupRenderer} renderers.colGroup Col group renderer.
     * @param {RowsRenderer} renderers.rows Rows renderer.
     * @param {CellsRenderer} renderers.cells Cells renderer.
     */
  }, {
    key: "setRenderers",
    value: function setRenderers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, rowHeaders = _ref2.rowHeaders, columnHeaders = _ref2.columnHeaders, colGroup = _ref2.colGroup, rows = _ref2.rows, cells = _ref2.cells;
      rowHeaders.setTable(this);
      columnHeaders.setTable(this);
      colGroup.setTable(this);
      rows.setTable(this);
      cells.setTable(this);
      this.rowHeaders = rowHeaders;
      this.columnHeaders = columnHeaders;
      this.colGroup = colGroup;
      this.rows = rows;
      this.cells = cells;
    }
    /**
     * Transforms visual/rendered row index to source index.
     *
     * @param {number} rowIndex Rendered index.
     * @returns {number}
     */
  }, {
    key: "renderedRowToSource",
    value: function renderedRowToSource(rowIndex) {
      return this.rowFilter.renderedToSource(rowIndex);
    }
    /**
     * Transforms visual/rendered column index to source index.
     *
     * @param {number} columnIndex Rendered index.
     * @returns {number}
     */
  }, {
    key: "renderedColumnToSource",
    value: function renderedColumnToSource(columnIndex) {
      return this.columnFilter.renderedToSource(columnIndex);
    }
    /**
     * Renders the table.
     */
  }, {
    key: "render",
    value: function render() {
      this.colGroup.adjust();
      this.columnHeaders.adjust();
      this.rows.adjust();
      this.rowHeaders.adjust();
      this.columnHeaders.render();
      this.rows.render();
      this.rowHeaders.render();
      this.cells.render();
      this.columnUtils.calculateWidths();
      this.colGroup.render();
      var rowsToRender = this.rowsToRender, rows = this.rows;
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        var TR = rows.getRenderedNode(visibleRowIndex);
        if (TR.firstChild) {
          var sourceRowIndex = this.renderedRowToSource(visibleRowIndex);
          var rowHeight = this.rowUtils.getHeight(sourceRowIndex);
          if (rowHeight) {
            TR.firstChild.style.height = "".concat(rowHeight - 1, "px");
          } else {
            TR.firstChild.style.height = "";
          }
        }
      }
    }
  }]);
  return TableRenderer2;
}();
function _classCallCheck$2o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2o(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Renderer = /* @__PURE__ */ function() {
  function Renderer2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, TABLE = _ref2.TABLE, THEAD = _ref2.THEAD, COLGROUP = _ref2.COLGROUP, TBODY = _ref2.TBODY, rowUtils = _ref2.rowUtils, columnUtils = _ref2.columnUtils, cellRenderer = _ref2.cellRenderer;
    _classCallCheck$2o(this, Renderer2);
    this.renderer = new TableRenderer(TABLE, {
      cellRenderer
    });
    this.renderer.setRenderers({
      rowHeaders: new RowHeadersRenderer(),
      columnHeaders: new ColumnHeadersRenderer(THEAD),
      colGroup: new ColGroupRenderer(COLGROUP),
      rows: new RowsRenderer(TBODY),
      cells: new CellsRenderer()
    });
    this.renderer.setAxisUtils(rowUtils, columnUtils);
  }
  _createClass$2o(Renderer2, [{
    key: "setFilters",
    value: function setFilters(rowFilter, columnFilter) {
      this.renderer.setFilters(rowFilter, columnFilter);
      return this;
    }
    /**
     * Sets the viewport size of the rendered table.
     *
     * @param {number} rowsCount An amount of rows to render.
     * @param {number} columnsCount An amount of columns to render.
     * @returns {Renderer}
     */
  }, {
    key: "setViewportSize",
    value: function setViewportSize(rowsCount, columnsCount) {
      this.renderer.setViewportSize(rowsCount, columnsCount);
      return this;
    }
    /**
     * Sets row and column header functions.
     *
     * @param {Function[]} rowHeaders Row header functions. Factories for creating content for row headers.
     * @param {Function[]} columnHeaders Column header functions. Factories for creating content for column headers.
     * @returns {Renderer}
     */
  }, {
    key: "setHeaderContentRenderers",
    value: function setHeaderContentRenderers(rowHeaders, columnHeaders) {
      this.renderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
      return this;
    }
    /**
     * Adjusts the table (preparing for render).
     */
  }, {
    key: "adjust",
    value: function adjust() {
      this.renderer.adjust();
    }
    /**
     * Renders the table.
     */
  }, {
    key: "render",
    value: function render() {
      this.renderer.render();
    }
  }]);
  return Renderer2;
}();
function _classCallCheck$2n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2n(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ColumnUtils = /* @__PURE__ */ function() {
  function ColumnUtils2(dataAccessObject, wtSettings) {
    _classCallCheck$2n(this, ColumnUtils2);
    this.dataAccessObject = dataAccessObject;
    this.wtSettings = wtSettings;
    this.headerWidths = /* @__PURE__ */ new Map();
  }
  _createClass$2n(ColumnUtils2, [{
    key: "getWidth",
    value: function getWidth(sourceIndex) {
      return this.wtSettings.getSetting("columnWidth", sourceIndex) || this.wtSettings.getSetting("defaultColumnWidth");
    }
    /**
     * Returns stretched column width based on passed source index.
     *
     * @param {number} sourceIndex Column source index.
     * @returns {number}
     */
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(sourceIndex) {
      var calculator = this.dataAccessObject.wtViewport.columnsRenderCalculator;
      var width = this.getWidth(sourceIndex);
      if (calculator) {
        var stretchedWidth = calculator.getStretchedColumnWidth(sourceIndex, width);
        if (stretchedWidth) {
          width = stretchedWidth;
        }
      }
      return width;
    }
    /**
     * Returns column header height based on passed header level.
     *
     * @param {number} level Column header level.
     * @returns {number}
     */
  }, {
    key: "getHeaderHeight",
    value: function getHeaderHeight(level) {
      var height = this.wtSettings.getSetting("defaultRowHeight");
      var oversizedHeight = this.dataAccessObject.wtViewport.oversizedColumnHeaders[level];
      if (oversizedHeight !== void 0) {
        height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
      }
      return height;
    }
    /**
     * Returns column header width based on passed source index.
     *
     * @param {number} sourceIndex Column source index.
     * @returns {number}
     */
  }, {
    key: "getHeaderWidth",
    value: function getHeaderWidth(sourceIndex) {
      return this.headerWidths.get(this.dataAccessObject.wtTable.columnFilter.sourceToRendered(sourceIndex));
    }
    /**
     * Calculates column header widths that can be retrieved from the cache.
     */
  }, {
    key: "calculateWidths",
    value: function calculateWidths() {
      var wtSettings = this.wtSettings;
      var _this$dataAccessObjec = this.dataAccessObject, wtTable = _this$dataAccessObjec.wtTable, wtViewport = _this$dataAccessObjec.wtViewport, cloneSource = _this$dataAccessObjec.cloneSource;
      var mainHolder = cloneSource ? cloneSource.wtTable.holder : wtTable.holder;
      var scrollbarCompensation = mainHolder.offsetHeight < mainHolder.scrollHeight ? getScrollbarWidth() : 0;
      var rowHeaderWidthSetting = wtSettings.getSetting("rowHeaderWidth");
      wtViewport.columnsRenderCalculator.refreshStretching(wtViewport.getViewportWidth() - scrollbarCompensation);
      rowHeaderWidthSetting = wtSettings.getSetting("onModifyRowHeaderWidth", rowHeaderWidthSetting);
      if (rowHeaderWidthSetting !== null && rowHeaderWidthSetting !== void 0) {
        var rowHeadersCount = wtSettings.getSetting("rowHeaders").length;
        var defaultColumnWidth = wtSettings.getSetting("defaultColumnWidth");
        for (var visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
          var width = Array.isArray(rowHeaderWidthSetting) ? rowHeaderWidthSetting[visibleColumnIndex] : rowHeaderWidthSetting;
          width = width === null || width === void 0 ? defaultColumnWidth : width;
          this.headerWidths.set(visibleColumnIndex, width);
        }
      }
    }
  }]);
  return ColumnUtils2;
}();
function _classCallCheck$2m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2m(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var RowUtils = /* @__PURE__ */ function() {
  function RowUtils2(dataAccessObject, wtSettings) {
    _classCallCheck$2m(this, RowUtils2);
    this.dataAccessObject = dataAccessObject;
    this.wtSettings = wtSettings;
  }
  _createClass$2m(RowUtils2, [{
    key: "getHeight",
    value: function getHeight(sourceIndex) {
      var height = this.wtSettings.getSetting("rowHeight", sourceIndex);
      var oversizedHeight = this.dataAccessObject.wtViewport.oversizedRows[sourceIndex];
      if (oversizedHeight !== void 0) {
        height = height === void 0 ? oversizedHeight : Math.max(height, oversizedHeight);
      }
      return height;
    }
  }]);
  return RowUtils2;
}();
function _toConsumableArray$t(arr) {
  return _arrayWithoutHoles$t(arr) || _iterableToArray$v(arr) || _unsupportedIterableToArray$14(arr) || _nonIterableSpread$t();
}
function _nonIterableSpread$t() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$v(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$t(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$14(arr);
}
function _slicedToArray$I(arr, i) {
  return _arrayWithHoles$K(arr) || _iterableToArrayLimit$I(arr, i) || _unsupportedIterableToArray$14(arr, i) || _nonIterableRest$K();
}
function _nonIterableRest$K() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$14(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$14(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$14(o, minLen);
}
function _arrayLikeToArray$14(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$I(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$K(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2l(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$E(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Table = /* @__PURE__ */ function() {
  function Table2(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {
    var _this = this;
    _classCallCheck$2l(this, Table2);
    _defineProperty$E(this, "wtSettings", null);
    _defineProperty$E(this, "domBindings", void 0);
    _defineProperty$E(this, "TBODY", null);
    _defineProperty$E(this, "THEAD", null);
    _defineProperty$E(this, "COLGROUP", null);
    _defineProperty$E(this, "hasTableHeight", true);
    _defineProperty$E(this, "hasTableWidth", true);
    _defineProperty$E(this, "isTableVisible", false);
    _defineProperty$E(this, "tableOffset", 0);
    _defineProperty$E(this, "holderOffset", 0);
    this.domBindings = domBindings;
    this.isMaster = name === "master";
    this.name = name;
    this.dataAccessObject = dataAccessObject;
    this.facadeGetter = facadeGetter;
    this.wtSettings = wtSettings;
    this.instance = this.dataAccessObject.wot;
    this.wot = this.dataAccessObject.wot;
    this.TABLE = domBindings.rootTable;
    removeTextNodes(this.TABLE);
    this.spreader = this.createSpreader(this.TABLE);
    this.hider = this.createHider(this.spreader);
    this.holder = this.createHolder(this.hider);
    this.wtRootElement = this.holder.parentNode;
    if (this.isMaster) {
      this.alignOverlaysWithTrimmingContainer();
    }
    this.fixTableDomTree();
    this.rowFilter = null;
    this.columnFilter = null;
    this.correctHeaderWidth = false;
    var origRowHeaderWidth = this.wtSettings.getSettingPure("rowHeaderWidth");
    this.wtSettings.update("rowHeaderWidth", function() {
      return _this._modifyRowHeaderWidth(origRowHeaderWidth);
    });
    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings);
    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings);
    this.tableRenderer = new Renderer({
      // TODO refactoring, It can be passed through IOC.
      TABLE: this.TABLE,
      THEAD: this.THEAD,
      COLGROUP: this.COLGROUP,
      TBODY: this.TBODY,
      rowUtils: this.rowUtils,
      columnUtils: this.columnUtils,
      cellRenderer: this.wtSettings.getSettingPure("cellRenderer")
    });
  }
  _createClass$2l(Table2, [{
    key: "is",
    value: function is2(overlayTypeName) {
      return this.name === overlayTypeName;
    }
    /**
     *
     */
  }, {
    key: "fixTableDomTree",
    value: function fixTableDomTree() {
      var rootDocument = this.domBindings.rootDocument;
      this.TBODY = this.TABLE.querySelector("tbody");
      if (!this.TBODY) {
        this.TBODY = rootDocument.createElement("tbody");
        this.TABLE.appendChild(this.TBODY);
      }
      this.THEAD = this.TABLE.querySelector("thead");
      if (!this.THEAD) {
        this.THEAD = rootDocument.createElement("thead");
        this.TABLE.insertBefore(this.THEAD, this.TBODY);
      }
      this.COLGROUP = this.TABLE.querySelector("colgroup");
      if (!this.COLGROUP) {
        this.COLGROUP = rootDocument.createElement("colgroup");
        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
      }
    }
    /**
     * @param {HTMLTableElement} table An element to process.
     * @returns {HTMLElement}
     */
  }, {
    key: "createSpreader",
    value: function createSpreader(table) {
      var parent = table.parentNode;
      var spreader;
      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
        spreader = this.domBindings.rootDocument.createElement("div");
        spreader.className = "wtSpreader";
        if (parent) {
          parent.insertBefore(spreader, table);
        }
        spreader.appendChild(table);
      }
      spreader.style.position = "relative";
      return spreader;
    }
    /**
     * @param {HTMLElement} spreader An element to the hider element is injected.
     * @returns {HTMLElement}
     */
  }, {
    key: "createHider",
    value: function createHider(spreader) {
      var parent = spreader.parentNode;
      var hider;
      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
        hider = this.domBindings.rootDocument.createElement("div");
        hider.className = "wtHider";
        if (parent) {
          parent.insertBefore(hider, spreader);
        }
        hider.appendChild(spreader);
      }
      return hider;
    }
    /**
     *
     * @param {HTMLElement} hider An element to the holder element is injected.
     * @returns {HTMLElement}
     */
  }, {
    key: "createHolder",
    value: function createHolder(hider) {
      var parent = hider.parentNode;
      var holder2;
      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
        holder2 = this.domBindings.rootDocument.createElement("div");
        holder2.style.position = "relative";
        holder2.className = "wtHolder";
        if (parent) {
          parent.insertBefore(holder2, hider);
        }
        if (this.isMaster) {
          holder2.parentNode.className += "ht_master handsontable";
          holder2.parentNode.setAttribute("dir", this.wtSettings.getSettingPure("rtlMode") ? "rtl" : "ltr");
        }
        holder2.appendChild(hider);
      }
      return holder2;
    }
    /**
     * Redraws the table.
     *
     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.
     *                                   If FALSE or UNDEFINED, will perform a full redraw.
     * @returns {Table}
     */
  }, {
    key: "draw",
    value: function draw() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var wtSettings = this.wtSettings;
      var _this$dataAccessObjec = this.dataAccessObject, wtOverlays = _this$dataAccessObjec.wtOverlays, wtViewport = _this$dataAccessObjec.wtViewport;
      var totalRows = wtSettings.getSetting("totalRows");
      var totalColumns = wtSettings.getSetting("totalColumns");
      var rowHeaders = wtSettings.getSetting("rowHeaders");
      var rowHeadersCount = rowHeaders.length;
      var columnHeaders = wtSettings.getSetting("columnHeaders");
      var columnHeadersCount = columnHeaders.length;
      var syncScroll = false;
      var runFastDraw = fastDraw;
      if (this.isMaster) {
        this.holderOffset = offset(this.holder);
        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);
        if (rowHeadersCount && !wtSettings.getSetting("fixedColumnsStart")) {
          var leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();
          var previousState = this.correctHeaderWidth;
          this.correctHeaderWidth = leftScrollPos !== 0;
          if (previousState !== this.correctHeaderWidth) {
            runFastDraw = false;
          }
        }
      }
      if (this.isMaster) {
        syncScroll = wtOverlays.updateStateOfRendering();
      }
      if (runFastDraw) {
        if (this.isMaster) {
          wtViewport.createVisibleCalculators();
        }
        if (wtOverlays) {
          wtOverlays.refresh(true);
        }
      } else {
        if (this.isMaster) {
          this.tableOffset = offset(this.TABLE);
        } else {
          this.tableOffset = this.dataAccessObject.parentTableOffset;
        }
        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;
        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;
        this.rowFilter = new RowFilter$1(startRow, totalRows, columnHeadersCount);
        this.columnFilter = new ColumnFilter$1(startColumn, totalColumns, rowHeadersCount);
        var performRedraw = true;
        if (this.isMaster) {
          this.alignOverlaysWithTrimmingContainer();
          var skipRender = {};
          this.wtSettings.getSetting("beforeDraw", true, skipRender);
          performRedraw = skipRender.skipRender !== true;
        }
        if (performRedraw) {
          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {
            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);
          }
          this.resetOversizedRows();
          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();
          var workspaceWidth;
          if (this.isMaster) {
            workspaceWidth = this.dataAccessObject.workspaceWidth;
            this.dataAccessObject.wtViewport.containerWidth = null;
            this.markOversizedColumnHeaders();
          }
          this.adjustColumnHeaderHeights();
          if (this.isMaster || this.is(CLONE_BOTTOM)) {
            this.markOversizedRows();
          }
          if (this.isMaster) {
            this.dataAccessObject.wtViewport.createVisibleCalculators();
            this.dataAccessObject.wtOverlays.refresh(false);
            this.dataAccessObject.wtOverlays.applyToDOM();
            var hiderWidth = outerWidth(this.hider);
            var tableWidth = outerWidth(this.TABLE);
            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {
              this.columnUtils.calculateWidths();
              this.tableRenderer.renderer.colGroup.render();
            }
            if (workspaceWidth !== this.dataAccessObject.wtViewport.getWorkspaceWidth()) {
              this.dataAccessObject.wtViewport.containerWidth = null;
              this.columnUtils.calculateWidths();
              this.tableRenderer.renderer.colGroup.render();
            }
            this.wtSettings.getSetting("onDraw", true);
          } else if (this.is(CLONE_BOTTOM)) {
            this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();
          }
        }
      }
      var positionChanged = false;
      if (this.isMaster) {
        positionChanged = wtOverlays.topOverlay.resetFixedPosition();
        if (wtOverlays.bottomOverlay.clone) {
          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;
        }
        positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;
        if (wtOverlays.topInlineStartCornerOverlay) {
          wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();
        }
        if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {
          wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();
        }
      }
      if (positionChanged) {
        wtOverlays.refreshAll();
        wtOverlays.adjustElementsSize();
      } else {
        this.refreshSelections(runFastDraw);
      }
      if (syncScroll) {
        wtOverlays.syncScrollWithMaster();
      }
      this.dataAccessObject.drawn = true;
      return this;
    }
    /**
     * @param {number} col The visual column index.
     */
  }, {
    key: "markIfOversizedColumnHeader",
    value: function markIfOversizedColumnHeader(col) {
      var sourceColIndex = this.columnFilter.renderedToSource(col);
      var level = this.wtSettings.getSetting("columnHeaders").length;
      var defaultRowHeight = this.wtSettings.getSetting("defaultRowHeight");
      var previousColHeaderHeight;
      var currentHeader;
      var currentHeaderHeight;
      var columnHeaderHeightSetting = this.wtSettings.getSetting("columnHeaderHeight") || [];
      while (level) {
        level -= 1;
        previousColHeaderHeight = this.getColumnHeaderHeight(level);
        currentHeader = this.getColumnHeader(sourceColIndex, level);
        if (!currentHeader) {
          continue;
        }
        currentHeaderHeight = innerHeight(currentHeader);
        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
        }
        if (Array.isArray(columnHeaderHeightSetting)) {
          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {
            this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];
          }
        } else if (!isNaN(columnHeaderHeightSetting)) {
          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;
        }
        if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {
          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;
        }
      }
    }
    /**
     *
     */
  }, {
    key: "adjustColumnHeaderHeights",
    value: function adjustColumnHeaderHeights() {
      var wtSettings = this.wtSettings;
      var children = this.THEAD.childNodes;
      var oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;
      var columnHeaders = wtSettings.getSetting("columnHeaders");
      for (var i = 0, len = columnHeaders.length; i < len; i++) {
        if (oversizedColumnHeaders[i]) {
          if (!children[i] || children[i].childNodes.length === 0) {
            return;
          }
          children[i].childNodes[0].style.height = "".concat(oversizedColumnHeaders[i], "px");
        }
      }
    }
    /**
     * Resets cache of row heights. The cache should be cached for each render cycle in a case
     * when new cell values have content which increases/decreases cell height.
     */
  }, {
    key: "resetOversizedRows",
    value: function resetOversizedRows() {
      var wtSettings = this.wtSettings;
      var wtViewport = this.dataAccessObject.wtViewport;
      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {
        return;
      }
      if (!wtSettings.getSetting("externalRowCalculator")) {
        var rowsToRender = this.getRenderedRowsCount();
        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);
          if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {
            wtViewport.oversizedRows[sourceRow] = void 0;
          }
        }
      }
    }
    /**
     * @param {string} className The CSS class name to remove from the table cells.
     */
  }, {
    key: "removeClassFromCells",
    value: function removeClassFromCells(className) {
      var nodes = this.TABLE.querySelectorAll(".".concat(className));
      for (var i = 0, len = nodes.length; i < len; i++) {
        removeClass(nodes[i], className);
      }
    }
    /**
     * Refresh the table selection by re-rendering Selection instances connected with that instance.
     *
     * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.
     */
  }, {
    key: "refreshSelections",
    value: function refreshSelections(fastDraw) {
      var wtSettings = this.wtSettings;
      var selections = this.dataAccessObject.selections;
      if (!selections) {
        return;
      }
      var highlights = Array.from(selections);
      var len = highlights.length;
      if (fastDraw) {
        var classesToRemove = [];
        for (var i = 0; i < len; i++) {
          var _highlights$i$setting = highlights[i].settings, highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName, highlightRowClassName = _highlights$i$setting.highlightRowClassName, highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;
          var classNames = highlights[i].classNames;
          var classNamesLength = classNames.length;
          for (var j = 0; j < classNamesLength; j++) {
            if (!classesToRemove.includes(classNames[j])) {
              classesToRemove.push(classNames[j]);
            }
          }
          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {
            classesToRemove.push(highlightHeaderClassName);
          }
          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {
            classesToRemove.push(highlightRowClassName);
          }
          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {
            classesToRemove.push(highlightColumnClassName);
          }
        }
        var additionalClassesToRemove = wtSettings.getSetting("onBeforeRemoveCellClassNames");
        if (Array.isArray(additionalClassesToRemove)) {
          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {
            classesToRemove.push(additionalClassesToRemove[_i]);
          }
        }
        var classesToRemoveLength = classesToRemove.length;
        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {
          this.removeClassFromCells(classesToRemove[_i2]);
        }
      }
      for (var _i3 = 0; _i3 < len; _i3++) {
        highlights[_i3].draw(this.facadeGetter(), fastDraw);
      }
    }
    /**
     * Get cell element at coords.
     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the
     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column
     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the
     * outmost header element.
     *
     * In case an element for the coords is not rendered, the method returns an error code.
     * To produce the error code, the input parameters are validated in the order in which they
     * are given. Thus, if both the row and the column coords are out of the rendered bounds,
     * the method returns the error code for the row.
     *
     * @param {CellCoords} coords The cell coordinates.
     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:
     *  -1 row before viewport
     *  -2 row after viewport
     *  -3 column before viewport
     *  -4 column after viewport.
     */
  }, {
    key: "getCell",
    value: function getCell(coords) {
      var row = coords.row;
      var column = coords.col;
      var hookResult = this.wtSettings.getSetting("onModifyGetCellCoords", row, column);
      if (hookResult && Array.isArray(hookResult)) {
        var _hookResult = _slicedToArray$I(hookResult, 2);
        row = _hookResult[0];
        column = _hookResult[1];
      }
      if (this.isRowBeforeRenderedRows(row)) {
        return -1;
      } else if (this.isRowAfterRenderedRows(row)) {
        return -2;
      } else if (this.isColumnBeforeRenderedColumns(column)) {
        return -3;
      } else if (this.isColumnAfterRenderedColumns(column)) {
        return -4;
      }
      var TR;
      if (row < 0) {
        TR = this.THEAD.childNodes[this.rowFilter.sourceRowToVisibleColHeadedRow(row)];
      } else {
        TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      }
      if (!TR && row >= 0) {
        throw new Error("TR was expected to be rendered but is not");
      }
      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];
      if (!TD && column >= 0) {
        throw new Error("TD or TH was expected to be rendered but is not");
      }
      return TD;
    }
    /**
     * GetColumnHeader.
     *
     * @param {number} col Column index.
     * @param {number} [level=0] Header level (0 = most distant to the table).
     * @returns {object} HTMLElement on success or undefined on error.
     */
  }, {
    key: "getColumnHeader",
    value: function getColumnHeader(col) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var TR = this.THEAD.childNodes[level];
      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
    }
    /**
     * Gets all columns headers (TH elements) from the table.
     *
     * @param {number} column A source column index.
     * @returns {HTMLTableCellElement[]}
     */
  }, {
    key: "getColumnHeaders",
    value: function getColumnHeaders(column) {
      var THs = [];
      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);
      this.THEAD.childNodes.forEach(function(TR) {
        var TH = TR.childNodes[visibleColumn];
        if (TH) {
          THs.push(TH);
        }
      });
      return THs;
    }
    /**
     * GetRowHeader.
     *
     * @param {number} row Row index.
     * @param {number} [level=0] Header level (0 = most distant to the table).
     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`.
     */
  }, {
    key: "getRowHeader",
    value: function getRowHeader(row) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
        return;
      }
      var rowHeadersCount = this.wtSettings.getSetting("rowHeaders").length;
      if (level >= rowHeadersCount) {
        return;
      }
      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];
    }
    /**
     * Gets all rows headers (TH elements) from the table.
     *
     * @param {number} row A source row index.
     * @returns {HTMLTableCellElement[]}
     */
  }, {
    key: "getRowHeaders",
    value: function getRowHeaders(row) {
      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
        return [];
      }
      var THs = [];
      var rowHeadersCount = this.wtSettings.getSetting("rowHeaders").length;
      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {
        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];
        if (TH) {
          THs.push(TH);
        }
      }
      return THs;
    }
    /**
     * Returns cell coords object for a given TD (or a child element of a TD element).
     *
     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).
     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.
     */
  }, {
    key: "getCoords",
    value: function getCoords(TD) {
      var cellElement = TD;
      if (cellElement.nodeName !== "TD" && cellElement.nodeName !== "TH") {
        cellElement = closest(cellElement, ["TD", "TH"]);
      }
      if (cellElement === null) {
        return null;
      }
      var TR = cellElement.parentNode;
      var CONTAINER = TR.parentNode;
      var row = index(TR);
      var col = cellElement.cellIndex;
      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {
        if (CONTAINER.nodeName === "THEAD") {
          row -= CONTAINER.childNodes.length;
        }
      } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {
        var totalRows = this.wtSettings.getSetting("totalRows");
        row = totalRows - CONTAINER.childNodes.length + row;
      } else if (CONTAINER === this.THEAD) {
        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
      } else {
        row = this.rowFilter.renderedToSource(row);
      }
      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {
        col = this.columnFilter.offsettedTH(col);
      } else {
        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);
      }
      return this.wot.createCellCoords(row, col);
    }
    /**
     * Check if any of the rendered rows is higher than expected, and if so, cache them.
     */
  }, {
    key: "markOversizedRows",
    value: function markOversizedRows() {
      if (this.wtSettings.getSetting("externalRowCalculator")) {
        return;
      }
      var rowCount = this.TBODY.childNodes.length;
      var expectedTableHeight = rowCount * this.wtSettings.getSetting("defaultRowHeight");
      var actualTableHeight = innerHeight(this.TBODY) - 1;
      var previousRowHeight;
      var rowInnerHeight;
      var sourceRowIndex;
      var currentTr;
      var rowHeader;
      if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting("fixedRowsBottom")) {
        return;
      }
      while (rowCount) {
        rowCount -= 1;
        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);
        previousRowHeight = this.getRowHeight(sourceRowIndex);
        currentTr = this.getTrForRow(sourceRowIndex);
        rowHeader = currentTr.querySelector("th");
        if (rowHeader) {
          rowInnerHeight = innerHeight(rowHeader);
        } else {
          rowInnerHeight = innerHeight(currentTr) - 1;
        }
        if (!previousRowHeight && this.wtSettings.getSetting("defaultRowHeight") < rowInnerHeight || previousRowHeight < rowInnerHeight) {
          rowInnerHeight += 1;
          this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;
        }
      }
    }
    /**
     * @param {number} row The visual row index.
     * @returns {HTMLTableElement}
     */
  }, {
    key: "getTrForRow",
    value: function getTrForRow(row) {
      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
    }
    /**
     * Checks if the column index (negative value from -1 to N) is rendered.
     *
     * @param {number} column The column index (negative value from -1 to N).
     * @returns {boolean}
     */
  }, {
    key: "isColumnHeaderRendered",
    value: function isColumnHeaderRendered(column) {
      if (column >= 0) {
        return false;
      }
      var rowHeaders = this.wtSettings.getSetting("rowHeaders");
      var rowHeadersCount = rowHeaders.length;
      return Math.abs(column) <= rowHeadersCount;
    }
    /**
     * Checks if the row index (negative value from -1 to N) is rendered.
     *
     * @param {number} row The row index (negative value from -1 to N).
     * @returns {boolean}
     */
  }, {
    key: "isRowHeaderRendered",
    value: function isRowHeaderRendered(row) {
      if (row >= 0) {
        return false;
      }
      var columnHeaders = this.wtSettings.getSetting("columnHeaders");
      var columnHeadersCount = columnHeaders.length;
      return Math.abs(row) <= columnHeadersCount;
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * Check if the given row index is lower than the index of the first row that
     * is currently rendered and return TRUE in that case, or FALSE otherwise.
     *
     * Negative row index is used to check the columns' headers.
     *
     *  Headers
     *           +--------------+                                     â
     *       -3  â    â    â    â                                     â
     *           +--------------+                                     â
     *       -2  â    â    â    â                                     â TRUE
     *           +--------------+                                     â
     *       -1  â    â    â    â                                     â
     *  Cells  +==================+                                   â
     *        0  â    â    â    â <--- For fixedRowsTop: 1            â
     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)
     *        1  â A2 â B2 â C2 â      not render the first row.      â
     *           +--------------+                                     â FALSE
     *        2  â A3 â B3 â C3 â                                     â
     *           +--------------+                                  ---+ last rendered row
     *                                                                â
     *                                                                â FALSE
     *
     * @param {number} row The visual row index.
     * @memberof Table#
     * @function isRowBeforeRenderedRows
     * @returns {boolean}
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "isRowBeforeRenderedRows",
    value: function isRowBeforeRenderedRows(row) {
      var first = this.getFirstRenderedRow();
      if (row < 0 && first <= 0) {
        return !this.isRowHeaderRendered(row);
      }
      return row < first;
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * Check if the given column index is greater than the index of the last column that
     * is currently rendered and return TRUE in that case, or FALSE otherwise.
     *
     * The negative row index is used to check the columns' headers. However,
     * keep in mind that for negative indexes, the method always returns FALSE as
     * it is not possible to render headers partially. The "after" index can not be
     * lower than -1.
     *
     *  Headers
     *           +--------------+                                     â
     *       -3  â    â    â    â                                     â
     *           +--------------+                                     â
     *       -2  â    â    â    â                                     â FALSE
     *           +--------------+                                     â
     *       -1  â    â    â    â                                     â
     *  Cells  +==================+                                   â
     *        0  â    â    â    â <--- For fixedRowsTop: 1            â
     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)
     *        1  â A2 â B2 â C2 â      not render the first rows      â
     *           +--------------+                                     â FALSE
     *        2  â A3 â B3 â C3 â                                     â
     *           +--------------+                                  ---+ last rendered row
     *                                                                â
     *                                                                â TRUE
     *
     * @param {number} row The visual row index.
     * @memberof Table#
     * @function isRowAfterRenderedRows
     * @returns {boolean}
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "isRowAfterRenderedRows",
    value: function isRowAfterRenderedRows(row) {
      return row > this.getLastRenderedRow();
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * Check if the given column index is lower than the index of the first column that
     * is currently rendered and return TRUE in that case, or FALSE otherwise.
     *
     * Negative column index is used to check the rows' headers.
     *
     *                            For fixedColumnsStart: 1 the master overlay
     *                            do not render this first columns.
     *  Headers    -3   -2   -1    |
     *           +----+----+----ââ â +------+------+
     *           â    â    â    â    â  B1  â  C1  â
     *           +--------------ââ â --------------â
     *           â    â    â    â    â  B2  â  C2  â
     *           +--------------ââ â --------------â
     *           â    â    â    â    â  B3  â  C3  â
     *           +----+----+----ââ â +------+------+
     *                               â·             â·
     *      -------------------------+-------------+---------------->
     *          TRUE             first    FALSE   last         FALSE
     *                           rendered         rendered
     *                           column           column
     *
     * @param {number} column The visual column index.
     * @memberof Table#
     * @function isColumnBeforeRenderedColumns
     * @returns {boolean}
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "isColumnBeforeRenderedColumns",
    value: function isColumnBeforeRenderedColumns(column) {
      var first = this.getFirstRenderedColumn();
      if (column < 0 && first <= 0) {
        return !this.isColumnHeaderRendered(column);
      }
      return column < first;
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * Check if the given column index is greater than the index of the last column that
     * is currently rendered and return TRUE in that case, or FALSE otherwise.
     *
     * The negative column index is used to check the rows' headers. However,
     * keep in mind that for negative indexes, the method always returns FALSE as
     * it is not possible to render headers partially. The "after" index can not be
     * lower than -1.
     *
     *                            For fixedColumnsStart: 1 the master overlay
     *                            do not render this first columns.
     *  Headers    -3   -2   -1    |
     *           +----+----+----ââ â +------+------+
     *           â    â    â    â    â  B1  â  C1  â
     *           +--------------ââ â --------------â
     *           â    â    â    â    â  B2  â  C2  â
     *           +--------------ââ â --------------â
     *           â    â    â    â    â  B3  â  C3  â
     *           +----+----+----ââ â +------+------+
     *                               â·             â·
     *      -------------------------+-------------+---------------->
     *          FALSE             first    FALSE   last         TRUE
     *                           rendered         rendered
     *                           column           column
     *
     * @param {number} column The visual column index.
     * @memberof Table#
     * @function isColumnAfterRenderedColumns
     * @returns {boolean}
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "isColumnAfterRenderedColumns",
    value: function isColumnAfterRenderedColumns(column) {
      return this.columnFilter && column > this.getLastRenderedColumn();
    }
  }, {
    key: "isColumnAfterViewport",
    value: function isColumnAfterViewport(column) {
      return this.columnFilter && column > this.getLastVisibleColumn();
    }
  }, {
    key: "isRowAfterViewport",
    value: function isRowAfterViewport(row) {
      return this.rowFilter && row > this.getLastVisibleRow();
    }
  }, {
    key: "isColumnBeforeViewport",
    value: function isColumnBeforeViewport(column) {
      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
    }
  }, {
    key: "isLastRowFullyVisible",
    value: function isLastRowFullyVisible() {
      return this.getLastVisibleRow() === this.getLastRenderedRow();
    }
  }, {
    key: "isLastColumnFullyVisible",
    value: function isLastColumnFullyVisible() {
      return this.getLastVisibleColumn() === this.getLastRenderedColumn();
    }
  }, {
    key: "allRowsInViewport",
    value: function allRowsInViewport() {
      return this.wtSettings.getSetting("totalRows") === this.getVisibleRowsCount();
    }
  }, {
    key: "allColumnsInViewport",
    value: function allColumnsInViewport() {
      return this.wtSettings.getSetting("totalColumns") === this.getVisibleColumnsCount();
    }
    /**
     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.
     *
     * @param {number} sourceRow The physical row index.
     * @returns {number}
     */
  }, {
    key: "getRowHeight",
    value: function getRowHeight(sourceRow) {
      return this.rowUtils.getHeight(sourceRow);
    }
    /**
     * @param {number} level The column level.
     * @returns {number}
     */
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight(level) {
      return this.columnUtils.getHeaderHeight(level);
    }
    /**
     * @param {number} sourceColumn The physical column index.
     * @returns {number}
     */
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(sourceColumn) {
      return this.columnUtils.getWidth(sourceColumn);
    }
    /**
     * @param {number} sourceColumn The physical column index.
     * @returns {number}
     */
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(sourceColumn) {
      return this.columnUtils.getStretchedColumnWidth(sourceColumn);
    }
    /**
     * Checks if the table has defined size. It returns `true` when the table has width and height
     * set bigger than `0px`.
     *
     * @returns {boolean}
     */
  }, {
    key: "hasDefinedSize",
    value: function hasDefinedSize() {
      return this.hasTableHeight && this.hasTableWidth;
    }
    /**
     * Gets table's width. The returned width is the width of the rendered cells that fit in the
     * current viewport. The value may change depends on the viewport position (scroll position).
     *
     * @returns {number}
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      return outerWidth(this.TABLE);
    }
    /**
     * Gets table's height. The returned height is the height of the rendered cells that fit in the
     * current viewport. The value may change depends on the viewport position (scroll position).
     *
     * @returns {number}
     */
  }, {
    key: "getHeight",
    value: function getHeight() {
      return outerHeight(this.TABLE);
    }
    /**
     * Gets table's total width. The returned width is the width of all rendered cells (including headers)
     * that can be displayed in the table.
     *
     * @returns {number}
     */
  }, {
    key: "getTotalWidth",
    value: function getTotalWidth() {
      var width = outerWidth(this.hider);
      return width !== 0 ? width : this.getWidth();
    }
    /**
     * Gets table's total height. The returned height is the height of all rendered cells (including headers)
     * that can be displayed in the table.
     *
     * @returns {number}
     */
  }, {
    key: "getTotalHeight",
    value: function getTotalHeight() {
      var height = outerHeight(this.hider);
      return height !== 0 ? height : this.getHeight();
    }
    /**
     * Checks if the table is visible. It returns `true` when the holder element (or its parents)
     * has CSS 'display' property different than 'none'.
     *
     * @returns {boolean}
     */
  }, {
    key: "isVisible",
    value: function isVisible$1() {
      return isVisible(this.TABLE);
    }
    /**
     * Modify row header widths provided by user in class contructor.
     *
     * @private
     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..
     * @returns {number}
     */
  }, {
    key: "_modifyRowHeaderWidth",
    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {
      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;
      if (Array.isArray(widths)) {
        widths = _toConsumableArray$t(widths);
        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);
      } else {
        widths = this._correctRowHeaderWidth(widths);
      }
      return widths;
    }
    /**
     * Correct row header width if necessary.
     *
     * @private
     * @param {number} width The width to process.
     * @returns {number}
     */
  }, {
    key: "_correctRowHeaderWidth",
    value: function _correctRowHeaderWidth(width) {
      var rowHeaderWidth = width;
      if (typeof width !== "number") {
        rowHeaderWidth = this.wtSettings.getSetting("defaultColumnWidth");
      }
      if (this.correctHeaderWidth) {
        rowHeaderWidth += 1;
      }
      return rowHeaderWidth;
    }
  }]);
  return Table2;
}();
const Table$1 = Table;
var MIXIN_NAME$6 = "stickyRowsBottom";
var stickyRowsBottom = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow: function getFirstRenderedRow() {
    var totalRows = this.wtSettings.getSetting("totalRows");
    var fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
    var index2 = totalRows - fixedRowsBottom;
    if (totalRows === 0 || fixedRowsBottom === 0) {
      return -1;
    }
    if (index2 < 0) {
      return 0;
    }
    return index2;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow: function getFirstVisibleRow() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow: function getLastRenderedRow() {
    return this.wtSettings.getSetting("totalRows") - 1;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow: function getLastVisibleRow() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount: function getRenderedRowsCount() {
    var totalRows = this.wtSettings.getSetting("totalRows");
    return Math.min(this.wtSettings.getSetting("fixedRowsBottom"), totalRows);
  },
  /**
   * Get the number of fully visible rows in the viewport.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount: function getVisibleRowsCount() {
    return this.getRenderedRowsCount();
  }
};
defineGetter(stickyRowsBottom, "MIXIN_NAME", MIXIN_NAME$6, {
  writable: false,
  enumerable: false
});
const stickyRowsBottom$1 = stickyRowsBottom;
var MIXIN_NAME$5 = "stickyColumnsStart";
var stickyColumnsStart = {
  /**
   * Get the source index of the first rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedColumn: function getFirstRenderedColumn() {
    var totalColumns = this.wtSettings.getSetting("totalColumns");
    if (totalColumns === 0) {
      return -1;
    }
    return 0;
  },
  /**
   * Get the source index of the first column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleColumn: function getFirstVisibleColumn() {
    return this.getFirstRenderedColumn();
  },
  /**
   * Get the source index of the last rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedColumn: function getLastRenderedColumn() {
    return this.getRenderedColumnsCount() - 1;
  },
  /**
   * Get the source index of the last column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleColumn: function getLastVisibleColumn() {
    return this.getLastRenderedColumn();
  },
  /**
   * Get the number of rendered columns.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedColumnsCount: function getRenderedColumnsCount() {
    var totalColumns = this.wtSettings.getSetting("totalColumns");
    return Math.min(this.wtSettings.getSetting("fixedColumnsStart"), totalColumns);
  },
  /**
   * Get the number of fully visible columns in the viewport.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleColumnsCount: function getVisibleColumnsCount() {
    return this.getRenderedColumnsCount();
  }
};
defineGetter(stickyColumnsStart, "MIXIN_NAME", MIXIN_NAME$5, {
  writable: false,
  enumerable: false
});
const stickyColumnsStart$1 = stickyColumnsStart;
function _typeof$1s(obj) {
  "@babel/helpers - typeof";
  return _typeof$1s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1s(obj);
}
function _defineProperties$2k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2k(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$2k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$1j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1k(subClass, superClass);
}
function _setPrototypeOf$1k(o, p2) {
  _setPrototypeOf$1k = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1k(o, p2);
}
function _createSuper$1j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1j(this, result);
  };
}
function _possibleConstructorReturn$1j(self2, call2) {
  if (call2 && (_typeof$1s(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1j(self2);
}
function _assertThisInitialized$1j(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1j(o) {
  _getPrototypeOf$1j = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1j(o);
}
var BottomInlineStartCornerOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$1j(BottomInlineStartCornerOverlayTable2, _Table);
  var _super = _createSuper$1j(BottomInlineStartCornerOverlayTable2);
  function BottomInlineStartCornerOverlayTable2(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    _classCallCheck$2k(this, BottomInlineStartCornerOverlayTable2);
    return _super.call(this, dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_BOTTOM_INLINE_START_CORNER);
  }
  return _createClass$2k(BottomInlineStartCornerOverlayTable2);
}(Table$1);
mixin(BottomInlineStartCornerOverlayTable, stickyRowsBottom$1);
mixin(BottomInlineStartCornerOverlayTable, stickyColumnsStart$1);
const BottomInlineStartCornerOverlayTable$1 = BottomInlineStartCornerOverlayTable;
var CLONE_TOP = "top";
var CLONE_BOTTOM = "bottom";
var CLONE_INLINE_START = "inline_start";
var CLONE_TOP_INLINE_START_CORNER = "top_inline_start_corner";
var CLONE_BOTTOM_INLINE_START_CORNER = "bottom_inline_start_corner";
var CLONE_TYPES = [CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER];
var CLONE_CLASS_NAMES = /* @__PURE__ */ new Map([[CLONE_TOP, "ht_clone_".concat(CLONE_TOP)], [CLONE_BOTTOM, "ht_clone_".concat(CLONE_BOTTOM)], [CLONE_INLINE_START, "ht_clone_".concat(CLONE_INLINE_START, " ht_clone_left")], [CLONE_TOP_INLINE_START_CORNER, "ht_clone_".concat(CLONE_TOP_INLINE_START_CORNER, " ht_clone_top_left_corner")], [CLONE_BOTTOM_INLINE_START_CORNER, "ht_clone_".concat(CLONE_BOTTOM_INLINE_START_CORNER, " ht_clone_bottom_left_corner")]]);
function _classCallCheck$2j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2j(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$D(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Scroll = /* @__PURE__ */ function() {
  function Scroll2(dataAccessObject) {
    _classCallCheck$2j(this, Scroll2);
    _defineProperty$D(this, "dataAccessObject", void 0);
    _defineProperty$D(this, "lastScrolledColumnPos", -1);
    _defineProperty$D(this, "lastScrolledRowPos", -1);
    this.dataAccessObject = dataAccessObject;
  }
  _createClass$2j(Scroll2, [{
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);
      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);
      return scrolledHorizontally || scrolledVertically;
    }
    /**
     * Scrolls viewport to a column.
     *
     * @param {number} column Visual column index.
     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      var _this$dataAccessObjec = this.dataAccessObject, drawn = _this$dataAccessObjec.drawn, totalColumns = _this$dataAccessObjec.totalColumns;
      if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {
        return false;
      }
      var firstVisibleColumn = this.getFirstVisibleColumn();
      var lastVisibleColumn = this.getLastVisibleColumn();
      var autoSnapping = snapToRight === void 0 && snapToLeft === void 0;
      var _this$dataAccessObjec2 = this.dataAccessObject, fixedColumnsStart = _this$dataAccessObjec2.fixedColumnsStart, inlineStartOverlay = _this$dataAccessObjec2.inlineStartOverlay;
      if (autoSnapping && column < fixedColumnsStart) {
        return false;
      }
      var result = false;
      if (firstVisibleColumn === -1) {
        result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > this.lastScrolledColumnPos : snapToRight);
      } else if (autoSnapping && (column < firstVisibleColumn || column > lastVisibleColumn) || !autoSnapping) {
        result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > lastVisibleColumn : snapToRight);
      }
      if (result) {
        this.lastScrolledColumnPos = column;
      }
      return result;
    }
    /**
     * Scrolls viewport to a row.
     *
     * @param {number} row Visual row index.
     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      var _this$dataAccessObjec3 = this.dataAccessObject, drawn = _this$dataAccessObjec3.drawn, totalRows = _this$dataAccessObjec3.totalRows;
      if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {
        return false;
      }
      var firstVisibleRow = this.getFirstVisibleRow();
      var lastVisibleRow = this.getLastVisibleRow();
      var autoSnapping = snapToTop === void 0 && snapToBottom === void 0;
      var _this$dataAccessObjec4 = this.dataAccessObject, fixedRowsBottom = _this$dataAccessObjec4.fixedRowsBottom, fixedRowsTop = _this$dataAccessObjec4.fixedRowsTop, topOverlay = _this$dataAccessObjec4.topOverlay;
      if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {
        return false;
      }
      var result = false;
      if (firstVisibleRow === -1) {
        result = topOverlay.scrollTo(row, autoSnapping ? row > this.lastScrolledRowPos : snapToBottom);
      } else if (autoSnapping && (row < firstVisibleRow || row > lastVisibleRow) || !autoSnapping) {
        result = topOverlay.scrollTo(row, autoSnapping ? row > lastVisibleRow : snapToBottom);
      }
      if (result) {
        this.lastScrolledRowPos = row;
      }
      return result;
    }
    /**
     * Get first visible row based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow4() {
      var _this$dataAccessObjec5 = this.dataAccessObject, topOverlay = _this$dataAccessObjec5.topOverlay, wtTable = _this$dataAccessObjec5.wtTable, wtViewport = _this$dataAccessObjec5.wtViewport, totalRows = _this$dataAccessObjec5.totalRows, fixedRowsTop = _this$dataAccessObjec5.fixedRowsTop, rootWindow = _this$dataAccessObjec5.rootWindow;
      var firstVisibleRow = wtTable.getFirstVisibleRow();
      if (topOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var totalTableHeight = innerHeight(wtTable.hider);
        var windowHeight = innerHeight(rootWindow);
        var windowScrollTop = getScrollTop(rootWindow, rootWindow);
        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {
          var rowsHeight = wtViewport.getColumnHeaderHeight();
          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);
          for (var row = totalRows; row > 0; row--) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);
            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {
              firstVisibleRow = row;
              break;
            }
          }
        }
      }
      return firstVisibleRow;
    }
    /**
     * Get last visible row based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow4() {
      var _this$dataAccessObjec6 = this.dataAccessObject, topOverlay = _this$dataAccessObjec6.topOverlay, wtTable = _this$dataAccessObjec6.wtTable, wtViewport = _this$dataAccessObjec6.wtViewport, totalRows = _this$dataAccessObjec6.totalRows, rootWindow = _this$dataAccessObjec6.rootWindow;
      var lastVisibleRow = wtTable.getLastVisibleRow();
      if (topOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var windowScrollTop = getScrollTop(rootWindow, rootWindow);
        if (rootElementOffset.top > windowScrollTop) {
          var windowHeight = innerHeight(rootWindow);
          var rowsHeight = wtViewport.getColumnHeaderHeight();
          for (var row = 1; row <= totalRows; row++) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);
            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {
              lastVisibleRow = row - 2;
              break;
            }
          }
        }
      }
      return lastVisibleRow;
    }
    /**
     * Get first visible column based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn3() {
      var _this$dataAccessObjec7 = this.dataAccessObject, inlineStartOverlay = _this$dataAccessObjec7.inlineStartOverlay, wtTable = _this$dataAccessObjec7.wtTable, wtViewport = _this$dataAccessObjec7.wtViewport, totalColumns = _this$dataAccessObjec7.totalColumns, rootWindow = _this$dataAccessObjec7.rootWindow;
      var firstVisibleColumn = wtTable.getFirstVisibleColumn();
      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var totalTableWidth = innerWidth(wtTable.hider);
        var windowWidth = innerWidth(rootWindow);
        var windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));
        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {
          var columnsWidth = wtViewport.getRowHeaderWidth();
          for (var column = totalColumns; column > 0; column--) {
            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);
            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {
              firstVisibleColumn = column;
              break;
            }
          }
        }
      }
      return firstVisibleColumn;
    }
    /**
     * Get last visible column based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn3() {
      var _this$dataAccessObjec8 = this.dataAccessObject, inlineStartOverlay = _this$dataAccessObjec8.inlineStartOverlay, wtTable = _this$dataAccessObjec8.wtTable, wtViewport = _this$dataAccessObjec8.wtViewport, totalColumns = _this$dataAccessObjec8.totalColumns, rootWindow = _this$dataAccessObjec8.rootWindow;
      var lastVisibleColumn = wtTable.getLastVisibleColumn();
      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));
        if (rootElementOffset.left > windowScrollLeft) {
          var windowWidth = innerWidth(rootWindow);
          var columnsWidth = wtViewport.getRowHeaderWidth();
          for (var column = 1; column <= totalColumns; column++) {
            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);
            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {
              lastVisibleColumn = column - 2;
              break;
            }
          }
        }
      }
      return lastVisibleColumn;
    }
  }]);
  return Scroll2;
}();
const Scroll$1 = Scroll;
function _classCallCheck$2i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2i(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$C(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var CoreAbstract = /* @__PURE__ */ function() {
  function CoreAbstract2(table, settings) {
    _classCallCheck$2i(this, CoreAbstract2);
    _defineProperty$C(this, "wtTable", void 0);
    _defineProperty$C(this, "wtScroll", void 0);
    _defineProperty$C(this, "wtViewport", void 0);
    _defineProperty$C(this, "wtOverlays", void 0);
    _defineProperty$C(this, "selections", void 0);
    _defineProperty$C(this, "wtEvent", void 0);
    _defineProperty$C(this, "guid", "wt_".concat(randomString()));
    _defineProperty$C(this, "drawInterrupted", false);
    _defineProperty$C(this, "drawn", false);
    _defineProperty$C(this, "domBindings", void 0);
    _defineProperty$C(this, "wtSettings", void 0);
    this.domBindings = {
      rootTable: table,
      rootDocument: table.ownerDocument,
      rootWindow: table.ownerDocument.defaultView
    };
    this.wtSettings = settings;
    this.wtScroll = new Scroll$1(this.createScrollDao());
  }
  _createClass$2i(CoreAbstract2, [{
    key: "eventManager",
    get: (
      /**
       * The walkontable instance id.
       *
       * @public
       * @type {Readonly<string>}
       */
      /**
       * The DOM bindings.
       *
       * @public
       * @type {DomBindings}
       */
      /**
       * Settings.
       *
       * @public
       * @type {Settings}
       */
      function get2() {
        return new EventManager$1(this);
      }
    )
  }, {
    key: "findOriginalHeaders",
    value: function findOriginalHeaders() {
      var originalHeaders = [];
      if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
        for (var c2 = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c2 < clen; c2++) {
          originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c2].innerHTML);
        }
        if (!this.wtSettings.getSetting("columnHeaders").length) {
          this.wtSettings.update("columnHeaders", [function(column, TH) {
            fastInnerText(TH, originalHeaders[column]);
          }]);
        }
      }
    }
    /**
     * Creates and returns the CellCoords object.
     *
     * @param {*} row The row index.
     * @param {*} column The column index.
     * @returns {CellCoords}
     */
  }, {
    key: "createCellCoords",
    value: function createCellCoords(row, column) {
      return new CellCoords$1(row, column, this.wtSettings.getSetting("rtlMode"));
    }
    /**
     * Creates and returns the CellRange object.
     *
     * @param {CellCoords} highlight The highlight coordinates.
     * @param {CellCoords} from The from coordinates.
     * @param {CellCoords} to The to coordinates.
     * @returns {CellRange}
     */
  }, {
    key: "createCellRange",
    value: function createCellRange(highlight, from3, to) {
      return new CellRange$1(highlight, from3, to, this.wtSettings.getSetting("rtlMode"));
    }
    /**
     * Force rerender of Walkontable.
     *
     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
     *                                   the data. It will only work if Table.draw() does not force
     *                                   rendering anyway.
     * @returns {Walkontable}
     */
  }, {
    key: "draw",
    value: function draw() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.drawInterrupted = false;
      if (!fastDraw && !this.wtTable.isVisible()) {
        this.drawInterrupted = true;
      } else {
        this.wtTable.draw(fastDraw);
      }
      return this;
    }
    /**
     * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,
     * if not set or set to false, returns TD from the master table.
     *
     * @param {CellCoords} coords The cell coordinates.
     * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,
     *                                  if the wanted cell is in the range of fixed rows, it will return a TD element
     *                                  from the top overlay.
     * @returns {HTMLElement}
     */
  }, {
    key: "getCell",
    value: function getCell(coords) {
      var topmost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!topmost) {
        return this.wtTable.getCell(coords);
      }
      var totalRows = this.wtSettings.getSetting("totalRows");
      var fixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
      var fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
      var fixedColumnsStart = this.wtSettings.getSetting("fixedColumnsStart");
      if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {
        return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);
      } else if (coords.row < fixedRowsTop) {
        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
      } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {
        if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {
          return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);
        }
      } else if (coords.col < fixedColumnsStart) {
        return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);
      } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {
        if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {
          return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);
        }
      }
      return this.wtTable.getCell(coords);
    }
    /**
     * Scrolls the viewport to a cell (rerenders if needed).
     *
     * @param {CellCoords} coords The cell coordinates to scroll to.
     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      if (coords.col < 0 || coords.row < 0) {
        return false;
      }
      return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
    /**
     * Scrolls the viewport to a column (rerenders if needed).
     *
     * @param {number} column Visual column index.
     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      if (column < 0) {
        return false;
      }
      return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);
    }
    /**
     * Scrolls the viewport to a row (rerenders if needed).
     *
     * @param {number} row Visual row index.
     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      if (row < 0) {
        return false;
      }
      return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);
    }
    /**
     * @returns {Array}
     */
  }, {
    key: "getViewport",
    value: function getViewport() {
      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.wtOverlays.destroy();
      this.wtEvent.destroy();
    }
    /**
     * Create data access object for scroll.
     *
     * @protected
     * @returns {ScrollDao}
     */
  }, {
    key: "createScrollDao",
    value: function createScrollDao() {
      var wot = this;
      return {
        get drawn() {
          return wot.drawn;
        },
        get topOverlay() {
          return wot.wtOverlays.topOverlay;
        },
        get inlineStartOverlay() {
          return wot.wtOverlays.inlineStartOverlay;
        },
        get wtTable() {
          return wot.wtTable;
        },
        get wtViewport() {
          return wot.wtViewport;
        },
        get rootWindow() {
          return wot.domBindings.rootWindow;
        },
        // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)
        get totalRows() {
          return wot.wtSettings.getSetting("totalRows");
        },
        get totalColumns() {
          return wot.wtSettings.getSetting("totalColumns");
        },
        get fixedRowsTop() {
          return wot.wtSettings.getSetting("fixedRowsTop");
        },
        get fixedRowsBottom() {
          return wot.wtSettings.getSetting("fixedRowsBottom");
        },
        get fixedColumnsStart() {
          return wot.wtSettings.getSetting("fixedColumnsStart");
        }
      };
    }
    // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide
    // dynamically access to related objects
    /**
     * Create data access object for wtTable.
     *
     * @protected
     * @returns {TableDao}
     */
  }, {
    key: "getTableDao",
    value: function getTableDao() {
      var wot = this;
      return {
        get wot() {
          return wot;
        },
        get parentTableOffset() {
          return wot.cloneSource.wtTable.tableOffset;
        },
        get cloneSource() {
          return wot.cloneSource;
        },
        get workspaceWidth() {
          return wot.wtViewport.getWorkspaceWidth();
        },
        get wtViewport() {
          return wot.wtViewport;
        },
        get wtOverlays() {
          return wot.wtOverlays;
        },
        get selections() {
          return wot.selections;
        },
        get drawn() {
          return wot.drawn;
        },
        set drawn(v2) {
          wot.drawn = v2;
        },
        get wtTable() {
          return wot.wtTable;
        },
        get startColumnRendered() {
          return wot.wtViewport.columnsRenderCalculator.startColumn;
        },
        get startColumnVisible() {
          return wot.wtViewport.columnsVisibleCalculator.startColumn;
        },
        get endColumnRendered() {
          return wot.wtViewport.columnsRenderCalculator.endColumn;
        },
        get endColumnVisible() {
          return wot.wtViewport.columnsVisibleCalculator.endColumn;
        },
        get countColumnsRendered() {
          return wot.wtViewport.columnsRenderCalculator.count;
        },
        get countColumnsVisible() {
          return wot.wtViewport.columnsVisibleCalculator.count;
        },
        get startRowRendered() {
          return wot.wtViewport.rowsRenderCalculator.startRow;
        },
        get startRowVisible() {
          return wot.wtViewport.rowsVisibleCalculator.startRow;
        },
        get endRowRendered() {
          return wot.wtViewport.rowsRenderCalculator.endRow;
        },
        get endRowVisible() {
          return wot.wtViewport.rowsVisibleCalculator.endRow;
        },
        get countRowsRendered() {
          return wot.wtViewport.rowsRenderCalculator.count;
        },
        get countRowsVisible() {
          return wot.wtViewport.rowsVisibleCalculator.count;
        }
      };
    }
  }]);
  return CoreAbstract2;
}();
function _typeof$1r(obj) {
  "@babel/helpers - typeof";
  return _typeof$1r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1r(obj);
}
function _defineProperties$2h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2h(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$2h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$1i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1j(subClass, superClass);
}
function _setPrototypeOf$1j(o, p2) {
  _setPrototypeOf$1j = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1j(o, p2);
}
function _createSuper$1i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1i(this, result);
  };
}
function _possibleConstructorReturn$1i(self2, call2) {
  if (call2 && (_typeof$1r(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1i(self2);
}
function _assertThisInitialized$1i(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1i(o) {
  _getPrototypeOf$1i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1i(o);
}
function _defineProperty$B(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Clone = /* @__PURE__ */ function(_CoreAbstract) {
  _inherits$1i(Clone2, _CoreAbstract);
  var _super = _createSuper$1i(Clone2);
  function Clone2(table, settings, clone2) {
    var _this;
    _classCallCheck$2h(this, Clone2);
    _this = _super.call(this, table, settings);
    _defineProperty$B(_assertThisInitialized$1i(_this), "cloneSource", void 0);
    _defineProperty$B(_assertThisInitialized$1i(_this), "cloneOverlay", void 0);
    var facadeGetter = _this.wtSettings.getSetting("facade", _assertThisInitialized$1i(_this));
    _this.cloneSource = clone2.source;
    _this.cloneOverlay = clone2.overlay;
    _this.wtTable = _this.cloneOverlay.createTable(_this.getTableDao(), facadeGetter, _this.domBindings, _this.wtSettings);
    _this.wtViewport = clone2.viewport;
    _this.selections = clone2.selections;
    _this.wtEvent = new Event$2(facadeGetter, _this.domBindings, _this.wtSettings, _this.eventManager, _this.wtTable, _this.selections, clone2.event);
    _this.findOriginalHeaders();
    return _this;
  }
  return _createClass$2h(Clone2);
}(CoreAbstract);
function _classCallCheck$2g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2g(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$A(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Overlay = /* @__PURE__ */ function() {
  function Overlay2(wotInstance, facadeGetter, type, wtSettings, domBindings) {
    _classCallCheck$2g(this, Overlay2);
    _defineProperty$A(this, "wtSettings", null);
    defineGetter(this, "wot", wotInstance, {
      writable: false
    });
    this.domBindings = domBindings;
    this.facadeGetter = facadeGetter;
    this.wtSettings = wtSettings;
    var _this$wot$wtTable = this.wot.wtTable, TABLE = _this$wot$wtTable.TABLE, hider = _this$wot$wtTable.hider, spreader = _this$wot$wtTable.spreader, holder2 = _this$wot$wtTable.holder, wtRootElement = _this$wot$wtTable.wtRootElement;
    this.instance = this.wot;
    this.type = type;
    this.mainTableScrollableElement = null;
    this.TABLE = TABLE;
    this.hider = hider;
    this.spreader = spreader;
    this.holder = holder2;
    this.wtRootElement = wtRootElement;
    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
    this.updateStateOfRendering();
    this.clone = this.makeClone();
  }
  _createClass$2g(Overlay2, [{
    key: "updateStateOfRendering",
    value: function updateStateOfRendering() {
      var previousState = this.needFullRender;
      this.needFullRender = this.shouldBeRendered();
      var changed = previousState !== this.needFullRender;
      if (changed && !this.needFullRender) {
        this.reset();
      }
      return changed;
    }
    /**
     * Checks if overlay should be fully rendered.
     *
     * @returns {boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return true;
    }
    /**
     * Update the trimming container.
     */
  }, {
    key: "updateTrimmingContainer",
    value: function updateTrimmingContainer() {
      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
    }
    /**
     * Update the main scrollable element.
     */
  }, {
    key: "updateMainScrollableElement",
    value: function updateMainScrollableElement() {
      var wtTable = this.wot.wtTable;
      var rootWindow = this.domBindings.rootWindow;
      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden") {
        this.mainTableScrollableElement = this.wot.wtTable.holder;
      } else {
        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);
      }
    }
    /**
     * Calculates coordinates of the provided element, relative to the root Handsontable element.
     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.
     *
     * @param {HTMLElement} element The cell element to calculate the position for.
     * @param {number} rowIndex Visual row index.
     * @param {number} columnIndex Visual column index.
     * @returns {{top: number, start: number}|undefined}
     */
  }, {
    key: "getRelativeCellPosition",
    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {
      if (this.clone.wtTable.holder.contains(element) === false) {
        warn$1("The provided element is not a child of the ".concat(this.type, " overlay"));
        return;
      }
      var windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;
      var fixedColumnStart = columnIndex < this.wtSettings.getSetting("fixedColumnsStart");
      var fixedRowTop = rowIndex < this.wtSettings.getSetting("fixedRowsTop");
      var fixedRowBottom = rowIndex >= this.wtSettings.getSetting("totalRows") - this.wtSettings.getSetting("fixedRowsBottom");
      var spreader = this.clone.wtTable.spreader;
      var spreaderOffset = {
        start: this.getRelativeStartPosition(spreader),
        top: spreader.offsetTop
      };
      var elementOffset = {
        start: this.getRelativeStartPosition(element),
        top: element.offsetTop
      };
      var offsetObject = null;
      if (windowScroll) {
        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);
      } else {
        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);
      }
      return offsetObject;
    }
    /**
     * Get inline start value depending of direction.
     *
     * @param {HTMLElement} el Element.
     * @returns {number}
     */
  }, {
    key: "getRelativeStartPosition",
    value: function getRelativeStartPosition(el) {
      return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;
    }
    /**
     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window
     * as a scrollable element.
     *
     * @private
     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.
     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.
     * @param {number} elementOffset Offset position of the cell element.
     * @param {number} spreaderOffset Offset position of the spreader element.
     * @returns {{top: number, left: number}}
     */
  }, {
    key: "getRelativeCellPositionWithinWindow",
    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {
      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();
      var horizontalOffset = 0;
      var verticalOffset = 0;
      if (!onFixedColumn) {
        horizontalOffset = spreaderOffset.start;
      } else {
        var absoluteRootElementStartPosition = absoluteRootElementPosition.left;
        if (this.isRtl()) {
          absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());
        }
        horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;
      }
      if (onFixedRowTop) {
        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();
        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;
      } else {
        verticalOffset = spreaderOffset.top;
      }
      return {
        start: elementOffset.start + horizontalOffset,
        top: elementOffset.top + verticalOffset
      };
    }
    /**
     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window
     * as a scrollable element.
     *
     * @private
     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.
     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.
     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.
     * @param {number} elementOffset Offset position of the cell element.
     * @param {number} spreaderOffset Offset position of the spreader element.
     * @returns {{top: number, left: number}}
     */
  }, {
    key: "getRelativeCellPositionWithinHolder",
    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {
      var tableScrollPosition = {
        horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),
        vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()
      };
      var horizontalOffset = 0;
      var verticalOffset = 0;
      if (!onFixedColumn) {
        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;
      }
      if (onFixedRowBottom) {
        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();
        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();
        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;
      } else if (!onFixedRowTop) {
        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;
      }
      return {
        start: elementOffset.start - horizontalOffset,
        top: elementOffset.top - verticalOffset
      };
    }
    /**
     * Make a clone of table for overlay.
     *
     * @returns {Clone}
     */
  }, {
    key: "makeClone",
    value: function makeClone() {
      if (CLONE_TYPES.indexOf(this.type) === -1) {
        throw new Error('Clone type "'.concat(this.type, '" is not supported.'));
      }
      var wtTable = this.wot.wtTable;
      var _this$domBindings = this.domBindings, rootDocument = _this$domBindings.rootDocument, rootWindow = _this$domBindings.rootWindow;
      var clone2 = rootDocument.createElement("DIV");
      var clonedTable = rootDocument.createElement("TABLE");
      var tableParent = wtTable.wtRootElement.parentNode;
      clone2.className = "".concat(CLONE_CLASS_NAMES.get(this.type), " handsontable");
      clone2.setAttribute("dir", this.isRtl() ? "rtl" : "ltr");
      clone2.style.position = "absolute";
      clone2.style.top = 0;
      clone2.style.overflow = "visible";
      if (this.isRtl()) {
        clone2.style.right = 0;
      } else {
        clone2.style.left = 0;
      }
      clonedTable.className = wtTable.TABLE.className;
      clone2.appendChild(clonedTable);
      tableParent.appendChild(clone2);
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      if (preventOverflow === true || preventOverflow === "horizontal" && this.type === CLONE_TOP || preventOverflow === "vertical" && this.type === CLONE_INLINE_START) {
        this.mainTableScrollableElement = rootWindow;
      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue("overflow") === "hidden") {
        this.mainTableScrollableElement = wtTable.holder;
      } else {
        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);
      }
      return new Clone(clonedTable, this.wtSettings, {
        // todo ioc factory
        source: this.wot,
        overlay: this,
        viewport: this.wot.wtViewport,
        // todo ioc , or factor func if used only here
        event: this.wot.wtEvent,
        // todo ioc , or factory func if used only here
        selections: this.wot.selections
        // todo ioc , or factory func if used only here
      });
    }
    /**
     * Refresh/Redraw overlay.
     *
     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
     *                                   the data. It will only work if Table.draw() does not force
     *                                   rendering anyway.
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var nextCycleRenderFlag = this.shouldBeRendered();
      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {
        this.clone.draw(fastDraw);
      }
      this.needFullRender = nextCycleRenderFlag;
    }
    /**
     * Reset overlay styles to initial values.
     */
  }, {
    key: "reset",
    value: function reset() {
      if (!this.clone) {
        return;
      }
      var holder2 = this.clone.wtTable.holder;
      var hider = this.clone.wtTable.hider;
      var holderStyle = holder2.style;
      var hiderStyle = hider.style;
      var rootStyle = holder2.parentNode.style;
      arrayEach([holderStyle, hiderStyle, rootStyle], function(style) {
        style.width = "";
        style.height = "";
      });
    }
    /**
     * Determine if Walkontable is running in RTL mode.
     *
     * @returns {boolean}
     */
  }, {
    key: "isRtl",
    value: function isRtl() {
      return this.wtSettings.getSetting("rtlMode");
    }
    /**
     * Destroy overlay instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.clone.eventManager.destroy();
    }
  }]);
  return Overlay2;
}();
function _typeof$1q(obj) {
  "@babel/helpers - typeof";
  return _typeof$1q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1q(obj);
}
function _construct$5(Parent, args, Class) {
  if (_isNativeReflectConstruct$1i()) {
    _construct$5 = Reflect.construct.bind();
  } else {
    _construct$5 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1i(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$5.apply(null, arguments);
}
function _classCallCheck$2f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2f(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1i(subClass, superClass);
}
function _setPrototypeOf$1i(o, p2) {
  _setPrototypeOf$1i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1i(o, p2);
}
function _createSuper$1h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1h(this, result);
  };
}
function _possibleConstructorReturn$1h(self2, call2) {
  if (call2 && (_typeof$1q(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1h(self2);
}
function _assertThisInitialized$1h(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1h(o) {
  _getPrototypeOf$1h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1h(o);
}
var BottomInlineStartCornerOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$1h(BottomInlineStartCornerOverlay2, _Overlay);
  var _super = _createSuper$1h(BottomInlineStartCornerOverlay2);
  function BottomInlineStartCornerOverlay2(wotInstance, facadeGetter, wtSettings, domBindings, bottomOverlay, inlineStartOverlay) {
    var _this;
    _classCallCheck$2f(this, BottomInlineStartCornerOverlay2);
    _this = _super.call(this, wotInstance, facadeGetter, CLONE_BOTTOM_INLINE_START_CORNER, wtSettings, domBindings);
    _this.bottomOverlay = bottomOverlay;
    _this.inlineStartOverlay = inlineStartOverlay;
    return _this;
  }
  _createClass$2f(BottomInlineStartCornerOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$5(BottomInlineStartCornerOverlayTable$1, args);
    }
    /**
     * Checks if overlay should be fully rendered.
     *
     * @returns {boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wtSettings.getSetting("shouldRenderBottomOverlay") && this.wtSettings.getSetting("shouldRenderInlineStartOverlay");
    }
    /**
     * Updates the corner overlay position.
     *
     * @returns {boolean}
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      var wot = this.wot;
      this.updateTrimmingContainer();
      if (!wot.wtTable.holder.parentNode) {
        return false;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      overlayRoot.style.top = "";
      if (this.trimmingContainer === this.domBindings.rootWindow) {
        var inlineStartOffset = this.inlineStartOverlay.getOverlayOffset();
        var bottom2 = this.bottomOverlay.getOverlayOffset();
        overlayRoot.style[this.isRtl() ? "right" : "left"] = "".concat(inlineStartOffset, "px");
        overlayRoot.style.bottom = "".concat(bottom2, "px");
      } else {
        resetCssTransform(overlayRoot);
        this.repositionOverlay();
      }
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRoot.style.height = "".concat(tableHeight, "px");
      overlayRoot.style.width = "".concat(tableWidth, "px");
      return false;
    }
    /**
     * Reposition the overlay.
     */
  }, {
    key: "repositionOverlay",
    value: function repositionOverlay() {
      var _this$wot = this.wot, wtTable = _this$wot.wtTable, wtViewport = _this$wot.wtViewport;
      var rootDocument = this.domBindings.rootDocument;
      var cloneRoot = this.clone.wtTable.holder.parentNode;
      var bottomOffset = 0;
      if (!wtViewport.hasVerticalScroll()) {
        bottomOffset += wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();
      }
      if (wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {
        bottomOffset += getScrollbarWidth(rootDocument);
      }
      cloneRoot.style.bottom = "".concat(bottomOffset, "px");
    }
  }]);
  return BottomInlineStartCornerOverlay2;
}(Overlay);
var MIXIN_NAME$4 = "calculatedColumns";
var calculatedColumns = {
  /**
   * Get the source index of the first rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedColumn: function getFirstRenderedColumn2() {
    var startColumn = this.dataAccessObject.startColumnRendered;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  /**
   * Get the source index of the first column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleColumn: function getFirstVisibleColumn2() {
    var startColumn = this.dataAccessObject.startColumnVisible;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  /**
   * Get the source index of the last rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedColumn: function getLastRenderedColumn2() {
    var endColumn = this.dataAccessObject.endColumnRendered;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  /**
   * Get the source index of the last column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleColumn: function getLastVisibleColumn2() {
    var endColumn = this.dataAccessObject.endColumnVisible;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  /**
   * Get the number of rendered columns.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedColumnsCount: function getRenderedColumnsCount2() {
    return this.dataAccessObject.countColumnsRendered;
  },
  /**
   * Get the number of fully visible columns in the viewport.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleColumnsCount: function getVisibleColumnsCount2() {
    return this.dataAccessObject.countColumnsVisible;
  }
};
defineGetter(calculatedColumns, "MIXIN_NAME", MIXIN_NAME$4, {
  writable: false,
  enumerable: false
});
const calculatedColumns$1 = calculatedColumns;
function _typeof$1p(obj) {
  "@babel/helpers - typeof";
  return _typeof$1p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1p(obj);
}
function _defineProperties$2e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2e(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$2e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$1g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1h(subClass, superClass);
}
function _setPrototypeOf$1h(o, p2) {
  _setPrototypeOf$1h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1h(o, p2);
}
function _createSuper$1g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1g(this, result);
  };
}
function _possibleConstructorReturn$1g(self2, call2) {
  if (call2 && (_typeof$1p(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1g(self2);
}
function _assertThisInitialized$1g(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1g(o) {
  _getPrototypeOf$1g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1g(o);
}
var BottomOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$1g(BottomOverlayTable2, _Table);
  var _super = _createSuper$1g(BottomOverlayTable2);
  function BottomOverlayTable2(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    _classCallCheck$2e(this, BottomOverlayTable2);
    return _super.call(this, dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_BOTTOM);
  }
  return _createClass$2e(BottomOverlayTable2);
}(Table$1);
mixin(BottomOverlayTable, stickyRowsBottom$1);
mixin(BottomOverlayTable, calculatedColumns$1);
const BottomOverlayTable$1 = BottomOverlayTable;
function _typeof$1o(obj) {
  "@babel/helpers - typeof";
  return _typeof$1o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1o(obj);
}
function _construct$4(Parent, args, Class) {
  if (_isNativeReflectConstruct$1g()) {
    _construct$4 = Reflect.construct.bind();
  } else {
    _construct$4 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1g(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$4.apply(null, arguments);
}
function _classCallCheck$2d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2d(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1g(subClass, superClass);
}
function _setPrototypeOf$1g(o, p2) {
  _setPrototypeOf$1g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1g(o, p2);
}
function _createSuper$1f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1f(this, result);
  };
}
function _possibleConstructorReturn$1f(self2, call2) {
  if (call2 && (_typeof$1o(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1f(self2);
}
function _assertThisInitialized$1f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1f(o) {
  _getPrototypeOf$1f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1f(o);
}
function _defineProperty$z(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BottomOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$1f(BottomOverlay2, _Overlay);
  var _super = _createSuper$1f(BottomOverlay2);
  function BottomOverlay2(wotInstance, facadeGetter, wtSettings, domBindings) {
    var _this;
    _classCallCheck$2d(this, BottomOverlay2);
    _this = _super.call(this, wotInstance, facadeGetter, CLONE_BOTTOM, wtSettings, domBindings);
    _defineProperty$z(_assertThisInitialized$1f(_this), "cachedFixedRowsBottom", -1);
    _this.cachedFixedRowsBottom = _this.wtSettings.getSetting("fixedRowsBottom");
    return _this;
  }
  _createClass$2d(BottomOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$4(BottomOverlayTable$1, args);
    }
    /**
     * Checks if overlay should be fully rendered.
     *
     * @returns {boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wtSettings.getSetting("shouldRenderBottomOverlay");
    }
    /**
     * Updates the top overlay position.
     *
     * @returns {boolean}
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        return false;
      }
      var rootWindow = this.domBindings.rootWindow;
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      overlayRoot.style.top = "";
      var overlayPosition = 0;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
        overlayPosition = this.getOverlayOffset();
        overlayRoot.style.bottom = "".concat(overlayPosition, "px");
      } else {
        overlayPosition = this.getScrollPosition();
        this.repositionOverlay();
      }
      var positionChanged = this.adjustHeaderBordersPosition(overlayPosition);
      this.adjustElementsSize();
      return positionChanged;
    }
    /**
     * Updates the bottom overlay position.
     */
  }, {
    key: "repositionOverlay",
    value: function repositionOverlay() {
      var _this$wot = this.wot, wtTable = _this$wot.wtTable, wtViewport = _this$wot.wtViewport;
      var rootDocument = this.domBindings.rootDocument;
      var cloneRoot = this.clone.wtTable.holder.parentNode;
      var bottomOffset = 0;
      if (!wtViewport.hasVerticalScroll()) {
        bottomOffset += wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();
      }
      if (wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {
        bottomOffset += getScrollbarWidth(rootDocument);
      }
      cloneRoot.style.bottom = "".concat(bottomOffset, "px");
    }
    /**
     * Sets the main overlay's vertical scroll position.
     *
     * @param {number} pos The scroll position.
     * @returns {boolean}
     */
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var rootWindow = this.domBindings.rootWindow;
      var result = false;
      if (this.mainTableScrollableElement === rootWindow) {
        rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);
        result = true;
      } else if (this.mainTableScrollableElement.scrollTop !== pos) {
        this.mainTableScrollableElement.scrollTop = pos;
        result = true;
      }
      return result;
    }
    /**
     * Triggers onScroll hook callback.
     */
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wtSettings.getSetting("onScrollHorizontally");
    }
    /**
     * Calculates total sum cells height.
     *
     * @param {number} from Row index which calculates started from.
     * @param {number} to Row index where calculation is finished.
     * @returns {number} Height sum.
     */
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from3, to) {
      var _this$wot2 = this.wot, wtTable = _this$wot2.wtTable, wtSettings = _this$wot2.wtSettings;
      var defaultRowHeight = wtSettings.getSetting("defaultRowHeight");
      var row = from3;
      var sum = 0;
      while (row < to) {
        var height = wtTable.getRowHeight(row);
        sum += height === void 0 ? defaultRowHeight : height;
        row += 1;
      }
      return sum;
    }
    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
      }
    }
    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var _this$wot3 = this.wot, wtTable = _this$wot3.wtTable, wtViewport = _this$wot3.wtViewport;
      var _this$domBindings = this.domBindings, rootDocument = _this$domBindings.rootDocument, rootWindow = _this$domBindings.rootWindow;
      var scrollbarWidth = getScrollbarWidth(rootDocument);
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      if (this.trimmingContainer !== rootWindow || preventOverflow === "horizontal") {
        var width = wtViewport.getWorkspaceWidth();
        if (this.wot.wtOverlays.hasScrollbarRight) {
          width -= scrollbarWidth;
        }
        width = Math.min(width, wtTable.wtRootElement.scrollWidth);
        overlayRootStyle.width = "".concat(width, "px");
      } else {
        overlayRootStyle.width = "";
      }
      this.clone.wtTable.holder.style.width = overlayRootStyle.width;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRootStyle.height = "".concat(tableHeight, "px");
    }
    /**
     * Adjust overlay root childs size.
     */
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var holder2 = this.clone.wtTable.holder;
      this.clone.wtTable.hider.style.width = this.hider.style.width;
      holder2.style.width = holder2.parentNode.style.width;
      holder2.style.height = holder2.parentNode.style.height;
    }
    /**
     * Adjust the overlay dimensions and position.
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wtSettings.getSetting("totalRows");
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.top = "0";
      } else {
        throw new Error("Incorrect value of the rowsRenderCalculator");
      }
      this.spreader.style.bottom = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
    /**
     * Synchronize calculated left position to an element.
     */
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      var styleProperty = this.isRtl() ? "right" : "left";
      var spreader = this.clone.wtTable.spreader;
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        spreader.style[styleProperty] = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else {
        spreader.style[styleProperty] = "";
      }
    }
    /**
     * Scrolls vertically to a row.
     *
     * @param {number} sourceRow Row index which you want to scroll to.
     * @param {boolean} [bottomEdge=false] If `true`, scrolls according to the bottom edge (top edge is by default).
     */
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceRow, bottomEdge) {
      var newY = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;
      if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
        scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);
      }
      if (bottomEdge) {
        newY += this.sumCellSizes(0, sourceRow + 1);
        newY -= this.wot.wtViewport.getViewportHeight();
        newY += 1;
      } else {
        newY += this.sumCellSizes(this.wtSettings.getSetting("fixedRowsBottom"), sourceRow);
      }
      newY += scrollbarCompensation;
      this.setScrollPosition(newY);
    }
    /**
     * Gets table parent top position.
     *
     * @returns {number}
     */
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      if (this.mainTableScrollableElement === this.domBindings.rootWindow) {
        return this.wot.wtTable.holderOffset.top;
      }
      return 0;
    }
    /**
     * Gets the main overlay's vertical scroll position.
     *
     * @returns {number} Main table's vertical scroll position.
     */
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollTop(this.mainTableScrollableElement, this.domBindings.rootWindow);
    }
    /**
     * Gets the main overlay's vertical overlay offset.
     *
     * @returns {number} Main table's vertical overlay offset.
     */
  }, {
    key: "getOverlayOffset",
    value: function getOverlayOffset() {
      var rootWindow = this.domBindings.rootWindow;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      var overlayOffset = 0;
      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
        var rootHeight = this.wot.wtTable.getTotalHeight();
        var overlayRootHeight = this.clone.wtTable.getTotalHeight();
        var maxOffset = rootHeight - overlayRootHeight;
        var docClientHeight = this.domBindings.rootDocument.documentElement.clientHeight;
        overlayOffset = Math.max(this.getTableParentOffset() - this.getScrollPosition() - docClientHeight + rootHeight, 0);
        if (overlayOffset > maxOffset) {
          overlayOffset = 0;
        }
      }
      return overlayOffset;
    }
    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue).
     *
     * @param {number} position Header Y position if trimming container is window or scroll top if not.
     * @returns {boolean}
     */
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
      var areFixedRowsBottomChanged = this.cachedFixedRowsBottom !== fixedRowsBottom;
      var columnHeaders = this.wtSettings.getSetting("columnHeaders");
      var positionChanged = false;
      if ((areFixedRowsBottomChanged || fixedRowsBottom === 0) && columnHeaders.length > 0) {
        var masterParent = this.wot.wtTable.holder.parentNode;
        var previousState = hasClass(masterParent, "innerBorderBottom");
        this.cachedFixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
        if (position || this.wtSettings.getSetting("totalRows") === 0) {
          addClass(masterParent, "innerBorderBottom");
          positionChanged = !previousState;
        } else {
          removeClass(masterParent, "innerBorderBottom");
          positionChanged = previousState;
        }
      }
      return positionChanged;
    }
  }]);
  return BottomOverlay2;
}(Overlay);
var MIXIN_NAME$3 = "calculatedRows";
var calculatedRows = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow: function getFirstRenderedRow2() {
    var startRow = this.dataAccessObject.startRowRendered;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow: function getFirstVisibleRow2() {
    var startRow = this.dataAccessObject.startRowVisible;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow: function getLastRenderedRow2() {
    var endRow = this.dataAccessObject.endRowRendered;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow: function getLastVisibleRow2() {
    var endRow = this.dataAccessObject.endRowVisible;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount: function getRenderedRowsCount2() {
    return this.dataAccessObject.countRowsRendered;
  },
  /**
   * Get the number of fully visible rows in the viewport.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount: function getVisibleRowsCount2() {
    return this.dataAccessObject.countRowsVisible;
  }
};
defineGetter(calculatedRows, "MIXIN_NAME", MIXIN_NAME$3, {
  writable: false,
  enumerable: false
});
const calculatedRows$1 = calculatedRows;
function _typeof$1n(obj) {
  "@babel/helpers - typeof";
  return _typeof$1n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1n(obj);
}
function _defineProperties$2c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2c(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$2c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$1e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1f(subClass, superClass);
}
function _setPrototypeOf$1f(o, p2) {
  _setPrototypeOf$1f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1f(o, p2);
}
function _createSuper$1e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1e(this, result);
  };
}
function _possibleConstructorReturn$1e(self2, call2) {
  if (call2 && (_typeof$1n(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1e(self2);
}
function _assertThisInitialized$1e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1e(o) {
  _getPrototypeOf$1e = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1e(o);
}
var InlineStartOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$1e(InlineStartOverlayTable2, _Table);
  var _super = _createSuper$1e(InlineStartOverlayTable2);
  function InlineStartOverlayTable2(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    _classCallCheck$2c(this, InlineStartOverlayTable2);
    return _super.call(this, dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_INLINE_START);
  }
  return _createClass$2c(InlineStartOverlayTable2);
}(Table$1);
mixin(InlineStartOverlayTable, calculatedRows$1);
mixin(InlineStartOverlayTable, stickyColumnsStart$1);
const InlineStartOverlayTable$1 = InlineStartOverlayTable;
function _typeof$1m(obj) {
  "@babel/helpers - typeof";
  return _typeof$1m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1m(obj);
}
function _construct$3(Parent, args, Class) {
  if (_isNativeReflectConstruct$1e()) {
    _construct$3 = Reflect.construct.bind();
  } else {
    _construct$3 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1e(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$3.apply(null, arguments);
}
function _classCallCheck$2b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2b(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1e(subClass, superClass);
}
function _setPrototypeOf$1e(o, p2) {
  _setPrototypeOf$1e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1e(o, p2);
}
function _createSuper$1d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1d(this, result);
  };
}
function _possibleConstructorReturn$1d(self2, call2) {
  if (call2 && (_typeof$1m(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1d(self2);
}
function _assertThisInitialized$1d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1d(o) {
  _getPrototypeOf$1d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1d(o);
}
var InlineStartOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$1d(InlineStartOverlay2, _Overlay);
  var _super = _createSuper$1d(InlineStartOverlay2);
  function InlineStartOverlay2(wotInstance, facadeGetter, wtSettings, domBindings) {
    _classCallCheck$2b(this, InlineStartOverlay2);
    return _super.call(this, wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings);
  }
  _createClass$2b(InlineStartOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$3(InlineStartOverlayTable$1, args);
    }
    /**
     * Checks if overlay should be fully rendered.
     *
     * @returns {boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wtSettings.getSetting("shouldRenderInlineStartOverlay");
    }
    /**
     * Updates the left overlay position.
     *
     * @returns {boolean}
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      var wtTable = this.wot.wtTable;
      if (!this.needFullRender || !wtTable.holder.parentNode) {
        return false;
      }
      var rootWindow = this.domBindings.rootWindow;
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      var overlayPosition = 0;
      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "horizontal")) {
        overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);
        setOverlayPosition(overlayRoot, "".concat(overlayPosition, "px"), "0px");
      } else {
        overlayPosition = this.getScrollPosition();
        resetCssTransform(overlayRoot);
      }
      var positionChanged = this.adjustHeaderBordersPosition(overlayPosition);
      this.adjustElementsSize();
      return positionChanged;
    }
    /**
     * Sets the main overlay's horizontal scroll position.
     *
     * @param {number} pos The scroll position.
     * @returns {boolean}
     */
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var rootWindow = this.domBindings.rootWindow;
      var result = false;
      if (this.isRtl()) {
        pos = -pos;
      }
      if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {
        rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));
        result = true;
      } else if (this.mainTableScrollableElement.scrollLeft !== pos) {
        this.mainTableScrollableElement.scrollLeft = pos;
        result = true;
      }
      return result;
    }
    /**
     * Triggers onScroll hook callback.
     */
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wtSettings.getSetting("onScrollVertically");
    }
    /**
     * Calculates total sum cells width.
     *
     * @param {number} from Column index which calculates started from.
     * @param {number} to Column index where calculation is finished.
     * @returns {number} Width sum.
     */
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from3, to) {
      var defaultColumnWidth = this.wtSettings.getSetting("defaultColumnWidth");
      var column = from3;
      var sum = 0;
      while (column < to) {
        sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;
        column += 1;
      }
      return sum;
    }
    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
      }
    }
    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var wtTable = this.wot.wtTable;
      var _this$domBindings = this.domBindings, rootDocument = _this$domBindings.rootDocument, rootWindow = _this$domBindings.rootWindow;
      var scrollbarHeight = getScrollbarWidth(rootDocument);
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      if (this.trimmingContainer !== rootWindow || preventOverflow === "vertical") {
        var height = this.wot.wtViewport.getWorkspaceHeight();
        if (this.wot.wtOverlays.hasScrollbarBottom) {
          height -= scrollbarHeight;
        }
        height = Math.min(height, wtTable.wtRootElement.scrollHeight);
        overlayRootStyle.height = "".concat(height, "px");
      } else {
        overlayRootStyle.height = "";
      }
      this.clone.wtTable.holder.style.height = overlayRootStyle.height;
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      overlayRootStyle.width = "".concat(tableWidth, "px");
    }
    /**
     * Adjust overlay root childs size.
     */
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var _selections$getCell$g;
      var holder2 = this.clone.wtTable.holder;
      var selections = this.wot.selections;
      var facade = this.facadeGetter();
      var selectionCornerOffset = Math.abs((_selections$getCell$g = selections === null || selections === void 0 ? void 0 : selections.getCell().getBorder(facade).cornerCenterPointOffset) !== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);
      this.clone.wtTable.hider.style.height = this.hider.style.height;
      holder2.style.height = holder2.parentNode.style.height;
      holder2.style.width = "".concat(parseInt(holder2.parentNode.style.width, 10) + selectionCornerOffset, "px");
    }
    /**
     * Adjust the overlay dimensions and position.
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wtSettings.getSetting("totalColumns");
      var styleProperty = this.isRtl() ? "right" : "left";
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        this.spreader.style[styleProperty] = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style[styleProperty] = "0";
      } else {
        throw new Error("Incorrect value of the columnsRenderCalculator");
      }
      if (this.isRtl()) {
        this.spreader.style.left = "";
      } else {
        this.spreader.style.right = "";
      }
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
    /**
     * Synchronize calculated top position to an element.
     */
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.clone.wtTable.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else {
        this.clone.wtTable.spreader.style.top = "";
      }
    }
    /**
     * Scrolls horizontally to a column at the left edge of the viewport.
     *
     * @param {number} sourceCol  Column index which you want to scroll to.
     * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right
     *                                    edge (left edge is by default).
     * @returns {boolean}
     */
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceCol, beyondRendered) {
      var newX = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;
      if (beyondRendered) {
        var columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);
        var viewportWidth = this.wot.wtViewport.getViewportWidth();
        if (columnWidth > viewportWidth) {
          beyondRendered = false;
        }
      }
      if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
        scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);
      }
      if (beyondRendered) {
        newX += this.sumCellSizes(0, sourceCol + 1);
        newX -= this.wot.wtViewport.getViewportWidth();
      } else {
        newX += this.sumCellSizes(this.wtSettings.getSetting("fixedColumnsStart"), sourceCol);
      }
      newX += scrollbarCompensation;
      return this.setScrollPosition(newX);
    }
    /**
     * Gets table parent left position.
     *
     * @returns {number}
     */
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      var offset2 = 0;
      if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {
        offset2 = this.wot.wtTable.holderOffset.left;
      }
      return offset2;
    }
    /**
     * Gets the main overlay's horizontal scroll position.
     *
     * @returns {number} Main table's horizontal scroll position.
     */
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));
    }
    /**
     * Gets the main overlay's horizontal overlay offset.
     *
     * @returns {number} Main table's horizontal overlay offset.
     */
  }, {
    key: "getOverlayOffset",
    value: function getOverlayOffset() {
      var rootWindow = this.domBindings.rootWindow;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      var overlayOffset = 0;
      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "horizontal")) {
        if (this.isRtl()) {
          overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));
        } else {
          overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);
        }
        var rootWidth = this.wot.wtTable.getTotalWidth();
        var overlayRootWidth = this.clone.wtTable.getTotalWidth();
        var maxOffset = rootWidth - overlayRootWidth;
        if (overlayOffset > maxOffset) {
          overlayOffset = 0;
        }
      }
      return overlayOffset;
    }
    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue).
     *
     * @param {number} position Header X position if trimming container is window or scroll top if not.
     * @returns {boolean}
     */
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var masterParent = this.wot.wtTable.holder.parentNode;
      var rowHeaders = this.wtSettings.getSetting("rowHeaders");
      var fixedColumnsStart = this.wtSettings.getSetting("fixedColumnsStart");
      var totalRows = this.wtSettings.getSetting("totalRows");
      if (totalRows) {
        removeClass(masterParent, "emptyRows");
      } else {
        addClass(masterParent, "emptyRows");
      }
      var positionChanged = false;
      if (fixedColumnsStart && !rowHeaders.length) {
        addClass(masterParent, "innerBorderLeft innerBorderInlineStart");
      } else if (!fixedColumnsStart && rowHeaders.length) {
        var previousState = hasClass(masterParent, "innerBorderInlineStart");
        if (position) {
          addClass(masterParent, "innerBorderLeft innerBorderInlineStart");
          positionChanged = !previousState;
        } else {
          removeClass(masterParent, "innerBorderLeft innerBorderInlineStart");
          positionChanged = previousState;
        }
      }
      return positionChanged;
    }
  }]);
  return InlineStartOverlay2;
}(Overlay);
var MIXIN_NAME$2 = "stickyRowsTop";
var stickyRowsTop = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow: function getFirstRenderedRow3() {
    var totalRows = this.wtSettings.getSetting("totalRows");
    if (totalRows === 0) {
      return -1;
    }
    return 0;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow: function getFirstVisibleRow3() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow: function getLastRenderedRow3() {
    return this.getRenderedRowsCount() - 1;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow: function getLastVisibleRow3() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount: function getRenderedRowsCount3() {
    var totalRows = this.wtSettings.getSetting("totalRows");
    return Math.min(this.wtSettings.getSetting("fixedRowsTop"), totalRows);
  },
  /**
   * Get the number of fully visible rows in the viewport.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount: function getVisibleRowsCount3() {
    return this.getRenderedRowsCount();
  }
};
defineGetter(stickyRowsTop, "MIXIN_NAME", MIXIN_NAME$2, {
  writable: false,
  enumerable: false
});
const stickyRowsTop$1 = stickyRowsTop;
function _typeof$1l(obj) {
  "@babel/helpers - typeof";
  return _typeof$1l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1l(obj);
}
function _defineProperties$2a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2a(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$2a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$1c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1d(subClass, superClass);
}
function _setPrototypeOf$1d(o, p2) {
  _setPrototypeOf$1d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1d(o, p2);
}
function _createSuper$1c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1c(this, result);
  };
}
function _possibleConstructorReturn$1c(self2, call2) {
  if (call2 && (_typeof$1l(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1c(self2);
}
function _assertThisInitialized$1c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1c(o) {
  _getPrototypeOf$1c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1c(o);
}
var TopInlineStartCornerOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$1c(TopInlineStartCornerOverlayTable2, _Table);
  var _super = _createSuper$1c(TopInlineStartCornerOverlayTable2);
  function TopInlineStartCornerOverlayTable2(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    _classCallCheck$2a(this, TopInlineStartCornerOverlayTable2);
    return _super.call(this, dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_TOP_INLINE_START_CORNER);
  }
  return _createClass$2a(TopInlineStartCornerOverlayTable2);
}(Table$1);
mixin(TopInlineStartCornerOverlayTable, stickyRowsTop$1);
mixin(TopInlineStartCornerOverlayTable, stickyColumnsStart$1);
const TopInlineStartCornerOverlayTable$1 = TopInlineStartCornerOverlayTable;
function _typeof$1k(obj) {
  "@babel/helpers - typeof";
  return _typeof$1k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1k(obj);
}
function _construct$2(Parent, args, Class) {
  if (_isNativeReflectConstruct$1c()) {
    _construct$2 = Reflect.construct.bind();
  } else {
    _construct$2 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1c(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$2.apply(null, arguments);
}
function _classCallCheck$29(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$29(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$29(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$29(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$29(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1c(subClass, superClass);
}
function _setPrototypeOf$1c(o, p2) {
  _setPrototypeOf$1c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1c(o, p2);
}
function _createSuper$1b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1b(this, result);
  };
}
function _possibleConstructorReturn$1b(self2, call2) {
  if (call2 && (_typeof$1k(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1b(self2);
}
function _assertThisInitialized$1b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1b(o) {
  _getPrototypeOf$1b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1b(o);
}
function _defineProperty$y(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TopInlineStartCornerOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$1b(TopInlineStartCornerOverlay2, _Overlay);
  var _super = _createSuper$1b(TopInlineStartCornerOverlay2);
  function TopInlineStartCornerOverlay2(wotInstance, facadeGetter, wtSettings, domBindings, topOverlay, inlineStartOverlay) {
    var _this;
    _classCallCheck$29(this, TopInlineStartCornerOverlay2);
    _this = _super.call(this, wotInstance, facadeGetter, CLONE_TOP_INLINE_START_CORNER, wtSettings, domBindings);
    _defineProperty$y(_assertThisInitialized$1b(_this), "topOverlay", void 0);
    _defineProperty$y(_assertThisInitialized$1b(_this), "inlineStartOverlay", void 0);
    _this.topOverlay = topOverlay;
    _this.inlineStartOverlay = inlineStartOverlay;
    return _this;
  }
  _createClass$29(TopInlineStartCornerOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$2(TopInlineStartCornerOverlayTable$1, args);
    }
    /**
     * Checks if overlay should be fully rendered.
     *
     * @returns {boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wtSettings.getSetting("shouldRenderTopOverlay") && this.wtSettings.getSetting("shouldRenderInlineStartOverlay");
    }
    /**
     * Updates the corner overlay position.
     *
     * @returns {boolean}
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      this.updateTrimmingContainer();
      if (!this.wot.wtTable.holder.parentNode) {
        return false;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      if (this.trimmingContainer === this.domBindings.rootWindow) {
        var left2 = this.inlineStartOverlay.getOverlayOffset() * (this.isRtl() ? -1 : 1);
        var top2 = this.topOverlay.getOverlayOffset();
        setOverlayPosition(overlayRoot, "".concat(left2, "px"), "".concat(top2, "px"));
      } else {
        resetCssTransform(overlayRoot);
      }
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRoot.style.height = "".concat(tableHeight, "px");
      overlayRoot.style.width = "".concat(tableWidth, "px");
      return false;
    }
  }]);
  return TopInlineStartCornerOverlay2;
}(Overlay);
function _typeof$1j(obj) {
  "@babel/helpers - typeof";
  return _typeof$1j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1j(obj);
}
function _defineProperties$28(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$28(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$28(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$28(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$28(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$1a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1b(subClass, superClass);
}
function _setPrototypeOf$1b(o, p2) {
  _setPrototypeOf$1b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1b(o, p2);
}
function _createSuper$1a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1a(this, result);
  };
}
function _possibleConstructorReturn$1a(self2, call2) {
  if (call2 && (_typeof$1j(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1a(self2);
}
function _assertThisInitialized$1a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1a(o) {
  _getPrototypeOf$1a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1a(o);
}
var TopOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$1a(TopOverlayTable2, _Table);
  var _super = _createSuper$1a(TopOverlayTable2);
  function TopOverlayTable2(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    _classCallCheck$28(this, TopOverlayTable2);
    return _super.call(this, dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_TOP);
  }
  return _createClass$28(TopOverlayTable2);
}(Table$1);
mixin(TopOverlayTable, stickyRowsTop$1);
mixin(TopOverlayTable, calculatedColumns$1);
const TopOverlayTable$1 = TopOverlayTable;
function _typeof$1i(obj) {
  "@babel/helpers - typeof";
  return _typeof$1i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1i(obj);
}
function _construct$1(Parent, args, Class) {
  if (_isNativeReflectConstruct$1a()) {
    _construct$1 = Reflect.construct.bind();
  } else {
    _construct$1 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1a(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$1.apply(null, arguments);
}
function _classCallCheck$27(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$27(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$27(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$27(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$27(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$19(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1a(subClass, superClass);
}
function _setPrototypeOf$1a(o, p2) {
  _setPrototypeOf$1a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1a(o, p2);
}
function _createSuper$19(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$19(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$19(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$19(this, result);
  };
}
function _possibleConstructorReturn$19(self2, call2) {
  if (call2 && (_typeof$1i(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$19(self2);
}
function _assertThisInitialized$19(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$19(o) {
  _getPrototypeOf$19 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$19(o);
}
function _defineProperty$x(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TopOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$19(TopOverlay2, _Overlay);
  var _super = _createSuper$19(TopOverlay2);
  function TopOverlay2(wotInstance, facadeGetter, wtSettings, domBindings) {
    var _this;
    _classCallCheck$27(this, TopOverlay2);
    _this = _super.call(this, wotInstance, facadeGetter, CLONE_TOP, wtSettings, domBindings);
    _defineProperty$x(_assertThisInitialized$19(_this), "cachedFixedRowsTop", -1);
    _this.cachedFixedRowsTop = _this.wtSettings.getSetting("fixedRowsTop");
    return _this;
  }
  _createClass$27(TopOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$1(TopOverlayTable$1, args);
    }
    /**
     * Checks if overlay should be fully rendered.
     *
     * @returns {boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wtSettings.getSetting("shouldRenderTopOverlay");
    }
    /**
     * Updates the top overlay position.
     *
     * @returns {boolean}
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        return false;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var rootWindow = this.domBindings.rootWindow;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      var overlayPosition = 0;
      var skipInnerBorderAdjusting = false;
      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
        var wtTable = this.wot.wtTable;
        var hiderRect = wtTable.hider.getBoundingClientRect();
        var bottom2 = Math.ceil(hiderRect.bottom);
        var rootHeight = overlayRoot.offsetHeight;
        skipInnerBorderAdjusting = bottom2 === rootHeight;
        overlayPosition = this.getOverlayOffset();
        setOverlayPosition(overlayRoot, "0px", "".concat(overlayPosition, "px"));
      } else {
        overlayPosition = this.getScrollPosition();
        resetCssTransform(overlayRoot);
      }
      var positionChanged = this.adjustHeaderBordersPosition(overlayPosition, skipInnerBorderAdjusting);
      this.adjustElementsSize();
      return positionChanged;
    }
    /**
     * Sets the main overlay's vertical scroll position.
     *
     * @param {number} pos The scroll position.
     * @returns {boolean}
     */
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var rootWindow = this.domBindings.rootWindow;
      var result = false;
      if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollY !== pos) {
        rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);
        result = true;
      } else if (this.mainTableScrollableElement.scrollTop !== pos) {
        this.mainTableScrollableElement.scrollTop = pos;
        result = true;
      }
      return result;
    }
    /**
     * Triggers onScroll hook callback.
     */
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wtSettings.getSetting("onScrollHorizontally");
    }
    /**
     * Calculates total sum cells height.
     *
     * @param {number} from Row index which calculates started from.
     * @param {number} to Row index where calculation is finished.
     * @returns {number} Height sum.
     */
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from3, to) {
      var defaultRowHeight = this.wtSettings.getSetting("defaultRowHeight");
      var row = from3;
      var sum = 0;
      while (row < to) {
        var height = this.wot.wtTable.getRowHeight(row);
        sum += height === void 0 ? defaultRowHeight : height;
        row += 1;
      }
      return sum;
    }
    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
      }
    }
    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var wtTable = this.wot.wtTable;
      var _this$domBindings = this.domBindings, rootDocument = _this$domBindings.rootDocument, rootWindow = _this$domBindings.rootWindow;
      var scrollbarWidth = getScrollbarWidth(rootDocument);
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      if (this.trimmingContainer !== rootWindow || preventOverflow === "horizontal") {
        var width = this.wot.wtViewport.getWorkspaceWidth();
        if (this.wot.wtOverlays.hasScrollbarRight) {
          width -= scrollbarWidth;
        }
        width = Math.min(width, wtTable.wtRootElement.scrollWidth);
        overlayRootStyle.width = "".concat(width, "px");
      } else {
        overlayRootStyle.width = "";
      }
      this.clone.wtTable.holder.style.width = overlayRootStyle.width;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRootStyle.height = "".concat(tableHeight, "px");
    }
    /**
     * Adjust overlay root childs size.
     */
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var _selections$getCell$g;
      var holder2 = this.clone.wtTable.holder;
      var selections = this.wot.selections;
      var facade = this.facadeGetter();
      var selectionCornerOffset = Math.abs((_selections$getCell$g = selections === null || selections === void 0 ? void 0 : selections.getCell().getBorder(facade).cornerCenterPointOffset) !== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);
      this.clone.wtTable.hider.style.width = this.hider.style.width;
      holder2.style.width = holder2.parentNode.style.width;
      holder2.style.height = "".concat(parseInt(holder2.parentNode.style.height, 10) + selectionCornerOffset, "px");
    }
    /**
     * Adjust the overlay dimensions and position.
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wtSettings.getSetting("totalRows");
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.top = "0";
      } else {
        throw new Error("Incorrect value of the rowsRenderCalculator");
      }
      this.spreader.style.bottom = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
    /**
     * Synchronize calculated left position to an element.
     */
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      var styleProperty = this.isRtl() ? "right" : "left";
      var spreader = this.clone.wtTable.spreader;
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        spreader.style[styleProperty] = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else {
        spreader.style[styleProperty] = "";
      }
    }
    /**
     * Scrolls vertically to a row.
     *
     * @param {number} sourceRow Row index which you want to scroll to.
     * @param {boolean} [bottomEdge] If `true`, scrolls according to the bottom edge (top edge is by default).
     * @returns {boolean}
     */
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceRow, bottomEdge) {
      var wot = this.wot, wtSettings = this.wtSettings;
      var sourceInstance = wot.cloneSource ? wot.cloneSource : wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var newY = this.getTableParentOffset();
      var scrollbarCompensation = 0;
      if (bottomEdge) {
        var rowHeight = this.wot.wtTable.getRowHeight(sourceRow);
        var viewportHeight = this.wot.wtViewport.getViewportHeight();
        if (rowHeight > viewportHeight) {
          bottomEdge = false;
        }
      }
      if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
        scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);
      }
      if (bottomEdge) {
        var fixedRowsBottom = wtSettings.getSetting("fixedRowsBottom");
        var totalRows = wtSettings.getSetting("totalRows");
        newY += this.sumCellSizes(0, sourceRow + 1);
        newY -= wot.wtViewport.getViewportHeight() - this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
        newY += 1;
      } else {
        newY += this.sumCellSizes(wtSettings.getSetting("fixedRowsTop"), sourceRow);
      }
      newY += scrollbarCompensation;
      return this.setScrollPosition(newY);
    }
    /**
     * Gets table parent top position.
     *
     * @returns {number}
     */
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      if (this.mainTableScrollableElement === this.domBindings.rootWindow) {
        return this.wot.wtTable.holderOffset.top;
      }
      return 0;
    }
    /**
     * Gets the main overlay's vertical scroll position.
     *
     * @returns {number} Main table's vertical scroll position.
     */
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollTop(this.mainTableScrollableElement, this.domBindings.rootWindow);
    }
    /**
     * Gets the main overlay's vertical overlay offset.
     *
     * @returns {number} Main table's vertical overlay offset.
     */
  }, {
    key: "getOverlayOffset",
    value: function getOverlayOffset() {
      var rootWindow = this.domBindings.rootWindow;
      var preventOverflow = this.wtSettings.getSetting("preventOverflow");
      var overlayOffset = 0;
      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
        var rootHeight = this.wot.wtTable.getTotalHeight();
        var overlayRootHeight = this.clone.wtTable.getTotalHeight();
        var maxOffset = rootHeight - overlayRootHeight;
        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);
        if (overlayOffset > maxOffset) {
          overlayOffset = 0;
        }
      }
      return overlayOffset;
    }
    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue).
     *
     * @param {number} position Header Y position if trimming container is window or scroll top if not.
     * @param {boolean} [skipInnerBorderAdjusting=false] If `true` the inner border adjusting will be skipped.
     * @returns {boolean}
     */
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var skipInnerBorderAdjusting = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var masterParent = this.wot.wtTable.holder.parentNode;
      var totalColumns = this.wtSettings.getSetting("totalColumns");
      if (totalColumns) {
        removeClass(masterParent, "emptyColumns");
      } else {
        addClass(masterParent, "emptyColumns");
      }
      var positionChanged = false;
      if (!skipInnerBorderAdjusting) {
        var fixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
        var areFixedRowsTopChanged = this.cachedFixedRowsTop !== fixedRowsTop;
        var columnHeaders = this.wtSettings.getSetting("columnHeaders");
        if ((areFixedRowsTopChanged || fixedRowsTop === 0) && columnHeaders.length > 0) {
          var previousState = hasClass(masterParent, "innerBorderTop");
          this.cachedFixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
          if (position || this.wtSettings.getSetting("totalRows") === 0) {
            addClass(masterParent, "innerBorderTop");
            positionChanged = !previousState;
          } else {
            removeClass(masterParent, "innerBorderTop");
            positionChanged = previousState;
          }
        }
      }
      return positionChanged;
    }
  }]);
  return TopOverlay2;
}(Overlay);
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$19()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$19(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct$19() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _setPrototypeOf$19(o, p2) {
  _setPrototypeOf$19 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$19(o, p2);
}
function _classCallCheck$26(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$26(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$26(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$26(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$26(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$w(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Overlays = /* @__PURE__ */ function() {
  function Overlays2(wotInstance, facadeGetter, domBindings, wtSettings, eventManager, wtTable) {
    _classCallCheck$26(this, Overlays2);
    _defineProperty$w(this, "wot", null);
    _defineProperty$w(this, "topOverlay", null);
    _defineProperty$w(this, "bottomOverlay", null);
    _defineProperty$w(this, "inlineStartOverlay", null);
    _defineProperty$w(this, "topInlineStartCornerOverlay", null);
    _defineProperty$w(this, "bottomInlineStartCornerOverlay", null);
    _defineProperty$w(this, "browserLineHeight", void 0);
    _defineProperty$w(this, "wtSettings", null);
    this.wot = wotInstance;
    this.wtSettings = wtSettings;
    this.domBindings = domBindings;
    this.facadeGetter = facadeGetter;
    this.wtTable = wtTable;
    var _this$domBindings = this.domBindings, rootDocument = _this$domBindings.rootDocument, rootWindow = _this$domBindings.rootWindow;
    this.instance = this.wot;
    this.eventManager = eventManager;
    this.scrollbarSize = getScrollbarWidth(rootDocument);
    var isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden";
    this.scrollableElement = isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);
    this.initOverlays();
    this.hasScrollbarBottom = false;
    this.hasScrollbarRight = false;
    this.destroyed = false;
    this.keyPressed = false;
    this.spreaderLastSize = {
      width: null,
      height: null
    };
    this.verticalScrolling = false;
    this.horizontalScrolling = false;
    this.initBrowserLineHeight();
    this.registerListeners();
    this.lastScrollX = rootWindow.scrollX;
    this.lastScrollY = rootWindow.scrollY;
  }
  _createClass$26(Overlays2, [{
    key: "initBrowserLineHeight",
    value: function initBrowserLineHeight() {
      var _this$domBindings2 = this.domBindings, rootWindow = _this$domBindings2.rootWindow, rootDocument = _this$domBindings2.rootDocument;
      var computedStyle = rootWindow.getComputedStyle(rootDocument.body);
      var lineHeight = parseInt(computedStyle.lineHeight, 10);
      var lineHeightFalback = parseInt(computedStyle.fontSize, 10) * 1.2;
      this.browserLineHeight = lineHeight || lineHeightFalback;
    }
    /**
     * Prepare overlays based on user settings.
     *
     * @private
     */
  }, {
    key: "initOverlays",
    value: function initOverlays() {
      var args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];
      this.topOverlay = _construct(TopOverlay, args);
      this.bottomOverlay = _construct(BottomOverlay, args);
      this.inlineStartOverlay = _construct(InlineStartOverlay, args);
      this.topInlineStartCornerOverlay = _construct(TopInlineStartCornerOverlay, args.concat([this.topOverlay, this.inlineStartOverlay]));
      this.bottomInlineStartCornerOverlay = _construct(BottomInlineStartCornerOverlay, args.concat([this.bottomOverlay, this.inlineStartOverlay]));
    }
    /**
     * Update state of rendering, check if changed.
     *
     * @package
     * @returns {boolean} Returns `true` if changes applied to overlay needs scroll synchronization.
     */
  }, {
    key: "updateStateOfRendering",
    value: function updateStateOfRendering() {
      var syncScroll = this.topOverlay.updateStateOfRendering();
      syncScroll = this.bottomOverlay.updateStateOfRendering() || syncScroll;
      syncScroll = this.inlineStartOverlay.updateStateOfRendering() || syncScroll;
      if (this.inlineStartOverlay.needFullRender) {
        if (this.topOverlay.needFullRender) {
          syncScroll = this.topInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;
        }
        if (this.bottomOverlay.needFullRender) {
          syncScroll = this.bottomInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;
        }
      }
      return syncScroll;
    }
    /**
     * Refresh and redraw table.
     */
  }, {
    key: "refreshAll",
    value: function refreshAll() {
      if (!this.wot.drawn) {
        return;
      }
      if (!this.wtTable.holder.parentNode) {
        this.destroy();
        return;
      }
      this.wot.draw(true);
      if (this.verticalScrolling) {
        this.inlineStartOverlay.onScroll();
      }
      if (this.horizontalScrolling) {
        this.topOverlay.onScroll();
      }
      this.verticalScrolling = false;
      this.horizontalScrolling = false;
    }
    /**
     * Register all necessary event listeners.
     */
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this = this;
      var _this$domBindings3 = this.domBindings, rootDocument = _this$domBindings3.rootDocument, rootWindow = _this$domBindings3.rootWindow;
      var topOverlayScrollableElement = this.topOverlay.mainTableScrollableElement;
      var inlineStartOverlayScrollableElement = this.inlineStartOverlay.mainTableScrollableElement;
      this.eventManager.addEventListener(rootDocument.documentElement, "keydown", function(event2) {
        return _this.onKeyDown(event2);
      });
      this.eventManager.addEventListener(rootDocument.documentElement, "keyup", function() {
        return _this.onKeyUp();
      });
      this.eventManager.addEventListener(rootDocument, "visibilitychange", function() {
        return _this.onKeyUp();
      });
      this.eventManager.addEventListener(topOverlayScrollableElement, "scroll", function(event2) {
        return _this.onTableScroll(event2);
      }, {
        passive: true
      });
      if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {
        this.eventManager.addEventListener(inlineStartOverlayScrollableElement, "scroll", function(event2) {
          return _this.onTableScroll(event2);
        }, {
          passive: true
        });
      }
      var isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;
      var isScrollOnWindow = this.scrollableElement === rootWindow;
      var preventWheel = this.wtSettings.getSetting("preventWheel");
      var wheelEventOptions = {
        passive: isScrollOnWindow
      };
      if (preventWheel || isHighPixelRatio || !isChrome()) {
        this.eventManager.addEventListener(this.wtTable.wtRootElement, "wheel", function(event2) {
          return _this.onCloneWheel(event2, preventWheel);
        }, wheelEventOptions);
      }
      var overlays = [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
      overlays.forEach(function(overlay) {
        if (overlay && overlay.needFullRender) {
          var holder2 = overlay.clone.wtTable.holder;
          _this.eventManager.addEventListener(holder2, "wheel", function(event2) {
            return _this.onCloneWheel(event2, preventWheel);
          }, wheelEventOptions);
        }
      });
      var resizeTimeout;
      this.eventManager.addEventListener(rootWindow, "resize", function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          _this.wtSettings.getSetting("onWindowResize");
        }, 200);
      });
    }
    /**
     * Deregister all previously registered listeners.
     */
  }, {
    key: "deregisterListeners",
    value: function deregisterListeners() {
      this.eventManager.clearEvents(true);
    }
    /**
     * Scroll listener.
     *
     * @param {Event} event The mouse event object.
     */
  }, {
    key: "onTableScroll",
    value: function onTableScroll(event2) {
      var rootWindow = this.domBindings.rootWindow;
      var masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;
      var masterVertical = this.topOverlay.mainTableScrollableElement;
      var target = event2.target;
      if (this.keyPressed) {
        if (masterVertical !== rootWindow && target !== rootWindow && !event2.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event2.target.contains(masterHorizontal)) {
          return;
        }
      }
      this.syncScrollPositions(event2);
    }
    /**
     * Wheel listener for cloned overlays.
     *
     * @param {Event} event The mouse event object.
     * @param {boolean} preventDefault If `true`, the `preventDefault` will be called on event object.
     */
  }, {
    key: "onCloneWheel",
    value: function onCloneWheel(event2, preventDefault) {
      var rootWindow = this.domBindings.rootWindow;
      var masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;
      var masterVertical = this.topOverlay.mainTableScrollableElement;
      var target = event2.target;
      var shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);
      var shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);
      if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally)) {
        return;
      }
      var isScrollPossible = this.translateMouseWheelToScroll(event2);
      if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {
        event2.preventDefault();
      }
    }
    /**
     * Key down listener.
     *
     * @param {Event} event The keyboard event object.
     */
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event2) {
      this.keyPressed = isKey(event2.keyCode, "ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT");
    }
    /**
     * Key up listener.
     */
  }, {
    key: "onKeyUp",
    value: function onKeyUp() {
      this.keyPressed = false;
    }
    /**
     * Translate wheel event into scroll event and sync scroll overlays position.
     *
     * @private
     * @param {Event} event The mouse event object.
     * @returns {boolean}
     */
  }, {
    key: "translateMouseWheelToScroll",
    value: function translateMouseWheelToScroll(event2) {
      var deltaY = isNaN(event2.deltaY) ? -1 * event2.wheelDeltaY : event2.deltaY;
      var deltaX = isNaN(event2.deltaX) ? -1 * event2.wheelDeltaX : event2.deltaX;
      if (event2.deltaMode === 1) {
        deltaX += deltaX * this.browserLineHeight;
        deltaY += deltaY * this.browserLineHeight;
      }
      var isScrollVerticallyPossible = this.scrollVertically(deltaY);
      var isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);
      return isScrollVerticallyPossible || isScrollHorizontallyPossible;
    }
    /**
     * Scrolls main scrollable element horizontally.
     *
     * @param {number} delta Relative value to scroll.
     * @returns {boolean}
     */
  }, {
    key: "scrollVertically",
    value: function scrollVertically(delta) {
      var previousScroll = this.scrollableElement.scrollTop;
      this.scrollableElement.scrollTop += delta;
      return previousScroll !== this.scrollableElement.scrollTop;
    }
    /**
     * Scrolls main scrollable element horizontally.
     *
     * @param {number} delta Relative value to scroll.
     * @returns {boolean}
     */
  }, {
    key: "scrollHorizontally",
    value: function scrollHorizontally(delta) {
      var previousScroll = this.scrollableElement.scrollLeft;
      this.scrollableElement.scrollLeft += delta;
      return previousScroll !== this.scrollableElement.scrollLeft;
    }
    /**
     * Synchronize scroll position between master table and overlay table.
     *
     * @private
     */
  }, {
    key: "syncScrollPositions",
    value: function syncScrollPositions() {
      if (this.destroyed) {
        return;
      }
      var rootWindow = this.domBindings.rootWindow;
      var topHolder = this.topOverlay.clone.wtTable.holder;
      var leftHolder = this.inlineStartOverlay.clone.wtTable.holder;
      var _ref2 = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop], scrollLeft = _ref2[0], scrollTop = _ref2[1];
      this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;
      this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;
      this.lastScrollX = rootWindow.scrollX;
      this.lastScrollY = rootWindow.scrollY;
      if (this.horizontalScrolling) {
        topHolder.scrollLeft = scrollLeft;
        var bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null;
        if (bottomHolder) {
          bottomHolder.scrollLeft = scrollLeft;
        }
      }
      if (this.verticalScrolling) {
        leftHolder.scrollTop = scrollTop;
      }
      this.refreshAll();
    }
    /**
     * Synchronize overlay scrollbars with the master scrollbar.
     */
  }, {
    key: "syncScrollWithMaster",
    value: function syncScrollWithMaster() {
      var master = this.topOverlay.mainTableScrollableElement;
      var scrollLeft = master.scrollLeft, scrollTop = master.scrollTop;
      if (this.topOverlay.needFullRender) {
        this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
      }
      if (this.bottomOverlay.needFullRender) {
        this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
      }
      if (this.inlineStartOverlay.needFullRender) {
        this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop;
      }
    }
    /**
     * Update the main scrollable elements for all the overlays.
     */
  }, {
    key: "updateMainScrollableElements",
    value: function updateMainScrollableElements() {
      this.deregisterListeners();
      this.inlineStartOverlay.updateMainScrollableElement();
      this.topOverlay.updateMainScrollableElement();
      if (this.bottomOverlay.needFullRender) {
        this.bottomOverlay.updateMainScrollableElement();
      }
      var wtTable = this.wtTable;
      var rootWindow = this.domBindings.rootWindow;
      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden") {
        this.scrollableElement = wtTable.holder;
      } else {
        this.scrollableElement = getScrollableElement(wtTable.TABLE);
      }
      this.registerListeners();
    }
    /**
     *
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroy();
      this.topOverlay.destroy();
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.destroy();
      }
      this.inlineStartOverlay.destroy();
      if (this.topInlineStartCornerOverlay) {
        this.topInlineStartCornerOverlay.destroy();
      }
      if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {
        this.bottomInlineStartCornerOverlay.destroy();
      }
      this.destroyed = true;
    }
    /**
     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
     *                                   the data. It will only work if Table.draw() does not force
     *                                   rendering anyway.
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var spreader = this.wtTable.spreader;
      var width = spreader.clientWidth;
      var height = spreader.clientHeight;
      if (width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height) {
        this.spreaderLastSize.width = width;
        this.spreaderLastSize.height = height;
        this.adjustElementsSize();
      }
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.refresh(fastDraw);
      }
      this.inlineStartOverlay.refresh(fastDraw);
      this.topOverlay.refresh(fastDraw);
      if (this.topInlineStartCornerOverlay) {
        this.topInlineStartCornerOverlay.refresh(fastDraw);
      }
      if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {
        this.bottomInlineStartCornerOverlay.refresh(fastDraw);
      }
    }
    /**
     * Adjust overlays elements size and master table size.
     *
     * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var wtViewport = this.wot.wtViewport;
      var wtTable = this.wtTable;
      var totalColumns = this.wtSettings.getSetting("totalColumns");
      var totalRows = this.wtSettings.getSetting("totalRows");
      var headerRowSize = wtViewport.getRowHeaderWidth();
      var headerColumnSize = wtViewport.getColumnHeaderHeight();
      var hiderStyle = wtTable.hider.style;
      hiderStyle.width = "".concat(headerRowSize + this.inlineStartOverlay.sumCellSizes(0, totalColumns), "px");
      hiderStyle.height = "".concat(headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1, "px");
      if (this.scrollbarSize > 0) {
        var _wtTable$wtRootElemen = wtTable.wtRootElement, rootElemScrollHeight = _wtTable$wtRootElemen.scrollHeight, rootElemScrollWidth = _wtTable$wtRootElemen.scrollWidth;
        var _wtTable$holder = wtTable.holder, holderScrollHeight = _wtTable$holder.scrollHeight, holderScrollWidth = _wtTable$holder.scrollWidth;
        this.hasScrollbarRight = rootElemScrollHeight < holderScrollHeight;
        this.hasScrollbarBottom = rootElemScrollWidth < holderScrollWidth;
        if (this.hasScrollbarRight && wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {
          this.hasScrollbarBottom = true;
        } else if (this.hasScrollbarBottom && wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) {
          this.hasScrollbarRight = true;
        }
      }
      this.topOverlay.adjustElementsSize(force);
      this.inlineStartOverlay.adjustElementsSize(force);
      this.bottomOverlay.adjustElementsSize(force);
    }
    /**
     *
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      if (!this.wtTable.isVisible()) {
        return;
      }
      this.topOverlay.applyToDOM();
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.applyToDOM();
      }
      this.inlineStartOverlay.applyToDOM();
    }
    /**
     * Get the parent overlay of the provided element.
     *
     * @param {HTMLElement} element An element to process.
     * @returns {object|null}
     */
  }, {
    key: "getParentOverlay",
    value: function getParentOverlay(element) {
      if (!element) {
        return null;
      }
      var overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
      var result = null;
      arrayEach(overlays, function(overlay) {
        if (!overlay) {
          return;
        }
        if (overlay.clone && overlay.clone.wtTable.TABLE.contains(element)) {
          result = overlay.clone;
        }
      });
      return result;
    }
    /**
     * Synchronize the class names between the main overlay table and the tables on the other overlays.
     *
     */
  }, {
    key: "syncOverlayTableClassNames",
    value: function syncOverlayTableClassNames() {
      var masterTable = this.wtTable.TABLE;
      var overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
      arrayEach(overlays, function(elem) {
        if (!elem) {
          return;
        }
        elem.clone.wtTable.TABLE.className = masterTable.className;
      });
    }
  }]);
  return Overlays2;
}();
const Overlays$1 = Overlays;
function _classCallCheck$25(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$25(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$25(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$25(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$25(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Settings = /* @__PURE__ */ function() {
  function Settings2(settings) {
    var _this = this;
    _classCallCheck$25(this, Settings2);
    _defineProperty$v(this, "settings", {});
    _defineProperty$v(this, "defaults", Object.freeze(this.getDefaults()));
    objectEach(this.defaults, function(value, key) {
      if (settings[key] !== void 0) {
        _this.settings[key] = settings[key];
      } else if (value === void 0) {
        throw new Error('A required setting "'.concat(key, '" was not provided'));
      } else {
        _this.settings[key] = value;
      }
    });
  }
  _createClass$25(Settings2, [{
    key: "getDefaults",
    value: function getDefaults() {
      var _this2 = this;
      return {
        facade: void 0,
        table: void 0,
        // Determines whether the Walkontable instance is used as dataset viewer. When its instance is used as
        // a context menu, autocomplete list, etc, the returned value is `false`.
        isDataViewInstance: true,
        // presentation mode
        externalRowCalculator: false,
        stretchH: "none",
        // values: all, last, none
        currentRowClassName: null,
        currentColumnClassName: null,
        preventOverflow: function preventOverflow() {
          return false;
        },
        preventWheel: false,
        // data source
        data: void 0,
        freezeOverlays: false,
        // Number of renderable columns for the left overlay.
        fixedColumnsStart: 0,
        // Number of renderable rows for the top overlay.
        fixedRowsTop: 0,
        // Number of renderable rows for the bottom overlay.
        fixedRowsBottom: 0,
        // Enable the inline start overlay when conditions are met (left for LTR and right for RTL document mode).
        shouldRenderInlineStartOverlay: function shouldRenderInlineStartOverlay() {
          return _this2.getSetting("fixedColumnsStart") > 0 || _this2.getSetting("rowHeaders").length > 0;
        },
        // Enable the top overlay when conditions are met.
        shouldRenderTopOverlay: function shouldRenderTopOverlay() {
          return _this2.getSetting("fixedRowsTop") > 0 || _this2.getSetting("columnHeaders").length > 0;
        },
        // Enable the bottom overlay when conditions are met.
        shouldRenderBottomOverlay: function shouldRenderBottomOverlay() {
          return _this2.getSetting("fixedRowsBottom") > 0;
        },
        minSpareRows: 0,
        // this must be array of functions: [function (row, TH) {}]
        rowHeaders: function rowHeaders() {
          return [];
        },
        // this must be array of functions: [function (column, TH) {}]
        columnHeaders: function columnHeaders() {
          return [];
        },
        totalRows: void 0,
        totalColumns: void 0,
        cellRenderer: function cellRenderer(row, column, TD) {
          var cellData = _this2.getSetting("data", row, column);
          fastInnerText(TD, cellData === void 0 || cellData === null ? "" : cellData);
        },
        // columnWidth: 50,
        columnWidth: function columnWidth() {
        },
        rowHeight: function rowHeight() {
        },
        defaultRowHeight: 23,
        defaultColumnWidth: 50,
        selections: null,
        hideBorderOnMouseDownOver: false,
        viewportRowCalculatorOverride: null,
        viewportColumnCalculatorOverride: null,
        // callbacks
        onCellMouseDown: null,
        onCellContextMenu: null,
        onCellMouseOver: null,
        onCellMouseOut: null,
        onCellMouseUp: null,
        //    onCellMouseOut: null,
        onCellDblClick: null,
        onCellCornerMouseDown: null,
        onCellCornerDblClick: null,
        beforeDraw: null,
        onDraw: null,
        onBeforeRemoveCellClassNames: null,
        onAfterDrawSelection: null,
        onBeforeDrawBorders: null,
        onScrollVertically: null,
        onScrollHorizontally: null,
        onBeforeTouchScroll: null,
        onAfterMomentumScroll: null,
        onBeforeStretchingColumnWidth: function onBeforeStretchingColumnWidth(width) {
          return width;
        },
        onModifyRowHeaderWidth: null,
        onModifyGetCellCoords: null,
        onBeforeHighlightingRowHeader: function onBeforeHighlightingRowHeader(sourceRow) {
          return sourceRow;
        },
        onBeforeHighlightingColumnHeader: function onBeforeHighlightingColumnHeader(sourceCol) {
          return sourceCol;
        },
        onWindowResize: null,
        renderAllRows: false,
        groups: false,
        rowHeaderWidth: null,
        columnHeaderHeight: null,
        headerClassName: null,
        rtlMode: false
      };
    }
    /**
     * Update settings.
     *
     * @param {object} settings The singular settings to update or if passed as object to merge with.
     * @param {*} value The value to set if the first argument is passed as string.
     * @returns {Settings}
     */
  }, {
    key: "update",
    value: function update(settings, value) {
      var _this3 = this;
      if (value === void 0) {
        objectEach(settings, function(settingValue, key) {
          _this3.settings[key] = settingValue;
        });
      } else {
        this.settings[settings] = value;
      }
      return this;
    }
    /**
     * Get setting by name.
     *
     * @param {$Keys<SettingsPure>} key The settings key to retrieve.
     * @param {*} [param1] Additional parameter passed to the options defined as function.
     * @param {*} [param2] Additional parameter passed to the options defined as function.
     * @param {*} [param3] Additional parameter passed to the options defined as function.
     * @param {*} [param4] Additional parameter passed to the options defined as function.
     * @returns {*}
     */
  }, {
    key: "getSetting",
    value: function getSetting(key, param1, param2, param3, param4) {
      if (typeof this.settings[key] === "function") {
        return this.settings[key](param1, param2, param3, param4);
      } else if (param1 !== void 0 && Array.isArray(this.settings[key])) {
        return this.settings[key][param1];
      }
      return this.settings[key];
    }
    /**
     * Get a setting value without any evaluation.
     *
     * @param {string} key The settings key to retrieve.
     * @returns {*}
     */
  }, {
    key: "getSettingPure",
    value: function getSettingPure(key) {
      return this.settings[key];
    }
    /**
     * Checks if setting exists.
     *
     * @param {boolean} key The settings key to check.
     * @returns {boolean}
     */
  }, {
    key: "has",
    value: function has2(key) {
      return !!this.settings[key];
    }
  }]);
  return Settings2;
}();
function _typeof$1h(obj) {
  "@babel/helpers - typeof";
  return _typeof$1h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1h(obj);
}
function _classCallCheck$24(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$24(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$24(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$24(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$24(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$18(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$18(subClass, superClass);
}
function _setPrototypeOf$18(o, p2) {
  _setPrototypeOf$18 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$18(o, p2);
}
function _createSuper$18(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$18();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$18(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$18(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$18(this, result);
  };
}
function _possibleConstructorReturn$18(self2, call2) {
  if (call2 && (_typeof$1h(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$18(self2);
}
function _assertThisInitialized$18(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$18() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$18(o) {
  _getPrototypeOf$18 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$18(o);
}
var MasterTable = /* @__PURE__ */ function(_Table) {
  _inherits$18(MasterTable2, _Table);
  var _super = _createSuper$18(MasterTable2);
  function MasterTable2(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    _classCallCheck$24(this, MasterTable2);
    return _super.call(this, dataAccessObject, facadeGetter, domBindings, wtSettings, "master");
  }
  _createClass$24(MasterTable2, [{
    key: "alignOverlaysWithTrimmingContainer",
    value: function alignOverlaysWithTrimmingContainer() {
      var trimmingElement = getTrimmingContainer(this.wtRootElement);
      var rootWindow = this.domBindings.rootWindow;
      if (trimmingElement === rootWindow) {
        var preventOverflow = this.wtSettings.getSetting("preventOverflow");
        if (!preventOverflow) {
          this.holder.style.overflow = "visible";
          this.wtRootElement.style.overflow = "visible";
        }
      } else {
        var trimmingElementParent = trimmingElement.parentElement;
        var trimmingHeight = getStyle(trimmingElement, "height", rootWindow);
        var trimmingOverflow = getStyle(trimmingElement, "overflow", rootWindow);
        var holderStyle = this.holder.style;
        var scrollWidth = trimmingElement.scrollWidth, scrollHeight = trimmingElement.scrollHeight;
        var _trimmingElement$getB = trimmingElement.getBoundingClientRect(), width = _trimmingElement$getB.width, height = _trimmingElement$getB.height;
        var overflow = ["auto", "hidden", "scroll"];
        if (trimmingElementParent && overflow.includes(trimmingOverflow)) {
          var cloneNode = trimmingElement.cloneNode(false);
          cloneNode.style.overflow = "auto";
          if (trimmingElement.nextElementSibling) {
            trimmingElementParent.insertBefore(cloneNode, trimmingElement.nextElementSibling);
          } else {
            trimmingElementParent.appendChild(cloneNode);
          }
          var cloneHeight = parseInt(getComputedStyle(cloneNode, rootWindow).height, 10);
          trimmingElementParent.removeChild(cloneNode);
          if (cloneHeight === 0) {
            height = 0;
          }
        }
        height = Math.min(height, scrollHeight);
        holderStyle.height = trimmingHeight === "auto" ? "auto" : "".concat(height, "px");
        width = Math.min(width, scrollWidth);
        holderStyle.width = "".concat(width, "px");
        holderStyle.overflow = "";
        this.hasTableHeight = holderStyle.height === "auto" ? true : height > 0;
        this.hasTableWidth = width > 0;
      }
      this.isTableVisible = isVisible(this.TABLE);
    }
  }, {
    key: "markOversizedColumnHeaders",
    value: function markOversizedColumnHeaders() {
      var wtSettings = this.wtSettings;
      var wtViewport = this.dataAccessObject.wtViewport;
      var overlayName = "master";
      var columnHeaders = wtSettings.getSetting("columnHeaders");
      var columnHeadersCount = columnHeaders.length;
      if (columnHeadersCount && !wtViewport.hasOversizedColumnHeadersMarked[overlayName]) {
        var rowHeaders = wtSettings.getSetting("rowHeaders");
        var rowHeaderCount = rowHeaders.length;
        var columnCount = this.getRenderedColumnsCount();
        for (var i = 0; i < columnHeadersCount; i++) {
          for (var renderedColumnIndex = -1 * rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
            this.markIfOversizedColumnHeader(renderedColumnIndex);
          }
        }
        wtViewport.hasOversizedColumnHeadersMarked[overlayName] = true;
      }
    }
  }]);
  return MasterTable2;
}(Table$1);
mixin(MasterTable, calculatedRows$1);
mixin(MasterTable, calculatedColumns$1);
const MasterTable$1 = MasterTable;
function _classCallCheck$23(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$23(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$23(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$23(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$23(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Viewport = /* @__PURE__ */ function() {
  function Viewport2(dataAccessObject, domBindings, wtSettings, eventManager, wtTable) {
    var _this = this;
    _classCallCheck$23(this, Viewport2);
    this.dataAccessObject = dataAccessObject;
    this.wot = dataAccessObject.wot;
    this.instance = this.wot;
    this.domBindings = domBindings;
    this.wtSettings = wtSettings;
    this.wtTable = wtTable;
    this.oversizedRows = [];
    this.oversizedColumnHeaders = [];
    this.hasOversizedColumnHeadersMarked = {};
    this.clientHeight = 0;
    this.containerWidth = NaN;
    this.rowHeaderWidth = NaN;
    this.rowsVisibleCalculator = null;
    this.columnsVisibleCalculator = null;
    this.eventManager = eventManager;
    this.eventManager.addEventListener(this.domBindings.rootWindow, "resize", function() {
      _this.clientHeight = _this.getWorkspaceHeight();
    });
  }
  _createClass$23(Viewport2, [{
    key: "getWorkspaceHeight",
    value: function getWorkspaceHeight() {
      var currentDocument = this.domBindings.rootDocument;
      var trimmingContainer = this.dataAccessObject.topOverlayTrimmingContainer;
      var height = 0;
      if (trimmingContainer === this.domBindings.rootWindow) {
        height = currentDocument.documentElement.clientHeight;
      } else {
        var elemHeight = outerHeight(trimmingContainer);
        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;
      }
      return height;
    }
  }, {
    key: "getWorkspaceWidth",
    value: function getWorkspaceWidth() {
      var wtSettings = this.wtSettings;
      var _this$domBindings = this.domBindings, rootDocument = _this$domBindings.rootDocument, rootWindow = _this$domBindings.rootWindow;
      var trimmingContainer = this.dataAccessObject.inlineStartOverlayTrimmingContainer;
      var docOffsetWidth = rootDocument.documentElement.offsetWidth;
      var totalColumns = wtSettings.getSetting("totalColumns");
      var preventOverflow = wtSettings.getSetting("preventOverflow");
      var isRtl = wtSettings.getSetting("rtlMode");
      var tableRect = this.wtTable.TABLE.getBoundingClientRect();
      var inlineStart = isRtl ? tableRect.right - docOffsetWidth : tableRect.left;
      var tableOffset = docOffsetWidth - inlineStart;
      var width;
      var overflow;
      if (preventOverflow) {
        return outerWidth(this.wtTable.wtRootElement);
      }
      if (wtSettings.getSetting("freezeOverlays")) {
        width = Math.min(tableOffset, docOffsetWidth);
      } else {
        width = Math.min(this.getContainerFillWidth(), tableOffset, docOffsetWidth);
      }
      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {
        return rootDocument.documentElement.clientWidth;
      }
      if (trimmingContainer !== rootWindow) {
        overflow = getStyle(this.dataAccessObject.inlineStartOverlayTrimmingContainer, "overflow", rootWindow);
        if (overflow === "scroll" || overflow === "hidden" || overflow === "auto") {
          return Math.max(width, trimmingContainer.clientWidth);
        }
      }
      var stretchSetting = wtSettings.getSetting("stretchH");
      if (stretchSetting === "none" || !stretchSetting) {
        return Math.max(width, outerWidth(this.wtTable.TABLE));
      }
      return width;
    }
    /**
     * Checks if viewport has vertical scroll.
     *
     * @returns {boolean}
     */
  }, {
    key: "hasVerticalScroll",
    value: function hasVerticalScroll() {
      return this.wtTable.hider.offsetHeight > this.getWorkspaceHeight();
    }
    /**
     * Checks if viewport has horizontal scroll.
     *
     * @returns {boolean}
     */
  }, {
    key: "hasHorizontalScroll",
    value: function hasHorizontalScroll() {
      return this.wtTable.hider.offsetWidth > this.getWorkspaceWidth();
    }
    /**
     * @param {number} from The visual column index from the width sum is start calculated.
     * @param {number} length The length of the column to traverse.
     * @returns {number}
     */
  }, {
    key: "sumColumnWidths",
    value: function sumColumnWidths(from3, length) {
      var sum = 0;
      var column = from3;
      while (column < length) {
        sum += this.wtTable.getColumnWidth(column);
        column += 1;
      }
      return sum;
    }
    /**
     * @returns {number}
     */
  }, {
    key: "getContainerFillWidth",
    value: function getContainerFillWidth() {
      if (this.containerWidth) {
        return this.containerWidth;
      }
      var mainContainer = this.wtTable.holder;
      var dummyElement = this.domBindings.rootDocument.createElement("div");
      dummyElement.style.width = "100%";
      dummyElement.style.height = "1px";
      mainContainer.appendChild(dummyElement);
      var fillWidth = dummyElement.offsetWidth;
      this.containerWidth = fillWidth;
      mainContainer.removeChild(dummyElement);
      return fillWidth;
    }
    /**
     * @returns {number}
     */
  }, {
    key: "getWorkspaceOffset",
    value: function getWorkspaceOffset() {
      return offset(this.wtTable.TABLE);
    }
    /**
     * @returns {number}
     */
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight() {
      var columnHeaders = this.wtSettings.getSetting("columnHeaders");
      if (!columnHeaders.length) {
        this.columnHeaderHeight = 0;
      } else if (isNaN(this.columnHeaderHeight)) {
        this.columnHeaderHeight = outerHeight(this.wtTable.THEAD);
      }
      return this.columnHeaderHeight;
    }
    /**
     * @returns {number}
     */
  }, {
    key: "getViewportHeight",
    value: function getViewportHeight() {
      var containerHeight = this.getWorkspaceHeight();
      if (containerHeight === Infinity) {
        return containerHeight;
      }
      var columnHeaderHeight = this.getColumnHeaderHeight();
      if (columnHeaderHeight > 0) {
        containerHeight -= columnHeaderHeight;
      }
      return containerHeight;
    }
    /**
     * @returns {number}
     */
  }, {
    key: "getRowHeaderWidth",
    value: function getRowHeaderWidth() {
      var rowHeadersWidthSetting = this.wtSettings.getSetting("rowHeaderWidth");
      var rowHeaders = this.wtSettings.getSetting("rowHeaders");
      if (rowHeadersWidthSetting) {
        this.rowHeaderWidth = 0;
        for (var i = 0, len = rowHeaders.length; i < len; i++) {
          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;
        }
      }
      if (isNaN(this.rowHeaderWidth)) {
        if (rowHeaders.length) {
          var TH = this.wtTable.TABLE.querySelector("TH");
          this.rowHeaderWidth = 0;
          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {
            if (TH) {
              this.rowHeaderWidth += outerWidth(TH);
              TH = TH.nextSibling;
            } else {
              this.rowHeaderWidth += 50;
            }
          }
        } else {
          this.rowHeaderWidth = 0;
        }
      }
      this.rowHeaderWidth = this.wtSettings.getSetting("onModifyRowHeaderWidth", this.rowHeaderWidth) || this.rowHeaderWidth;
      return this.rowHeaderWidth;
    }
    /**
     * @returns {number}
     */
  }, {
    key: "getViewportWidth",
    value: function getViewportWidth() {
      var containerWidth = this.getWorkspaceWidth();
      if (containerWidth === Infinity) {
        return containerWidth;
      }
      var rowHeaderWidth = this.getRowHeaderWidth();
      if (rowHeaderWidth > 0) {
        return containerWidth - rowHeaderWidth;
      }
      return containerWidth;
    }
    /**
     * Creates:
     * - rowsRenderCalculator (before draw, to qualify rows for rendering)
     * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).
     *
     * @param {number} calculationType The render type ID, which determines for what type of
     *                                 calculation calculator is created.
     * @returns {ViewportRowsCalculator}
     */
  }, {
    key: "createRowsCalculator",
    value: function createRowsCalculator() {
      var calculationType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RENDER_TYPE;
      var wtSettings = this.wtSettings, wtTable = this.wtTable;
      var height;
      var scrollbarHeight;
      var fixedRowsHeight;
      this.rowHeaderWidth = NaN;
      if (wtSettings.getSetting("renderAllRows") && calculationType === RENDER_TYPE) {
        height = Infinity;
      } else {
        height = this.getViewportHeight();
      }
      var pos = this.dataAccessObject.topScrollPosition - this.dataAccessObject.topParentOffset;
      if (pos < 0) {
        pos = 0;
      }
      var fixedRowsTop = wtSettings.getSetting("fixedRowsTop");
      var fixedRowsBottom = wtSettings.getSetting("fixedRowsBottom");
      var totalRows = wtSettings.getSetting("totalRows");
      if (fixedRowsTop) {
        fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, fixedRowsTop);
        pos += fixedRowsHeight;
        height -= fixedRowsHeight;
      }
      if (fixedRowsBottom && this.dataAccessObject.bottomOverlay.clone) {
        fixedRowsHeight = this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
        height -= fixedRowsHeight;
      }
      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {
        scrollbarHeight = 0;
      } else {
        scrollbarHeight = getScrollbarWidth(this.domBindings.rootDocument);
      }
      return new ViewportRowsCalculator$1({
        viewportSize: height,
        scrollOffset: pos,
        totalItems: wtSettings.getSetting("totalRows"),
        itemSizeFn: function itemSizeFn(sourceRow) {
          return wtTable.getRowHeight(sourceRow);
        },
        overrideFn: wtSettings.getSettingPure("viewportRowCalculatorOverride"),
        calculationType,
        scrollbarHeight
      });
    }
    /**
     * Creates:
     * - columnsRenderCalculator (before draw, to qualify columns for rendering)
     * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).
     *
     * @param {number} calculationType The render type ID, which determines for what type of
     *                                 calculation calculator is created.
     * @returns {ViewportColumnsCalculator}
     */
  }, {
    key: "createColumnsCalculator",
    value: function createColumnsCalculator() {
      var calculationType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RENDER_TYPE;
      var wtSettings = this.wtSettings, wtTable = this.wtTable;
      var width = this.getViewportWidth();
      var pos = Math.abs(this.dataAccessObject.inlineStartScrollPosition) - this.dataAccessObject.inlineStartParentOffset;
      this.columnHeaderHeight = NaN;
      if (pos < 0) {
        pos = 0;
      }
      var fixedColumnsStart = wtSettings.getSetting("fixedColumnsStart");
      if (fixedColumnsStart) {
        var fixedColumnsWidth = this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, fixedColumnsStart);
        pos += fixedColumnsWidth;
        width -= fixedColumnsWidth;
      }
      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {
        width -= getScrollbarWidth(this.domBindings.rootDocument);
      }
      return new ViewportColumnsCalculator$1({
        viewportSize: width,
        scrollOffset: Math.abs(pos),
        totalItems: wtSettings.getSetting("totalColumns"),
        itemSizeFn: function itemSizeFn(sourceCol) {
          return wtTable.getColumnWidth(sourceCol);
        },
        overrideFn: wtSettings.getSettingPure("viewportColumnCalculatorOverride"),
        calculationType,
        stretchMode: wtSettings.getSetting("stretchH"),
        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {
          return wtSettings.getSetting("onBeforeStretchingColumnWidth", stretchedWidth, column);
        }
      });
    }
    /**
     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and
     * cols should be rendered).
     *
     * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.
     *                           If `false` or `undefined`, will perform a full redraw.
     * @returns {boolean} The fastDraw value, possibly modified.
     */
  }, {
    key: "createRenderCalculators",
    value: function createRenderCalculators() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var runFastDraw = fastDraw;
      if (runFastDraw) {
        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);
        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);
        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {
          runFastDraw = false;
        }
      }
      if (!runFastDraw) {
        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);
        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);
      }
      this.rowsVisibleCalculator = null;
      this.columnsVisibleCalculator = null;
      return runFastDraw;
    }
    /**
     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are
     * the actually fully visible rows and columns).
     */
  }, {
    key: "createVisibleCalculators",
    value: function createVisibleCalculators() {
      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);
      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);
    }
    /**
     * Returns information whether proposedRowsVisibleCalculator viewport
     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).
     *
     * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.
     * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).
     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).
     */
  }, {
    key: "areAllProposedVisibleRowsAlreadyRendered",
    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {
      if (!this.rowsVisibleCalculator) {
        return false;
      }
      var startRow = proposedRowsVisibleCalculator.startRow, endRow = proposedRowsVisibleCalculator.endRow;
      if (startRow === null && endRow === null) {
        return false;
      }
      var _this$rowsRenderCalcu = this.rowsRenderCalculator, renderedStartRow = _this$rowsRenderCalcu.startRow, renderedEndRow = _this$rowsRenderCalcu.endRow;
      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {
        return false;
      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wtSettings.getSetting("totalRows") - 1) {
        return false;
      }
      return true;
    }
    /**
     * Returns information whether proposedColumnsVisibleCalculator viewport
     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).
     *
     * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.
     * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).
     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).
     */
  }, {
    key: "areAllProposedVisibleColumnsAlreadyRendered",
    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {
      if (!this.columnsVisibleCalculator) {
        return false;
      }
      var startColumn = proposedColumnsVisibleCalculator.startColumn, endColumn = proposedColumnsVisibleCalculator.endColumn;
      if (startColumn === null && endColumn === null) {
        return false;
      }
      var _this$columnsRenderCa = this.columnsRenderCalculator, renderedStartColumn = _this$columnsRenderCa.startColumn, renderedEndColumn = _this$columnsRenderCa.endColumn;
      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {
        return false;
      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wtSettings.getSetting("totalColumns") - 1) {
        return false;
      }
      return true;
    }
    /**
     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.
     */
  }, {
    key: "resetHasOversizedColumnHeadersMarked",
    value: function resetHasOversizedColumnHeadersMarked() {
      objectEach(this.hasOversizedColumnHeadersMarked, function(value, key, object) {
        object[key] = void 0;
      });
    }
  }]);
  return Viewport2;
}();
const Viewport$1 = Viewport;
function _typeof$1g(obj) {
  "@babel/helpers - typeof";
  return _typeof$1g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1g(obj);
}
function _classCallCheck$22(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$22(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$22(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$22(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$22(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$17(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$17(subClass, superClass);
}
function _setPrototypeOf$17(o, p2) {
  _setPrototypeOf$17 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$17(o, p2);
}
function _createSuper$17(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$17();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$17(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$17(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$17(this, result);
  };
}
function _possibleConstructorReturn$17(self2, call2) {
  if (call2 && (_typeof$1g(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$17(self2);
}
function _assertThisInitialized$17(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$17() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$17(o) {
  _getPrototypeOf$17 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$17(o);
}
var Walkontable = /* @__PURE__ */ function(_CoreAbstract) {
  _inherits$17(Walkontable2, _CoreAbstract);
  var _super = _createSuper$17(Walkontable2);
  function Walkontable2(table, settings) {
    var _this;
    _classCallCheck$22(this, Walkontable2);
    _this = _super.call(this, table, new Settings(settings));
    var facadeGetter = _this.wtSettings.getSetting("facade", _assertThisInitialized$17(_this));
    _this.wtTable = new MasterTable$1(_this.getTableDao(), facadeGetter, _this.domBindings, _this.wtSettings);
    _this.wtViewport = new Viewport$1(_this.getViewportDao(), _this.domBindings, _this.wtSettings, _this.eventManager, _this.wtTable);
    _this.selections = _this.wtSettings.getSetting("selections");
    _this.wtEvent = new Event$2(facadeGetter, _this.domBindings, _this.wtSettings, _this.eventManager, _this.wtTable, _this.selections);
    _this.wtOverlays = new Overlays$1(
      // TODO create DAO and remove reference to the Walkontable instance.
      _assertThisInitialized$17(_this),
      facadeGetter,
      _this.domBindings,
      _this.wtSettings,
      _this.eventManager,
      _this.wtTable
    );
    _this.exportSettingsAsClassNames();
    _this.findOriginalHeaders();
    return _this;
  }
  _createClass$22(Walkontable2, [{
    key: "exportSettingsAsClassNames",
    value: function exportSettingsAsClassNames() {
      var _this2 = this;
      var toExport = {
        rowHeaders: "htRowHeaders",
        columnHeaders: "htColumnHeaders"
      };
      var allClassNames = [];
      var newClassNames = [];
      objectEach(toExport, function(className, key) {
        if (_this2.wtSettings.getSetting(key).length) {
          newClassNames.push(className);
        }
        allClassNames.push(className);
      });
      removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);
      addClass(this.wtTable.wtRootElement.parentNode, newClassNames);
    }
    /**
     * @returns {ViewportDao}
     */
  }, {
    key: "getViewportDao",
    value: function getViewportDao() {
      var wot = this;
      return {
        get wot() {
          return wot;
        },
        get topOverlayTrimmingContainer() {
          return wot.wtOverlays.topOverlay.trimmingContainer;
        },
        get inlineStartOverlayTrimmingContainer() {
          return wot.wtOverlays.inlineStartOverlay.trimmingContainer;
        },
        get topScrollPosition() {
          return wot.wtOverlays.topOverlay.getScrollPosition();
        },
        get topParentOffset() {
          return wot.wtOverlays.topOverlay.getTableParentOffset();
        },
        get inlineStartScrollPosition() {
          return wot.wtOverlays.inlineStartOverlay.getScrollPosition();
        },
        get inlineStartParentOffset() {
          return wot.wtOverlays.inlineStartOverlay.getTableParentOffset();
        },
        get topOverlay() {
          return wot.wtOverlays.topOverlay;
        },
        get inlineStartOverlay() {
          return wot.wtOverlays.inlineStartOverlay;
        },
        get bottomOverlay() {
          return wot.wtOverlays.bottomOverlay;
        }
      };
    }
  }]);
  return Walkontable2;
}(CoreAbstract);
function _classCallCheck$21(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$21(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$21(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$21(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$21(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var WalkontableFacade = /* @__PURE__ */ function() {
  function WalkontableFacade2(settingsOrInstance) {
    _classCallCheck$21(this, WalkontableFacade2);
    if (settingsOrInstance instanceof CoreAbstract) {
      this._wot = settingsOrInstance;
    } else {
      this._initFromSettings(settingsOrInstance);
    }
  }
  _createClass$21(WalkontableFacade2, [{
    key: "_initFromSettings",
    value: function _initFromSettings(settings) {
      settings.facade = function(instance) {
        var facade = new WalkontableFacade2(instance);
        return function() {
          return facade;
        };
      };
      this._wot = new Walkontable(settings.table, settings);
    }
  }, {
    key: "guid",
    get: function get2() {
      return this._wot.guid;
    }
  }, {
    key: "rootDocument",
    get: function get2() {
      return this._wot.domBindings.rootDocument;
    }
  }, {
    key: "rootWindow",
    get: function get2() {
      return this._wot.domBindings.rootWindow;
    }
  }, {
    key: "wtSettings",
    get: function get2() {
      return this._wot.wtSettings;
    }
  }, {
    key: "cloneSource",
    get: function get2() {
      return this._wot.cloneSource;
    }
  }, {
    key: "cloneOverlay",
    get: function get2() {
      return this._wot.cloneOverlay;
    }
  }, {
    key: "selections",
    get: function get2() {
      return this._wot.selections;
    }
  }, {
    key: "wtViewport",
    get: function get2() {
      return this._wot.wtViewport;
    }
  }, {
    key: "wtOverlays",
    get: function get2() {
      return this._wot.wtOverlays;
    }
  }, {
    key: "wtTable",
    get: function get2() {
      return this._wot.wtTable;
    }
  }, {
    key: "wtEvent",
    get: function get2() {
      return this._wot.wtEvent;
    }
  }, {
    key: "wtScroll",
    get: function get2() {
      return this._wot.wtScroll;
    }
  }, {
    key: "drawn",
    get: function get2() {
      return this._wot.drawn;
    },
    set: function set2(value) {
      this._wot.drawn = value;
    }
  }, {
    key: "drawInterrupted",
    get: function get2() {
      return this._wot.drawInterrupted;
    },
    set: function set2(value) {
      this._wot.drawInterrupted = value;
    }
  }, {
    key: "lastMouseOver",
    get: function get2() {
      return this._wot.lastMouseOver;
    },
    set: function set2(value) {
      this._wot.lastMouseOver = value;
    }
  }, {
    key: "momentumScrolling",
    get: function get2() {
      return this._wot.momentumScrolling;
    },
    set: function set2(value) {
      this._wot.momentumScrolling = value;
    }
  }, {
    key: "touchApplied",
    get: function get2() {
      return this._wot.touchApplied;
    },
    set: function set2(value) {
      this._wot.touchApplied = value;
    }
  }, {
    key: "domBindings",
    get: function get2() {
      return this._wot.domBindings;
    }
  }, {
    key: "eventListeners",
    get: function get2() {
      return this._wot.eventListeners;
    },
    set: function set2(value) {
      this._wot.eventListeners = value;
    }
  }, {
    key: "eventManager",
    get: function get2() {
      return this._wot.eventManager;
    }
  }, {
    key: "createCellCoords",
    value: function createCellCoords(row, column) {
      return this._wot.createCellCoords(row, column);
    }
  }, {
    key: "createCellRange",
    value: function createCellRange(highlight, from3, to) {
      return this._wot.createCellRange(highlight, from3, to);
    }
  }, {
    key: "draw",
    value: function draw() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this._wot.draw(fastDraw);
      return this;
    }
  }, {
    key: "getCell",
    value: function getCell(coords) {
      var topmost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this._wot.getCell(coords, topmost);
    }
  }, {
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      return this._wot.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      return this._wot.scrollViewportHorizontally(column, snapToRight, snapToLeft);
    }
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      return this._wot.scrollViewportVertically(row, snapToTop, snapToBottom);
    }
  }, {
    key: "getViewport",
    value: function getViewport() {
      return this._wot.getViewport();
    }
  }, {
    key: "getOverlayName",
    value: function getOverlayName() {
      return this._wot.cloneOverlay ? this._wot.cloneOverlay.type : "master";
    }
  }, {
    key: "exportSettingsAsClassNames",
    value: function exportSettingsAsClassNames() {
      return this._wot.exportSettingsAsClassNames();
    }
  }, {
    key: "update",
    value: function update(settings, value) {
      this._wot.wtSettings.update(settings, value);
      return this;
    }
  }, {
    key: "getSetting",
    value: function getSetting(key, param1, param2, param3, param4) {
      return this._wot.wtSettings.getSetting(key, param1, param2, param3, param4);
    }
  }, {
    key: "hasSetting",
    value: function hasSetting(key) {
      return this._wot.wtSettings.hasSetting(key);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._wot.destroy();
    }
  }]);
  return WalkontableFacade2;
}();
var DESCRIPTORS$3 = descriptors;
var uncurryThis$5 = functionUncurryThis;
var objectKeys$1 = objectKeys$4;
var toIndexedObject$2 = toIndexedObject$d;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable3 = uncurryThis$5($propertyIsEnumerable);
var push = uncurryThis$5([].push);
var createMethod = function(TO_ENTRIES) {
  return function(it) {
    var O = toIndexedObject$2(it);
    var keys3 = objectKeys$1(O);
    var length = keys3.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys3[i++];
      if (!DESCRIPTORS$3 || propertyIsEnumerable3(O, key)) {
        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};
var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};
var $$8 = _export;
var $values = objectToArray.values;
$$8({ target: "Object", stat: true }, {
  values: function values2(O) {
    return $values(O);
  }
});
function _slicedToArray$H(arr, i) {
  return _arrayWithHoles$J(arr) || _iterableToArrayLimit$H(arr, i) || _unsupportedIterableToArray$13(arr, i) || _nonIterableRest$J();
}
function _nonIterableRest$J() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$13(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$13(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$13(o, minLen);
}
function _arrayLikeToArray$13(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$H(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$J(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$20(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$20(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$20(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$20(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$20(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Border = /* @__PURE__ */ function() {
  function Border2(wotInstance, settings) {
    _classCallCheck$20(this, Border2);
    if (!settings) {
      return;
    }
    this.eventManager = wotInstance.eventManager;
    this.instance = wotInstance;
    this.wot = wotInstance;
    this.settings = settings;
    this.mouseDown = false;
    this.main = null;
    this.top = null;
    this.bottom = null;
    this.start = null;
    this.end = null;
    this.topStyle = null;
    this.bottomStyle = null;
    this.startStyle = null;
    this.endStyle = null;
    this.cornerDefaultStyle = {
      width: "6px",
      height: "6px",
      borderWidth: "1px",
      borderStyle: "solid",
      borderColor: "#FFF"
    };
    this.cornerCenterPointOffset = -(parseInt(this.cornerDefaultStyle.width, 10) / 2);
    this.corner = null;
    this.cornerStyle = null;
    this.createBorders(settings);
    this.registerListeners();
  }
  _createClass$20(Border2, [{
    key: "registerListeners",
    value: function registerListeners() {
      var _this2 = this;
      var documentBody = this.wot.rootDocument.body;
      this.eventManager.addEventListener(documentBody, "mousedown", function() {
        return _this2.onMouseDown();
      });
      this.eventManager.addEventListener(documentBody, "mouseup", function() {
        return _this2.onMouseUp();
      });
      var _loop = function _loop2(c3, len2) {
        var element = _this2.main.childNodes[c3];
        _this2.eventManager.addEventListener(element, "mouseenter", function(event2) {
          return _this2.onMouseEnter(event2, _this2.main.childNodes[c3]);
        });
      };
      for (var c2 = 0, len = this.main.childNodes.length; c2 < len; c2++) {
        _loop(c2);
      }
    }
    /**
     * Mouse down listener.
     *
     * @private
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown() {
      this.mouseDown = true;
    }
    /**
     * Mouse up listener.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      this.mouseDown = false;
    }
    /**
     * Mouse enter listener for fragment selection functionality.
     *
     * @private
     * @param {Event} event Dom event.
     * @param {HTMLElement} parentElement Part of border element.
     */
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(event2, parentElement) {
      if (!this.mouseDown || !this.wot.getSetting("hideBorderOnMouseDownOver")) {
        return;
      }
      event2.preventDefault();
      stopImmediatePropagation(event2);
      var _this = this;
      var documentBody = this.wot.rootDocument.body;
      var bounds = parentElement.getBoundingClientRect();
      parentElement.style.display = "none";
      function isOutside(mouseEvent) {
        if (mouseEvent.clientY < Math.floor(bounds.top)) {
          return true;
        }
        if (mouseEvent.clientY > Math.ceil(bounds.top + bounds.height)) {
          return true;
        }
        if (mouseEvent.clientX < Math.floor(bounds.left)) {
          return true;
        }
        if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {
          return true;
        }
      }
      function handler(handlerEvent) {
        if (isOutside(handlerEvent)) {
          _this.eventManager.removeEventListener(documentBody, "mousemove", handler);
          parentElement.style.display = "block";
        }
      }
      this.eventManager.addEventListener(documentBody, "mousemove", handler);
    }
    /**
     * Create border elements.
     *
     * @param {object} settings The border settings.
     */
  }, {
    key: "createBorders",
    value: function createBorders(settings) {
      var rootDocument = this.wot.rootDocument;
      this.main = rootDocument.createElement("div");
      var borderDivs = ["top", "start", "bottom", "end", "corner"];
      var style = this.main.style;
      style.position = "absolute";
      style.top = 0;
      style.left = 0;
      for (var i = 0; i < 5; i++) {
        var position = borderDivs[i];
        var div = rootDocument.createElement("div");
        div.className = "wtBorder ".concat(this.settings.className || "");
        if (this.settings[position] && this.settings[position].hide) {
          div.className += " hidden";
        }
        style = div.style;
        style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;
        style.height = this.settings[position] && this.settings[position].width ? "".concat(this.settings[position].width, "px") : "".concat(settings.border.width, "px");
        style.width = this.settings[position] && this.settings[position].width ? "".concat(this.settings[position].width, "px") : "".concat(settings.border.width, "px");
        this.main.appendChild(div);
      }
      this.top = this.main.childNodes[0];
      this.start = this.main.childNodes[1];
      this.bottom = this.main.childNodes[2];
      this.end = this.main.childNodes[3];
      this.topStyle = this.top.style;
      this.startStyle = this.start.style;
      this.bottomStyle = this.bottom.style;
      this.endStyle = this.end.style;
      this.corner = this.main.childNodes[4];
      this.corner.className += " corner";
      this.cornerStyle = this.corner.style;
      this.cornerStyle.width = this.cornerDefaultStyle.width;
      this.cornerStyle.height = this.cornerDefaultStyle.height;
      this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(" ");
      if (isMobileBrowser()) {
        this.createMultipleSelectorHandles();
      }
      this.disappear();
      var wtTable = this.wot.wtTable;
      var bordersHolder = wtTable.bordersHolder;
      if (!bordersHolder) {
        bordersHolder = rootDocument.createElement("div");
        bordersHolder.className = "htBorders";
        wtTable.bordersHolder = bordersHolder;
        wtTable.spreader.appendChild(bordersHolder);
      }
      bordersHolder.appendChild(this.main);
    }
    /**
     * Create multiple selector handler for mobile devices.
     */
  }, {
    key: "createMultipleSelectorHandles",
    value: function createMultipleSelectorHandles() {
      var _this3 = this;
      var rootDocument = this.wot.rootDocument;
      this.selectionHandles = {
        top: rootDocument.createElement("DIV"),
        topHitArea: rootDocument.createElement("DIV"),
        bottom: rootDocument.createElement("DIV"),
        bottomHitArea: rootDocument.createElement("DIV")
      };
      var width = 10;
      var hitAreaWidth = 40;
      this.selectionHandles.top.className = "topSelectionHandle topLeftSelectionHandle";
      this.selectionHandles.topHitArea.className = "topSelectionHandle-HitArea topLeftSelectionHandle-HitArea";
      this.selectionHandles.bottom.className = "bottomSelectionHandle bottomRightSelectionHandle";
      this.selectionHandles.bottomHitArea.className = "bottomSelectionHandle-HitArea bottomRightSelectionHandle-HitArea";
      this.selectionHandles.styles = {
        top: this.selectionHandles.top.style,
        topHitArea: this.selectionHandles.topHitArea.style,
        bottom: this.selectionHandles.bottom.style,
        bottomHitArea: this.selectionHandles.bottomHitArea.style
      };
      var hitAreaStyle = {
        position: "absolute",
        height: "".concat(hitAreaWidth, "px"),
        width: "".concat(hitAreaWidth, "px"),
        "border-radius": "".concat(parseInt(hitAreaWidth / 1.5, 10), "px")
      };
      objectEach(hitAreaStyle, function(value, key) {
        _this3.selectionHandles.styles.bottomHitArea[key] = value;
        _this3.selectionHandles.styles.topHitArea[key] = value;
      });
      var handleStyle = {
        position: "absolute",
        height: "".concat(width, "px"),
        width: "".concat(width, "px"),
        "border-radius": "".concat(parseInt(width / 1.5, 10), "px"),
        background: "#F5F5FF",
        border: "1px solid #4285c8"
      };
      objectEach(handleStyle, function(value, key) {
        _this3.selectionHandles.styles.bottom[key] = value;
        _this3.selectionHandles.styles.top[key] = value;
      });
      this.main.appendChild(this.selectionHandles.top);
      this.main.appendChild(this.selectionHandles.bottom);
      this.main.appendChild(this.selectionHandles.topHitArea);
      this.main.appendChild(this.selectionHandles.bottomHitArea);
    }
    /**
     * @param {number} row The visual row index.
     * @param {number} col The visual column index.
     * @returns {boolean}
     */
  }, {
    key: "isPartRange",
    value: function isPartRange(row, col) {
      var areaSelection = this.wot.selections.createOrGetArea();
      if (areaSelection.cellRange) {
        if (row !== areaSelection.cellRange.to.row || col !== areaSelection.cellRange.to.col) {
          return true;
        }
      }
      return false;
    }
    /**
     * @param {number} row The visual row index.
     * @param {number} col The visual column index.
     * @param {number} top The top position of the handler.
     * @param {number} left The left position of the handler.
     * @param {number} width The width of the handler.
     * @param {number} height The height of the handler.
     */
  }, {
    key: "updateMultipleSelectionHandlesPosition",
    value: function updateMultipleSelectionHandlesPosition(row, col, top2, left2, width, height) {
      var isRtl = this.wot.wtSettings.getSetting("rtlMode");
      var inlinePosProperty = isRtl ? "right" : "left";
      var _this$selectionHandle = this.selectionHandles.styles, topStyles = _this$selectionHandle.top, topHitAreaStyles = _this$selectionHandle.topHitArea, bottomStyles = _this$selectionHandle.bottom, bottomHitAreaStyles = _this$selectionHandle.bottomHitArea;
      var handleBorderSize = parseInt(topStyles.borderWidth, 10);
      var handleSize = parseInt(topStyles.width, 10);
      var hitAreaSize = parseInt(topHitAreaStyles.width, 10);
      var totalTableWidth = this.wot.wtTable.getWidth();
      var totalTableHeight = this.wot.wtTable.getHeight();
      topStyles.top = "".concat(parseInt(top2 - handleSize - 1, 10), "px");
      topStyles[inlinePosProperty] = "".concat(parseInt(left2 - handleSize - 1, 10), "px");
      topHitAreaStyles.top = "".concat(parseInt(top2 - hitAreaSize / 4 * 3, 10), "px");
      topHitAreaStyles[inlinePosProperty] = "".concat(parseInt(left2 - hitAreaSize / 4 * 3, 10), "px");
      var bottomHandlerInline = Math.min(parseInt(left2 + width, 10), totalTableWidth - handleSize - handleBorderSize * 2);
      var bottomHandlerAreaInline = Math.min(parseInt(left2 + width - hitAreaSize / 4, 10), totalTableWidth - hitAreaSize - handleBorderSize * 2);
      bottomStyles[inlinePosProperty] = "".concat(bottomHandlerInline, "px");
      bottomHitAreaStyles[inlinePosProperty] = "".concat(bottomHandlerAreaInline, "px");
      var bottomHandlerTop = Math.min(parseInt(top2 + height, 10), totalTableHeight - handleSize - handleBorderSize * 2);
      var bottomHandlerAreaTop = Math.min(parseInt(top2 + height - hitAreaSize / 4, 10), totalTableHeight - hitAreaSize - handleBorderSize * 2);
      bottomStyles.top = "".concat(bottomHandlerTop, "px");
      bottomHitAreaStyles.top = "".concat(bottomHandlerAreaTop, "px");
      if (this.settings.border.cornerVisible && this.settings.border.cornerVisible()) {
        topStyles.display = "block";
        topHitAreaStyles.display = "block";
        if (this.isPartRange(row, col)) {
          bottomStyles.display = "none";
          bottomHitAreaStyles.display = "none";
        } else {
          bottomStyles.display = "block";
          bottomHitAreaStyles.display = "block";
        }
      } else {
        topStyles.display = "none";
        bottomStyles.display = "none";
        topHitAreaStyles.display = "none";
        bottomHitAreaStyles.display = "none";
      }
      if (row === this.wot.wtSettings.getSetting("fixedRowsTop") || col === this.wot.wtSettings.getSetting("fixedColumnsStart")) {
        topStyles.zIndex = "9999";
        topHitAreaStyles.zIndex = "9999";
      } else {
        topStyles.zIndex = "";
        topHitAreaStyles.zIndex = "";
      }
    }
    /**
     * Show border around one or many cells.
     *
     * @param {Array} corners The corner coordinates.
     */
  }, {
    key: "appear",
    value: function appear(corners) {
      if (this.disabled) {
        return;
      }
      var _this$wot = this.wot, wtTable = _this$wot.wtTable, rootDocument = _this$wot.rootDocument, rootWindow = _this$wot.rootWindow;
      var fromRow;
      var toRow;
      var fromColumn;
      var toColumn;
      var rowHeader;
      var columnHeader;
      var rowsCount = wtTable.getRenderedRowsCount();
      for (var i = 0; i < rowsCount; i += 1) {
        var s = wtTable.rowFilter.renderedToSource(i);
        if (s >= corners[0] && s <= corners[2]) {
          fromRow = s;
          rowHeader = corners[0];
          break;
        }
      }
      for (var _i = rowsCount - 1; _i >= 0; _i -= 1) {
        var _s = wtTable.rowFilter.renderedToSource(_i);
        if (_s >= corners[0] && _s <= corners[2]) {
          toRow = _s;
          break;
        }
      }
      var columnsCount = wtTable.getRenderedColumnsCount();
      for (var _i2 = 0; _i2 < columnsCount; _i2 += 1) {
        var _s2 = wtTable.columnFilter.renderedToSource(_i2);
        if (_s2 >= corners[1] && _s2 <= corners[3]) {
          fromColumn = _s2;
          columnHeader = corners[1];
          break;
        }
      }
      for (var _i3 = columnsCount - 1; _i3 >= 0; _i3 -= 1) {
        var _s3 = wtTable.columnFilter.renderedToSource(_i3);
        if (_s3 >= corners[1] && _s3 <= corners[3]) {
          toColumn = _s3;
          break;
        }
      }
      if (fromRow === void 0 || fromColumn === void 0) {
        this.disappear();
        return;
      }
      var fromTD = wtTable.getCell(this.wot.createCellCoords(fromRow, fromColumn));
      var isMultiple = fromRow !== toRow || fromColumn !== toColumn;
      var toTD = isMultiple ? wtTable.getCell(this.wot.createCellCoords(toRow, toColumn)) : fromTD;
      var fromOffset = offset(fromTD);
      var toOffset = isMultiple ? offset(toTD) : fromOffset;
      var containerOffset = offset(wtTable.TABLE);
      var containerWidth = outerWidth(wtTable.TABLE);
      var minTop = fromOffset.top;
      var minLeft = fromOffset.left;
      var isRtl = this.wot.wtSettings.getSetting("rtlMode");
      var inlineStartPos = 0;
      var width = 0;
      if (isRtl) {
        var fromWidth = outerWidth(fromTD);
        var gridRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;
        width = minLeft + fromWidth - toOffset.left;
        inlineStartPos = rootWindow.innerWidth - minLeft - fromWidth - gridRightPos - 1;
      } else {
        width = toOffset.left + outerWidth(toTD) - minLeft;
        inlineStartPos = minLeft - containerOffset.left - 1;
      }
      if (this.isEntireColumnSelected(fromRow, toRow)) {
        var modifiedValues = this.getDimensionsFromHeader("columns", fromColumn, toColumn, rowHeader, containerOffset);
        var fromTH = null;
        if (modifiedValues) {
          var _modifiedValues = _slicedToArray$H(modifiedValues, 3);
          fromTH = _modifiedValues[0];
          inlineStartPos = _modifiedValues[1];
          width = _modifiedValues[2];
        }
        if (fromTH) {
          fromTD = fromTH;
        }
      }
      var top2 = minTop - containerOffset.top - 1;
      var height = toOffset.top + outerHeight(toTD) - minTop;
      if (this.isEntireRowSelected(fromColumn, toColumn)) {
        var _modifiedValues2 = this.getDimensionsFromHeader("rows", fromRow, toRow, columnHeader, containerOffset);
        var _fromTH = null;
        if (_modifiedValues2) {
          var _modifiedValues3 = _slicedToArray$H(_modifiedValues2, 3);
          _fromTH = _modifiedValues3[0];
          top2 = _modifiedValues3[1];
          height = _modifiedValues3[2];
        }
        if (_fromTH) {
          fromTD = _fromTH;
        }
      }
      var style = getComputedStyle(fromTD, rootWindow);
      if (parseInt(style.borderTopWidth, 10) > 0) {
        top2 += 1;
        height = height > 0 ? height - 1 : 0;
      }
      if (parseInt(style[isRtl ? "borderRightWidth" : "borderLeftWidth"], 10) > 0) {
        inlineStartPos += 1;
        width = width > 0 ? width - 1 : 0;
      }
      var inlinePosProperty = isRtl ? "right" : "left";
      this.topStyle.top = "".concat(top2, "px");
      this.topStyle[inlinePosProperty] = "".concat(inlineStartPos, "px");
      this.topStyle.width = "".concat(width, "px");
      this.topStyle.display = "block";
      this.startStyle.top = "".concat(top2, "px");
      this.startStyle[inlinePosProperty] = "".concat(inlineStartPos, "px");
      this.startStyle.height = "".concat(height, "px");
      this.startStyle.display = "block";
      var delta = Math.floor(this.settings.border.width / 2);
      this.bottomStyle.top = "".concat(top2 + height - delta, "px");
      this.bottomStyle[inlinePosProperty] = "".concat(inlineStartPos, "px");
      this.bottomStyle.width = "".concat(width, "px");
      this.bottomStyle.display = "block";
      this.endStyle.top = "".concat(top2, "px");
      this.endStyle[inlinePosProperty] = "".concat(inlineStartPos + width - delta, "px");
      this.endStyle.height = "".concat(height + 1, "px");
      this.endStyle.display = "block";
      var cornerVisibleSetting = this.settings.border.cornerVisible;
      cornerVisibleSetting = typeof cornerVisibleSetting === "function" ? cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;
      var hookResult = this.wot.getSetting("onModifyGetCellCoords", toRow, toColumn);
      var checkRow = toRow, checkCol = toColumn;
      if (hookResult && Array.isArray(hookResult)) {
        var _hookResult = _slicedToArray$H(hookResult, 4);
        checkRow = _hookResult[2];
        checkCol = _hookResult[3];
      }
      if (isMobileBrowser() || !cornerVisibleSetting || this.isPartRange(checkRow, checkCol)) {
        this.cornerStyle.display = "none";
      } else {
        this.cornerStyle.top = "".concat(top2 + height + this.cornerCenterPointOffset - 1, "px");
        this.cornerStyle[inlinePosProperty] = "".concat(inlineStartPos + width + this.cornerCenterPointOffset - 1, "px");
        this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;
        this.cornerStyle.width = this.cornerDefaultStyle.width;
        this.cornerStyle.display = "none";
        var trimmingContainer = getTrimmingContainer(wtTable.TABLE);
        var trimToWindow = trimmingContainer === rootWindow;
        if (trimToWindow) {
          trimmingContainer = rootDocument.documentElement;
        }
        var cornerHalfWidth = parseInt(this.cornerDefaultStyle.width, 10) / 2;
        var cornerHalfHeight = parseInt(this.cornerDefaultStyle.height, 10) / 2;
        if (toColumn === this.wot.getSetting("totalColumns") - 1) {
          var toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : toTD.offsetLeft;
          var cornerOverlappingContainer = false;
          var cornerEdge = 0;
          if (isRtl) {
            cornerEdge = toTdOffsetLeft - parseInt(this.cornerDefaultStyle.width, 10) / 2;
            cornerOverlappingContainer = cornerEdge < 0;
          } else {
            cornerEdge = toTdOffsetLeft + outerWidth(toTD) + parseInt(this.cornerDefaultStyle.width, 10) / 2;
            cornerOverlappingContainer = cornerEdge >= innerWidth(trimmingContainer);
          }
          if (cornerOverlappingContainer) {
            this.cornerStyle[inlinePosProperty] = "".concat(Math.floor(inlineStartPos + width + this.cornerCenterPointOffset - cornerHalfWidth), "px");
            this.cornerStyle[isRtl ? "borderLeftWidth" : "borderRightWidth"] = 0;
          }
        }
        if (toRow === this.wot.getSetting("totalRows") - 1) {
          var toTdOffsetTop = trimToWindow ? toTD.getBoundingClientRect().top : toTD.offsetTop;
          var cornerBottomEdge = toTdOffsetTop + outerHeight(toTD) + parseInt(this.cornerDefaultStyle.height, 10) / 2;
          var _cornerOverlappingContainer = cornerBottomEdge >= innerHeight(trimmingContainer);
          if (_cornerOverlappingContainer) {
            this.cornerStyle.top = "".concat(Math.floor(top2 + height + this.cornerCenterPointOffset - cornerHalfHeight), "px");
            this.cornerStyle.borderBottomWidth = 0;
          }
        }
        this.cornerStyle.display = "block";
      }
      if (isMobileBrowser()) {
        this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top2, inlineStartPos, width, height);
      }
    }
    /**
     * Check whether an entire column of cells is selected.
     *
     * @private
     * @param {number} startRowIndex Start row index.
     * @param {number} endRowIndex End row index.
     * @returns {boolean}
     */
  }, {
    key: "isEntireColumnSelected",
    value: function isEntireColumnSelected(startRowIndex, endRowIndex) {
      return startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === this.wot.wtTable.getLastRenderedRow();
    }
    /**
     * Check whether an entire row of cells is selected.
     *
     * @private
     * @param {number} startColumnIndex Start column index.
     * @param {number} endColumnIndex End column index.
     * @returns {boolean}
     */
  }, {
    key: "isEntireRowSelected",
    value: function isEntireRowSelected(startColumnIndex, endColumnIndex) {
      return startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && endColumnIndex === this.wot.wtTable.getLastRenderedColumn();
    }
    /**
     * Get left/top index and width/height depending on the `direction` provided.
     *
     * @private
     * @param {string} direction `rows` or `columns`, defines if an entire column or row is selected.
     * @param {number} fromIndex Start index of the selection.
     * @param {number} toIndex End index of the selection.
     * @param {number} headerIndex The header index as negative value.
     * @param {number} containerOffset Offset of the container.
     * @returns {Array|boolean} Returns an array of [headerElement, left, width] or [headerElement, top, height], depending on `direction` (`false` in case of an error getting the headers).
     */
  }, {
    key: "getDimensionsFromHeader",
    value: function getDimensionsFromHeader(direction, fromIndex, toIndex, headerIndex, containerOffset) {
      var wtTable = this.wot.wtTable;
      var rootHotElement = wtTable.wtRootElement.parentNode;
      var getHeaderFn = null;
      var dimensionFn = null;
      var entireSelectionClassname = null;
      var index2 = null;
      var dimension = null;
      var dimensionProperty = null;
      var startHeader = null;
      var endHeader = null;
      switch (direction) {
        case "rows":
          getHeaderFn = function getHeaderFn2() {
            return wtTable.getRowHeader.apply(wtTable, arguments);
          };
          dimensionFn = function dimensionFn2() {
            return outerHeight.apply(void 0, arguments);
          };
          entireSelectionClassname = "ht__selection--rows";
          dimensionProperty = "top";
          break;
        case "columns":
          getHeaderFn = function getHeaderFn2() {
            return wtTable.getColumnHeader.apply(wtTable, arguments);
          };
          dimensionFn = function dimensionFn2() {
            return outerWidth.apply(void 0, arguments);
          };
          entireSelectionClassname = "ht__selection--columns";
          dimensionProperty = "left";
          break;
      }
      if (rootHotElement.classList.contains(entireSelectionClassname)) {
        var columnHeaderLevelCount = this.wot.getSetting("columnHeaders").length;
        startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - headerIndex);
        endHeader = getHeaderFn(toIndex, columnHeaderLevelCount - headerIndex);
        if (!startHeader || !endHeader) {
          return false;
        }
        var startHeaderOffset = offset(startHeader);
        var endOffset = offset(endHeader);
        if (startHeader && endHeader) {
          index2 = startHeaderOffset[dimensionProperty] - containerOffset[dimensionProperty] - 1;
          dimension = endOffset[dimensionProperty] + dimensionFn(endHeader) - startHeaderOffset[dimensionProperty];
        }
        return [startHeader, index2, dimension];
      }
      return false;
    }
    /**
     * Change border style.
     *
     * @private
     * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.
     * @param {object} border The border object descriptor.
     */
  }, {
    key: "changeBorderStyle",
    value: function changeBorderStyle(borderElement, border) {
      var style = this[borderElement].style;
      var borderStyle = border[borderElement];
      if (!borderStyle || borderStyle.hide) {
        addClass(this[borderElement], "hidden");
      } else {
        if (hasClass(this[borderElement], "hidden")) {
          removeClass(this[borderElement], "hidden");
        }
        style.backgroundColor = borderStyle.color;
        if (borderElement === "top" || borderElement === "bottom") {
          style.height = "".concat(borderStyle.width, "px");
        }
        if (borderElement === "start" || borderElement === "end") {
          style.width = "".concat(borderStyle.width, "px");
        }
      }
    }
    /**
     * Change border style to default.
     *
     * @private
     * @param {string} position The position type ("top", "bottom", "start", "end") to change.
     */
  }, {
    key: "changeBorderToDefaultStyle",
    value: function changeBorderToDefaultStyle(position) {
      var defaultBorder = {
        width: 1,
        color: "#000"
      };
      var style = this[position].style;
      style.backgroundColor = defaultBorder.color;
      style.width = "".concat(defaultBorder.width, "px");
      style.height = "".concat(defaultBorder.width, "px");
    }
    /**
     * Toggle class 'hidden' to element.
     *
     * @private
     * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.
     * @param {boolean} [remove] Defines type of the action to perform.
     */
  }, {
    key: "toggleHiddenClass",
    value: function toggleHiddenClass(borderElement, remove) {
      this.changeBorderToDefaultStyle(borderElement);
      if (remove) {
        addClass(this[borderElement], "hidden");
      } else {
        removeClass(this[borderElement], "hidden");
      }
    }
    /**
     * Hide border.
     */
  }, {
    key: "disappear",
    value: function disappear() {
      this.topStyle.display = "none";
      this.bottomStyle.display = "none";
      this.startStyle.display = "none";
      this.endStyle.display = "none";
      this.cornerStyle.display = "none";
      if (isMobileBrowser()) {
        this.selectionHandles.styles.top.display = "none";
        this.selectionHandles.styles.topHitArea.display = "none";
        this.selectionHandles.styles.bottom.display = "none";
        this.selectionHandles.styles.bottomHitArea.display = "none";
      }
    }
    /**
     * Cleans up all the DOM state related to a Border instance. Call this prior to deleting a Border instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroyWithOwnEventsOnly();
      this.main.parentNode.removeChild(this.main);
    }
  }]);
  return Border2;
}();
const Border$1 = Border;
function _slicedToArray$G(arr, i) {
  return _arrayWithHoles$I(arr) || _iterableToArrayLimit$G(arr, i) || _unsupportedIterableToArray$12(arr, i) || _nonIterableRest$I();
}
function _nonIterableRest$I() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$12(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$12(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$12(o, minLen);
}
function _arrayLikeToArray$12(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$G(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$I(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$1f(obj) {
  "@babel/helpers - typeof";
  return _typeof$1f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1f(obj);
}
function _classCallCheck$1$(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1$(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1$(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1$(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1$(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Selection$2 = /* @__PURE__ */ function() {
  function Selection2(settings, cellRange) {
    _classCallCheck$1$(this, Selection2);
    this.settings = settings;
    this.cellRange = cellRange || null;
    this.instanceBorders = {};
    this.classNames = [this.settings.className];
    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);
  }
  _createClass$1$(Selection2, [{
    key: "getBorder",
    value: function getBorder(wotInstance) {
      if (!this.instanceBorders[wotInstance.guid]) {
        this.instanceBorders[wotInstance.guid] = new Border$1(wotInstance, this.settings);
      }
      return this.instanceBorders[wotInstance.guid];
    }
    /**
     * Checks if selection is empty.
     *
     * @returns {boolean}
     */
  }, {
    key: "isEmpty",
    value: function isEmpty2() {
      return this.cellRange === null;
    }
    /**
     * Adds a cell coords to the selection.
     *
     * @param {CellCoords} coords The cell coordinates to add.
     * @returns {Selection}
     */
  }, {
    key: "add",
    value: function add(coords) {
      if (this.isEmpty()) {
        this.cellRange = this.settings.createCellRange(coords);
      } else {
        this.cellRange.expand(coords);
      }
      return this;
    }
    /**
     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean
     * information about success.
     *
     * @param {CellCoords} oldCoords An old cell coordinates to replace.
     * @param {CellCoords} newCoords The new cell coordinates.
     * @returns {boolean}
     */
  }, {
    key: "replace",
    value: function replace2(oldCoords, newCoords) {
      if (!this.isEmpty()) {
        if (this.cellRange.from.isEqual(oldCoords)) {
          this.cellRange.from = newCoords;
          return true;
        }
        if (this.cellRange.to.isEqual(oldCoords)) {
          this.cellRange.to = newCoords;
          return true;
        }
      }
      return false;
    }
    /**
     * Clears selection.
     *
     * @returns {Selection}
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.cellRange = null;
      return this;
    }
    /**
     * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection coordinates.
     *
     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
     */
  }, {
    key: "getCorners",
    value: function getCorners() {
      var topStart = this.cellRange.getOuterTopStartCorner();
      var bottomEnd = this.cellRange.getOuterBottomEndCorner();
      return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];
    }
    /**
     * Adds class name to cell element at given coords.
     *
     * @param {WalkontableFacade} wotInstance Walkontable instance.
     * @param {number} sourceRow Cell row coord.
     * @param {number} sourceColumn Cell column coord.
     * @param {string} className Class name.
     * @param {boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes
     *                                            in a continuous way.
     * @returns {Selection}
     */
  }, {
    key: "addClassAtCoords",
    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {
      var markIntersections = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var TD = wotInstance.wtTable.getCell(this.settings.createCellCoords(sourceRow, sourceColumn));
      if (_typeof$1f(TD) === "object") {
        var cellClassName = className;
        if (markIntersections) {
          cellClassName = this.classNameGenerator(TD);
          if (!this.classNames.includes(cellClassName)) {
            this.classNames.push(cellClassName);
          }
        }
        addClass(TD, cellClassName);
      }
      return this;
    }
    /**
     * Generate helper for calculating classNames based on previously added base className.
     * The generated className is always generated as a continuation of the previous className. For example, when
     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When
     * the element doesn't have any classNames than the base className will be returned ('area');.
     *
     * @param {string} baseClassName Base className to be used.
     * @param {number} layerLevelOwner Layer level which the instance of the Selection belongs to.
     * @returns {Function}
     */
  }, {
    key: "linearClassNameGenerator",
    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {
      return function calcClassName(element) {
        var previousIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        if (layerLevelOwner === 0 || previousIndex === 0) {
          return baseClassName;
        }
        var index2 = previousIndex >= 0 ? previousIndex : layerLevelOwner;
        var className = baseClassName;
        index2 -= 1;
        var previousClassName = index2 === 0 ? baseClassName : "".concat(baseClassName, "-").concat(index2);
        if (hasClass(element, previousClassName)) {
          var currentLayer = index2 + 1;
          className = "".concat(baseClassName, "-").concat(currentLayer);
        } else {
          className = calcClassName(element, index2);
        }
        return className;
      };
    }
    /**
     * @param {WalkontableFacade} wotInstance The Walkontable instance.
     */
  }, {
    key: "draw",
    value: function draw(wotInstance) {
      if (this.isEmpty()) {
        if (this.settings.border) {
          this.getBorder(wotInstance).disappear();
        }
        return;
      }
      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();
      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();
      var corners = this.getCorners();
      var _corners = _slicedToArray$G(corners, 4), topRow = _corners[0], topColumn = _corners[1], bottomRow = _corners[2], bottomColumn = _corners[3];
      var _this$settings = this.settings, highlightHeaderClassName = _this$settings.highlightHeaderClassName, highlightColumnClassName = _this$settings.highlightColumnClassName, highlightRowClassName = _this$settings.highlightRowClassName, highlightOnlyClosestHeader = _this$settings.highlightOnlyClosestHeader, selectionType = _this$settings.selectionType;
      var isHeaderSelectionType = selectionType === void 0 || ["active-header", "header"].includes(selectionType);
      if (isHeaderSelectionType && topColumn !== null && bottomColumn !== null) {
        var selectionColumnCursor = 0;
        for (var column = 0; column < renderedColumns; column += 1) {
          var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);
          if (sourceCol >= topColumn && sourceCol <= bottomColumn) {
            var THs = wotInstance.wtTable.getColumnHeaders(sourceCol);
            var closestHeaderLevel = THs.length - 1;
            if (highlightOnlyClosestHeader && THs.length > 1) {
              THs = [THs[closestHeaderLevel]];
            }
            for (var headerLevel = 0; headerLevel < THs.length; headerLevel += 1) {
              var newClasses = [];
              var TH = THs[headerLevel];
              if (highlightHeaderClassName) {
                newClasses.push(highlightHeaderClassName);
              }
              if (highlightColumnClassName) {
                newClasses.push(highlightColumnClassName);
              }
              headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : headerLevel;
              var newSourceCol = wotInstance.getSetting("onBeforeHighlightingColumnHeader", sourceCol, headerLevel, {
                selectionType,
                columnCursor: selectionColumnCursor,
                selectionWidth: bottomColumn - topColumn + 1,
                classNames: newClasses
              });
              if (newSourceCol !== sourceCol) {
                TH = wotInstance.wtTable.getColumnHeader(newSourceCol, headerLevel);
              }
              addClass(TH, newClasses);
            }
            selectionColumnCursor += 1;
          }
        }
      }
      if (topRow !== null && bottomRow !== null) {
        var selectionRowCursor = 0;
        for (var row = 0; row < renderedRows; row += 1) {
          var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);
          if (isHeaderSelectionType && sourceRow >= topRow && sourceRow <= bottomRow) {
            var _THs = wotInstance.wtTable.getRowHeaders(sourceRow);
            var _closestHeaderLevel = _THs.length - 1;
            if (highlightOnlyClosestHeader && _THs.length > 1) {
              _THs = [_THs[_closestHeaderLevel]];
            }
            for (var _headerLevel = 0; _headerLevel < _THs.length; _headerLevel += 1) {
              var _newClasses = [];
              var _TH = _THs[_headerLevel];
              if (highlightHeaderClassName) {
                _newClasses.push(highlightHeaderClassName);
              }
              if (highlightRowClassName) {
                _newClasses.push(highlightRowClassName);
              }
              _headerLevel = highlightOnlyClosestHeader ? _closestHeaderLevel : _headerLevel;
              var newSourceRow = wotInstance.getSetting("onBeforeHighlightingRowHeader", sourceRow, _headerLevel, {
                selectionType,
                rowCursor: selectionRowCursor,
                selectionHeight: bottomRow - topRow + 1,
                classNames: _newClasses
              });
              if (newSourceRow !== sourceRow) {
                _TH = wotInstance.wtTable.getRowHeader(newSourceRow, _headerLevel);
              }
              addClass(_TH, _newClasses);
            }
            selectionRowCursor += 1;
          }
          if (topColumn !== null && bottomColumn !== null) {
            for (var _column = 0; _column < renderedColumns; _column += 1) {
              var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);
              if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {
                if (this.settings.className) {
                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);
                }
              } else if (sourceRow >= topRow && sourceRow <= bottomRow) {
                if (highlightRowClassName) {
                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightRowClassName);
                }
              } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {
                if (highlightColumnClassName) {
                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightColumnClassName);
                }
              }
              var additionalSelectionClass = wotInstance.getSetting("onAfterDrawSelection", sourceRow, _sourceCol, this.settings.layerLevel);
              if (typeof additionalSelectionClass === "string") {
                this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);
              }
            }
          }
        }
      }
      wotInstance.getSetting("onBeforeDrawBorders", corners, this.settings.className);
      if (this.settings.border) {
        this.getBorder(wotInstance).appear(corners);
      }
    }
    /**
     * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      Object.values(this.instanceBorders).forEach(function(border) {
        return border.destroy();
      });
    }
  }]);
  return Selection2;
}();
const Selection$3 = Selection$2;
function mouseDown(_ref2) {
  var isShiftKey = _ref2.isShiftKey, isLeftClick2 = _ref2.isLeftClick, isRightClick2 = _ref2.isRightClick, coords = _ref2.coords, selection = _ref2.selection, controller = _ref2.controller, cellCoordsFactory = _ref2.cellCoordsFactory;
  var currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
  var selectedCorner = selection.isSelectedByCorner();
  var selectedRow = selection.isSelectedByRowHeader();
  if (isShiftKey && currentSelection) {
    if (coords.row >= 0 && coords.col >= 0 && !controller.cell) {
      selection.setRangeEnd(coords);
    } else if ((selectedCorner || selectedRow) && coords.row >= 0 && coords.col >= 0 && !controller.cell) {
      selection.setRangeEnd(cellCoordsFactory(coords.row, coords.col));
    } else if (selectedCorner && coords.row < 0 && !controller.column) {
      selection.setRangeEnd(cellCoordsFactory(currentSelection.to.row, coords.col));
    } else if (selectedRow && coords.col < 0 && !controller.row) {
      selection.setRangeEnd(cellCoordsFactory(coords.row, currentSelection.to.col));
    } else if ((!selectedCorner && !selectedRow && coords.col < 0 || selectedCorner && coords.col < 0) && !controller.row) {
      selection.selectRows(Math.max(currentSelection.from.row, 0), coords.row, coords.col);
    } else if ((!selectedCorner && !selectedRow && coords.row < 0 || selectedRow && coords.row < 0) && !controller.column) {
      selection.selectColumns(Math.max(currentSelection.from.col, 0), coords.col, coords.row);
    }
  } else {
    var allowRightClickSelection = !selection.inInSelection(coords);
    var performSelection = isLeftClick2 || isRightClick2 && allowRightClickSelection;
    if (coords.row < 0 && coords.col >= 0 && !controller.column) {
      if (performSelection) {
        selection.selectColumns(coords.col, coords.col, coords.row);
      }
    } else if (coords.col < 0 && coords.row >= 0 && !controller.row) {
      if (performSelection) {
        selection.selectRows(coords.row, coords.row, coords.col);
      }
    } else if (coords.col >= 0 && coords.row >= 0 && !controller.cell) {
      if (performSelection) {
        selection.setRangeStart(coords);
      }
    } else if (coords.col < 0 && coords.row < 0) {
      selection.selectAll(true, true);
    }
  }
}
function mouseOver(_ref2) {
  var isLeftClick2 = _ref2.isLeftClick, coords = _ref2.coords, selection = _ref2.selection, controller = _ref2.controller, cellCoordsFactory = _ref2.cellCoordsFactory;
  if (!isLeftClick2) {
    return;
  }
  var selectedRow = selection.isSelectedByRowHeader();
  var selectedColumn = selection.isSelectedByColumnHeader();
  var countCols = selection.tableProps.countCols();
  var countRows = selection.tableProps.countRows();
  if (selectedColumn && !controller.column) {
    selection.setRangeEnd(cellCoordsFactory(countRows - 1, coords.col));
  } else if (selectedRow && !controller.row) {
    selection.setRangeEnd(cellCoordsFactory(coords.row, countCols - 1));
  } else if (!controller.cell) {
    selection.setRangeEnd(coords);
  }
}
var handlers = /* @__PURE__ */ new Map([["mousedown", mouseDown], ["mouseover", mouseOver], ["touchstart", mouseDown]]);
function handleMouseEvent(event2, _ref3) {
  var coords = _ref3.coords, selection = _ref3.selection, controller = _ref3.controller, cellCoordsFactory = _ref3.cellCoordsFactory;
  handlers.get(event2.type)({
    coords,
    selection,
    controller,
    cellCoordsFactory,
    isShiftKey: event2.shiftKey,
    isLeftClick: isLeftClick(event2) || event2.type === "touchstart",
    isRightClick: isRightClick(event2)
  });
}
var holder = /* @__PURE__ */ new WeakMap();
var rootInstanceSymbol = Symbol("rootInstance");
function registerAsRootInstance(object) {
  holder.set(object, true);
}
function hasValidParameter(rootSymbol) {
  return rootSymbol === rootInstanceSymbol;
}
function isRootInstance(object) {
  return holder.has(object);
}
function _slicedToArray$F(arr, i) {
  return _arrayWithHoles$H(arr) || _iterableToArrayLimit$F(arr, i) || _unsupportedIterableToArray$11(arr, i) || _nonIterableRest$H();
}
function _nonIterableRest$H() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$F(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$H(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$s(arr) {
  return _arrayWithoutHoles$s(arr) || _iterableToArray$u(arr) || _unsupportedIterableToArray$11(arr) || _nonIterableSpread$s();
}
function _nonIterableSpread$s() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$11(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$11(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$11(o, minLen);
}
function _iterableToArray$u(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$s(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$11(arr);
}
function _arrayLikeToArray$11(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1_(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1_(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1_(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1_(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1_(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var privatePool$i = /* @__PURE__ */ new WeakMap();
var TableView = /* @__PURE__ */ function() {
  function TableView2(instance) {
    _classCallCheck$1_(this, TableView2);
    this.instance = instance;
    this.eventManager = new EventManager$1(instance);
    this.settings = instance.getSettings();
    this.THEAD = void 0;
    this.TBODY = void 0;
    this._wt = void 0;
    this.activeWt = void 0;
    this.postponedAdjustElementsSize = false;
    privatePool$i.set(this, {
      /**
       * Defines if the text should be selected during mousemove.
       *
       * @private
       * @type {boolean}
       */
      selectionMouseDown: false,
      /**
       * @private
       * @type {boolean}
       */
      mouseDown: void 0,
      /**
       * Main <TABLE> element.
       *
       * @private
       * @type {HTMLTableElement}
       */
      table: void 0,
      /**
       * Cached width of the rootElement.
       *
       * @type {number}
       */
      lastWidth: 0,
      /**
       * Cached height of the rootElement.
       *
       * @type {number}
       */
      lastHeight: 0
    });
    this.createElements();
    this.registerEvents();
    this.initializeWalkontable();
  }
  _createClass$1_(TableView2, [{
    key: "render",
    value: function render() {
      if (!this.instance.isRenderSuspended()) {
        this.instance.runHooks("beforeRender", this.instance.forceFullRender);
        if (this.postponedAdjustElementsSize) {
          this.postponedAdjustElementsSize = false;
          this.adjustElementsSize(true);
        }
        this._wt.draw(!this.instance.forceFullRender);
        this.instance.runHooks("afterRender", this.instance.forceFullRender);
        this.instance.forceFullRender = false;
        this.instance.renderCall = false;
      }
    }
    /**
     * Adjust overlays elements size and master table size.
     *
     * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (this.instance.isRenderSuspended()) {
        this.postponedAdjustElementsSize = true;
      } else {
        this._wt.wtOverlays.adjustElementsSize(force);
      }
    }
    /**
     * Returns td object given coordinates.
     *
     * @param {CellCoords} coords Renderable cell coordinates.
     * @param {boolean} topmost Indicates whether the cell should be calculated from the topmost.
     * @returns {HTMLTableCellElement|null}
     */
  }, {
    key: "getCellAtCoords",
    value: function getCellAtCoords(coords, topmost) {
      var td = this._wt.getCell(coords, topmost);
      if (td < 0) {
        return null;
      }
      return td;
    }
    /**
     * Scroll viewport to a cell.
     *
     * @param {CellCoords} coords Renderable cell coordinates.
     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.
     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.
     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      return this._wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
    /**
     * Scroll viewport to a column.
     *
     * @param {number} column Renderable column index.
     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.
     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      return this._wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);
    }
    /**
     * Scroll viewport to a row.
     *
     * @param {number} row Renderable row index.
     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.
     * @returns {boolean}
     */
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      return this._wt.scrollViewportVertically(row, snapToTop, snapToBottom);
    }
    /**
     * Prepares DOMElements and adds correct className to the root element.
     *
     * @private
     */
  }, {
    key: "createElements",
    value: function createElements() {
      var priv = privatePool$i.get(this);
      var _this$instance = this.instance, rootElement = _this$instance.rootElement, rootDocument = _this$instance.rootDocument;
      var originalStyle = rootElement.getAttribute("style");
      if (originalStyle) {
        rootElement.setAttribute("data-originalstyle", originalStyle);
      }
      addClass(rootElement, "handsontable");
      priv.table = rootDocument.createElement("TABLE");
      addClass(priv.table, "htCore");
      if (this.instance.getSettings().tableClassName) {
        addClass(priv.table, this.instance.getSettings().tableClassName);
      }
      this.THEAD = rootDocument.createElement("THEAD");
      priv.table.appendChild(this.THEAD);
      this.TBODY = rootDocument.createElement("TBODY");
      priv.table.appendChild(this.TBODY);
      this.instance.table = priv.table;
      this.instance.container.insertBefore(priv.table, this.instance.container.firstChild);
    }
    /**
     * Attaches necessary listeners.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this = this;
      var priv = privatePool$i.get(this);
      var _this$instance2 = this.instance, rootElement = _this$instance2.rootElement, rootDocument = _this$instance2.rootDocument, selection = _this$instance2.selection;
      var documentElement = rootDocument.documentElement;
      this.eventManager.addEventListener(rootElement, "mousedown", function(event2) {
        priv.selectionMouseDown = true;
        if (!_this.isTextSelectionAllowed(event2.target)) {
          var rootWindow = _this.instance.rootWindow;
          clearTextSelection(rootWindow);
          event2.preventDefault();
          rootWindow.focus();
        }
      });
      this.eventManager.addEventListener(rootElement, "mouseup", function() {
        priv.selectionMouseDown = false;
      });
      this.eventManager.addEventListener(rootElement, "mousemove", function(event2) {
        if (priv.selectionMouseDown && !_this.isTextSelectionAllowed(event2.target)) {
          if (_this.settings.fragmentSelection) {
            clearTextSelection(_this.instance.rootWindow);
          }
          event2.preventDefault();
        }
      });
      this.eventManager.addEventListener(documentElement, "keyup", function(event2) {
        if (selection.isInProgress() && !event2.shiftKey) {
          selection.finish();
        }
      });
      this.eventManager.addEventListener(documentElement, "mouseup", function(event2) {
        if (selection.isInProgress() && isLeftClick(event2)) {
          selection.finish();
        }
        priv.mouseDown = false;
        if (isOutsideInput(rootDocument.activeElement) || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event2.target) && !isRightClick(event2)) {
          _this.instance.unlisten();
        }
      });
      this.eventManager.addEventListener(documentElement, "contextmenu", function(event2) {
        if (selection.isInProgress() && isRightClick(event2)) {
          selection.finish();
          priv.mouseDown = false;
        }
      });
      this.eventManager.addEventListener(documentElement, "touchend", function() {
        if (selection.isInProgress()) {
          selection.finish();
        }
        priv.mouseDown = false;
      });
      this.eventManager.addEventListener(documentElement, "mousedown", function(event2) {
        var originalTarget = event2.target;
        var eventX = event2.x || event2.clientX;
        var eventY = event2.y || event2.clientY;
        var next2 = event2.target;
        if (priv.mouseDown || !rootElement || !_this.instance.view) {
          return;
        }
        var holder2 = _this.instance.view._wt.wtTable.holder;
        if (next2 === holder2) {
          var scrollbarWidth = getScrollbarWidth(rootDocument);
          if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder2 || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder2) {
            return;
          }
        } else {
          while (next2 !== documentElement) {
            if (next2 === null) {
              if (event2.isTargetWebComponent) {
                break;
              }
              return;
            }
            if (next2 === rootElement) {
              return;
            }
            next2 = next2.parentNode;
          }
        }
        var outsideClickDeselects = typeof _this.settings.outsideClickDeselects === "function" ? _this.settings.outsideClickDeselects(originalTarget) : _this.settings.outsideClickDeselects;
        if (outsideClickDeselects) {
          _this.instance.deselectCell();
        } else {
          _this.instance.destroyEditor(false, false);
        }
      });
      this.eventManager.addEventListener(priv.table, "selectstart", function(event2) {
        if (_this.settings.fragmentSelection || isInput(event2.target)) {
          return;
        }
        event2.preventDefault();
      });
    }
    /**
     * Translate renderable cell coordinates to visual coordinates.
     *
     * @param {CellCoords} coords The cell coordinates.
     * @returns {CellCoords}
     */
  }, {
    key: "translateFromRenderableToVisualCoords",
    value: function translateFromRenderableToVisualCoords(_ref2) {
      var _this$instance3;
      var row = _ref2.row, col = _ref2.col;
      return (_this$instance3 = this.instance)._createCellCoords.apply(_this$instance3, _toConsumableArray$s(this.translateFromRenderableToVisualIndex(row, col)));
    }
    /**
     * Translate renderable row and column indexes to visual row and column indexes.
     *
     * @param {number} renderableRow Renderable row index.
     * @param {number} renderableColumn Renderable columnIndex.
     * @returns {number[]}
     */
  }, {
    key: "translateFromRenderableToVisualIndex",
    value: function translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {
      var visualRow = renderableRow >= 0 ? this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;
      var visualColumn = renderableColumn >= 0 ? this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;
      if (visualRow === null) {
        visualRow = renderableRow;
      }
      if (visualColumn === null) {
        visualColumn = renderableColumn;
      }
      return [visualRow, visualColumn];
    }
    /**
     * Returns the number of renderable indexes.
     *
     * @private
     * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
     * @param {number} maxElements Maximum number of elements (rows or columns).
     *
     * @returns {number|*}
     */
  }, {
    key: "countRenderableIndexes",
    value: function countRenderableIndexes(indexMapper, maxElements) {
      var consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);
      var firstNotHiddenIndex = indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);
      if (firstNotHiddenIndex === null) {
        return 0;
      }
      return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;
    }
    /**
     * Returns the number of renderable columns.
     *
     * @returns {number}
     */
  }, {
    key: "countRenderableColumns",
    value: function countRenderableColumns() {
      return this.countRenderableIndexes(this.instance.columnIndexMapper, this.settings.maxCols);
    }
    /**
     * Returns the number of renderable rows.
     *
     * @returns {number}
     */
  }, {
    key: "countRenderableRows",
    value: function countRenderableRows() {
      return this.countRenderableIndexes(this.instance.rowIndexMapper, this.settings.maxRows);
    }
    /**
     * Returns number of not hidden row indexes counting from the passed starting index.
     * The counting direction can be controlled by `incrementBy` argument.
     *
     * @param {number} visualIndex The visual index from which the counting begins.
     * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
     * @returns {number}
     */
  }, {
    key: "countNotHiddenRowIndexes",
    value: function countNotHiddenRowIndexes(visualIndex, incrementBy) {
      return this.countNotHiddenIndexes(visualIndex, incrementBy, this.instance.rowIndexMapper, this.countRenderableRows());
    }
    /**
     * Returns number of not hidden column indexes counting from the passed starting index.
     * The counting direction can be controlled by `incrementBy` argument.
     *
     * @param {number} visualIndex The visual index from which the counting begins.
     * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
     * @returns {number}
     */
  }, {
    key: "countNotHiddenColumnIndexes",
    value: function countNotHiddenColumnIndexes(visualIndex, incrementBy) {
      return this.countNotHiddenIndexes(visualIndex, incrementBy, this.instance.columnIndexMapper, this.countRenderableColumns());
    }
    /**
     * Returns number of not hidden indexes counting from the passed starting index.
     * The counting direction can be controlled by `incrementBy` argument.
     *
     * @param {number} visualIndex The visual index from which the counting begins.
     * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
     * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
     * @param {number} renderableIndexesCount Total count of renderable indexes for specific axis.
     * @returns {number}
     */
  }, {
    key: "countNotHiddenIndexes",
    value: function countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {
      if (isNaN(visualIndex) || visualIndex < 0) {
        return 0;
      }
      var firstVisibleIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);
      var renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);
      if (!Number.isInteger(renderableIndex)) {
        return 0;
      }
      var notHiddenIndexes = 0;
      if (incrementBy < 0) {
        notHiddenIndexes = renderableIndex + 1;
      } else if (incrementBy > 0) {
        notHiddenIndexes = renderableIndexesCount - renderableIndex;
      }
      return notHiddenIndexes;
    }
    /**
     * The function returns the number of not hidden column indexes that fit between the first and
     * last fixed column in the left (or right in RTL mode) overlay.
     *
     * @returns {number}
     */
  }, {
    key: "countNotHiddenFixedColumnsStart",
    value: function countNotHiddenFixedColumnsStart() {
      var countCols = this.instance.countCols();
      var visualFixedColumnsStart = Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;
      return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);
    }
    /**
     * The function returns the number of not hidden row indexes that fit between the first and
     * last fixed row in the top overlay.
     *
     * @returns {number}
     */
  }, {
    key: "countNotHiddenFixedRowsTop",
    value: function countNotHiddenFixedRowsTop() {
      var countRows = this.instance.countRows();
      var visualFixedRowsTop = Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;
      return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);
    }
    /**
     * The function returns the number of not hidden row indexes that fit between the first and
     * last fixed row in the bottom overlay.
     *
     * @returns {number}
     */
  }, {
    key: "countNotHiddenFixedRowsBottom",
    value: function countNotHiddenFixedRowsBottom() {
      var countRows = this.instance.countRows();
      var visualFixedRowsBottom = Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);
      return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);
    }
    /**
     * Checks if at least one cell than belongs to the main table is not covered by the top, left or
     * bottom overlay.
     *
     * @returns {boolean}
     */
  }, {
    key: "isMainTableNotFullyCoveredByOverlays",
    value: function isMainTableNotFullyCoveredByOverlays() {
      var fixedAllRows = this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();
      var fixedAllColumns = this.countNotHiddenFixedColumnsStart();
      return this.instance.countRenderedRows() > fixedAllRows && this.instance.countRenderedCols() > fixedAllColumns;
    }
    /**
     * Defines default configuration and initializes WalkOnTable instance.
     *
     * @private
     */
  }, {
    key: "initializeWalkontable",
    value: function initializeWalkontable() {
      var _this2 = this;
      var priv = privatePool$i.get(this);
      var walkontableConfig = {
        rtlMode: this.instance.isRtl(),
        externalRowCalculator: this.instance.getPlugin("autoRowSize") && this.instance.getPlugin("autoRowSize").isEnabled(),
        table: priv.table,
        isDataViewInstance: function isDataViewInstance() {
          return isRootInstance(_this2.instance);
        },
        preventOverflow: function preventOverflow() {
          return _this2.settings.preventOverflow;
        },
        preventWheel: function preventWheel() {
          return _this2.settings.preventWheel;
        },
        stretchH: function stretchH() {
          return _this2.settings.stretchH;
        },
        data: function data2(renderableRow, renderableColumn) {
          var _this2$instance;
          return (_this2$instance = _this2.instance).getDataAtCell.apply(_this2$instance, _toConsumableArray$s(_this2.translateFromRenderableToVisualIndex(renderableRow, renderableColumn)));
        },
        totalRows: function totalRows() {
          return _this2.countRenderableRows();
        },
        totalColumns: function totalColumns() {
          return _this2.countRenderableColumns();
        },
        // Number of renderable columns for the left overlay.
        fixedColumnsStart: function fixedColumnsStart() {
          return _this2.countNotHiddenFixedColumnsStart();
        },
        // Number of renderable rows for the top overlay.
        fixedRowsTop: function fixedRowsTop() {
          return _this2.countNotHiddenFixedRowsTop();
        },
        // Number of renderable rows for the bottom overlay.
        fixedRowsBottom: function fixedRowsBottom() {
          return _this2.countNotHiddenFixedRowsBottom();
        },
        // Enable the inline start overlay when conditions are met.
        shouldRenderInlineStartOverlay: function shouldRenderInlineStartOverlay() {
          return _this2.settings.fixedColumnsStart > 0 || walkontableConfig.rowHeaders().length > 0;
        },
        // Enable the top overlay when conditions are met.
        shouldRenderTopOverlay: function shouldRenderTopOverlay() {
          return _this2.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;
        },
        // Enable the bottom overlay when conditions are met.
        shouldRenderBottomOverlay: function shouldRenderBottomOverlay() {
          return _this2.settings.fixedRowsBottom > 0;
        },
        minSpareRows: function minSpareRows() {
          return _this2.settings.minSpareRows;
        },
        renderAllRows: this.settings.renderAllRows,
        rowHeaders: function rowHeaders() {
          var headerRenderers = [];
          if (_this2.instance.hasRowHeaders()) {
            headerRenderers.push(function(renderableRowIndex, TH) {
              var visualRowIndex = renderableRowIndex >= 0 ? _this2.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
              _this2.appendRowHeader(visualRowIndex, TH);
            });
          }
          _this2.instance.runHooks("afterGetRowHeaderRenderers", headerRenderers);
          return headerRenderers;
        },
        columnHeaders: function columnHeaders() {
          var headerRenderers = [];
          if (_this2.instance.hasColHeaders()) {
            headerRenderers.push(function(renderedColumnIndex, TH) {
              var visualColumnsIndex = renderedColumnIndex >= 0 ? _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;
              _this2.appendColHeader(visualColumnsIndex, TH);
            });
          }
          _this2.instance.runHooks("afterGetColumnHeaderRenderers", headerRenderers);
          return headerRenderers;
        },
        columnWidth: function columnWidth(renderedColumnIndex) {
          var visualIndex = _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
          return _this2.instance.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);
        },
        rowHeight: function rowHeight(renderedRowIndex) {
          var visualIndex = _this2.instance.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);
          return _this2.instance.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);
        },
        cellRenderer: function cellRenderer(renderedRowIndex, renderedColumnIndex, TD) {
          var _this2$translateFromR = _this2.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex), _this2$translateFromR2 = _slicedToArray$F(_this2$translateFromR, 2), visualRowIndex = _this2$translateFromR2[0], visualColumnIndex = _this2$translateFromR2[1];
          var modifiedCellCoords = _this2.instance.runHooks("modifyGetCellCoords", visualRowIndex, visualColumnIndex);
          var visualRowToCheck = visualRowIndex;
          var visualColumnToCheck = visualColumnIndex;
          if (Array.isArray(modifiedCellCoords)) {
            var _modifiedCellCoords = _slicedToArray$F(modifiedCellCoords, 2);
            visualRowToCheck = _modifiedCellCoords[0];
            visualColumnToCheck = _modifiedCellCoords[1];
          }
          var cellProperties = _this2.instance.getCellMeta(visualRowToCheck, visualColumnToCheck);
          var prop = _this2.instance.colToProp(visualColumnToCheck);
          var value = _this2.instance.getDataAtRowProp(visualRowToCheck, prop);
          if (_this2.instance.hasHook("beforeValueRender")) {
            value = _this2.instance.runHooks("beforeValueRender", value, cellProperties);
          }
          _this2.instance.runHooks("beforeRenderer", TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
          _this2.instance.getCellRenderer(cellProperties)(_this2.instance, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
          _this2.instance.runHooks("afterRenderer", TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
        },
        selections: this.instance.selection.highlight,
        hideBorderOnMouseDownOver: function hideBorderOnMouseDownOver() {
          return _this2.settings.fragmentSelection;
        },
        onWindowResize: function onWindowResize() {
          if (!_this2.instance || _this2.instance.isDestroyed) {
            return;
          }
          _this2.instance.refreshDimensions();
        },
        onCellMouseDown: function onCellMouseDown(event2, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          var controller = {
            row: false,
            column: false,
            cell: false
          };
          _this2.instance.listen();
          _this2.activeWt = wt;
          priv.mouseDown = true;
          _this2.instance.runHooks("beforeOnCellMouseDown", event2, visualCoords, TD, controller);
          if (isImmediatePropagationStopped(event2)) {
            return;
          }
          handleMouseEvent(event2, {
            coords: visualCoords,
            selection: _this2.instance.selection,
            controller,
            cellCoordsFactory: function cellCoordsFactory(row, column) {
              return _this2.instance._createCellCoords(row, column);
            }
          });
          _this2.instance.runHooks("afterOnCellMouseDown", event2, visualCoords, TD);
          _this2.activeWt = _this2._wt;
        },
        onCellContextMenu: function onCellContextMenu(event2, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          _this2.activeWt = wt;
          priv.mouseDown = false;
          if (_this2.instance.selection.isInProgress()) {
            _this2.instance.selection.finish();
          }
          _this2.instance.runHooks("beforeOnCellContextMenu", event2, visualCoords, TD);
          if (isImmediatePropagationStopped(event2)) {
            return;
          }
          _this2.instance.runHooks("afterOnCellContextMenu", event2, visualCoords, TD);
          _this2.activeWt = _this2._wt;
        },
        onCellMouseOut: function onCellMouseOut(event2, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          _this2.activeWt = wt;
          _this2.instance.runHooks("beforeOnCellMouseOut", event2, visualCoords, TD);
          if (isImmediatePropagationStopped(event2)) {
            return;
          }
          _this2.instance.runHooks("afterOnCellMouseOut", event2, visualCoords, TD);
          _this2.activeWt = _this2._wt;
        },
        onCellMouseOver: function onCellMouseOver(event2, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          var controller = {
            row: false,
            column: false,
            cell: false
          };
          _this2.activeWt = wt;
          _this2.instance.runHooks("beforeOnCellMouseOver", event2, visualCoords, TD, controller);
          if (isImmediatePropagationStopped(event2)) {
            return;
          }
          if (priv.mouseDown) {
            handleMouseEvent(event2, {
              coords: visualCoords,
              selection: _this2.instance.selection,
              controller,
              cellCoordsFactory: function cellCoordsFactory(row, column) {
                return _this2.instance._createCellCoords(row, column);
              }
            });
          }
          _this2.instance.runHooks("afterOnCellMouseOver", event2, visualCoords, TD);
          _this2.activeWt = _this2._wt;
        },
        onCellMouseUp: function onCellMouseUp(event2, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          _this2.activeWt = wt;
          _this2.instance.runHooks("beforeOnCellMouseUp", event2, visualCoords, TD);
          if (isImmediatePropagationStopped(event2) || _this2.instance.isDestroyed) {
            return;
          }
          _this2.instance.runHooks("afterOnCellMouseUp", event2, visualCoords, TD);
          _this2.activeWt = _this2._wt;
        },
        onCellCornerMouseDown: function onCellCornerMouseDown(event2) {
          event2.preventDefault();
          _this2.instance.runHooks("afterOnCellCornerMouseDown", event2);
        },
        onCellCornerDblClick: function onCellCornerDblClick(event2) {
          event2.preventDefault();
          _this2.instance.runHooks("afterOnCellCornerDblClick", event2);
        },
        beforeDraw: function beforeDraw(force, skipRender) {
          return _this2.beforeRender(force, skipRender);
        },
        onDraw: function onDraw(force) {
          return _this2.afterRender(force);
        },
        onScrollVertically: function onScrollVertically() {
          return _this2.instance.runHooks("afterScrollVertically");
        },
        onScrollHorizontally: function onScrollHorizontally() {
          return _this2.instance.runHooks("afterScrollHorizontally");
        },
        onBeforeRemoveCellClassNames: function onBeforeRemoveCellClassNames() {
          return _this2.instance.runHooks("beforeRemoveCellClassNames");
        },
        onBeforeHighlightingRowHeader: function onBeforeHighlightingRowHeader(renderableRow, headerLevel, highlightMeta) {
          var rowMapper = _this2.instance.rowIndexMapper;
          var visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);
          var newVisualRow = _this2.instance.runHooks("beforeHighlightingRowHeader", visualRow, headerLevel, highlightMeta);
          return rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(newVisualRow, 1));
        },
        onBeforeHighlightingColumnHeader: function onBeforeHighlightingColumnHeader(renderableColumn, headerLevel, highlightMeta) {
          var columnMapper = _this2.instance.columnIndexMapper;
          var visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);
          var newVisualColumn = _this2.instance.runHooks("beforeHighlightingColumnHeader", visualColumn, headerLevel, highlightMeta);
          return columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(newVisualColumn, 1));
        },
        onAfterDrawSelection: function onAfterDrawSelection(currentRow, currentColumn, layerLevel) {
          var cornersOfSelection;
          var _this2$translateFromR3 = _this2.translateFromRenderableToVisualIndex(currentRow, currentColumn), _this2$translateFromR4 = _slicedToArray$F(_this2$translateFromR3, 2), visualRowIndex = _this2$translateFromR4[0], visualColumnIndex = _this2$translateFromR4[1];
          var selectedRange = _this2.instance.selection.getSelectedRange();
          var selectionRangeSize = selectedRange.size();
          if (selectionRangeSize > 0) {
            var selectionOffset = (layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0) + 1 - selectionRangeSize;
            var selectionForLayer = selectedRange.peekByIndex(selectionOffset);
            cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];
          }
          return _this2.instance.runHooks("afterDrawSelection", visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);
        },
        onBeforeDrawBorders: function onBeforeDrawBorders(corners, borderClassName) {
          var _corners = _slicedToArray$F(corners, 4), startRenderableRow = _corners[0], startRenderableColumn = _corners[1], endRenderableRow = _corners[2], endRenderableColumn = _corners[3];
          var visualCorners = [_this2.instance.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), _this2.instance.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];
          return _this2.instance.runHooks("beforeDrawBorders", visualCorners, borderClassName);
        },
        onBeforeTouchScroll: function onBeforeTouchScroll() {
          return _this2.instance.runHooks("beforeTouchScroll");
        },
        onAfterMomentumScroll: function onAfterMomentumScroll() {
          return _this2.instance.runHooks("afterMomentumScroll");
        },
        onBeforeStretchingColumnWidth: function onBeforeStretchingColumnWidth(stretchedWidth, renderedColumnIndex) {
          var visualColumnIndex = _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
          return _this2.instance.runHooks("beforeStretchingColumnWidth", stretchedWidth, visualColumnIndex);
        },
        onModifyRowHeaderWidth: function onModifyRowHeaderWidth(rowHeaderWidth) {
          return _this2.instance.runHooks("modifyRowHeaderWidth", rowHeaderWidth);
        },
        onModifyGetCellCoords: function onModifyGetCellCoords(renderableRowIndex, renderableColumnIndex, topmost) {
          var rowMapper = _this2.instance.rowIndexMapper;
          var columnMapper = _this2.instance.columnIndexMapper;
          var visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;
          var visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
          var visualIndexes = _this2.instance.runHooks("modifyGetCellCoords", visualRowIndex, visualColumnIndex, topmost);
          if (Array.isArray(visualIndexes)) {
            var _visualIndexes = _slicedToArray$F(visualIndexes, 4), visualRowFrom = _visualIndexes[0], visualColumnFrom = _visualIndexes[1], visualRowTo = _visualIndexes[2], visualColumnTo = _visualIndexes[3];
            return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];
          }
        },
        viewportRowCalculatorOverride: function viewportRowCalculatorOverride(calc) {
          var viewportOffset = _this2.settings.viewportRowRenderingOffset;
          if (viewportOffset === "auto" && _this2.settings.fixedRowsTop) {
            viewportOffset = 10;
          }
          if (viewportOffset > 0 || viewportOffset === "auto") {
            var renderableRows = _this2.countRenderableRows();
            var firstRenderedRow = calc.startRow;
            var lastRenderedRow = calc.endRow;
            if (typeof viewportOffset === "number") {
              calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);
              calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);
            } else if (viewportOffset === "auto") {
              var offset2 = Math.ceil(lastRenderedRow / renderableRows * 12);
              calc.startRow = Math.max(firstRenderedRow - offset2, 0);
              calc.endRow = Math.min(lastRenderedRow + offset2, renderableRows - 1);
            }
          }
          _this2.instance.runHooks("afterViewportRowCalculatorOverride", calc);
        },
        viewportColumnCalculatorOverride: function viewportColumnCalculatorOverride(calc) {
          var viewportOffset = _this2.settings.viewportColumnRenderingOffset;
          if (viewportOffset === "auto" && _this2.settings.fixedColumnsStart) {
            viewportOffset = 10;
          }
          if (viewportOffset > 0 || viewportOffset === "auto") {
            var renderableColumns = _this2.countRenderableColumns();
            var firstRenderedColumn = calc.startColumn;
            var lastRenderedColumn = calc.endColumn;
            if (typeof viewportOffset === "number") {
              calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);
              calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);
            }
            if (viewportOffset === "auto") {
              var offset2 = Math.ceil(lastRenderedColumn / renderableColumns * 6);
              calc.startColumn = Math.max(firstRenderedColumn - offset2, 0);
              calc.endColumn = Math.min(lastRenderedColumn + offset2, renderableColumns - 1);
            }
          }
          _this2.instance.runHooks("afterViewportColumnCalculatorOverride", calc);
        },
        rowHeaderWidth: function rowHeaderWidth() {
          return _this2.settings.rowHeaderWidth;
        },
        columnHeaderHeight: function columnHeaderHeight() {
          var columnHeaderHeight2 = _this2.instance.runHooks("modifyColumnHeaderHeight");
          return _this2.settings.columnHeaderHeight || columnHeaderHeight2;
        }
      };
      this.instance.runHooks("beforeInitWalkontable", walkontableConfig);
      this._wt = new WalkontableFacade(walkontableConfig);
      this.activeWt = this._wt;
      var spreader = this._wt.wtTable.spreader;
      var _this$instance$rootEl = this.instance.rootElement.getBoundingClientRect(), width = _this$instance$rootEl.width, height = _this$instance$rootEl.height;
      this.setLastSize(width, height);
      this.eventManager.addEventListener(spreader, "mousedown", function(event2) {
        if (event2.target === spreader && event2.which === 3) {
          event2.stopPropagation();
        }
      });
      this.eventManager.addEventListener(spreader, "contextmenu", function(event2) {
        if (event2.target === spreader && event2.which === 3) {
          event2.stopPropagation();
        }
      });
      this.eventManager.addEventListener(this.instance.rootDocument.documentElement, "click", function() {
        if (_this2.settings.observeDOMVisibility) {
          if (_this2._wt.drawInterrupted) {
            _this2.instance.forceFullRender = true;
            _this2.render();
          }
        }
      });
    }
    /**
     * Checks if it's possible to create text selection in element.
     *
     * @private
     * @param {HTMLElement} el The element to check.
     * @returns {boolean}
     */
  }, {
    key: "isTextSelectionAllowed",
    value: function isTextSelectionAllowed(el) {
      if (isInput(el)) {
        return true;
      }
      var isChildOfTableBody = isChildOf(el, this.instance.view._wt.wtTable.spreader);
      if (this.settings.fragmentSelection === true && isChildOfTableBody) {
        return true;
      }
      if (this.settings.fragmentSelection === "cell" && this.isSelectedOnlyCell() && isChildOfTableBody) {
        return true;
      }
      if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {
        return true;
      }
      return false;
    }
    /**
     * Checks if user's been called mousedown.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "isMouseDown",
    value: function isMouseDown() {
      return privatePool$i.get(this).mouseDown;
    }
    /**
     * Check if selected only one cell.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "isSelectedOnlyCell",
    value: function isSelectedOnlyCell() {
      var _this$instance$getSel, _this$instance$getSel2;
      return (_this$instance$getSel = (_this$instance$getSel2 = this.instance.getSelectedRangeLast()) === null || _this$instance$getSel2 === void 0 ? void 0 : _this$instance$getSel2.isSingle()) !== null && _this$instance$getSel !== void 0 ? _this$instance$getSel : false;
    }
    /**
     * Checks if active cell is editing.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "isCellEdited",
    value: function isCellEdited() {
      var activeEditor = this.instance.getActiveEditor();
      return activeEditor && activeEditor.isOpened();
    }
    /**
     * `beforeDraw` callback.
     *
     * @private
     * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if
     *                        rendering was triggered by scrolling or moving selection.
     * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering
     *                            cycle will be skipped.
     */
  }, {
    key: "beforeRender",
    value: function beforeRender(force, skipRender) {
      if (force) {
        this.instance.runHooks("beforeViewRender", this.instance.forceFullRender, skipRender);
      }
    }
    /**
     * `afterRender` callback.
     *
     * @private
     * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if
     *                        rendering was triggered by scrolling or moving selection.
     */
  }, {
    key: "afterRender",
    value: function afterRender(force) {
      if (force) {
        this.instance.runHooks("afterViewRender", this.instance.forceFullRender);
      }
    }
    /**
     * Append row header to a TH element.
     *
     * @private
     * @param {number} visualRowIndex The visual row index.
     * @param {HTMLTableHeaderCellElement} TH The table header element.
     */
  }, {
    key: "appendRowHeader",
    value: function appendRowHeader(visualRowIndex, TH) {
      if (TH.firstChild) {
        var container = TH.firstChild;
        if (!hasClass(container, "relative")) {
          empty(TH);
          this.appendRowHeader(visualRowIndex, TH);
          return;
        }
        this.updateCellHeader(container.querySelector(".rowHeader"), visualRowIndex, this.instance.getRowHeader);
      } else {
        var _this$instance4 = this.instance, rootDocument = _this$instance4.rootDocument, getRowHeader = _this$instance4.getRowHeader;
        var div = rootDocument.createElement("div");
        var span = rootDocument.createElement("span");
        div.className = "relative";
        span.className = "rowHeader";
        this.updateCellHeader(span, visualRowIndex, getRowHeader);
        div.appendChild(span);
        TH.appendChild(div);
      }
      this.instance.runHooks("afterGetRowHeader", visualRowIndex, TH);
    }
    /**
     * Append column header to a TH element.
     *
     * @private
     * @param {number} visualColumnIndex Visual column index.
     * @param {HTMLTableHeaderCellElement} TH The table header element.
     */
  }, {
    key: "appendColHeader",
    value: function appendColHeader(visualColumnIndex, TH) {
      if (TH.firstChild) {
        var container = TH.firstChild;
        if (hasClass(container, "relative")) {
          this.updateCellHeader(container.querySelector(".colHeader"), visualColumnIndex, this.instance.getColHeader);
        } else {
          empty(TH);
          this.appendColHeader(visualColumnIndex, TH);
        }
      } else {
        var rootDocument = this.instance.rootDocument;
        var div = rootDocument.createElement("div");
        var span = rootDocument.createElement("span");
        div.className = "relative";
        span.className = "colHeader";
        this.updateCellHeader(span, visualColumnIndex, this.instance.getColHeader);
        div.appendChild(span);
        TH.appendChild(div);
      }
      this.instance.runHooks("afterGetColHeader", visualColumnIndex, TH);
    }
    /**
     * Updates header cell content.
     *
     * @since 0.15.0-beta4
     * @param {HTMLElement} element Element to update.
     * @param {number} index Row index or column index.
     * @param {Function} content Function which should be returns content for this cell.
     */
  }, {
    key: "updateCellHeader",
    value: function updateCellHeader(element, index2, content) {
      var renderedIndex = index2;
      var parentOverlay = this._wt.wtOverlays.getParentOverlay(element) || this._wt;
      if (element.parentNode) {
        if (hasClass(element, "colHeader")) {
          renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index2);
        } else if (hasClass(element, "rowHeader")) {
          renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index2);
        }
      }
      if (renderedIndex > -1) {
        fastInnerHTML(element, content(index2));
      } else {
        fastInnerText(element, String.fromCharCode(160));
        addClass(element, "cornerHeader");
      }
    }
    /**
     * Given a element's left (or right in RTL mode) position relative to the viewport, returns maximum
     * element width until the right (or left) edge of the viewport (before scrollbar).
     *
     * @private
     * @param {number} inlineOffset The left (or right in RTL mode) offset.
     * @returns {number}
     */
  }, {
    key: "maximumVisibleElementWidth",
    value: function maximumVisibleElementWidth(inlineOffset) {
      var workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();
      var maxWidth = workspaceWidth - inlineOffset;
      return maxWidth > 0 ? maxWidth : 0;
    }
    /**
     * Given a element's top position relative to the viewport, returns maximum element height until the bottom
     * edge of the viewport (before scrollbar).
     *
     * @private
     * @param {number} topOffset The top offset.
     * @returns {number}
     */
  }, {
    key: "maximumVisibleElementHeight",
    value: function maximumVisibleElementHeight(topOffset) {
      var workspaceHeight = this._wt.wtViewport.getWorkspaceHeight();
      var maxHeight = workspaceHeight - topOffset;
      return maxHeight > 0 ? maxHeight : 0;
    }
    /**
     * Sets new dimensions of the container.
     *
     * @param {number} width The table width.
     * @param {number} height The table height.
     */
  }, {
    key: "setLastSize",
    value: function setLastSize(width, height) {
      var priv = privatePool$i.get(this);
      var _ref2 = [width, height];
      priv.lastWidth = _ref2[0];
      priv.lastHeight = _ref2[1];
    }
    /**
     * Returns cached dimensions.
     *
     * @returns {object}
     */
  }, {
    key: "getLastSize",
    value: function getLastSize() {
      var priv = privatePool$i.get(this);
      return {
        width: priv.lastWidth,
        height: priv.lastHeight
      };
    }
    /**
     * Returns the first fully visible row in the table viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getFirstFullyVisibleRow",
    value: function getFirstFullyVisibleRow() {
      return this.instance.rowIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getFirstVisibleRow());
    }
    /**
     * Returns the last fully visible row in the table viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getLastFullyVisibleRow",
    value: function getLastFullyVisibleRow() {
      return this.instance.rowIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getLastVisibleRow());
    }
    /**
     * Returns the first fully visible column in the table viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getFirstFullyVisibleColumn",
    value: function getFirstFullyVisibleColumn() {
      return this.instance.columnIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getFirstVisibleColumn());
    }
    /**
     * Returns the last fully visible column in the table viewport.
     *
     * @returns {number}
     */
  }, {
    key: "getLastFullyVisibleColumn",
    value: function getLastFullyVisibleColumn() {
      return this.instance.columnIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getLastVisibleColumn());
    }
    /**
     * Destroys internal WalkOnTable's instance. Detaches all of the bonded listeners.
     *
     * @private
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this._wt.destroy();
      this.eventManager.destroy();
    }
  }]);
  return TableView2;
}();
const TableView$1 = TableView;
var _staticRegister$4 = staticRegister("cellTypes"), register$2 = _staticRegister$4.register, getItem$1 = _staticRegister$4.getItem, hasItem = _staticRegister$4.hasItem;
_staticRegister$4.getNames;
_staticRegister$4.getValues;
function _getItem(name) {
  if (!hasItem(name)) {
    throw Error('You declared cell type "'.concat(name, '" as a string that is not mapped to a known object.\n                 Cell type must be an object or a string mapped to an object registered by\n                 "Handsontable.cellTypes.registerCellType" method'));
  }
  return getItem$1(name);
}
function _register(name, type) {
  if (typeof name !== "string") {
    type = name;
    name = type.CELL_TYPE;
  }
  var _type = type, editor = _type.editor, renderer = _type.renderer, validator = _type.validator;
  if (editor) {
    _register$3(name, editor);
  }
  if (renderer) {
    _register$2(name, renderer);
  }
  if (validator) {
    _register$1(name, validator);
  }
  register$2(name, type);
}
function _typeof$1e(obj) {
  "@babel/helpers - typeof";
  return _typeof$1e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1e(obj);
}
var COLUMN_LABEL_BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;
function spreadsheetColumnLabel(index2) {
  var dividend = index2 + 1;
  var columnLabel = "";
  var modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;
    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);
  }
  return columnLabel;
}
function cellMethodLookupFactory(methodName, allowUndefined) {
  var isUndefinedAllowed = typeof allowUndefined === "undefined" ? true : allowUndefined;
  return function cellMethodLookup(row, col) {
    return function getMethodFromProperties(properties) {
      if (!properties) {
        return;
      }
      if (hasOwnProperty$2(properties, methodName) && properties[methodName] !== void 0) {
        return properties[methodName];
      } else if (hasOwnProperty$2(properties, "type") && properties.type) {
        if (typeof properties.type !== "string") {
          throw new Error('Cell "type" must be a string');
        }
        var type = _getItem(properties.type);
        if (hasOwnProperty$2(type, methodName)) {
          return type[methodName];
        } else if (isUndefinedAllowed) {
          return;
        }
      }
      return getMethodFromProperties(Object.getPrototypeOf(properties));
    }(typeof row === "number" ? this.getCellMeta(row, col) : row);
  };
}
function dataRowToChangesArray(dataRow) {
  var rowOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var dataRows = dataRow;
  var changesArray = [];
  if (!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {
    dataRows = [dataRow];
  }
  dataRows.forEach(function(row, rowIndex) {
    if (Array.isArray(row)) {
      row.forEach(function(value, column) {
        changesArray.push([rowIndex + rowOffset, column, value]);
      });
    } else {
      Object.keys(row).forEach(function(propName) {
        changesArray.push([rowIndex + rowOffset, propName, row[propName]]);
      });
    }
  });
  return changesArray;
}
function countFirstRowKeys(data2) {
  var result = 0;
  if (Array.isArray(data2)) {
    if (data2[0] && Array.isArray(data2[0])) {
      result = data2[0].length;
    } else if (data2[0] && isObject$7(data2[0])) {
      result = deepObjectSize(data2[0]);
    }
  }
  return result;
}
function isArrayOfArrays(data2) {
  return !!(Array.isArray(data2) && data2.length && data2.every(function(el) {
    return Array.isArray(el);
  }));
}
function isArrayOfObjects(data2) {
  return !!(Array.isArray(data2) && data2.length && data2.every(function(el) {
    return _typeof$1e(el) === "object" && !Array.isArray(el) && el !== null;
  }));
}
function _classCallCheck$1Z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1Z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1Z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1Z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1Z(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DataSource = /* @__PURE__ */ function() {
  function DataSource2(hotInstance) {
    var dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    _classCallCheck$1Z(this, DataSource2);
    this.hot = hotInstance;
    this.data = dataSource;
    this.dataType = "array";
    this.colToProp = function() {
    };
    this.propToCol = function() {
    };
  }
  _createClass$1Z(DataSource2, [{
    key: "modifyRowData",
    value: function modifyRowData(rowIndex) {
      var modifyRowData2;
      if (this.hot.hasHook("modifyRowData")) {
        modifyRowData2 = this.hot.runHooks("modifyRowData", rowIndex);
      }
      return modifyRowData2 !== void 0 && !Number.isInteger(modifyRowData2) ? modifyRowData2 : this.data[rowIndex];
    }
    /**
     * Get all data.
     *
     * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided
     *                                  in another format.
     * @returns {Array}
     */
  }, {
    key: "getData",
    value: function getData() {
      var toArray = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!this.data || this.data.length === 0) {
        return this.data;
      }
      return this.getByRange(null, null, toArray);
    }
    /**
     * Set new data source.
     *
     * @param {Array} data The new data.
     */
  }, {
    key: "setData",
    value: function setData(data2) {
      this.data = data2;
    }
    /**
     * Returns array of column values from the data source. `column` is the index of the row in the data source.
     *
     * @param {number} column Visual column index.
     * @returns {Array}
     */
  }, {
    key: "getAtColumn",
    value: function getAtColumn(column) {
      var _this = this;
      var result = [];
      arrayEach(this.data, function(row, rowIndex) {
        var value = _this.getAtCell(rowIndex, column);
        result.push(value);
      });
      return result;
    }
    /**
     * Returns a single row of the data or a subset of its columns. If a column range or `toArray` arguments are provided, it
     * operates only on the columns declared by the `columns` setting or the data schema.
     *
     * @param {number} row Physical row index.
     * @param {number} [startColumn] Starting index for the column range (optional).
     * @param {number} [endColumn] Ending index for the column range (optional).
     * @param {boolean} [toArray=false] `true` if the returned value should be forced to be presented as an array.
     * @returns {Array|object}
     */
  }, {
    key: "getAtRow",
    value: function getAtRow(row, startColumn, endColumn) {
      var _this2 = this;
      var toArray = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var getAllProps = startColumn === void 0 && endColumn === void 0;
      var dataRow = null;
      var newDataRow = null;
      dataRow = this.modifyRowData(row);
      if (Array.isArray(dataRow)) {
        newDataRow = [];
        if (getAllProps) {
          dataRow.forEach(function(cell, column) {
            newDataRow[column] = _this2.getAtPhysicalCell(row, column, dataRow);
          });
        } else {
          rangeEach(startColumn, endColumn, function(column) {
            newDataRow[column - startColumn] = _this2.getAtPhysicalCell(row, column, dataRow);
          });
        }
      } else if (isObject$7(dataRow) || isFunction(dataRow)) {
        if (toArray) {
          newDataRow = [];
        } else {
          newDataRow = {};
        }
        if (!getAllProps || toArray) {
          var rangeStart = 0;
          var rangeEnd = this.countFirstRowKeys() - 1;
          rangeEach(rangeStart, rangeEnd, function(column) {
            var prop = _this2.colToProp(column);
            if (column >= (startColumn || rangeStart) && column <= (endColumn || rangeEnd) && !Number.isInteger(prop)) {
              var cellValue = _this2.getAtPhysicalCell(row, prop, dataRow);
              if (toArray) {
                newDataRow.push(cellValue);
              } else {
                setProperty(newDataRow, prop, cellValue);
              }
            }
          });
        } else {
          objectEach(dataRow, function(value, prop) {
            setProperty(newDataRow, prop, _this2.getAtPhysicalCell(row, prop, dataRow));
          });
        }
      }
      return newDataRow;
    }
    /**
     * Set the provided value in the source data set at the provided coordinates.
     *
     * @param {number} row Physical row index.
     * @param {number|string} column Property name / physical column index.
     * @param {*} value The value to be set at the provided coordinates.
     */
  }, {
    key: "setAtCell",
    value: function setAtCell(row, column, value) {
      if (row >= this.countRows() || column >= this.countFirstRowKeys()) {
        return;
      }
      if (this.hot.hasHook("modifySourceData")) {
        var valueHolder = createObjectPropListener(value);
        this.hot.runHooks("modifySourceData", row, this.propToCol(column), valueHolder, "set");
        if (valueHolder.isTouched()) {
          value = valueHolder.value;
        }
      }
      if (!Number.isInteger(column)) {
        setProperty(this.data[row], column, value);
      } else {
        this.data[row][column] = value;
      }
    }
    /**
     * Get data from the source data set using the physical indexes.
     *
     * @private
     * @param {number} row Physical row index.
     * @param {string|number|Function} column Physical column index / property / function.
     * @param {Array|object} dataRow A representation of a data row.
     * @returns {*} Value at the provided coordinates.
     */
  }, {
    key: "getAtPhysicalCell",
    value: function getAtPhysicalCell(row, column, dataRow) {
      var result = null;
      if (dataRow) {
        if (typeof column === "string") {
          result = getProperty(dataRow, column);
        } else if (typeof column === "function") {
          result = column(dataRow);
        } else {
          result = dataRow[column];
        }
      }
      if (this.hot.hasHook("modifySourceData")) {
        var valueHolder = createObjectPropListener(result);
        this.hot.runHooks("modifySourceData", row, this.colToProp(column), valueHolder, "get");
        if (valueHolder.isTouched()) {
          result = valueHolder.value;
        }
      }
      return result;
    }
    /**
     * Returns a single value from the data.
     *
     * @param {number} row Physical row index.
     * @param {number} column Visual column index.
     * @returns {*}
     */
  }, {
    key: "getAtCell",
    value: function getAtCell(row, column) {
      var dataRow = this.modifyRowData(row);
      return this.getAtPhysicalCell(row, this.colToProp(column), dataRow);
    }
    /**
     * Returns source data by passed range.
     *
     * @param {object} [start] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
     * @param {object} [end] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
     * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided
     *                                  in another format.
     * @returns {Array}
     */
  }, {
    key: "getByRange",
    value: function getByRange() {
      var _this3 = this;
      var start = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var end = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var toArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var getAllProps = false;
      var startRow = null;
      var startCol = null;
      var endRow = null;
      var endCol = null;
      if (start === null || end === null) {
        getAllProps = true;
        startRow = 0;
        endRow = this.countRows() - 1;
      } else {
        startRow = Math.min(start.row, end.row);
        startCol = Math.min(start.col, end.col);
        endRow = Math.max(start.row, end.row);
        endCol = Math.max(start.col, end.col);
      }
      var result = [];
      rangeEach(startRow, endRow, function(currentRow) {
        result.push(getAllProps ? _this3.getAtRow(currentRow, void 0, void 0, toArray) : _this3.getAtRow(currentRow, startCol, endCol, toArray));
      });
      return result;
    }
    /**
     * Count number of rows.
     *
     * @returns {number}
     */
  }, {
    key: "countRows",
    value: function countRows() {
      if (this.hot.hasHook("modifySourceLength")) {
        var modifiedSourceLength = this.hot.runHooks("modifySourceLength");
        if (Number.isInteger(modifiedSourceLength)) {
          return modifiedSourceLength;
        }
      }
      return this.data.length;
    }
    /**
     * Count number of columns.
     *
     * @returns {number}
     */
  }, {
    key: "countFirstRowKeys",
    value: function countFirstRowKeys$1() {
      return countFirstRowKeys(this.data);
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.data = null;
      this.hot = null;
    }
  }]);
  return DataSource2;
}();
const DataSource$1 = DataSource;
var hasOwn2 = hasOwnProperty_1;
var isDataDescriptor$1 = function(descriptor) {
  return descriptor !== void 0 && (hasOwn2(descriptor, "value") || hasOwn2(descriptor, "writable"));
};
var $$7 = _export;
var call$2 = functionCall;
var isObject = isObject$n;
var anObject$1 = anObject$l;
var isDataDescriptor = isDataDescriptor$1;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var getPrototypeOf2 = objectGetPrototypeOf;
function get(target, propertyKey) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject$1(target) === receiver)
    return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule$1.f(target, propertyKey);
  if (descriptor)
    return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call$2(descriptor.get, receiver);
  if (isObject(prototype = getPrototypeOf2(target)))
    return get(prototype, propertyKey, receiver);
}
$$7({ target: "Reflect", stat: true }, {
  get
});
var $$6 = _export;
var fails$3 = fails$G;
var toIndexedObject$1 = toIndexedObject$d;
var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$2 = descriptors;
var FAILS_ON_PRIMITIVES = fails$3(function() {
  nativeGetOwnPropertyDescriptor(1);
});
var FORCED$1 = !DESCRIPTORS$2 || FAILS_ON_PRIMITIVES;
$$6({ target: "Object", stat: true, forced: FORCED$1, sham: !DESCRIPTORS$2 }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject$1(it), key);
  }
});
var MIXIN_NAME$1 = "localHooks";
var localHooks = {
  /**
   * Internal hooks storage.
   */
  _localHooks: /* @__PURE__ */ Object.create(null),
  /**
   * Add hook to the collection.
   *
   * @param {string} key The hook name.
   * @param {Function} callback The hook callback.
   * @returns {object}
   */
  addLocalHook: function addLocalHook(key, callback) {
    if (!this._localHooks[key]) {
      this._localHooks[key] = [];
    }
    this._localHooks[key].push(callback);
    return this;
  },
  /**
   * Run hooks.
   *
   * @param {string} key The name of the hook to run.
   * @param {*} [arg1] An additional parameter passed to the callback function.
   * @param {*} [arg2] An additional parameter passed to the callback function.
   * @param {*} [arg3] An additional parameter passed to the callback function.
   * @param {*} [arg4] An additional parameter passed to the callback function.
   * @param {*} [arg5] An additional parameter passed to the callback function.
   * @param {*} [arg6] An additional parameter passed to the callback function.
   */
  runLocalHooks: function runLocalHooks(key, arg1, arg2, arg3, arg4, arg5, arg6) {
    if (this._localHooks[key]) {
      var length = this._localHooks[key].length;
      for (var i = 0; i < length; i++) {
        fastCall(this._localHooks[key][i], this, arg1, arg2, arg3, arg4, arg5, arg6);
      }
    }
  },
  /**
   * Clear all added hooks.
   *
   * @returns {object}
   */
  clearLocalHooks: function clearLocalHooks() {
    this._localHooks = {};
    return this;
  }
};
defineGetter(localHooks, "MIXIN_NAME", MIXIN_NAME$1, {
  writable: false,
  enumerable: false
});
const localHooks$1 = localHooks;
function _classCallCheck$1Y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1Y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1Y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1Y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1Y(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var IndexMap = /* @__PURE__ */ function() {
  function IndexMap2() {
    var initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    _classCallCheck$1Y(this, IndexMap2);
    this.indexedValues = [];
    this.initValueOrFn = initValueOrFn;
  }
  _createClass$1Y(IndexMap2, [{
    key: "getValues",
    value: function getValues() {
      return this.indexedValues;
    }
    /**
     * Get value for the particular index.
     *
     * @param {number} index Index for which value is got.
     * @returns {*}
     */
  }, {
    key: "getValueAtIndex",
    value: function getValueAtIndex(index2) {
      var values3 = this.indexedValues;
      if (index2 < values3.length) {
        return values3[index2];
      }
    }
    /**
     * Set new values for particular indexes.
     *
     * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
     *
     * @param {Array} values List of set values.
     */
  }, {
    key: "setValues",
    value: function setValues(values3) {
      this.indexedValues = values3.slice();
      this.runLocalHooks("change");
    }
    /**
     * Set new value for the particular index.
     *
     * @param {number} index The index.
     * @param {*} value The value to save.
     *
     * Note: Please keep in mind that it is not possible to set value beyond the map (not respecting already set
     * map's size). Please use the `setValues` method when you would like to extend the map.
     * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
     *
     * @returns {boolean}
     */
  }, {
    key: "setValueAtIndex",
    value: function setValueAtIndex(index2, value) {
      if (index2 < this.indexedValues.length) {
        this.indexedValues[index2] = value;
        this.runLocalHooks("change");
        return true;
      }
      return false;
    }
    /**
     * Clear all values to the defaults.
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.setDefaultValues();
    }
    /**
     * Get length of the index map.
     *
     * @returns {number}
     */
  }, {
    key: "getLength",
    value: function getLength() {
      return this.getValues().length;
    }
    /**
     * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.
     *
     * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
     *
     * @private
     * @param {number} [length] Length of list.
     */
  }, {
    key: "setDefaultValues",
    value: function setDefaultValues() {
      var _this = this;
      var length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.indexedValues.length;
      this.indexedValues.length = 0;
      if (isFunction(this.initValueOrFn)) {
        rangeEach(length - 1, function(index2) {
          return _this.indexedValues.push(_this.initValueOrFn(index2));
        });
      } else {
        rangeEach(length - 1, function() {
          return _this.indexedValues.push(_this.initValueOrFn);
        });
      }
      this.runLocalHooks("change");
    }
    /**
     * Initialize list with default values for particular indexes.
     *
     * @private
     * @param {number} length New length of indexed list.
     * @returns {IndexMap}
     */
  }, {
    key: "init",
    value: function init(length) {
      this.setDefaultValues(length);
      this.runLocalHooks("init");
      return this;
    }
    /**
     * Add values to the list.
     *
     * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
     *
     * @private
     */
  }, {
    key: "insert",
    value: function insert() {
      this.runLocalHooks("change");
    }
    /**
     * Remove values from the list.
     *
     * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
     *
     * @private
     */
  }, {
    key: "remove",
    value: function remove() {
      this.runLocalHooks("change");
    }
    /**
     * Destroys the Map instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearLocalHooks();
      this.indexedValues = null;
      this.initValueOrFn = null;
    }
  }]);
  return IndexMap2;
}();
mixin(IndexMap, localHooks$1);
function _toConsumableArray$r(arr) {
  return _arrayWithoutHoles$r(arr) || _iterableToArray$t(arr) || _unsupportedIterableToArray$10(arr) || _nonIterableSpread$r();
}
function _nonIterableSpread$r() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$10(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$10(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$10(o, minLen);
}
function _iterableToArray$t(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$r(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$10(arr);
}
function _arrayLikeToArray$10(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getListWithInsertedItems$3(indexedValues, insertionIndex, insertedIndexes, insertedValuesMapping) {
  var firstInsertedIndex = insertedIndexes.length ? insertedIndexes[0] : void 0;
  return [].concat(_toConsumableArray$r(indexedValues.slice(0, firstInsertedIndex)), _toConsumableArray$r(insertedIndexes.map(function(insertedIndex, ordinalNumber) {
    if (isFunction(insertedValuesMapping)) {
      return insertedValuesMapping(insertedIndex, ordinalNumber);
    }
    return insertedValuesMapping;
  })), _toConsumableArray$r(firstInsertedIndex === void 0 ? [] : indexedValues.slice(firstInsertedIndex)));
}
function getListWithRemovedItems$3(indexedValues, removedIndexes) {
  return arrayFilter(indexedValues, function(_, index2) {
    return removedIndexes.includes(index2) === false;
  });
}
function _typeof$1d(obj) {
  "@babel/helpers - typeof";
  return _typeof$1d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1d(obj);
}
function _classCallCheck$1X(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1X(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1X(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1X(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1X(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$T() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$T = Reflect.get.bind();
  } else {
    _get$T = function _get2(target, property, receiver) {
      var base = _superPropBase$T(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$T.apply(this, arguments);
}
function _superPropBase$T(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$16(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$16(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$16(subClass, superClass);
}
function _setPrototypeOf$16(o, p2) {
  _setPrototypeOf$16 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$16(o, p2);
}
function _createSuper$16(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$16();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$16(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$16(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$16(this, result);
  };
}
function _possibleConstructorReturn$16(self2, call2) {
  if (call2 && (_typeof$1d(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$16(self2);
}
function _assertThisInitialized$16(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$16() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$16(o) {
  _getPrototypeOf$16 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$16(o);
}
var PhysicalIndexToValueMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$16(PhysicalIndexToValueMap2, _IndexMap);
  var _super = _createSuper$16(PhysicalIndexToValueMap2);
  function PhysicalIndexToValueMap2() {
    _classCallCheck$1X(this, PhysicalIndexToValueMap2);
    return _super.apply(this, arguments);
  }
  _createClass$1X(PhysicalIndexToValueMap2, [{
    key: "insert",
    value: (
      /**
       * Add values to list and reorganize.
       *
       * @private
       * @param {number} insertionIndex Position inside the list.
       * @param {Array} insertedIndexes List of inserted indexes.
       */
      function insert(insertionIndex, insertedIndexes) {
        this.indexedValues = getListWithInsertedItems$3(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
        _get$T(_getPrototypeOf$16(PhysicalIndexToValueMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
      }
    )
    /**
     * Remove values from the list and reorganize.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      this.indexedValues = getListWithRemovedItems$3(this.indexedValues, removedIndexes);
      _get$T(_getPrototypeOf$16(PhysicalIndexToValueMap2.prototype), "remove", this).call(this, removedIndexes);
    }
  }]);
  return PhysicalIndexToValueMap2;
}(IndexMap);
function _typeof$1c(obj) {
  "@babel/helpers - typeof";
  return _typeof$1c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1c(obj);
}
function _classCallCheck$1W(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1W(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1W(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1W(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1W(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$15(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$15(subClass, superClass);
}
function _setPrototypeOf$15(o, p2) {
  _setPrototypeOf$15 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$15(o, p2);
}
function _createSuper$15(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$15();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$15(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$15(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$15(this, result);
  };
}
function _possibleConstructorReturn$15(self2, call2) {
  if (call2 && (_typeof$1c(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$15(self2);
}
function _assertThisInitialized$15(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$15() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$15(o) {
  _getPrototypeOf$15 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$15(o);
}
var HidingMap = /* @__PURE__ */ function(_PhysicalIndexToValue) {
  _inherits$15(HidingMap2, _PhysicalIndexToValue);
  var _super = _createSuper$15(HidingMap2);
  function HidingMap2() {
    var initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck$1W(this, HidingMap2);
    return _super.call(this, initValueOrFn);
  }
  _createClass$1W(HidingMap2, [{
    key: "getHiddenIndexes",
    value: function getHiddenIndexes() {
      return arrayReduce$1(this.getValues(), function(indexesList, isHidden, physicalIndex) {
        if (isHidden) {
          indexesList.push(physicalIndex);
        }
        return indexesList;
      }, []);
    }
  }]);
  return HidingMap2;
}(PhysicalIndexToValueMap);
function _toConsumableArray$q(arr) {
  return _arrayWithoutHoles$q(arr) || _iterableToArray$s(arr) || _unsupportedIterableToArray$$(arr) || _nonIterableSpread$q();
}
function _nonIterableSpread$q() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$$(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$$(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$$(o, minLen);
}
function _iterableToArray$s(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$q(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$$(arr);
}
function _arrayLikeToArray$$(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getListWithInsertedItems$2(indexedValues, insertionIndex, insertedIndexes) {
  return [].concat(_toConsumableArray$q(indexedValues.slice(0, insertionIndex)), _toConsumableArray$q(insertedIndexes), _toConsumableArray$q(indexedValues.slice(insertionIndex)));
}
function getListWithRemovedItems$2(indexedValues, removedIndexes) {
  return arrayFilter(indexedValues, function(index2) {
    return removedIndexes.includes(index2) === false;
  });
}
function getDecreasedIndexes(indexedValues, removedIndexes) {
  return arrayMap(indexedValues, function(index2) {
    return index2 - removedIndexes.filter(function(removedIndex) {
      return removedIndex < index2;
    }).length;
  });
}
function getIncreasedIndexes(indexedValues, insertedIndexes) {
  var firstInsertedIndex = insertedIndexes[0];
  var amountOfIndexes = insertedIndexes.length;
  return arrayMap(indexedValues, function(index2) {
    if (index2 >= firstInsertedIndex) {
      return index2 + amountOfIndexes;
    }
    return index2;
  });
}
function _typeof$1b(obj) {
  "@babel/helpers - typeof";
  return _typeof$1b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1b(obj);
}
function _toConsumableArray$p(arr) {
  return _arrayWithoutHoles$p(arr) || _iterableToArray$r(arr) || _unsupportedIterableToArray$_(arr) || _nonIterableSpread$p();
}
function _nonIterableSpread$p() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$_(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$_(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$_(o, minLen);
}
function _iterableToArray$r(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$p(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$_(arr);
}
function _arrayLikeToArray$_(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1V(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1V(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1V(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1V(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1V(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$S() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$S = Reflect.get.bind();
  } else {
    _get$S = function _get2(target, property, receiver) {
      var base = _superPropBase$S(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$S.apply(this, arguments);
}
function _superPropBase$S(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$14(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$14(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$14(subClass, superClass);
}
function _setPrototypeOf$14(o, p2) {
  _setPrototypeOf$14 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$14(o, p2);
}
function _createSuper$14(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$14();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$14(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$14(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$14(this, result);
  };
}
function _possibleConstructorReturn$14(self2, call2) {
  if (call2 && (_typeof$1b(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$14(self2);
}
function _assertThisInitialized$14(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$14() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$14(o) {
  _getPrototypeOf$14 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$14(o);
}
function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LinkedPhysicalIndexToValueMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$14(LinkedPhysicalIndexToValueMap2, _IndexMap);
  var _super = _createSuper$14(LinkedPhysicalIndexToValueMap2);
  function LinkedPhysicalIndexToValueMap2() {
    var _this;
    _classCallCheck$1V(this, LinkedPhysicalIndexToValueMap2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$u(_assertThisInitialized$14(_this), "orderOfIndexes", []);
    return _this;
  }
  _createClass$1V(LinkedPhysicalIndexToValueMap2, [{
    key: "getValues",
    value: (
      /**
       * Get full list of ordered values for particular indexes.
       *
       * @returns {Array}
       */
      function getValues() {
        var _this2 = this;
        return this.orderOfIndexes.map(function(physicalIndex) {
          return _this2.indexedValues[physicalIndex];
        });
      }
    )
    /**
     * Set new values for particular indexes. Entries are linked and stored in a certain order.
     *
     * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
     *
     * @param {Array} values List of set values.
     */
  }, {
    key: "setValues",
    value: function setValues(values3) {
      this.orderOfIndexes = _toConsumableArray$p(Array(values3.length).keys());
      _get$S(_getPrototypeOf$14(LinkedPhysicalIndexToValueMap2.prototype), "setValues", this).call(this, values3);
    }
    /**
     * Set value at index and add it to the linked list of entries. Entries are stored in a certain order.
     *
     * Note: Value will be added at the end of the queue.
     *
     * @param {number} index The index.
     * @param {*} value The value to save.
     * @param {number} position Position to which entry will be added.
     *
     * @returns {boolean}
     */
  }, {
    key: "setValueAtIndex",
    value: function setValueAtIndex(index2, value) {
      var position = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.orderOfIndexes.length;
      if (index2 < this.indexedValues.length) {
        this.indexedValues[index2] = value;
        if (this.orderOfIndexes.includes(index2) === false) {
          this.orderOfIndexes.splice(position, 0, index2);
        }
        this.runLocalHooks("change");
        return true;
      }
      return false;
    }
    /**
     * Clear value for particular index.
     *
     * @param {number} physicalIndex Physical index.
     */
  }, {
    key: "clearValue",
    value: function clearValue(physicalIndex) {
      this.orderOfIndexes = getListWithRemovedItems$2(this.orderOfIndexes, [physicalIndex]);
      if (isFunction(this.initValueOrFn)) {
        _get$S(_getPrototypeOf$14(LinkedPhysicalIndexToValueMap2.prototype), "setValueAtIndex", this).call(this, physicalIndex, this.initValueOrFn(physicalIndex));
      } else {
        _get$S(_getPrototypeOf$14(LinkedPhysicalIndexToValueMap2.prototype), "setValueAtIndex", this).call(this, physicalIndex, this.initValueOrFn);
      }
    }
    /**
     * Get length of the index map.
     *
     * @returns {number}
     */
  }, {
    key: "getLength",
    value: function getLength() {
      return this.orderOfIndexes.length;
    }
    /**
     * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.
     *
     * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
     *
     * @private
     * @param {number} [length] Length of list.
     */
  }, {
    key: "setDefaultValues",
    value: function setDefaultValues() {
      var length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.indexedValues.length;
      this.orderOfIndexes.length = 0;
      _get$S(_getPrototypeOf$14(LinkedPhysicalIndexToValueMap2.prototype), "setDefaultValues", this).call(this, length);
    }
    /**
     * Add values to list and reorganize. It updates list of indexes related to ordered values.
     *
     * @private
     * @param {number} insertionIndex Position inside the list.
     * @param {Array} insertedIndexes List of inserted indexes.
     */
  }, {
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      this.indexedValues = getListWithInsertedItems$3(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
      this.orderOfIndexes = getIncreasedIndexes(this.orderOfIndexes, insertedIndexes);
      _get$S(_getPrototypeOf$14(LinkedPhysicalIndexToValueMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
    /**
     * Remove values from the list and reorganize. It updates list of indexes related to ordered values.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      this.indexedValues = getListWithRemovedItems$3(this.indexedValues, removedIndexes);
      this.orderOfIndexes = getListWithRemovedItems$2(this.orderOfIndexes, removedIndexes);
      this.orderOfIndexes = getDecreasedIndexes(this.orderOfIndexes, removedIndexes);
      _get$S(_getPrototypeOf$14(LinkedPhysicalIndexToValueMap2.prototype), "remove", this).call(this, removedIndexes);
    }
    /**
     * Get every entry containing index and value, respecting order of indexes.
     *
     * @returns {Array}
     */
  }, {
    key: "getEntries",
    value: function getEntries() {
      var _this3 = this;
      return this.orderOfIndexes.map(function(physicalIndex) {
        return [physicalIndex, _this3.getValueAtIndex(physicalIndex)];
      });
    }
  }]);
  return LinkedPhysicalIndexToValueMap2;
}(IndexMap);
function _typeof$1a(obj) {
  "@babel/helpers - typeof";
  return _typeof$1a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1a(obj);
}
function _classCallCheck$1U(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1U(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1U(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1U(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1U(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$13(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$13(subClass, superClass);
}
function _setPrototypeOf$13(o, p2) {
  _setPrototypeOf$13 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$13(o, p2);
}
function _createSuper$13(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$13();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$13(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$13(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$13(this, result);
  };
}
function _possibleConstructorReturn$13(self2, call2) {
  if (call2 && (_typeof$1a(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$13(self2);
}
function _assertThisInitialized$13(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$13() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$13(o) {
  _getPrototypeOf$13 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$13(o);
}
var TrimmingMap = /* @__PURE__ */ function(_PhysicalIndexToValue) {
  _inherits$13(TrimmingMap2, _PhysicalIndexToValue);
  var _super = _createSuper$13(TrimmingMap2);
  function TrimmingMap2() {
    var initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck$1U(this, TrimmingMap2);
    return _super.call(this, initValueOrFn);
  }
  _createClass$1U(TrimmingMap2, [{
    key: "getTrimmedIndexes",
    value: function getTrimmedIndexes() {
      return arrayReduce$1(this.getValues(), function(indexesList, isTrimmed, physicalIndex) {
        if (isTrimmed) {
          indexesList.push(physicalIndex);
        }
        return indexesList;
      }, []);
    }
  }]);
  return TrimmingMap2;
}(PhysicalIndexToValueMap);
var alterStrategies = /* @__PURE__ */ new Map([["indexesSequence", {
  getListWithInsertedItems: getListWithInsertedItems$2,
  getListWithRemovedItems: getListWithRemovedItems$2
}], ["physicallyIndexed", {
  getListWithInsertedItems: getListWithInsertedItems$3,
  getListWithRemovedItems: getListWithRemovedItems$3
}]]);
var alterUtilsFactory = function alterUtilsFactory2(indexationStrategy) {
  if (alterStrategies.has(indexationStrategy) === false) {
    throw new Error("Alter strategy with ID '".concat(indexationStrategy, "' does not exist."));
  }
  return alterStrategies.get(indexationStrategy);
};
function _typeof$19(obj) {
  "@babel/helpers - typeof";
  return _typeof$19 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$19(obj);
}
function _classCallCheck$1T(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1T(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1T(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1T(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1T(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$R() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$R = Reflect.get.bind();
  } else {
    _get$R = function _get2(target, property, receiver) {
      var base = _superPropBase$R(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$R.apply(this, arguments);
}
function _superPropBase$R(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$12(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$12(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$12(subClass, superClass);
}
function _setPrototypeOf$12(o, p2) {
  _setPrototypeOf$12 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$12(o, p2);
}
function _createSuper$12(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$12();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$12(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$12(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$12(this, result);
  };
}
function _possibleConstructorReturn$12(self2, call2) {
  if (call2 && (_typeof$19(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$12(self2);
}
function _assertThisInitialized$12(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$12() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$12(o) {
  _getPrototypeOf$12 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$12(o);
}
var IndexesSequence = /* @__PURE__ */ function(_IndexMap) {
  _inherits$12(IndexesSequence2, _IndexMap);
  var _super = _createSuper$12(IndexesSequence2);
  function IndexesSequence2() {
    _classCallCheck$1T(this, IndexesSequence2);
    return _super.call(this, function(index2) {
      return index2;
    });
  }
  _createClass$1T(IndexesSequence2, [{
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      var listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);
      this.indexedValues = getListWithInsertedItems$2(listAfterUpdate, insertionIndex, insertedIndexes);
      _get$R(_getPrototypeOf$12(IndexesSequence2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
    /**
     * Remove values from the list and reorganize.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      var listAfterUpdate = getListWithRemovedItems$2(this.indexedValues, removedIndexes);
      this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);
      _get$R(_getPrototypeOf$12(IndexesSequence2.prototype), "remove", this).call(this, removedIndexes);
    }
  }]);
  return IndexesSequence2;
}(IndexMap);
var availableIndexMapTypes = /* @__PURE__ */ new Map([["hiding", HidingMap], ["index", IndexMap], ["linkedPhysicalIndexToValue", LinkedPhysicalIndexToValueMap], ["physicalIndexToValue", PhysicalIndexToValueMap], ["trimming", TrimmingMap]]);
function createIndexMap(mapType) {
  var initValueOrFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!availableIndexMapTypes.has(mapType)) {
    throw new Error('The provided map type ("'.concat(mapType, '") does not exist.'));
  }
  return new (availableIndexMapTypes.get(mapType))(initValueOrFn);
}
function _classCallCheck$1S(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1S(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1S(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1S(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1S(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var MapCollection = /* @__PURE__ */ function() {
  function MapCollection2() {
    _classCallCheck$1S(this, MapCollection2);
    this.collection = /* @__PURE__ */ new Map();
  }
  _createClass$1S(MapCollection2, [{
    key: "register",
    value: function register2(uniqueName, indexMap) {
      var _this = this;
      if (this.collection.has(uniqueName) === false) {
        this.collection.set(uniqueName, indexMap);
        indexMap.addLocalHook("change", function() {
          return _this.runLocalHooks("change", indexMap);
        });
      }
    }
    /**
     * Unregister custom index map.
     *
     * @param {string} name Name of the index map.
     */
  }, {
    key: "unregister",
    value: function unregister(name) {
      var indexMap = this.collection.get(name);
      if (isDefined(indexMap)) {
        indexMap.destroy();
        this.collection.delete(name);
        this.runLocalHooks("change", indexMap);
      }
    }
    /**
     * Unregisters and destroys all collected index map instances.
     */
  }, {
    key: "unregisterAll",
    value: function unregisterAll() {
      var _this2 = this;
      this.collection.forEach(function(indexMap, name) {
        return _this2.unregister(name);
      });
      this.collection.clear();
    }
    /**
     * Get index map for the provided name.
     *
     * @param {string} [name] Name of the index map.
     * @returns {Array|IndexMap}
     */
  }, {
    key: "get",
    value: function get2(name) {
      if (isUndefined(name)) {
        return Array.from(this.collection.values());
      }
      return this.collection.get(name);
    }
    /**
     * Get collection size.
     *
     * @returns {number}
     */
  }, {
    key: "getLength",
    value: function getLength() {
      return this.collection.size;
    }
    /**
     * Remove some indexes and corresponding mappings and update values of the others within all collection's index maps.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */
  }, {
    key: "removeFromEvery",
    value: function removeFromEvery(removedIndexes) {
      this.collection.forEach(function(indexMap) {
        indexMap.remove(removedIndexes);
      });
    }
    /**
     * Insert new indexes and corresponding mapping and update values of the others all collection's index maps.
     *
     * @private
     * @param {number} insertionIndex Position inside the actual list.
     * @param {Array} insertedIndexes List of inserted indexes.
     */
  }, {
    key: "insertToEvery",
    value: function insertToEvery(insertionIndex, insertedIndexes) {
      this.collection.forEach(function(indexMap) {
        indexMap.insert(insertionIndex, insertedIndexes);
      });
    }
    /**
     * Set default values to index maps within collection.
     *
     * @param {number} length Destination length for all stored maps.
     */
  }, {
    key: "initEvery",
    value: function initEvery(length) {
      this.collection.forEach(function(indexMap) {
        indexMap.init(length);
      });
    }
  }]);
  return MapCollection2;
}();
mixin(MapCollection, localHooks$1);
function _typeof$18(obj) {
  "@babel/helpers - typeof";
  return _typeof$18 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$18(obj);
}
function _classCallCheck$1R(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1R(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1R(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1R(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1R(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$11(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$11(subClass, superClass);
}
function _setPrototypeOf$11(o, p2) {
  _setPrototypeOf$11 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$11(o, p2);
}
function _createSuper$11(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$11();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$11(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$11(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$11(this, result);
  };
}
function _possibleConstructorReturn$11(self2, call2) {
  if (call2 && (_typeof$18(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$11(self2);
}
function _assertThisInitialized$11(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$11() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$11(o) {
  _getPrototypeOf$11 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$11(o);
}
var AggregatedCollection = /* @__PURE__ */ function(_MapCollection) {
  _inherits$11(AggregatedCollection2, _MapCollection);
  var _super = _createSuper$11(AggregatedCollection2);
  function AggregatedCollection2(aggregationFunction, fallbackValue) {
    var _this;
    _classCallCheck$1R(this, AggregatedCollection2);
    _this = _super.call(this);
    _this.mergedValuesCache = [];
    _this.aggregationFunction = aggregationFunction;
    _this.fallbackValue = fallbackValue;
    return _this;
  }
  _createClass$1R(AggregatedCollection2, [{
    key: "getMergedValues",
    value: function getMergedValues() {
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.mergedValuesCache;
      }
      if (this.getLength() === 0) {
        return [];
      }
      var mapsValuesMatrix = arrayMap(this.get(), function(map2) {
        return map2.getValues();
      });
      var indexesValuesMatrix = [];
      var mapsLength = isDefined(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;
      for (var index2 = 0; index2 < mapsLength; index2 += 1) {
        var valuesForIndex = [];
        for (var mapIndex = 0; mapIndex < this.getLength(); mapIndex += 1) {
          valuesForIndex.push(mapsValuesMatrix[mapIndex][index2]);
        }
        indexesValuesMatrix.push(valuesForIndex);
      }
      return arrayMap(indexesValuesMatrix, this.aggregationFunction);
    }
    /**
     * Get merged value for particular index.
     *
     * @param {number} index Index for which we calculate single result.
     * @param {boolean} [readFromCache=true] Determine if read results from the cache.
     * @returns {*}
     */
  }, {
    key: "getMergedValueAtIndex",
    value: function getMergedValueAtIndex(index2, readFromCache) {
      var valueAtIndex = this.getMergedValues(readFromCache)[index2];
      return isDefined(valueAtIndex) ? valueAtIndex : this.fallbackValue;
    }
    /**
     * Rebuild cache for the collection.
     */
  }, {
    key: "updateCache",
    value: function updateCache() {
      this.mergedValuesCache = this.getMergedValues(false);
    }
  }]);
  return AggregatedCollection2;
}(MapCollection);
function _classCallCheck$1Q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1Q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1Q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1Q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1Q(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateFieldInitSpec$9(obj, privateMap, value) {
  _checkPrivateRedeclaration$a(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$a(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet$9(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$9(receiver, privateMap, "set");
  _classApplyDescriptorSet$9(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet$9(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet$9(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$9(receiver, privateMap, "get");
  return _classApplyDescriptorGet$9(receiver, descriptor);
}
function _classExtractFieldDescriptor$9(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet$9(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _currentInitialChanges = /* @__PURE__ */ new WeakMap();
var ChangesObserver = /* @__PURE__ */ function() {
  function ChangesObserver2() {
    _classCallCheck$1Q(this, ChangesObserver2);
    _classPrivateFieldInitSpec$9(this, _currentInitialChanges, {
      writable: true,
      value: []
    });
  }
  _createClass$1Q(ChangesObserver2, [{
    key: "subscribe",
    value: (
      /**
       * Subscribes to the observer.
       *
       * @param {Function} callback A function that will be called when the new changes will appear.
       * @returns {ChangesObserver}
       */
      function subscribe(callback) {
        this.addLocalHook("change", callback);
        this._write(_classPrivateFieldGet$9(this, _currentInitialChanges));
        return this;
      }
    )
    /**
     * Unsubscribes all subscriptions. After the method call, the observer would not produce
     * any new events.
     *
     * @returns {ChangesObserver}
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.runLocalHooks("unsubscribe");
      this.clearLocalHooks();
      return this;
    }
    /**
     * The write method is executed by the ChangesObservable module. The module produces all
     * changes events that are distributed further by the observer.
     *
     * @private
     * @param {object} changes The chunk of changes produced by the ChangesObservable module.
     * @returns {ChangesObserver}
     */
  }, {
    key: "_write",
    value: function _write(changes) {
      if (changes.length > 0) {
        this.runLocalHooks("change", changes);
      }
      return this;
    }
    /**
     * The write method is executed by the ChangesObservable module. The module produces initial
     * changes that will be used to notify new subscribers.
     *
     * @private
     * @param {object} initialChanges The chunk of changes produced by the ChangesObservable module.
     */
  }, {
    key: "_writeInitialChanges",
    value: function _writeInitialChanges(initialChanges) {
      _classPrivateFieldSet$9(this, _currentInitialChanges, initialChanges);
    }
  }]);
  return ChangesObserver2;
}();
mixin(ChangesObserver, localHooks$1);
function arrayDiff(baseArray, newArray) {
  var changes = [];
  var i = 0;
  var j = 0;
  for (; i < baseArray.length && j < newArray.length; i++, j++) {
    if (baseArray[i] !== newArray[j]) {
      changes.push({
        op: "replace",
        index: j,
        oldValue: baseArray[i],
        newValue: newArray[j]
      });
    }
  }
  for (; i < newArray.length; i++) {
    changes.push({
      op: "insert",
      index: i,
      oldValue: void 0,
      newValue: newArray[i]
    });
  }
  for (; j < baseArray.length; j++) {
    changes.push({
      op: "remove",
      index: j,
      oldValue: baseArray[j],
      newValue: void 0
    });
  }
  return changes;
}
function _classCallCheck$1P(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1P(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1P(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1P(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1P(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateFieldInitSpec$8(obj, privateMap, value) {
  _checkPrivateRedeclaration$9(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$9(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet$8(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$8(receiver, privateMap, "get");
  return _classApplyDescriptorGet$8(receiver, descriptor);
}
function _classApplyDescriptorGet$8(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$8(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$8(receiver, privateMap, "set");
  _classApplyDescriptorSet$8(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$8(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$8(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _observers = /* @__PURE__ */ new WeakMap();
var _indexMatrix = /* @__PURE__ */ new WeakMap();
var _currentIndexState = /* @__PURE__ */ new WeakMap();
var _isMatrixIndexesInitialized = /* @__PURE__ */ new WeakMap();
var _initialIndexValue = /* @__PURE__ */ new WeakMap();
var ChangesObservable = /* @__PURE__ */ function() {
  function ChangesObservable2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, initialIndexValue = _ref2.initialIndexValue;
    _classCallCheck$1P(this, ChangesObservable2);
    _classPrivateFieldInitSpec$8(this, _observers, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    _classPrivateFieldInitSpec$8(this, _indexMatrix, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec$8(this, _currentIndexState, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec$8(this, _isMatrixIndexesInitialized, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$8(this, _initialIndexValue, {
      writable: true,
      value: false
    });
    _classPrivateFieldSet$8(this, _initialIndexValue, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);
  }
  _createClass$1P(ChangesObservable2, [{
    key: "createObserver",
    value: function createObserver() {
      var _this = this;
      var observer = new ChangesObserver();
      _classPrivateFieldGet$8(this, _observers).add(observer);
      observer.addLocalHook("unsubscribe", function() {
        _classPrivateFieldGet$8(_this, _observers).delete(observer);
      });
      observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet$8(this, _indexMatrix), _classPrivateFieldGet$8(this, _currentIndexState)));
      return observer;
    }
    /**
     * The method is an entry point for triggering new index map changes. Emitting the
     * changes triggers comparing algorithm which compares last saved state with a new
     * state. When there are some differences, the changes are sent to all subscribers.
     *
     * @param {Array} indexesState An array with index map state.
     */
  }, {
    key: "emit",
    value: function emit(indexesState) {
      var currentIndexState = _classPrivateFieldGet$8(this, _currentIndexState);
      if (!_classPrivateFieldGet$8(this, _isMatrixIndexesInitialized) || _classPrivateFieldGet$8(this, _indexMatrix).length !== indexesState.length) {
        if (indexesState.length === 0) {
          indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet$8(this, _initialIndexValue));
        } else {
          _classPrivateFieldSet$8(this, _indexMatrix, new Array(indexesState.length).fill(_classPrivateFieldGet$8(this, _initialIndexValue)));
        }
        if (!_classPrivateFieldGet$8(this, _isMatrixIndexesInitialized)) {
          _classPrivateFieldSet$8(this, _isMatrixIndexesInitialized, true);
          currentIndexState = _classPrivateFieldGet$8(this, _indexMatrix);
        }
      }
      var changes = arrayDiff(currentIndexState, indexesState);
      _classPrivateFieldGet$8(this, _observers).forEach(function(observer) {
        return observer._write(changes);
      });
      _classPrivateFieldSet$8(this, _currentIndexState, indexesState);
    }
  }]);
  return ChangesObservable2;
}();
var _templateObject$e;
function _toConsumableArray$o(arr) {
  return _arrayWithoutHoles$o(arr) || _iterableToArray$q(arr) || _unsupportedIterableToArray$Z(arr) || _nonIterableSpread$o();
}
function _nonIterableSpread$o() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$Z(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$Z(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$Z(o, minLen);
}
function _iterableToArray$q(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$o(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$Z(arr);
}
function _arrayLikeToArray$Z(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _taggedTemplateLiteral$e(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$1O(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1O(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1O(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1O(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1O(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var deprecationWarns = /* @__PURE__ */ new Set(["getFirstNotHiddenIndex"]);
var IndexMapper = /* @__PURE__ */ function() {
  function IndexMapper2() {
    var _this = this;
    _classCallCheck$1O(this, IndexMapper2);
    this.indexesSequence = new IndexesSequence();
    this.trimmingMapsCollection = new AggregatedCollection(function(valuesForIndex) {
      return valuesForIndex.some(function(value) {
        return value === true;
      });
    }, false);
    this.hidingMapsCollection = new AggregatedCollection(function(valuesForIndex) {
      return valuesForIndex.some(function(value) {
        return value === true;
      });
    }, false);
    this.variousMapsCollection = new MapCollection();
    this.hidingChangesObservable = new ChangesObservable({
      initialIndexValue: false
    });
    this.notTrimmedIndexesCache = [];
    this.notHiddenIndexesCache = [];
    this.isBatched = false;
    this.indexesSequenceChanged = false;
    this.trimmedIndexesChanged = false;
    this.hiddenIndexesChanged = false;
    this.renderablePhysicalIndexesCache = [];
    this.fromPhysicalToVisualIndexesCache = /* @__PURE__ */ new Map();
    this.fromVisualToRenderableIndexesCache = /* @__PURE__ */ new Map();
    this.indexesSequence.addLocalHook("change", function() {
      _this.indexesSequenceChanged = true;
      _this.updateCache();
      _this.runLocalHooks("change", _this.indexesSequence, null);
    });
    this.trimmingMapsCollection.addLocalHook("change", function(changedMap) {
      _this.trimmedIndexesChanged = true;
      _this.updateCache();
      _this.runLocalHooks("change", changedMap, _this.trimmingMapsCollection);
    });
    this.hidingMapsCollection.addLocalHook("change", function(changedMap) {
      _this.hiddenIndexesChanged = true;
      _this.updateCache();
      _this.runLocalHooks("change", changedMap, _this.hidingMapsCollection);
    });
    this.variousMapsCollection.addLocalHook("change", function(changedMap) {
      _this.runLocalHooks("change", changedMap, _this.variousMapsCollection);
    });
  }
  _createClass$1O(IndexMapper2, [{
    key: "suspendOperations",
    value: function suspendOperations() {
      this.isBatched = true;
    }
    /**
     * Resumes the cache update for this map. It recalculates the cache and restores the
     * default behavior where each map modification updates the cache.
     */
  }, {
    key: "resumeOperations",
    value: function resumeOperations() {
      this.isBatched = false;
      this.updateCache();
    }
    /**
     * It creates and returns the new instance of the ChangesObserver object. The object
     * allows listening to the index changes that happen while the Handsontable is running.
     *
     * @param {string} indexMapType The index map type which we want to observe.
     *                              Currently, only the 'hiding' index map types are observable.
     * @returns {ChangesObserver}
     */
  }, {
    key: "createChangesObserver",
    value: function createChangesObserver(indexMapType) {
      if (indexMapType !== "hiding") {
        throw new Error('Unsupported index map type "'.concat(indexMapType, '".'));
      }
      return this.hidingChangesObservable.createObserver();
    }
    /**
     * Creates and register the new IndexMap for specified IndexMapper instance.
     *
     * @param {string} indexName The uniq index name.
     * @param {string} mapType The index map type (e.q. "hiding, "trimming", "physicalIndexToValue").
     * @param {*} [initValueOrFn] The initial value for the index map.
     * @returns {IndexMap}
     */
  }, {
    key: "createAndRegisterIndexMap",
    value: function createAndRegisterIndexMap(indexName, mapType, initValueOrFn) {
      return this.registerMap(indexName, createIndexMap(mapType, initValueOrFn));
    }
    /**
     * Register map which provide some index mappings. Type of map determining to which collection it will be added.
     *
     * @param {string} uniqueName Name of the index map. It should be unique.
     * @param {IndexMap} indexMap Registered index map updated on items removal and insertion.
     * @returns {IndexMap}
     */
  }, {
    key: "registerMap",
    value: function registerMap(uniqueName, indexMap) {
      if (this.trimmingMapsCollection.get(uniqueName) || this.hidingMapsCollection.get(uniqueName) || this.variousMapsCollection.get(uniqueName)) {
        throw Error('Map with name "'.concat(uniqueName, '" has been already registered.'));
      }
      if (indexMap instanceof TrimmingMap) {
        this.trimmingMapsCollection.register(uniqueName, indexMap);
      } else if (indexMap instanceof HidingMap) {
        this.hidingMapsCollection.register(uniqueName, indexMap);
      } else {
        this.variousMapsCollection.register(uniqueName, indexMap);
      }
      var numberOfIndexes = this.getNumberOfIndexes();
      if (numberOfIndexes > 0) {
        indexMap.init(numberOfIndexes);
      }
      return indexMap;
    }
    /**
     * Unregister a map with given name.
     *
     * @param {string} name Name of the index map.
     */
  }, {
    key: "unregisterMap",
    value: function unregisterMap(name) {
      this.trimmingMapsCollection.unregister(name);
      this.hidingMapsCollection.unregister(name);
      this.variousMapsCollection.unregister(name);
    }
    /**
     * Unregisters all collected index map instances from all map collection types.
     */
  }, {
    key: "unregisterAll",
    value: function unregisterAll() {
      this.trimmingMapsCollection.unregisterAll();
      this.hidingMapsCollection.unregisterAll();
      this.variousMapsCollection.unregisterAll();
    }
    /**
     * Get a physical index corresponding to the given visual index.
     *
     * @param {number} visualIndex Visual index.
     * @returns {number|null} Returns translated index mapped by passed visual index.
     */
  }, {
    key: "getPhysicalFromVisualIndex",
    value: function getPhysicalFromVisualIndex(visualIndex) {
      var physicalIndex = this.notTrimmedIndexesCache[visualIndex];
      if (isDefined(physicalIndex)) {
        return physicalIndex;
      }
      return null;
    }
    /**
     * Get a physical index corresponding to the given renderable index.
     *
     * @param {number} renderableIndex Renderable index.
     * @returns {null|number}
     */
  }, {
    key: "getPhysicalFromRenderableIndex",
    value: function getPhysicalFromRenderableIndex(renderableIndex) {
      var physicalIndex = this.renderablePhysicalIndexesCache[renderableIndex];
      if (isDefined(physicalIndex)) {
        return physicalIndex;
      }
      return null;
    }
    /**
     * Get a visual index corresponding to the given physical index.
     *
     * @param {number} physicalIndex Physical index to search.
     * @returns {number|null} Returns a visual index of the index mapper.
     */
  }, {
    key: "getVisualFromPhysicalIndex",
    value: function getVisualFromPhysicalIndex(physicalIndex) {
      var visualIndex = this.fromPhysicalToVisualIndexesCache.get(physicalIndex);
      if (isDefined(visualIndex)) {
        return visualIndex;
      }
      return null;
    }
    /**
     * Get a visual index corresponding to the given renderable index.
     *
     * @param {number} renderableIndex Renderable index.
     * @returns {null|number}
     */
  }, {
    key: "getVisualFromRenderableIndex",
    value: function getVisualFromRenderableIndex(renderableIndex) {
      return this.getVisualFromPhysicalIndex(this.getPhysicalFromRenderableIndex(renderableIndex));
    }
    /**
     * Get a renderable index corresponding to the given visual index.
     *
     * @param {number} visualIndex Visual index.
     * @returns {null|number}
     */
  }, {
    key: "getRenderableFromVisualIndex",
    value: function getRenderableFromVisualIndex(visualIndex) {
      var renderableIndex = this.fromVisualToRenderableIndexesCache.get(visualIndex);
      if (isDefined(renderableIndex)) {
        return renderableIndex;
      }
      return null;
    }
    /**
     * Search for the first visible, not hidden index (represented by a visual index).
     *
     * This method is deprecated and will be removed in a next major version of Handsontable.
     * Use the {@link IndexMapper#getNearestNotHiddenIndex} method instead.
     *
     * @deprecated
     * @param {number} fromVisualIndex Visual start index. Starting point for finding destination index. Start point may be destination
     * point when handled index is NOT hidden.
     * @param {number} incrementBy We are searching for a next visible indexes by increasing (to be precise, or decreasing) indexes.
     * This variable represent indexes shift. We are looking for an index:
     * - for rows: from the top to the bottom (increasing indexes, then variable should have value 1) or
     * other way around (decreasing indexes, then variable should have the value -1)
     * - for columns: from the left to the right (increasing indexes, then variable should have value 1)
     * or other way around (decreasing indexes, then variable should have the value -1).
     * @param {boolean} searchAlsoOtherWayAround The argument determine if an additional other way around search should be
     * performed, when the search in the first direction had no effect in finding visual index.
     * @param {number} indexForNextSearch Visual index for next search, when the flag is truthy.
     *
     * @returns {number|null} Visual column index or `null`.
     */
  }, {
    key: "getFirstNotHiddenIndex",
    value: function getFirstNotHiddenIndex(fromVisualIndex, incrementBy) {
      var searchAlsoOtherWayAround = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var indexForNextSearch = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fromVisualIndex - incrementBy;
      if (deprecationWarns.has("getFirstNotHiddenIndex")) {
        deprecationWarns.delete("getFirstNotHiddenIndex");
        warn$1(toSingleLine(_templateObject$e || (_templateObject$e = _taggedTemplateLiteral$e(['The method "getFirstNotHiddenIndex" is deprecated and will be removed in the next \n                        major release. Please use "getNearestNotHiddenIndex" instead.'], ['The method "getFirstNotHiddenIndex" is deprecated and will be removed in the next\\x20\n                        major release. Please use "getNearestNotHiddenIndex" instead.']))));
      }
      var physicalIndex = this.getPhysicalFromVisualIndex(fromVisualIndex);
      if (physicalIndex === null) {
        if (searchAlsoOtherWayAround === true && indexForNextSearch !== fromVisualIndex - incrementBy) {
          return this.getFirstNotHiddenIndex(indexForNextSearch, -incrementBy, false, indexForNextSearch);
        }
        return null;
      }
      if (this.isHidden(physicalIndex) === false) {
        return fromVisualIndex;
      }
      return this.getFirstNotHiddenIndex(fromVisualIndex + incrementBy, incrementBy, searchAlsoOtherWayAround, indexForNextSearch);
    }
    /**
     * Search for the nearest not-hidden row or column.
     *
     * @param {number} fromVisualIndex The visual index of the row or column from which the search starts.<br><br>
     * If the row or column from which the search starts is not hidden, the method simply returns the `fromVisualIndex` number.
     * @param {number} searchDirection The search direction.<br><br>`1`: search from `fromVisualIndex` to the end of the dataset.<br><br>
     * `-1`: search from `fromVisualIndex` to the beginning of the dataset (i.e., to the row or column at visual index `0`).
     * @param {boolean} searchAlsoOtherWayAround `true`: if a search in a first direction failed, try the opposite direction.<br><br>
     * `false`: search in one direction only.
     *
     * @returns {number|null} A visual index of a row or column, or `null`.
     */
  }, {
    key: "getNearestNotHiddenIndex",
    value: function getNearestNotHiddenIndex(fromVisualIndex, searchDirection) {
      var searchAlsoOtherWayAround = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var physicalIndex = this.getPhysicalFromVisualIndex(fromVisualIndex);
      if (physicalIndex === null) {
        return null;
      }
      if (this.fromVisualToRenderableIndexesCache.has(fromVisualIndex)) {
        return fromVisualIndex;
      }
      var visibleIndexes = Array.from(this.fromVisualToRenderableIndexesCache.keys());
      var index2 = -1;
      if (searchDirection > 0) {
        index2 = visibleIndexes.findIndex(function(visualIndex) {
          return visualIndex > fromVisualIndex;
        });
      } else {
        index2 = visibleIndexes.reverse().findIndex(function(visualIndex) {
          return visualIndex < fromVisualIndex;
        });
      }
      if (index2 === -1) {
        if (searchAlsoOtherWayAround) {
          return this.getNearestNotHiddenIndex(fromVisualIndex, -searchDirection, false);
        }
        return null;
      }
      return visibleIndexes[index2];
    }
    /**
     * Set default values for all indexes in registered index maps.
     *
     * @param {number} [length] Destination length for all stored index maps.
     */
  }, {
    key: "initToLength",
    value: function initToLength() {
      var length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getNumberOfIndexes();
      this.notTrimmedIndexesCache = _toConsumableArray$o(new Array(length).keys());
      this.notHiddenIndexesCache = _toConsumableArray$o(new Array(length).keys());
      this.suspendOperations();
      this.indexesSequence.init(length);
      this.trimmingMapsCollection.initEvery(length);
      this.resumeOperations();
      this.suspendOperations();
      this.hidingMapsCollection.initEvery(length);
      this.variousMapsCollection.initEvery(length);
      this.resumeOperations();
      this.runLocalHooks("init");
    }
    /**
     * Trim/extend the mappers to fit the desired length.
     *
     * @param {number} length New mapper length.
     */
  }, {
    key: "fitToLength",
    value: function fitToLength(length) {
      var currentIndexCount = this.getNumberOfIndexes();
      if (length < currentIndexCount) {
        var indexesToBeRemoved = _toConsumableArray$o(Array(this.getNumberOfIndexes() - length).keys()).map(function(i) {
          return i + length;
        });
        this.removeIndexes(indexesToBeRemoved);
      } else {
        this.insertIndexes(currentIndexCount, length - currentIndexCount);
      }
    }
    /**
     * Get sequence of indexes.
     *
     * @returns {Array} Physical indexes.
     */
  }, {
    key: "getIndexesSequence",
    value: function getIndexesSequence() {
      return this.indexesSequence.getValues();
    }
    /**
     * Set completely new indexes sequence.
     *
     * @param {Array} indexes Physical indexes.
     */
  }, {
    key: "setIndexesSequence",
    value: function setIndexesSequence(indexes) {
      this.indexesSequence.setValues(indexes);
    }
    /**
     * Get all NOT trimmed indexes.
     *
     * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
     *
     * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
     * @returns {Array} List of physical indexes. Index of this native array is a "visual index",
     * value of this native array is a "physical index".
     */
  }, {
    key: "getNotTrimmedIndexes",
    value: function getNotTrimmedIndexes() {
      var _this2 = this;
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.notTrimmedIndexesCache;
      }
      var indexesSequence = this.getIndexesSequence();
      return indexesSequence.filter(function(physicalIndex) {
        return _this2.isTrimmed(physicalIndex) === false;
      });
    }
    /**
     * Get length of all NOT trimmed indexes.
     *
     * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
     *
     * @returns {number}
     */
  }, {
    key: "getNotTrimmedIndexesLength",
    value: function getNotTrimmedIndexesLength() {
      return this.getNotTrimmedIndexes().length;
    }
    /**
     * Get all NOT hidden indexes.
     *
     * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
     *
     * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
     * @returns {Array} List of physical indexes. Please keep in mind that index of this native array IS NOT a "visual index".
     */
  }, {
    key: "getNotHiddenIndexes",
    value: function getNotHiddenIndexes() {
      var _this3 = this;
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.notHiddenIndexesCache;
      }
      var indexesSequence = this.getIndexesSequence();
      return indexesSequence.filter(function(physicalIndex) {
        return _this3.isHidden(physicalIndex) === false;
      });
    }
    /**
     * Get length of all NOT hidden indexes.
     *
     * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
     *
     * @returns {number}
     */
  }, {
    key: "getNotHiddenIndexesLength",
    value: function getNotHiddenIndexesLength() {
      return this.getNotHiddenIndexes().length;
    }
    /**
     * Get list of physical indexes (respecting the sequence of indexes) which may be rendered (when they are in a viewport).
     *
     * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
     * @returns {Array} List of physical indexes. Index of this native array is a "renderable index",
     * value of this native array is a "physical index".
     */
  }, {
    key: "getRenderableIndexes",
    value: function getRenderableIndexes() {
      var _this4 = this;
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.renderablePhysicalIndexesCache;
      }
      var notTrimmedIndexes = this.getNotTrimmedIndexes();
      return notTrimmedIndexes.filter(function(physicalIndex) {
        return _this4.isHidden(physicalIndex) === false;
      });
    }
    /**
     * Get length of all NOT trimmed and NOT hidden indexes.
     *
     * @returns {number}
     */
  }, {
    key: "getRenderableIndexesLength",
    value: function getRenderableIndexesLength() {
      return this.getRenderableIndexes().length;
    }
    /**
     * Get number of all indexes.
     *
     * @returns {number}
     */
  }, {
    key: "getNumberOfIndexes",
    value: function getNumberOfIndexes() {
      return this.getIndexesSequence().length;
    }
    /**
     * Move indexes in the index mapper.
     *
     * @param {number|Array} movedIndexes Visual index(es) to move.
     * @param {number} finalIndex Visual index being a start index for the moved elements.
     */
  }, {
    key: "moveIndexes",
    value: function moveIndexes(movedIndexes, finalIndex) {
      var _this5 = this;
      if (typeof movedIndexes === "number") {
        movedIndexes = [movedIndexes];
      }
      var physicalMovedIndexes = arrayMap(movedIndexes, function(visualIndex) {
        return _this5.getPhysicalFromVisualIndex(visualIndex);
      });
      var notTrimmedIndexesLength = this.getNotTrimmedIndexesLength();
      var movedIndexesLength = movedIndexes.length;
      var listWithRemovedItems = getListWithRemovedItems$2(this.getIndexesSequence(), physicalMovedIndexes);
      var destinationPosition = notTrimmedIndexesLength - movedIndexesLength;
      if (finalIndex + movedIndexesLength < notTrimmedIndexesLength) {
        var physicalIndex = listWithRemovedItems.filter(function(index2) {
          return _this5.isTrimmed(index2) === false;
        })[finalIndex];
        destinationPosition = listWithRemovedItems.indexOf(physicalIndex);
      }
      this.setIndexesSequence(getListWithInsertedItems$2(listWithRemovedItems, destinationPosition, physicalMovedIndexes));
    }
    /**
     * Get whether index is trimmed. Index marked as trimmed isn't included in a {@link DataMap} and isn't rendered.
     *
     * @param {number} physicalIndex Physical index.
     * @returns {boolean}
     */
  }, {
    key: "isTrimmed",
    value: function isTrimmed(physicalIndex) {
      return this.trimmingMapsCollection.getMergedValueAtIndex(physicalIndex);
    }
    /**
     * Get whether index is hidden. Index marked as hidden is included in a {@link DataMap}, but isn't rendered.
     *
     * @param {number} physicalIndex Physical index.
     * @returns {boolean}
     */
  }, {
    key: "isHidden",
    value: function isHidden(physicalIndex) {
      return this.hidingMapsCollection.getMergedValueAtIndex(physicalIndex);
    }
    /**
     * Insert new indexes and corresponding mapping and update values of the others, for all stored index maps.
     *
     * @private
     * @param {number} firstInsertedVisualIndex First inserted visual index.
     * @param {number} amountOfIndexes Amount of inserted indexes.
     */
  }, {
    key: "insertIndexes",
    value: function insertIndexes(firstInsertedVisualIndex, amountOfIndexes) {
      var nthVisibleIndex = this.getNotTrimmedIndexes()[firstInsertedVisualIndex];
      var firstInsertedPhysicalIndex = isDefined(nthVisibleIndex) ? nthVisibleIndex : this.getNumberOfIndexes();
      var insertionIndex = this.getIndexesSequence().includes(nthVisibleIndex) ? this.getIndexesSequence().indexOf(nthVisibleIndex) : this.getNumberOfIndexes();
      var insertedIndexes = arrayMap(new Array(amountOfIndexes).fill(firstInsertedPhysicalIndex), function(nextIndex, stepsFromStart) {
        return nextIndex + stepsFromStart;
      });
      this.suspendOperations();
      this.indexesSequence.insert(insertionIndex, insertedIndexes);
      this.trimmingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
      this.hidingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
      this.variousMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
      this.resumeOperations();
    }
    /**
     * Remove some indexes and corresponding mappings and update values of the others, for all stored index maps.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */
  }, {
    key: "removeIndexes",
    value: function removeIndexes(removedIndexes) {
      this.suspendOperations();
      this.indexesSequence.remove(removedIndexes);
      this.trimmingMapsCollection.removeFromEvery(removedIndexes);
      this.hidingMapsCollection.removeFromEvery(removedIndexes);
      this.variousMapsCollection.removeFromEvery(removedIndexes);
      this.resumeOperations();
    }
    /**
     * Rebuild cache for some indexes. Every action on indexes sequence or indexes skipped in the process of rendering
     * by default reset cache, thus batching some index maps actions is recommended.
     *
     * @private
     * @param {boolean} [force=false] Determine if force cache update.
     */
  }, {
    key: "updateCache",
    value: function updateCache() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var anyCachedIndexChanged = this.indexesSequenceChanged || this.trimmedIndexesChanged || this.hiddenIndexesChanged;
      if (force === true || this.isBatched === false && anyCachedIndexChanged === true) {
        this.trimmingMapsCollection.updateCache();
        this.hidingMapsCollection.updateCache();
        this.notTrimmedIndexesCache = this.getNotTrimmedIndexes(false);
        this.notHiddenIndexesCache = this.getNotHiddenIndexes(false);
        this.renderablePhysicalIndexesCache = this.getRenderableIndexes(false);
        this.cacheFromPhysicalToVisualIndexes();
        this.cacheFromVisualToRenderableIndexes();
        if (this.hiddenIndexesChanged) {
          this.hidingChangesObservable.emit(this.hidingMapsCollection.getMergedValues());
        }
        this.runLocalHooks("cacheUpdated", {
          indexesSequenceChanged: this.indexesSequenceChanged,
          trimmedIndexesChanged: this.trimmedIndexesChanged,
          hiddenIndexesChanged: this.hiddenIndexesChanged
        });
        this.indexesSequenceChanged = false;
        this.trimmedIndexesChanged = false;
        this.hiddenIndexesChanged = false;
      }
    }
    /**
     * Update cache for translations from physical to visual indexes.
     *
     * @private
     */
  }, {
    key: "cacheFromPhysicalToVisualIndexes",
    value: function cacheFromPhysicalToVisualIndexes() {
      var nrOfNotTrimmedIndexes = this.getNotTrimmedIndexesLength();
      this.fromPhysicalToVisualIndexesCache.clear();
      for (var visualIndex = 0; visualIndex < nrOfNotTrimmedIndexes; visualIndex += 1) {
        var physicalIndex = this.getPhysicalFromVisualIndex(visualIndex);
        this.fromPhysicalToVisualIndexesCache.set(physicalIndex, visualIndex);
      }
    }
    /**
     * Update cache for translations from visual to renderable indexes.
     *
     * @private
     */
  }, {
    key: "cacheFromVisualToRenderableIndexes",
    value: function cacheFromVisualToRenderableIndexes() {
      var nrOfRenderableIndexes = this.getRenderableIndexesLength();
      this.fromVisualToRenderableIndexesCache.clear();
      for (var renderableIndex = 0; renderableIndex < nrOfRenderableIndexes; renderableIndex += 1) {
        var physicalIndex = this.getPhysicalFromRenderableIndex(renderableIndex);
        var visualIndex = this.getVisualFromPhysicalIndex(physicalIndex);
        this.fromVisualToRenderableIndexesCache.set(visualIndex, renderableIndex);
      }
    }
  }]);
  return IndexMapper2;
}();
mixin(IndexMapper, localHooks$1);
var _templateObject$d;
function _taggedTemplateLiteral$d(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function extendNotExistingKeys(target, extension) {
  objectEach(extension, function(value, key) {
    if (isUndefined(target[key])) {
      target[key] = value;
    }
  });
  return target;
}
function normalizeLanguageCode(languageCode) {
  var languageCodePattern = /^([a-zA-Z]{2})-([a-zA-Z]{2})$/;
  var partsOfLanguageCode = languageCodePattern.exec(languageCode);
  if (partsOfLanguageCode) {
    return "".concat(partsOfLanguageCode[1].toLowerCase(), "-").concat(partsOfLanguageCode[2].toUpperCase());
  }
  return languageCode;
}
function warnUserAboutLanguageRegistration(languageCode) {
  if (isDefined(languageCode)) {
    error(toSingleLine(_templateObject$d || (_templateObject$d = _taggedTemplateLiteral$d(['Language with code "', '" was not found. You should register particular language \n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.'], ['Language with code "', '" was not found. You should register particular language\\x20\n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.'])), languageCode));
  }
}
function pluralize(phrasePropositions, pluralForm) {
  var isPluralizable = Array.isArray(phrasePropositions) && Number.isInteger(pluralForm);
  if (isPluralizable) {
    return phrasePropositions[pluralForm];
  }
  return phrasePropositions;
}
var _staticRegister$3 = staticRegister("phraseFormatters"), registerGloballyPhraseFormatter = _staticRegister$3.register, getGlobalPhraseFormatters = _staticRegister$3.getValues;
function register$1(name, formatterFn) {
  registerGloballyPhraseFormatter(name, formatterFn);
}
function getAll() {
  return getGlobalPhraseFormatters();
}
register$1("pluralize", pluralize);
var CONTEXT_MENU_ITEMS_NAMESPACE = "ContextMenu:items";
var CONTEXTMENU_ITEMS_NO_ITEMS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".noItems");
var CONTEXTMENU_ITEMS_ROW_ABOVE = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertRowAbove");
var CONTEXTMENU_ITEMS_ROW_BELOW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertRowBelow");
var CONTEXTMENU_ITEMS_INSERT_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertColumnOnTheLeft");
var CONTEXTMENU_ITEMS_INSERT_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertColumnOnTheRight");
var CONTEXTMENU_ITEMS_REMOVE_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeRow");
var CONTEXTMENU_ITEMS_REMOVE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeColumn");
var CONTEXTMENU_ITEMS_UNDO = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".undo");
var CONTEXTMENU_ITEMS_REDO = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".redo");
var CONTEXTMENU_ITEMS_READ_ONLY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".readOnly");
var CONTEXTMENU_ITEMS_CLEAR_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".clearColumn");
var CONTEXTMENU_ITEMS_COPY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".copy");
var CONTEXTMENU_ITEMS_CUT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".cut");
var CONTEXTMENU_ITEMS_FREEZE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".freezeColumn");
var CONTEXTMENU_ITEMS_UNFREEZE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".unfreezeColumn");
var CONTEXTMENU_ITEMS_MERGE_CELLS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".mergeCells");
var CONTEXTMENU_ITEMS_UNMERGE_CELLS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".unmergeCells");
var CONTEXTMENU_ITEMS_ADD_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".addComment");
var CONTEXTMENU_ITEMS_EDIT_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".editComment");
var CONTEXTMENU_ITEMS_REMOVE_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeComment");
var CONTEXTMENU_ITEMS_READ_ONLY_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".readOnlyComment");
var CONTEXTMENU_ITEMS_ALIGNMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align");
var CONTEXTMENU_ITEMS_ALIGNMENT_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.left");
var CONTEXTMENU_ITEMS_ALIGNMENT_CENTER = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.center");
var CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.right");
var CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.justify");
var CONTEXTMENU_ITEMS_ALIGNMENT_TOP = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.top");
var CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.middle");
var CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.bottom");
var CONTEXTMENU_ITEMS_BORDERS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders");
var CONTEXTMENU_ITEMS_BORDERS_TOP = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.top");
var CONTEXTMENU_ITEMS_BORDERS_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.right");
var CONTEXTMENU_ITEMS_BORDERS_BOTTOM = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.bottom");
var CONTEXTMENU_ITEMS_BORDERS_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.left");
var CONTEXTMENU_ITEMS_REMOVE_BORDERS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.remove");
var CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".nestedHeaders.insertChildRow");
var CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".nestedHeaders.detachFromParent");
var CONTEXTMENU_ITEMS_HIDE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".hideColumn");
var CONTEXTMENU_ITEMS_SHOW_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".showColumn");
var CONTEXTMENU_ITEMS_HIDE_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".hideRow");
var CONTEXTMENU_ITEMS_SHOW_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".showRow");
var FILTERS_NAMESPACE = "Filters:";
var FILTERS_CONDITIONS_NAMESPACE = "".concat(FILTERS_NAMESPACE, "conditions");
var FILTERS_CONDITIONS_NONE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".none");
var FILTERS_CONDITIONS_EMPTY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isEmpty");
var FILTERS_CONDITIONS_NOT_EMPTY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotEmpty");
var FILTERS_CONDITIONS_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isEqualTo");
var FILTERS_CONDITIONS_NOT_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotEqualTo");
var FILTERS_CONDITIONS_BEGINS_WITH = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".beginsWith");
var FILTERS_CONDITIONS_ENDS_WITH = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".endsWith");
var FILTERS_CONDITIONS_CONTAINS = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".contains");
var FILTERS_CONDITIONS_NOT_CONTAIN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".doesNotContain");
var FILTERS_CONDITIONS_BY_VALUE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".byValue");
var FILTERS_CONDITIONS_GREATER_THAN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".greaterThan");
var FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".greaterThanOrEqualTo");
var FILTERS_CONDITIONS_LESS_THAN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".lessThan");
var FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".lessThanOrEqualTo");
var FILTERS_CONDITIONS_BETWEEN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isBetween");
var FILTERS_CONDITIONS_NOT_BETWEEN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotBetween");
var FILTERS_CONDITIONS_AFTER = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".after");
var FILTERS_CONDITIONS_BEFORE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".before");
var FILTERS_CONDITIONS_TODAY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".today");
var FILTERS_CONDITIONS_TOMORROW = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".tomorrow");
var FILTERS_CONDITIONS_YESTERDAY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".yesterday");
var FILTERS_DIVS_FILTER_BY_CONDITION = "".concat(FILTERS_NAMESPACE, "labels.filterByCondition");
var FILTERS_DIVS_FILTER_BY_VALUE = "".concat(FILTERS_NAMESPACE, "labels.filterByValue");
var FILTERS_LABELS_CONJUNCTION = "".concat(FILTERS_NAMESPACE, "labels.conjunction");
var FILTERS_LABELS_DISJUNCTION = "".concat(FILTERS_NAMESPACE, "labels.disjunction");
var FILTERS_VALUES_BLANK_CELLS = "".concat(FILTERS_NAMESPACE, "values.blankCells");
var FILTERS_BUTTONS_SELECT_ALL = "".concat(FILTERS_NAMESPACE, "buttons.selectAll");
var FILTERS_BUTTONS_CLEAR = "".concat(FILTERS_NAMESPACE, "buttons.clear");
var FILTERS_BUTTONS_OK = "".concat(FILTERS_NAMESPACE, "buttons.ok");
var FILTERS_BUTTONS_CANCEL = "".concat(FILTERS_NAMESPACE, "buttons.cancel");
var FILTERS_BUTTONS_PLACEHOLDER_SEARCH = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.search");
var FILTERS_BUTTONS_PLACEHOLDER_VALUE = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.value");
var FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.secondValue");
const dictionaryKeys = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CONTEXTMENU_ITEMS_ADD_COMMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,
  CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,
  CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,
  CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,
  CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,
  CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,
  CONTEXTMENU_ITEMS_ALIGNMENT_TOP,
  CONTEXTMENU_ITEMS_BORDERS,
  CONTEXTMENU_ITEMS_BORDERS_BOTTOM,
  CONTEXTMENU_ITEMS_BORDERS_LEFT,
  CONTEXTMENU_ITEMS_BORDERS_RIGHT,
  CONTEXTMENU_ITEMS_BORDERS_TOP,
  CONTEXTMENU_ITEMS_CLEAR_COLUMN,
  CONTEXTMENU_ITEMS_COPY,
  CONTEXTMENU_ITEMS_CUT,
  CONTEXTMENU_ITEMS_EDIT_COMMENT,
  CONTEXTMENU_ITEMS_FREEZE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_ROW,
  CONTEXTMENU_ITEMS_INSERT_LEFT,
  CONTEXTMENU_ITEMS_INSERT_RIGHT,
  CONTEXTMENU_ITEMS_MERGE_CELLS,
  CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD,
  CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD,
  CONTEXTMENU_ITEMS_NO_ITEMS,
  CONTEXTMENU_ITEMS_READ_ONLY,
  CONTEXTMENU_ITEMS_READ_ONLY_COMMENT,
  CONTEXTMENU_ITEMS_REDO,
  CONTEXTMENU_ITEMS_REMOVE_BORDERS,
  CONTEXTMENU_ITEMS_REMOVE_COLUMN,
  CONTEXTMENU_ITEMS_REMOVE_COMMENT,
  CONTEXTMENU_ITEMS_REMOVE_ROW,
  CONTEXTMENU_ITEMS_ROW_ABOVE,
  CONTEXTMENU_ITEMS_ROW_BELOW,
  CONTEXTMENU_ITEMS_SHOW_COLUMN,
  CONTEXTMENU_ITEMS_SHOW_ROW,
  CONTEXTMENU_ITEMS_UNDO,
  CONTEXTMENU_ITEMS_UNFREEZE_COLUMN,
  CONTEXTMENU_ITEMS_UNMERGE_CELLS,
  CONTEXT_MENU_ITEMS_NAMESPACE,
  FILTERS_BUTTONS_CANCEL,
  FILTERS_BUTTONS_CLEAR,
  FILTERS_BUTTONS_OK,
  FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
  FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE,
  FILTERS_BUTTONS_PLACEHOLDER_VALUE,
  FILTERS_BUTTONS_SELECT_ALL,
  FILTERS_CONDITIONS_AFTER,
  FILTERS_CONDITIONS_BEFORE,
  FILTERS_CONDITIONS_BEGINS_WITH,
  FILTERS_CONDITIONS_BETWEEN,
  FILTERS_CONDITIONS_BY_VALUE,
  FILTERS_CONDITIONS_CONTAINS,
  FILTERS_CONDITIONS_EMPTY,
  FILTERS_CONDITIONS_ENDS_WITH,
  FILTERS_CONDITIONS_EQUAL,
  FILTERS_CONDITIONS_GREATER_THAN,
  FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_LESS_THAN,
  FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_NAMESPACE,
  FILTERS_CONDITIONS_NONE,
  FILTERS_CONDITIONS_NOT_BETWEEN,
  FILTERS_CONDITIONS_NOT_CONTAIN,
  FILTERS_CONDITIONS_NOT_EMPTY,
  FILTERS_CONDITIONS_NOT_EQUAL,
  FILTERS_CONDITIONS_TODAY,
  FILTERS_CONDITIONS_TOMORROW,
  FILTERS_CONDITIONS_YESTERDAY,
  FILTERS_DIVS_FILTER_BY_CONDITION,
  FILTERS_DIVS_FILTER_BY_VALUE,
  FILTERS_LABELS_CONJUNCTION,
  FILTERS_LABELS_DISJUNCTION,
  FILTERS_NAMESPACE,
  FILTERS_VALUES_BLANK_CELLS
}, Symbol.toStringTag, { value: "Module" }));
var _dictionary;
function _defineProperty$t(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var dictionary = (_dictionary = {
  languageCode: "en-US"
}, _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_NO_ITEMS, "No available options"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ROW_ABOVE, "Insert row above"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ROW_BELOW, "Insert row below"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_INSERT_LEFT, "Insert column left"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_INSERT_RIGHT, "Insert column right"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_REMOVE_ROW, ["Remove row", "Remove rows"]), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_REMOVE_COLUMN, ["Remove column", "Remove columns"]), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_UNDO, "Undo"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_REDO, "Redo"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_READ_ONLY, "Read only"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_CLEAR_COLUMN, "Clear column"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT, "Alignment"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_LEFT, "Left"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_CENTER, "Center"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT, "Right"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY, "Justify"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_TOP, "Top"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE, "Middle"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM, "Bottom"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_FREEZE_COLUMN, "Freeze column"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_UNFREEZE_COLUMN, "Unfreeze column"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_BORDERS, "Borders"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_BORDERS_TOP, "Top"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_BORDERS_RIGHT, "Right"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_BORDERS_BOTTOM, "Bottom"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_BORDERS_LEFT, "Left"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_REMOVE_BORDERS, "Remove border(s)"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_ADD_COMMENT, "Add comment"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_EDIT_COMMENT, "Edit comment"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_REMOVE_COMMENT, "Delete comment"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_READ_ONLY_COMMENT, "Read-only comment"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_MERGE_CELLS, "Merge cells"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_UNMERGE_CELLS, "Unmerge cells"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_COPY, "Copy"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_CUT, "Cut"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD, "Insert child row"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD, "Detach from parent"), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_HIDE_COLUMN, ["Hide column", "Hide columns"]), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_SHOW_COLUMN, ["Show column", "Show columns"]), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_HIDE_ROW, ["Hide row", "Hide rows"]), _defineProperty$t(_dictionary, CONTEXTMENU_ITEMS_SHOW_ROW, ["Show row", "Show rows"]), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_NONE, "None"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_EMPTY, "Is empty"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_NOT_EMPTY, "Is not empty"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_EQUAL, "Is equal to"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_NOT_EQUAL, "Is not equal to"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_BEGINS_WITH, "Begins with"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_ENDS_WITH, "Ends with"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_CONTAINS, "Contains"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_NOT_CONTAIN, "Does not contain"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_GREATER_THAN, "Greater than"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL, "Greater than or equal to"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_LESS_THAN, "Less than"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL, "Less than or equal to"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_BETWEEN, "Is between"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_NOT_BETWEEN, "Is not between"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_AFTER, "After"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_BEFORE, "Before"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_TODAY, "Today"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_TOMORROW, "Tomorrow"), _defineProperty$t(_dictionary, FILTERS_CONDITIONS_YESTERDAY, "Yesterday"), _defineProperty$t(_dictionary, FILTERS_VALUES_BLANK_CELLS, "Blank cells"), _defineProperty$t(_dictionary, FILTERS_DIVS_FILTER_BY_CONDITION, "Filter by condition"), _defineProperty$t(_dictionary, FILTERS_DIVS_FILTER_BY_VALUE, "Filter by value"), _defineProperty$t(_dictionary, FILTERS_LABELS_CONJUNCTION, "And"), _defineProperty$t(_dictionary, FILTERS_LABELS_DISJUNCTION, "Or"), _defineProperty$t(_dictionary, FILTERS_BUTTONS_SELECT_ALL, "Select all"), _defineProperty$t(_dictionary, FILTERS_BUTTONS_CLEAR, "Clear"), _defineProperty$t(_dictionary, FILTERS_BUTTONS_OK, "OK"), _defineProperty$t(_dictionary, FILTERS_BUTTONS_CANCEL, "Cancel"), _defineProperty$t(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_SEARCH, "Search"), _defineProperty$t(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_VALUE, "Value"), _defineProperty$t(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE, "Second value"), _dictionary);
const DEFAULT_DICTIONARY = dictionary;
var DEFAULT_LANGUAGE_CODE = DEFAULT_DICTIONARY.languageCode;
var _staticRegister$2 = staticRegister("languagesDictionaries"), registerGloballyLanguageDictionary = _staticRegister$2.register, getGlobalLanguageDictionary = _staticRegister$2.getItem, hasGlobalLanguageDictionary = _staticRegister$2.hasItem, getGlobalLanguagesDictionaries = _staticRegister$2.getValues;
registerLanguageDictionary(DEFAULT_DICTIONARY);
function registerLanguageDictionary(languageCodeOrDictionary, dictionary2) {
  var languageCode = languageCodeOrDictionary;
  var dictionaryObject = dictionary2;
  if (isObject$7(languageCodeOrDictionary)) {
    dictionaryObject = languageCodeOrDictionary;
    languageCode = dictionaryObject.languageCode;
  }
  extendLanguageDictionary(languageCode, dictionaryObject);
  registerGloballyLanguageDictionary(languageCode, deepClone(dictionaryObject));
  return deepClone(dictionaryObject);
}
function extendLanguageDictionary(languageCode, dictionary2) {
  if (languageCode !== DEFAULT_LANGUAGE_CODE) {
    extendNotExistingKeys(dictionary2, getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));
  }
}
function getLanguageDictionary(languageCode) {
  if (!hasLanguageDictionary(languageCode)) {
    return null;
  }
  return deepClone(getGlobalLanguageDictionary(languageCode));
}
function hasLanguageDictionary(languageCode) {
  return hasGlobalLanguageDictionary(languageCode);
}
function getLanguagesDictionaries() {
  return getGlobalLanguagesDictionaries();
}
function getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {
  var languageDictionary = getLanguageDictionary(languageCode);
  if (languageDictionary === null) {
    return null;
  }
  var phrasePropositions = languageDictionary[dictionaryKey];
  if (isUndefined(phrasePropositions)) {
    return null;
  }
  var formattedPhrase = getFormattedPhrase(phrasePropositions, argumentsForFormatters);
  if (Array.isArray(formattedPhrase)) {
    return formattedPhrase[0];
  }
  return formattedPhrase;
}
function getFormattedPhrase(phrasePropositions, argumentsForFormatters) {
  var formattedPhrasePropositions = phrasePropositions;
  arrayEach(getAll(), function(formatter) {
    formattedPhrasePropositions = formatter(phrasePropositions, argumentsForFormatters);
  });
  return formattedPhrasePropositions;
}
function getValidLanguageCode(languageCode) {
  var normalizedLanguageCode = normalizeLanguageCode(languageCode);
  if (!hasLanguageDictionary(normalizedLanguageCode)) {
    normalizedLanguageCode = DEFAULT_LANGUAGE_CODE;
    warnUserAboutLanguageRegistration(languageCode);
  }
  return normalizedLanguageCode;
}
var $$5 = _export;
var DESCRIPTORS$1 = descriptors;
var ownKeys$i = ownKeys$k;
var toIndexedObject = toIndexedObject$d;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var createProperty = createProperty$6;
$$5({ target: "Object", stat: true, sham: !DESCRIPTORS$1 }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor5 = getOwnPropertyDescriptorModule.f;
    var keys3 = ownKeys$i(O);
    var result = {};
    var index2 = 0;
    var key, descriptor;
    while (keys3.length > index2) {
      descriptor = getOwnPropertyDescriptor5(O, key = keys3[index2++]);
      if (descriptor !== void 0)
        createProperty(result, key, descriptor);
    }
    return result;
  }
});
var ACTIVE_HEADER_TYPE = "active-header";
var AREA_TYPE = "area";
var CELL_TYPE$9 = "cell";
var FILL_TYPE = "fill";
var HEADER_TYPE = "header";
var CUSTOM_SELECTION_TYPE = "custom-selection";
function _typeof$17(obj) {
  "@babel/helpers - typeof";
  return _typeof$17 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$17(obj);
}
function _classCallCheck$1N(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1N(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1N(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1N(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1N(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$Q() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$Q = Reflect.get.bind();
  } else {
    _get$Q = function _get2(target, property, receiver) {
      var base = _superPropBase$Q(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$Q.apply(this, arguments);
}
function _superPropBase$Q(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$10(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$10(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$10(subClass, superClass);
}
function _setPrototypeOf$10(o, p2) {
  _setPrototypeOf$10 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$10(o, p2);
}
function _createSuper$10(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$10();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$10(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$10(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$10(this, result);
  };
}
function _possibleConstructorReturn$10(self2, call2) {
  if (call2 && (_typeof$17(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$10(self2);
}
function _assertThisInitialized$10(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$10() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$10(o) {
  _getPrototypeOf$10 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$10(o);
}
function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var VisualSelection = /* @__PURE__ */ function(_Selection) {
  _inherits$10(VisualSelection2, _Selection);
  var _super = _createSuper$10(VisualSelection2);
  function VisualSelection2(settings, visualCellRange) {
    var _this;
    _classCallCheck$1N(this, VisualSelection2);
    _this = _super.call(this, settings, null);
    _defineProperty$s(_assertThisInitialized$10(_this), "visualCellRange", null);
    _this.visualCellRange = visualCellRange || null;
    _this.commit();
    return _this;
  }
  _createClass$1N(VisualSelection2, [{
    key: "add",
    value: function add(coords) {
      if (this.visualCellRange === null) {
        this.visualCellRange = this.settings.createCellRange(coords);
      } else {
        this.visualCellRange.expand(coords);
      }
      return this;
    }
    /**
     * Clears visual and renderable selection.
     *
     * @returns {VisualSelection}
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.visualCellRange = null;
      return _get$Q(_getPrototypeOf$10(VisualSelection2.prototype), "clear", this).call(this);
    }
    /**
     * Trims the passed cell range object by removing all coordinates that points to the hidden rows
     * or columns. The result is a new cell range object that points only to the visible indexes or `null`.
     *
     * @private
     * @param {CellRange} cellRange Cells range object to be trimmed.
     * @returns {CellRange} Visual non-hidden cells range coordinates.
     */
  }, {
    key: "trimToVisibleCellsRangeOnly",
    value: function trimToVisibleCellsRangeOnly(_ref2) {
      var from3 = _ref2.from, to = _ref2.to;
      var visibleFromCoords = this.getNearestNotHiddenCoords(from3, 1);
      var visibleToCoords = this.getNearestNotHiddenCoords(to, -1);
      if (visibleFromCoords === null || visibleToCoords === null) {
        return null;
      }
      if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {
        var isHeaderTypeSelection = this.settings.type === "header" || this.settings.type === "active-header";
        if (!isHeaderTypeSelection) {
          return null;
        }
        visibleFromCoords = from3;
        visibleToCoords = to;
      }
      return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);
    }
    /**
     * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible
     * rows and/or columns the `null` value is returned.
     *
     * @private
     * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.
     * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for
     *                                  rows and from left to right for columns. For -1, it is the other way around.
     * @param {1|-1} columnSearchDirection The same as above but for rows.
     * @returns {CellCoords|null} Visual cell coordinates.
     */
  }, {
    key: "getNearestNotHiddenCoords",
    value: function getNearestNotHiddenCoords(coords, rowSearchDirection) {
      var columnSearchDirection = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rowSearchDirection;
      var nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper(), coords.row, rowSearchDirection);
      if (nextVisibleRow === null) {
        return null;
      }
      var nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper(), coords.col, columnSearchDirection);
      if (nextVisibleColumn === null) {
        return null;
      }
      return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);
    }
    /**
     * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.
     *
     * @private
     * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
     * @param {number} visualIndex The index as starting point for finding the nearest visible index.
     * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for
     *                               rows and from left to right for columns. For -1, it is the other way around.
     * @returns {number|null} Visual row/column index.
     */
  }, {
    key: "getNearestNotHiddenIndex",
    value: function getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {
      if (visualIndex < 0) {
        return visualIndex;
      }
      var nearestVisualIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);
      var isHeaderSelectionType = this.settings.type === "header" || this.settings.type === "active-header";
      if (isHeaderSelectionType && nearestVisualIndex === null) {
        return -1;
      }
      return nearestVisualIndex;
    }
    /**
     * Override internally stored visual indexes added by the Selection's `add` function. It should be executed
     * at the end of process of adding visual selection coordinates.
     *
     * @returns {VisualSelection}
     */
  }, {
    key: "commit",
    value: function commit() {
      if (this.visualCellRange === null) {
        return this;
      }
      var trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);
      if (trimmedCellRange === null) {
        this.cellRange = null;
      } else {
        this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);
      }
      return this;
    }
    /**
     * Some selection may be a part of broader cell range. This function sync coordinates of current selection
     * and the broader cell range when needed (current selection can't be presented visually).
     *
     * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.
     * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.
     *
     * Warn: Please keep in mind that this function may change coordinates of the handled broader range.
     *
     * @returns {VisualSelection}
     */
  }, {
    key: "syncWith",
    value: function syncWith(broaderCellRange) {
      var rowDirection = broaderCellRange.getVerticalDirection() === "N-S" ? 1 : -1;
      var columnDirection = broaderCellRange.getHorizontalDirection() === "W-E" ? 1 : -1;
      var singleCellRangeVisual = this.getNearestNotHiddenCoords(broaderCellRange.from.clone().normalize(), rowDirection, columnDirection);
      if (singleCellRangeVisual !== null && broaderCellRange.overlaps(singleCellRangeVisual)) {
        if (this.cellRange === null) {
          var singleCellRangeRenderable = this.settings.visualToRenderableCoords(singleCellRangeVisual);
          this.cellRange = this.settings.createCellRange(singleCellRangeRenderable);
        }
        broaderCellRange.setHighlight(singleCellRangeVisual);
        return this;
      }
      broaderCellRange.setHighlight(broaderCellRange.from);
      return this;
    }
    /**
     * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).
     * The method overwrites the original method to support header selection for hidden cells.
     * To make the header selection working, the CellCoords and CellRange have to support not
     * complete coordinates (`null` values for example, `row: null`, `col: 2`).
     *
     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
     */
  }, {
    key: "getCorners",
    value: function getCorners() {
      var _this$cellRange = this.cellRange, from3 = _this$cellRange.from, to = _this$cellRange.to;
      var isRowUndefined = from3.row === null || to.row === null;
      var isColumnUndefined = from3.col === null || to.col === null;
      var topLeftCorner = this.settings.createCellCoords(isRowUndefined ? null : Math.min(from3.row, to.row), isColumnUndefined ? null : Math.min(from3.col, to.col));
      var bottomRightCorner = this.settings.createCellCoords(isRowUndefined ? null : Math.max(from3.row, to.row), isColumnUndefined ? null : Math.max(from3.col, to.col));
      return [topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, bottomRightCorner.col];
    }
    /**
     * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection
     * coordinates (visual indexes).
     *
     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
     */
  }, {
    key: "getVisualCorners",
    value: function getVisualCorners() {
      var topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());
      var bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());
      return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];
    }
    /**
     * Creates a new CellRange object based on visual coordinates which before object creation are
     * translated to renderable indexes.
     *
     * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that
     *                                      points to the beginning of the selection.
     * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that
     *                                    points to the end of the selection.
     * @returns {CellRange}
     */
  }, {
    key: "createRenderableCellRange",
    value: function createRenderableCellRange(visualFromCoords, visualToCoords) {
      var renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);
      var renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);
      return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);
    }
  }]);
  return VisualSelection2;
}(Selection$3);
const VisualSelection$1 = VisualSelection;
var _excluded$8 = ["activeHeaderClassName"];
function ownKeys$h(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$h(Object(source), true).forEach(function(key) {
      _defineProperty$r(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$6(_ref2) {
  var activeHeaderClassName = _ref2.activeHeaderClassName, restOptions = _objectWithoutProperties$8(_ref2, _excluded$8);
  var s = new VisualSelection$1(_objectSpread$g(_objectSpread$g({
    highlightHeaderClassName: activeHeaderClassName
  }, restOptions), {}, {
    selectionType: ACTIVE_HEADER_TYPE
  }));
  return s;
}
var _excluded$7 = ["layerLevel", "areaCornerVisible"];
function ownKeys$g(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$g(Object(source), true).forEach(function(key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$5(_ref2) {
  var layerLevel = _ref2.layerLevel, areaCornerVisible = _ref2.areaCornerVisible, restOptions = _objectWithoutProperties$7(_ref2, _excluded$7);
  var s = new VisualSelection$1(_objectSpread$f(_objectSpread$f({
    className: "area",
    markIntersections: true,
    layerLevel: Math.min(layerLevel, 7),
    border: {
      width: 1,
      color: "#4b89ff",
      cornerVisible: areaCornerVisible
    }
  }, restOptions), {}, {
    selectionType: AREA_TYPE
  }));
  return s;
}
var _excluded$6 = ["cellCornerVisible"];
function ownKeys$f(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), true).forEach(function(key) {
      _defineProperty$p(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$4(_ref2) {
  var cellCornerVisible = _ref2.cellCornerVisible, restOptions = _objectWithoutProperties$6(_ref2, _excluded$6);
  var s = new VisualSelection$1(_objectSpread$e(_objectSpread$e({
    className: "current",
    border: {
      width: 2,
      color: "#4b89ff",
      cornerVisible: cellCornerVisible
    }
  }, restOptions), {}, {
    selectionType: CELL_TYPE$9
  }));
  return s;
}
var _excluded$5 = ["border", "visualCellRange"];
function ownKeys$e(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), true).forEach(function(key) {
      _defineProperty$o(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$3(_ref2) {
  var border = _ref2.border, visualCellRange = _ref2.visualCellRange, restOptions = _objectWithoutProperties$5(_ref2, _excluded$5);
  var s = new VisualSelection$1(_objectSpread$d(_objectSpread$d(_objectSpread$d({}, border), restOptions), {}, {
    selectionType: CUSTOM_SELECTION_TYPE
  }), visualCellRange);
  return s;
}
var DESCRIPTORS = descriptors;
var uncurryThis$4 = functionUncurryThis;
var call$1 = functionCall;
var fails$2 = fails$G;
var objectKeys = objectKeys$4;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$1 = toObject$f;
var IndexedObject = indexedObject;
var $assign = Object.assign;
var defineProperty4 = Object.defineProperty;
var concat2 = uncurryThis$4([].concat);
var objectAssign = !$assign || fails$2(function() {
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty4({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty4(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A2 = {};
  var B = {};
  var symbol = Symbol();
  var alphabet = "abcdefghijklmnopqrst";
  A2[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A2)[symbol] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
}) ? function assign(target, source) {
  var T = toObject$1(target);
  var argumentsLength = arguments.length;
  var index2 = 1;
  var getOwnPropertySymbols3 = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable4 = propertyIsEnumerableModule.f;
  while (argumentsLength > index2) {
    var S = IndexedObject(arguments[index2++]);
    var keys3 = getOwnPropertySymbols3 ? concat2(objectKeys(S), getOwnPropertySymbols3(S)) : objectKeys(S);
    var length = keys3.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys3[j++];
      if (!DESCRIPTORS || call$1(propertyIsEnumerable4, S, key))
        T[key] = S[key];
    }
  }
  return T;
} : $assign;
var $$4 = _export;
var assign2 = objectAssign;
$$4({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
  assign: assign2
});
function ownKeys$d(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), true).forEach(function(key) {
      _defineProperty$n(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function createHighlight$2(_ref2) {
  var restOptions = Object.assign({}, _ref2);
  var s = new VisualSelection$1(_objectSpread$c(_objectSpread$c({
    className: "fill",
    border: {
      width: 1,
      color: "#ff0000"
    }
  }, restOptions), {}, {
    selectionType: FILL_TYPE
  }));
  return s;
}
var _excluded$4 = ["headerClassName", "rowClassName", "columnClassName"];
function ownKeys$c(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), true).forEach(function(key) {
      _defineProperty$m(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$1(_ref2) {
  var headerClassName = _ref2.headerClassName, rowClassName = _ref2.rowClassName, columnClassName = _ref2.columnClassName, restOptions = _objectWithoutProperties$4(_ref2, _excluded$4);
  var s = new VisualSelection$1(_objectSpread$b(_objectSpread$b({
    className: "highlight",
    highlightHeaderClassName: headerClassName,
    highlightRowClassName: rowClassName,
    highlightColumnClassName: columnClassName
  }, restOptions), {}, {
    highlightOnlyClosestHeader: true,
    selectionType: HEADER_TYPE
  }));
  return s;
}
function ownKeys$b(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), true).forEach(function(key) {
      _defineProperty$l(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _staticRegister$1 = staticRegister("highlight/types"), register = _staticRegister$1.register, getItem = _staticRegister$1.getItem;
register(ACTIVE_HEADER_TYPE, createHighlight$6);
register(AREA_TYPE, createHighlight$5);
register(CELL_TYPE$9, createHighlight$4);
register(CUSTOM_SELECTION_TYPE, createHighlight$3);
register(FILL_TYPE, createHighlight$2);
register(HEADER_TYPE, createHighlight$1);
function createHighlight(highlightType, options) {
  return getItem(highlightType)(_objectSpread$a({
    type: highlightType
  }, options));
}
function _toConsumableArray$n(arr) {
  return _arrayWithoutHoles$n(arr) || _iterableToArray$p(arr) || _unsupportedIterableToArray$Y(arr) || _nonIterableSpread$n();
}
function _nonIterableSpread$n() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$Y(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$Y(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$Y(o, minLen);
}
function _iterableToArray$p(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$n(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$Y(arr);
}
function _arrayLikeToArray$Y(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys$a(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
      _defineProperty$k(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$1M(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1M(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1M(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1M(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1M(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Highlight = /* @__PURE__ */ function(_Symbol$iterator) {
  function Highlight2(options) {
    _classCallCheck$1M(this, Highlight2);
    this.options = options;
    this.layerLevel = 0;
    this.cell = createHighlight(CELL_TYPE$9, options);
    this.fill = createHighlight(FILL_TYPE, options);
    this.areas = /* @__PURE__ */ new Map();
    this.headers = /* @__PURE__ */ new Map();
    this.activeHeaders = /* @__PURE__ */ new Map();
    this.customSelections = [];
  }
  _createClass$1M(Highlight2, [{
    key: "isEnabledFor",
    value: function isEnabledFor(highlightType, coords) {
      var type = highlightType;
      if (highlightType === CELL_TYPE$9) {
        type = "current";
      }
      var disableHighlight = this.options.disabledCellSelection(coords.row, coords.col);
      if (typeof disableHighlight === "string") {
        disableHighlight = [disableHighlight];
      }
      return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);
    }
    /**
     * Set a new layer level to make access to the desire `area` and `header` highlights.
     *
     * @param {number} [level=0] Layer level to use.
     * @returns {Highlight}
     */
  }, {
    key: "useLayerLevel",
    value: function useLayerLevel() {
      var level = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.layerLevel = level;
      return this;
    }
    /**
     * Get Walkontable Selection instance created for controlling highlight of the currently selected/edited cell.
     *
     * @returns {Selection}
     */
  }, {
    key: "getCell",
    value: function getCell() {
      return this.cell;
    }
    /**
     * Get Walkontable Selection instance created for controlling highlight of the autofill functionality.
     *
     * @returns {Selection}
     */
  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill;
    }
    /**
     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
     * of the multiple selected cells.
     *
     * @returns {Selection}
     */
  }, {
    key: "createOrGetArea",
    value: function createOrGetArea() {
      var layerLevel = this.layerLevel;
      var area;
      if (this.areas.has(layerLevel)) {
        area = this.areas.get(layerLevel);
      } else {
        area = createHighlight(AREA_TYPE, _objectSpread$9({
          layerLevel
        }, this.options));
        this.areas.set(layerLevel, area);
      }
      return area;
    }
    /**
     * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.
     *
     * @returns {Selection[]}
     */
  }, {
    key: "getAreas",
    value: function getAreas() {
      return _toConsumableArray$n(this.areas.values());
    }
    /**
     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
     * of the multiple selected header cells.
     *
     * @returns {Selection}
     */
  }, {
    key: "createOrGetHeader",
    value: function createOrGetHeader() {
      var layerLevel = this.layerLevel;
      var header;
      if (this.headers.has(layerLevel)) {
        header = this.headers.get(layerLevel);
      } else {
        header = createHighlight(HEADER_TYPE, _objectSpread$9({}, this.options));
        this.headers.set(layerLevel, header);
      }
      return header;
    }
    /**
     * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.
     *
     * @returns {Selection[]}
     */
  }, {
    key: "getHeaders",
    value: function getHeaders() {
      return _toConsumableArray$n(this.headers.values());
    }
    /**
     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
     * of the multiple selected active header cells.
     *
     * @returns {Selection}
     */
  }, {
    key: "createOrGetActiveHeader",
    value: function createOrGetActiveHeader() {
      var layerLevel = this.layerLevel;
      var header;
      if (this.activeHeaders.has(layerLevel)) {
        header = this.activeHeaders.get(layerLevel);
      } else {
        header = createHighlight(ACTIVE_HEADER_TYPE, _objectSpread$9({}, this.options));
        this.activeHeaders.set(layerLevel, header);
      }
      return header;
    }
    /**
     * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.
     *
     * @returns {Selection[]}
     */
  }, {
    key: "getActiveHeaders",
    value: function getActiveHeaders() {
      return _toConsumableArray$n(this.activeHeaders.values());
    }
    /**
     * Get Walkontable Selection instance created for controlling highlight of the custom selection functionality.
     *
     * @returns {Selection}
     */
  }, {
    key: "getCustomSelections",
    value: function getCustomSelections() {
      return _toConsumableArray$n(this.customSelections.values());
    }
    /**
     * Add selection to the custom selection instance. The new selection are added to the end of the selection collection.
     *
     * @param {object} selectionInstance The selection instance.
     */
  }, {
    key: "addCustomSelection",
    value: function addCustomSelection(selectionInstance) {
      this.customSelections.push(createHighlight(CUSTOM_SELECTION_TYPE, _objectSpread$9(_objectSpread$9({}, this.options), selectionInstance)));
    }
    /**
     * Perform cleaning visual highlights for the whole table.
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.cell.clear();
      this.fill.clear();
      arrayEach(this.areas.values(), function(highlight) {
        return void highlight.clear();
      });
      arrayEach(this.headers.values(), function(highlight) {
        return void highlight.clear();
      });
      arrayEach(this.activeHeaders.values(), function(highlight) {
        return void highlight.clear();
      });
    }
    /**
     * This object can be iterate over using `for of` syntax or using internal `arrayEach` helper.
     *
     * @returns {Selection[]}
     */
  }, {
    key: _Symbol$iterator,
    value: function value() {
      return [this.cell, this.fill].concat(_toConsumableArray$n(this.areas.values()), _toConsumableArray$n(this.headers.values()), _toConsumableArray$n(this.activeHeaders.values()), _toConsumableArray$n(this.customSelections))[Symbol.iterator]();
    }
  }]);
  return Highlight2;
}(Symbol.iterator);
const Highlight$1 = Highlight;
function _classCallCheck$1L(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1L(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1L(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1L(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1L(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var SelectionRange = /* @__PURE__ */ function(_Symbol$iterator) {
  function SelectionRange2(createCellRange) {
    _classCallCheck$1L(this, SelectionRange2);
    this.ranges = [];
    this.createCellRange = createCellRange;
  }
  _createClass$1L(SelectionRange2, [{
    key: "isEmpty",
    value: function isEmpty2() {
      return this.size() === 0;
    }
    /**
     * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`
     * to the collection.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {SelectionRange}
     */
  }, {
    key: "set",
    value: function set2(coords) {
      this.clear();
      this.ranges.push(this.createCellRange(coords));
      return this;
    }
    /**
     * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {SelectionRange}
     */
  }, {
    key: "add",
    value: function add(coords) {
      this.ranges.push(this.createCellRange(coords));
      return this;
    }
    /**
     * Removes from the stack the last added coordinates.
     *
     * @returns {SelectionRange}
     */
  }, {
    key: "pop",
    value: function pop() {
      this.ranges.pop();
      return this;
    }
    /**
     * Get last added coordinates from ranges, it returns a CellRange instance.
     *
     * @returns {CellRange|undefined}
     */
  }, {
    key: "current",
    value: function current() {
      return this.peekByIndex(0);
    }
    /**
     * Get previously added coordinates from ranges, it returns a CellRange instance.
     *
     * @returns {CellRange|undefined}
     */
  }, {
    key: "previous",
    value: function previous() {
      return this.peekByIndex(-1);
    }
    /**
     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
     * the coords object is within selection range.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {boolean}
     */
  }, {
    key: "includes",
    value: function includes3(coords) {
      return this.ranges.some(function(cellRange) {
        return cellRange.includes(coords);
      });
    }
    /**
     * Clear collection.
     *
     * @returns {SelectionRange}
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.ranges.length = 0;
      return this;
    }
    /**
     * Get count of added all coordinates added to the selection.
     *
     * @returns {number}
     */
  }, {
    key: "size",
    value: function size() {
      return this.ranges.length;
    }
    /**
     * Peek the coordinates based on the offset where that coordinate resides in the collection.
     *
     * @param {number} [offset=0] An offset where the coordinate will be retrieved from.
     * @returns {CellRange|undefined}
     */
  }, {
    key: "peekByIndex",
    value: function peekByIndex() {
      var offset2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var rangeIndex = this.size() + offset2 - 1;
      var cellRange;
      if (rangeIndex >= 0) {
        cellRange = this.ranges[rangeIndex];
      }
      return cellRange;
    }
  }, {
    key: _Symbol$iterator,
    value: function value() {
      return this.ranges[Symbol.iterator]();
    }
  }]);
  return SelectionRange2;
}(Symbol.iterator);
const SelectionRange$1 = SelectionRange;
function _classCallCheck$1K(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1K(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1K(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1K(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1K(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Transformation = /* @__PURE__ */ function() {
  function Transformation2(range, options) {
    _classCallCheck$1K(this, Transformation2);
    this.range = range;
    this.options = options;
  }
  _createClass$1K(Transformation2, [{
    key: "transformStart",
    value: function transformStart(rowDelta, colDelta) {
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var delta = this.options.createCellCoords(rowDelta, colDelta);
      var highlightCoords = this.range.current().highlight;
      var _this$options$visualT = this.options.visualToRenderableCoords(highlightCoords), renderableRow = _this$options$visualT.row, renderableColumn = _this$options$visualT.col;
      var visualCoords = highlightCoords;
      var rowTransformDir = 0;
      var colTransformDir = 0;
      this.runLocalHooks("beforeTransformStart", delta);
      if (renderableRow !== null && renderableColumn !== null) {
        var totalRows = this.options.countRows();
        var totalCols = this.options.countCols();
        var fixedRowsBottom = this.options.fixedRowsBottom();
        var minSpareRows = this.options.minSpareRows();
        var minSpareCols = this.options.minSpareCols();
        var autoWrapRow = this.options.autoWrapRow();
        var autoWrapCol = this.options.autoWrapCol();
        if (renderableRow + rowDelta > totalRows - 1) {
          if (force && minSpareRows > 0 && !(fixedRowsBottom && renderableRow >= totalRows - fixedRowsBottom - 1)) {
            this.runLocalHooks("insertRowRequire", totalRows);
            totalRows = this.options.countRows();
          } else if (autoWrapCol) {
            delta.row = 1 - totalRows;
            delta.col = renderableColumn + delta.col === totalCols - 1 ? 1 - totalCols : 1;
          }
        } else if (autoWrapCol && renderableRow + delta.row < 0 && renderableColumn + delta.col >= 0) {
          delta.row = totalRows - 1;
          delta.col = renderableColumn + delta.col === 0 ? totalCols - 1 : -1;
        }
        if (renderableColumn + delta.col > totalCols - 1) {
          if (force && minSpareCols > 0) {
            this.runLocalHooks("insertColRequire", totalCols);
            totalCols = this.options.countCols();
          } else if (autoWrapRow) {
            delta.row = renderableRow + delta.row === totalRows - 1 ? 1 - totalRows : 1;
            delta.col = 1 - totalCols;
          }
        } else if (autoWrapRow && renderableColumn + delta.col < 0 && renderableRow + delta.row >= 0) {
          delta.row = renderableRow + delta.row === 0 ? totalRows - 1 : -1;
          delta.col = totalCols - 1;
        }
        var coords = this.options.createCellCoords(renderableRow + delta.row, renderableColumn + delta.col);
        rowTransformDir = 0;
        colTransformDir = 0;
        if (coords.row < 0) {
          rowTransformDir = -1;
          coords.row = 0;
        } else if (coords.row > 0 && coords.row >= totalRows) {
          rowTransformDir = 1;
          coords.row = totalRows - 1;
        }
        if (coords.col < 0) {
          colTransformDir = -1;
          coords.col = 0;
        } else if (coords.col > 0 && coords.col >= totalCols) {
          colTransformDir = 1;
          coords.col = totalCols - 1;
        }
        visualCoords = this.options.renderableToVisualCoords(coords);
      }
      this.runLocalHooks("afterTransformStart", visualCoords, rowTransformDir, colTransformDir);
      return visualCoords;
    }
    /**
     * Sets selection end cell relative to current selection end cell (if possible).
     *
     * @param {number} rowDelta Rows number to move, value can be passed as negative number.
     * @param {number} colDelta Columns number to move, value can be passed as negative number.
     * @returns {CellCoords} Visual coordinates after transformation.
     */
  }, {
    key: "transformEnd",
    value: function transformEnd(rowDelta, colDelta) {
      var delta = this.options.createCellCoords(rowDelta, colDelta);
      var cellRange = this.range.current();
      var visualCoords = cellRange.to;
      var rowTransformDir = 0;
      var colTransformDir = 0;
      this.runLocalHooks("beforeTransformEnd", delta);
      var _this$options$visualT2 = this.options.visualToRenderableCoords(cellRange.highlight), rowHighlight = _this$options$visualT2.row, colHighlight = _this$options$visualT2.col;
      if (rowHighlight !== null && colHighlight !== null) {
        var totalRows = this.options.countRows();
        var totalCols = this.options.countCols();
        var _this$options$visualT3 = this.options.visualToRenderableCoords(cellRange.to), rowTo = _this$options$visualT3.row, colTo = _this$options$visualT3.col;
        var coords = this.options.createCellCoords(rowTo + delta.row, colTo + delta.col);
        rowTransformDir = 0;
        colTransformDir = 0;
        if (coords.row < 0) {
          rowTransformDir = -1;
          coords.row = 0;
        } else if (coords.row > 0 && coords.row >= totalRows) {
          rowTransformDir = 1;
          coords.row = totalRows - 1;
        }
        if (coords.col < 0) {
          colTransformDir = -1;
          coords.col = 0;
        } else if (coords.col > 0 && coords.col >= totalCols) {
          colTransformDir = 1;
          coords.col = totalCols - 1;
        }
        visualCoords = this.options.renderableToVisualCoords(coords);
      }
      this.runLocalHooks("afterTransformEnd", visualCoords, rowTransformDir, colTransformDir);
      return visualCoords;
    }
  }]);
  return Transformation2;
}();
mixin(Transformation, localHooks$1);
const Transformation$1 = Transformation;
function _slicedToArray$E(arr, i) {
  return _arrayWithHoles$G(arr) || _iterableToArrayLimit$E(arr, i) || _unsupportedIterableToArray$X(arr, i) || _nonIterableRest$G();
}
function _nonIterableRest$G() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$X(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$X(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$X(o, minLen);
}
function _arrayLikeToArray$X(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$E(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$G(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$16(obj) {
  "@babel/helpers - typeof";
  return _typeof$16 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$16(obj);
}
var SELECTION_TYPE_UNRECOGNIZED = 0;
var SELECTION_TYPE_EMPTY = 1;
var SELECTION_TYPE_ARRAY = 2;
var SELECTION_TYPE_OBJECT = 3;
var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];
var ARRAY_TYPE_PATTERN = [["number"], ["number", "string"], ["number", "undefined"], ["number", "string", "undefined"]];
var rootCall = Symbol("root");
var childCall = Symbol("child");
function detectSelectionType(selectionRanges) {
  var _callSymbol = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rootCall;
  if (_callSymbol !== rootCall && _callSymbol !== childCall) {
    throw new Error("The second argument is used internally only and cannot be overwritten.");
  }
  var isArray3 = Array.isArray(selectionRanges);
  var isRootCall = _callSymbol === rootCall;
  var result = SELECTION_TYPE_UNRECOGNIZED;
  if (isArray3) {
    var firstItem = selectionRanges[0];
    if (selectionRanges.length === 0) {
      result = SELECTION_TYPE_EMPTY;
    } else if (isRootCall && firstItem instanceof CellRange$1) {
      result = SELECTION_TYPE_OBJECT;
    } else if (isRootCall && Array.isArray(firstItem)) {
      result = detectSelectionType(firstItem, childCall);
    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {
      var isArrayType = !selectionRanges.some(function(value, index2) {
        return !ARRAY_TYPE_PATTERN[index2].includes(_typeof$16(value));
      });
      if (isArrayType) {
        result = SELECTION_TYPE_ARRAY;
      }
    }
  }
  return result;
}
function normalizeSelectionFactory(type) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$keepDirection = _ref2.keepDirection, keepDirection = _ref$keepDirection === void 0 ? false : _ref$keepDirection, propToCol = _ref2.propToCol;
  if (!SELECTION_TYPES.includes(type)) {
    throw new Error("Unsupported selection ranges schema type was provided.");
  }
  return function(selection) {
    var isObjectType = type === SELECTION_TYPE_OBJECT;
    var rowStart = isObjectType ? selection.from.row : selection[0];
    var columnStart = isObjectType ? selection.from.col : selection[1];
    var rowEnd = isObjectType ? selection.to.row : selection[2];
    var columnEnd = isObjectType ? selection.to.col : selection[3];
    if (typeof propToCol === "function") {
      if (typeof columnStart === "string") {
        columnStart = propToCol(columnStart);
      }
      if (typeof columnEnd === "string") {
        columnEnd = propToCol(columnEnd);
      }
    }
    if (isUndefined(rowEnd)) {
      rowEnd = rowStart;
    }
    if (isUndefined(columnEnd)) {
      columnEnd = columnStart;
    }
    if (!keepDirection) {
      var origRowStart = rowStart;
      var origColumnStart = columnStart;
      var origRowEnd = rowEnd;
      var origColumnEnd = columnEnd;
      rowStart = Math.min(origRowStart, origRowEnd);
      columnStart = Math.min(origColumnStart, origColumnEnd);
      rowEnd = Math.max(origRowStart, origRowEnd);
      columnEnd = Math.max(origColumnStart, origColumnEnd);
    }
    return [rowStart, columnStart, rowEnd, columnEnd];
  };
}
function transformSelectionToColumnDistance(selectionRanges) {
  var selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  var unorderedIndexes = /* @__PURE__ */ new Set();
  arrayEach(selectionRanges, function(selection) {
    var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray$E(_selectionSchemaNorma, 4), columnStart = _selectionSchemaNorma2[1], columnEnd = _selectionSchemaNorma2[3];
    var columnNonHeaderStart = Math.max(columnStart, 0);
    var amount = columnEnd - columnNonHeaderStart + 1;
    arrayEach(Array.from(new Array(amount), function(_, i) {
      return columnNonHeaderStart + i;
    }), function(index2) {
      if (!unorderedIndexes.has(index2)) {
        unorderedIndexes.add(index2);
      }
    });
  });
  var orderedIndexes = Array.from(unorderedIndexes).sort(function(a, b2) {
    return a - b2;
  });
  var normalizedColumnRanges = arrayReduce$1(orderedIndexes, function(acc, visualColumnIndex, index2, array) {
    if (index2 !== 0 && visualColumnIndex === array[index2 - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([visualColumnIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedColumnRanges;
}
function transformSelectionToRowDistance(selectionRanges) {
  var selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  var unorderedIndexes = /* @__PURE__ */ new Set();
  arrayEach(selectionRanges, function(selection) {
    var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray$E(_selectionSchemaNorma3, 3), rowStart = _selectionSchemaNorma4[0], rowEnd = _selectionSchemaNorma4[2];
    var rowNonHeaderStart = Math.max(rowStart, 0);
    var amount = rowEnd - rowNonHeaderStart + 1;
    arrayEach(Array.from(new Array(amount), function(_, i) {
      return rowNonHeaderStart + i;
    }), function(index2) {
      if (!unorderedIndexes.has(index2)) {
        unorderedIndexes.add(index2);
      }
    });
  });
  var orderedIndexes = Array.from(unorderedIndexes).sort(function(a, b2) {
    return a - b2;
  });
  var normalizedRowRanges = arrayReduce$1(orderedIndexes, function(acc, rowIndex, index2, array) {
    if (index2 !== 0 && rowIndex === array[index2 - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([rowIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedRowRanges;
}
function isValidCoord(coord) {
  var maxTableItemsCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  return typeof coord === "number" && coord >= 0 && coord < maxTableItemsCount;
}
var _templateObject$c;
function _slicedToArray$D(arr, i) {
  return _arrayWithHoles$F(arr) || _iterableToArrayLimit$D(arr, i) || _unsupportedIterableToArray$W(arr, i) || _nonIterableRest$F();
}
function _nonIterableRest$F() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$W(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$W(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$W(o, minLen);
}
function _arrayLikeToArray$W(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$D(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$F(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _taggedTemplateLiteral$c(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$1J(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1J(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1J(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1J(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1J(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Selection = /* @__PURE__ */ function() {
  function Selection2(settings, tableProps) {
    var _this = this;
    _classCallCheck$1J(this, Selection2);
    this.settings = settings;
    this.tableProps = tableProps;
    this.inProgress = false;
    this.selectedByCorner = false;
    this.selectedByRowHeader = /* @__PURE__ */ new Set();
    this.selectedByColumnHeader = /* @__PURE__ */ new Set();
    this.selectedRange = new SelectionRange$1(function(highlight, from3, to) {
      return _this.tableProps.createCellRange(highlight, from3, to);
    });
    this.highlight = new Highlight$1({
      headerClassName: settings.currentHeaderClassName,
      activeHeaderClassName: settings.activeHeaderClassName,
      rowClassName: settings.currentRowClassName,
      columnClassName: settings.currentColClassName,
      disabledCellSelection: function disabledCellSelection(row, column) {
        return _this.tableProps.isDisabledCellSelection(row, column);
      },
      cellCornerVisible: function cellCornerVisible() {
        return _this.isCellCornerVisible.apply(_this, arguments);
      },
      areaCornerVisible: function areaCornerVisible() {
        return _this.isAreaCornerVisible.apply(_this, arguments);
      },
      visualToRenderableCoords: function visualToRenderableCoords(coords) {
        return _this.tableProps.visualToRenderableCoords(coords);
      },
      renderableToVisualCoords: function renderableToVisualCoords(coords) {
        return _this.tableProps.renderableToVisualCoords(coords);
      },
      createCellCoords: function createCellCoords(row, column) {
        return _this.tableProps.createCellCoords(row, column);
      },
      createCellRange: function createCellRange(highlight, from3, to) {
        return _this.tableProps.createCellRange(highlight, from3, to);
      },
      rowIndexMapper: function rowIndexMapper() {
        return _this.tableProps.rowIndexMapper();
      },
      columnIndexMapper: function columnIndexMapper() {
        return _this.tableProps.columnIndexMapper();
      }
    });
    this.transformation = new Transformation$1(this.selectedRange, {
      countRows: function countRows() {
        return _this.tableProps.countRowsTranslated();
      },
      countCols: function countCols() {
        return _this.tableProps.countColsTranslated();
      },
      visualToRenderableCoords: function visualToRenderableCoords(coords) {
        return _this.tableProps.visualToRenderableCoords(coords);
      },
      renderableToVisualCoords: function renderableToVisualCoords(coords) {
        return _this.tableProps.renderableToVisualCoords(coords);
      },
      createCellCoords: function createCellCoords(row, column) {
        return _this.tableProps.createCellCoords(row, column);
      },
      fixedRowsBottom: function fixedRowsBottom() {
        return settings.fixedRowsBottom;
      },
      minSpareRows: function minSpareRows() {
        return settings.minSpareRows;
      },
      minSpareCols: function minSpareCols() {
        return settings.minSpareCols;
      },
      autoWrapRow: function autoWrapRow() {
        return settings.autoWrapRow;
      },
      autoWrapCol: function autoWrapCol() {
        return settings.autoWrapCol;
      }
    });
    this.transformation.addLocalHook("beforeTransformStart", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _this.runLocalHooks.apply(_this, ["beforeModifyTransformStart"].concat(args));
    });
    this.transformation.addLocalHook("afterTransformStart", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.runLocalHooks.apply(_this, ["afterModifyTransformStart"].concat(args));
    });
    this.transformation.addLocalHook("beforeTransformEnd", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.runLocalHooks.apply(_this, ["beforeModifyTransformEnd"].concat(args));
    });
    this.transformation.addLocalHook("afterTransformEnd", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.runLocalHooks.apply(_this, ["afterModifyTransformEnd"].concat(args));
    });
    this.transformation.addLocalHook("insertRowRequire", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.runLocalHooks.apply(_this, ["insertRowRequire"].concat(args));
    });
    this.transformation.addLocalHook("insertColRequire", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.runLocalHooks.apply(_this, ["insertColRequire"].concat(args));
    });
  }
  _createClass$1J(Selection2, [{
    key: "getSelectedRange",
    value: function getSelectedRange() {
      return this.selectedRange;
    }
    /**
     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.
     */
  }, {
    key: "begin",
    value: function begin() {
      this.inProgress = true;
    }
    /**
     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.
     */
  }, {
    key: "finish",
    value: function finish() {
      this.runLocalHooks("afterSelectionFinished", Array.from(this.selectedRange));
      this.inProgress = false;
    }
    /**
     * Check if the process of selecting the cell/cells is in progress.
     *
     * @returns {boolean}
     */
  }, {
    key: "isInProgress",
    value: function isInProgress() {
      return this.inProgress;
    }
    /**
     * Starts selection range on given coordinate object.
     *
     * @param {CellCoords} coords Visual coords.
     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
     *                                      the default trigger will be used.
     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the
     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.
     */
  }, {
    key: "setRangeStart",
    value: function setRangeStart(coords, multipleSelection) {
      var fragment = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var isMultipleMode = this.settings.selectionMode === "multiple";
      var isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;
      var isRowNegative = coords.row < 0;
      var isColumnNegative = coords.col < 0;
      var selectedByCorner = isRowNegative && isColumnNegative;
      var coordsClone = coords.clone();
      this.selectedByCorner = selectedByCorner;
      this.runLocalHooks("beforeSetRangeStart".concat(fragment ? "Only" : ""), coordsClone);
      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {
        this.selectedRange.clear();
      }
      this.selectedRange.add(coordsClone);
      if (this.getLayerLevel() === 0) {
        this.selectedByRowHeader.clear();
        this.selectedByColumnHeader.clear();
      }
      if (!selectedByCorner && isColumnNegative) {
        this.selectedByRowHeader.add(this.getLayerLevel());
      }
      if (!selectedByCorner && isRowNegative) {
        this.selectedByColumnHeader.add(this.getLayerLevel());
      }
      if (!fragment) {
        this.setRangeEnd(coords);
      }
    }
    /**
     * Starts selection range on given coordinate object.
     *
     * @param {CellCoords} coords Visual coords.
     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
     *                                      the default trigger will be used.
     */
  }, {
    key: "setRangeStartOnly",
    value: function setRangeStartOnly(coords, multipleSelection) {
      this.setRangeStart(coords, multipleSelection, true);
    }
    /**
     * Ends selection range on given coordinate object.
     *
     * @param {CellCoords} coords Visual coords.
     */
  }, {
    key: "setRangeEnd",
    value: function setRangeEnd(coords) {
      if (this.selectedRange.isEmpty()) {
        return;
      }
      var coordsClone = coords.clone();
      this.runLocalHooks("beforeSetRangeEnd", coordsClone);
      this.begin();
      var cellRange = this.selectedRange.current();
      if (this.settings.selectionMode !== "single") {
        cellRange.setTo(this.tableProps.createCellCoords(coordsClone.row, coordsClone.col));
      }
      this.highlight.getCell().clear();
      if (this.highlight.isEnabledFor(CELL_TYPE$9, cellRange.highlight)) {
        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().syncWith(cellRange);
      }
      var layerLevel = this.getLayerLevel();
      if (layerLevel < this.highlight.layerLevel) {
        arrayEach(this.highlight.getAreas(), function(highlight) {
          return void highlight.clear();
        });
        arrayEach(this.highlight.getHeaders(), function(highlight) {
          return void highlight.clear();
        });
        arrayEach(this.highlight.getActiveHeaders(), function(highlight) {
          return void highlight.clear();
        });
      }
      this.highlight.useLayerLevel(layerLevel);
      var areaHighlight = this.highlight.createOrGetArea();
      var headerHighlight = this.highlight.createOrGetHeader();
      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();
      areaHighlight.clear();
      headerHighlight.clear();
      activeHeaderHighlight.clear();
      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {
        areaHighlight.add(cellRange.from).add(cellRange.to).commit();
        if (layerLevel === 1) {
          var previousRange = this.selectedRange.previous();
          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit().syncWith(previousRange);
          this.highlight.useLayerLevel(layerLevel);
        }
      }
      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {
        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;
        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;
        var headerCellRange = cellRange;
        if (areAnyRowsRendered || areAnyColumnsRendered) {
          headerCellRange = cellRange.clone();
        }
        if (areAnyRowsRendered) {
          headerCellRange.from.row = -1;
        }
        if (areAnyColumnsRendered) {
          headerCellRange.from.col = -1;
        }
        if (this.settings.selectionMode === "single") {
          if (this.isSelectedByAnyHeader()) {
            headerCellRange.from.normalize();
          }
          headerHighlight.add(headerCellRange.from).commit();
        } else {
          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();
        }
        if (this.isEntireRowSelected()) {
          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth();
          if (isRowSelected) {
            activeHeaderHighlight.add(this.tableProps.createCellCoords(cellRange.from.row, -1)).add(this.tableProps.createCellCoords(cellRange.to.row, -1)).commit();
          }
        }
        if (this.isEntireColumnSelected()) {
          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight();
          if (isColumnSelected) {
            activeHeaderHighlight.add(this.tableProps.createCellCoords(-1, cellRange.from.col)).add(this.tableProps.createCellCoords(-1, cellRange.to.col)).commit();
          }
        }
      }
      this.runLocalHooks("afterSetRangeEnd", coords);
    }
    /**
     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of
     * the selection.
     *
     * @returns {boolean}
     */
  }, {
    key: "isMultiple",
    value: function isMultiple() {
      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());
      this.runLocalHooks("afterIsMultipleSelection", isMultipleListener);
      return isMultipleListener.value;
    }
    /**
     * Selects cell relative to the current cell (if possible).
     *
     * @param {number} rowDelta Rows number to move, value can be passed as negative number.
     * @param {number} colDelta Columns number to move, value can be passed as negative number.
     * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will
     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.
     */
  }, {
    key: "transformStart",
    value: function transformStart(rowDelta, colDelta) {
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));
    }
    /**
     * Sets selection end cell relative to the current selection end cell (if possible).
     *
     * @param {number} rowDelta Rows number to move, value can be passed as negative number.
     * @param {number} colDelta Columns number to move, value can be passed as negative number.
     */
  }, {
    key: "transformEnd",
    value: function transformEnd(rowDelta, colDelta) {
      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));
    }
    /**
     * Returns currently used layer level.
     *
     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.
     */
  }, {
    key: "getLayerLevel",
    value: function getLayerLevel() {
      return this.selectedRange.size() - 1;
    }
    /**
     * Returns `true` if currently there is a selection on the screen, `false` otherwise.
     *
     * @returns {boolean}
     */
  }, {
    key: "isSelected",
    value: function isSelected() {
      return !this.selectedRange.isEmpty();
    }
    /**
     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`
     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header
     * was clicked on any selection layer level.
     *
     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
     * @returns {boolean}
     */
  }, {
    key: "isSelectedByRowHeader",
    value: function isSelectedByRowHeader() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);
    }
    /**
     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`
     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.
     *
     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
     * @returns {boolean}
     */
  }, {
    key: "isEntireRowSelected",
    value: function isEntireRowSelected() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);
    }
    /**
     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`
     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header
     * was clicked on any selection layer level.
     *
     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
     * @returns {boolean}
     */
  }, {
    key: "isSelectedByColumnHeader",
    value: function isSelectedByColumnHeader() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);
    }
    /**
     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`
     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.
     *
     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
     * @returns {boolean}
     */
  }, {
    key: "isEntireColumnSelected",
    value: function isEntireColumnSelected() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);
    }
    /**
     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.
     *
     * @returns {boolean}
     */
  }, {
    key: "isSelectedByAnyHeader",
    value: function isSelectedByAnyHeader() {
      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();
    }
    /**
     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.
     *
     * @returns {boolean}
     */
  }, {
    key: "isSelectedByCorner",
    value: function isSelectedByCorner() {
      return this.selectedByCorner;
    }
    /**
     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
     * the coords object is within selection range.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {boolean}
     */
  }, {
    key: "inInSelection",
    value: function inInSelection(coords) {
      return this.selectedRange.includes(coords);
    }
    /**
     * Returns `true` if the cell corner should be visible.
     *
     * @private
     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.
     */
  }, {
    key: "isCellCornerVisible",
    value: function isCellCornerVisible() {
      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();
    }
    /**
     * Returns `true` if the area corner should be visible.
     *
     * @param {number} layerLevel The layer level.
     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.
     */
  }, {
    key: "isAreaCornerVisible",
    value: function isAreaCornerVisible(layerLevel) {
      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {
        return false;
      }
      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();
    }
    /**
     * Clear the selection by resetting the collected ranges and highlights.
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.selectedRange.clear();
      this.highlight.clear();
    }
    /**
     * Deselects all selected cells.
     */
  }, {
    key: "deselect",
    value: function deselect() {
      if (!this.isSelected()) {
        return;
      }
      this.inProgress = false;
      this.clear();
      this.runLocalHooks("afterDeselect");
    }
    /**
     * Select all cells.
     *
     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`
     * otherwise.
     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`
     * otherwise.
     */
  }, {
    key: "selectAll",
    value: function selectAll() {
      var includeRowHeaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var nrOfRows = this.tableProps.countRows();
      var nrOfColumns = this.tableProps.countCols();
      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {
        return;
      }
      var startCoords = this.tableProps.createCellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);
      this.clear();
      this.setRangeStartOnly(startCoords);
      this.selectedByRowHeader.add(this.getLayerLevel());
      this.selectedByColumnHeader.add(this.getLayerLevel());
      this.setRangeEnd(this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1));
      this.finish();
    }
    /**
     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells
     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such
     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.
     * If the passed ranges have another format the exception will be thrown.
     *
     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.
     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
     */
  }, {
    key: "selectCells",
    value: function selectCells(selectionRanges) {
      var _this2 = this;
      var selectionType = detectSelectionType(selectionRanges);
      if (selectionType === SELECTION_TYPE_EMPTY) {
        return false;
      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {
        throw new Error(toSingleLine(_templateObject$c || (_templateObject$c = _taggedTemplateLiteral$c(["Unsupported format of the selection ranges was passed. To select cells pass \n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \n        columnEnd/columnPropEnd]]) or as an array of CellRange objects."], ["Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects."]))));
      }
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
        propToCol: function propToCol(prop) {
          return _this2.tableProps.propToCol(prop);
        },
        keepDirection: true
      });
      var nrOfRows = this.tableProps.countRows();
      var nrOfColumns = this.tableProps.countCols();
      var isValid = !selectionRanges.some(function(selection) {
        var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray$D(_selectionSchemaNorma, 4), rowStart = _selectionSchemaNorma2[0], columnStart = _selectionSchemaNorma2[1], rowEnd = _selectionSchemaNorma2[2], columnEnd = _selectionSchemaNorma2[3];
        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);
        return !_isValid;
      });
      if (isValid) {
        this.clear();
        arrayEach(selectionRanges, function(selection) {
          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray$D(_selectionSchemaNorma3, 4), rowStart = _selectionSchemaNorma4[0], columnStart = _selectionSchemaNorma4[1], rowEnd = _selectionSchemaNorma4[2], columnEnd = _selectionSchemaNorma4[3];
          _this2.setRangeStartOnly(_this2.tableProps.createCellCoords(rowStart, columnStart), false);
          _this2.setRangeEnd(_this2.tableProps.createCellCoords(rowEnd, columnEnd));
          _this2.finish();
        });
      }
      return isValid;
    }
    /**
     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at
     * `endColumn`.
     *
     * @param {number|string} startColumn Visual column index or column property from which the selection starts.
     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.
     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can
     *                                  take -1 to -N, where -1 means the header closest to the cells.
     *
     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
     */
  }, {
    key: "selectColumns",
    value: function selectColumns(startColumn) {
      var endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
      var headerLevel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var start = typeof startColumn === "string" ? this.tableProps.propToCol(startColumn) : startColumn;
      var end = typeof endColumn === "string" ? this.tableProps.propToCol(endColumn) : endColumn;
      var nrOfColumns = this.tableProps.countCols();
      var nrOfRows = this.tableProps.countRows();
      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);
      if (isValid) {
        this.setRangeStartOnly(this.tableProps.createCellCoords(headerLevel, start));
        this.setRangeEnd(this.tableProps.createCellCoords(nrOfRows - 1, end));
        this.finish();
      }
      return isValid;
    }
    /**
     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.
     *
     * @param {number} startRow Visual row index from which the selection starts.
     * @param {number} [endRow] Visual row index from to the selection finishes.
     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.
     *                                  The value can take -1 to -N, where -1 means the header
     *                                  closest to the cells.
     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
     */
  }, {
    key: "selectRows",
    value: function selectRows(startRow) {
      var endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
      var headerLevel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var nrOfRows = this.tableProps.countRows();
      var nrOfColumns = this.tableProps.countCols();
      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);
      if (isValid) {
        this.setRangeStartOnly(this.tableProps.createCellCoords(startRow, headerLevel));
        this.setRangeEnd(this.tableProps.createCellCoords(endRow, nrOfColumns - 1));
        this.finish();
      }
      return isValid;
    }
    /**
     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var customSelections = this.highlight.getCustomSelections();
      customSelections.forEach(function(customSelection) {
        customSelection.commit();
      });
      if (!this.isSelected()) {
        return;
      }
      var cellHighlight = this.highlight.getCell();
      var currentLayer = this.getLayerLevel();
      cellHighlight.commit().syncWith(this.selectedRange.current());
      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {
        this.highlight.useLayerLevel(layerLevel);
        var areaHighlight = this.highlight.createOrGetArea();
        var headerHighlight = this.highlight.createOrGetHeader();
        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();
        areaHighlight.commit();
        headerHighlight.commit();
        activeHeaderHighlight.commit();
      }
      this.highlight.useLayerLevel(currentLayer);
    }
  }]);
  return Selection2;
}();
mixin(Selection, localHooks$1);
const Selection$1 = Selection;
var $$3 = _export;
var uncurryThis$3 = functionUncurryThis;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var toLength$1 = toLength$7;
var toString$3 = toString$j;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$3 = requireObjectCoercible$e;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var nativeStartsWith = uncurryThis$3("".startsWith);
var stringSlice$1 = uncurryThis$3("".slice);
var min$1 = Math.min;
var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$1("startsWith");
var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function() {
  var descriptor = getOwnPropertyDescriptor$1(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
$$3({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
  startsWith: function startsWith(searchString) {
    var that = toString$3(requireObjectCoercible$3(this));
    notARegExp$1(searchString);
    var index2 = toLength$1(min$1(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString$3(searchString);
    return nativeStartsWith ? nativeStartsWith(that, search, index2) : stringSlice$1(that, index2, index2 + search.length) === search;
  }
});
var regUniversalNewLine = /^(\r\n|\n\r|\r|\n)/;
var regNextCellNoQuotes = /^[^\t\r\n]+/;
var regNextEmptyCell = /^\t/;
function parse(str) {
  var arr = [[""]];
  if (str.length === 0) {
    return arr;
  }
  var column = 0;
  var row = 0;
  var lastLength;
  while (str.length > 0) {
    if (lastLength === str.length) {
      break;
    }
    lastLength = str.length;
    if (str.match(regNextEmptyCell)) {
      str = str.replace(regNextEmptyCell, "");
      column += 1;
      arr[row][column] = "";
    } else if (str.match(regUniversalNewLine)) {
      str = str.replace(regUniversalNewLine, "");
      column = 0;
      row += 1;
      arr[row] = [""];
    } else {
      var nextCell = "";
      if (str.startsWith('"')) {
        var quoteNo = 0;
        var isStillCell = true;
        while (isStillCell) {
          var nextChar = str.slice(0, 1);
          if (nextChar === '"') {
            quoteNo += 1;
          }
          nextCell += nextChar;
          str = str.slice(1);
          if (str.length === 0 || str.match(/^[\t\r\n]/) && quoteNo % 2 === 0) {
            isStillCell = false;
          }
        }
        nextCell = nextCell.replace(/^"/, "").replace(/"$/, "").replace(/["]*/g, function(match2) {
          return new Array(Math.floor(match2.length / 2)).fill('"').join("");
        });
      } else {
        var matchedText = str.match(regNextCellNoQuotes);
        nextCell = matchedText ? matchedText[0] : "";
        str = str.slice(nextCell.length);
      }
      arr[row][column] = nextCell;
    }
  }
  return arr;
}
function stringify(arr) {
  var r2;
  var rLen;
  var c2;
  var cLen;
  var str = "";
  var val;
  for (r2 = 0, rLen = arr.length; r2 < rLen; r2 += 1) {
    cLen = arr[r2].length;
    for (c2 = 0; c2 < cLen; c2 += 1) {
      if (c2 > 0) {
        str += "	";
      }
      val = arr[r2][c2];
      if (typeof val === "string") {
        if (val.indexOf("\n") > -1) {
          str += '"'.concat(val.replace(/"/g, '""'), '"');
        } else {
          str += val;
        }
      } else if (val === null || val === void 0) {
        str += "";
      } else {
        str += val;
      }
    }
    if (r2 !== rLen - 1) {
      str += "\n";
    }
  }
  return str;
}
function _toConsumableArray$m(arr) {
  return _arrayWithoutHoles$m(arr) || _iterableToArray$o(arr) || _unsupportedIterableToArray$V(arr) || _nonIterableSpread$m();
}
function _nonIterableSpread$m() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$V(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$V(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$V(o, minLen);
}
function _iterableToArray$o(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$m(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$V(arr);
}
function _arrayLikeToArray$V(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _typeof$15(obj) {
  "@babel/helpers - typeof";
  return _typeof$15 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$15(obj);
}
function _classCallCheck$1I(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1I(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1I(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1I(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1I(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var copyableLookup = cellMethodLookupFactory("copyable", false);
var DataMap = /* @__PURE__ */ function() {
  function DataMap2(instance, data2, tableMeta) {
    _classCallCheck$1I(this, DataMap2);
    this.instance = instance;
    this.tableMeta = tableMeta;
    this.dataSource = data2;
    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};
    this.colToPropCache = void 0;
    this.propToColCache = void 0;
    this.createMap();
  }
  _createClass$1I(DataMap2, [{
    key: "createMap",
    value: function createMap() {
      var schema = this.getSchema();
      if (typeof schema === "undefined") {
        throw new Error("trying to create `columns` definition but you didn't provide `schema` nor `data`");
      }
      var columns = this.tableMeta.columns;
      var i;
      this.colToPropCache = [];
      this.propToColCache = /* @__PURE__ */ new Map();
      if (columns) {
        var columnsLen = 0;
        var filteredIndex = 0;
        var columnsAsFunc = false;
        if (typeof columns === "function") {
          var schemaLen = deepObjectSize(schema);
          columnsLen = schemaLen > 0 ? schemaLen : this.countFirstRowKeys();
          columnsAsFunc = true;
        } else {
          var maxCols = this.tableMeta.maxCols;
          columnsLen = Math.min(maxCols, columns.length);
        }
        for (i = 0; i < columnsLen; i++) {
          var column = columnsAsFunc ? columns(i) : columns[i];
          if (isObject$7(column)) {
            if (typeof column.data !== "undefined") {
              var index2 = columnsAsFunc ? filteredIndex : i;
              this.colToPropCache[index2] = column.data;
              this.propToColCache.set(column.data, index2);
            }
            filteredIndex += 1;
          }
        }
      } else {
        this.recursiveDuckColumns(schema);
      }
    }
    /**
     * Get the amount of physical columns in the first data row.
     *
     * @returns {number} Amount of physical columns in the first data row.
     */
  }, {
    key: "countFirstRowKeys",
    value: function countFirstRowKeys$1() {
      return countFirstRowKeys(this.dataSource);
    }
    /**
     * Generates columns' translation cache.
     *
     * @param {object} schema An object to generate schema from.
     * @param {number} lastCol The column index.
     * @param {number} parent The property cache for recursive calls.
     * @returns {number}
     */
  }, {
    key: "recursiveDuckColumns",
    value: function recursiveDuckColumns(schema, lastCol, parent) {
      var _this = this;
      var lastColumn = lastCol;
      var propertyParent = parent;
      var prop;
      if (typeof lastColumn === "undefined") {
        lastColumn = 0;
        propertyParent = "";
      }
      if (_typeof$15(schema) === "object" && !Array.isArray(schema)) {
        objectEach(schema, function(value, key) {
          if (value === null) {
            prop = propertyParent + key;
            _this.colToPropCache.push(prop);
            _this.propToColCache.set(prop, lastColumn);
            lastColumn += 1;
          } else {
            lastColumn = _this.recursiveDuckColumns(value, lastColumn, "".concat(key, "."));
          }
        });
      }
      return lastColumn;
    }
    /**
     * Returns property name that corresponds with the given column index.
     *
     * @param {string|number} column Visual column index or another passed argument.
     * @returns {string|number} Column property, physical column index or passed argument.
     */
  }, {
    key: "colToProp",
    value: function colToProp(column) {
      if (Number.isInteger(column) === false) {
        return column;
      }
      var physicalColumn = this.instance.toPhysicalColumn(column);
      if (physicalColumn === null) {
        return column;
      }
      if (this.colToPropCache && isDefined(this.colToPropCache[physicalColumn])) {
        return this.colToPropCache[physicalColumn];
      }
      return physicalColumn;
    }
    /**
     * Translates property into visual column index.
     *
     * @param {string|number} prop Column property which may be also a physical column index.
     * @returns {string|number} Visual column index or passed argument.
     */
  }, {
    key: "propToCol",
    value: function propToCol(prop) {
      var cachedPhysicalIndex = this.propToColCache.get(prop);
      if (isDefined(cachedPhysicalIndex)) {
        return this.instance.toVisualColumn(cachedPhysicalIndex);
      }
      var visualColumn = this.instance.toVisualColumn(prop);
      if (visualColumn === null) {
        return prop;
      }
      return visualColumn;
    }
    /**
     * Returns data's schema.
     *
     * @returns {object}
     */
  }, {
    key: "getSchema",
    value: function getSchema() {
      var schema = this.tableMeta.dataSchema;
      if (schema) {
        if (typeof schema === "function") {
          return schema();
        }
        return schema;
      }
      return this.duckSchema;
    }
    /**
     * Creates row at the bottom of the data array.
     *
     * @param {number} [index] Physical index of the row before which the new row will be inserted.
     * @param {number} [amount=1] An amount of rows to add.
     * @param {string} [source] Source of method call.
     * @fires Hooks#afterCreateRow
     * @returns {number} Returns number of created rows.
     */
  }, {
    key: "createRow",
    value: function createRow(index2) {
      var _this2 = this;
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      var sourceRowsCount = this.instance.countSourceRows();
      var physicalRowIndex = sourceRowsCount;
      var numberOfCreatedRows = 0;
      var rowIndex = index2;
      if (typeof rowIndex !== "number" || rowIndex >= sourceRowsCount) {
        rowIndex = sourceRowsCount;
      }
      if (rowIndex < this.instance.countRows()) {
        physicalRowIndex = this.instance.toPhysicalRow(rowIndex);
      }
      var continueProcess = this.instance.runHooks("beforeCreateRow", rowIndex, amount, source);
      if (continueProcess === false || physicalRowIndex === null) {
        return 0;
      }
      var maxRows = this.tableMeta.maxRows;
      var columnCount = this.instance.countCols();
      var rowsToAdd = [];
      var _loop = function _loop2() {
        var row = null;
        if (_this2.instance.dataType === "array") {
          if (_this2.tableMeta.dataSchema) {
            row = deepClone(_this2.getSchema());
          } else {
            row = [];
            rangeEach(columnCount - 1, function() {
              return row.push(null);
            });
          }
        } else if (_this2.instance.dataType === "function") {
          row = _this2.tableMeta.dataSchema(rowIndex + numberOfCreatedRows);
        } else {
          row = {};
          deepExtend(row, _this2.getSchema());
        }
        rowsToAdd.push(row);
        numberOfCreatedRows += 1;
      };
      while (numberOfCreatedRows < amount && sourceRowsCount + numberOfCreatedRows < maxRows) {
        _loop();
      }
      this.instance.rowIndexMapper.insertIndexes(rowIndex, numberOfCreatedRows);
      this.spliceData(physicalRowIndex, 0, rowsToAdd);
      this.instance.runHooks("afterCreateRow", rowIndex, numberOfCreatedRows, source);
      this.instance.forceFullRender = true;
      return numberOfCreatedRows;
    }
    /**
     * Creates column at the right of the data array.
     *
     * @param {number} [index] Visual index of the column before which the new column will be inserted.
     * @param {number} [amount=1] An amount of columns to add.
     * @param {string} [source] Source of method call.
     * @fires Hooks#afterCreateCol
     * @returns {number} Returns number of created columns.
     */
  }, {
    key: "createCol",
    value: function createCol(index2) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      if (!this.instance.isColumnModificationAllowed()) {
        throw new Error("Cannot create new column. When data source in an object, you can only have as much columns as defined in first data row, data schema or in the 'columns' setting.If you want to be able to add new columns, you have to use array datasource.");
      }
      var dataSource = this.dataSource;
      var maxCols = this.tableMeta.maxCols;
      var columnIndex = index2;
      if (typeof columnIndex !== "number" || columnIndex >= this.instance.countSourceCols()) {
        columnIndex = this.instance.countSourceCols();
      }
      var continueProcess = this.instance.runHooks("beforeCreateCol", columnIndex, amount, source);
      if (continueProcess === false) {
        return 0;
      }
      var physicalColumnIndex = this.instance.countSourceCols();
      if (columnIndex < this.instance.countCols()) {
        physicalColumnIndex = this.instance.toPhysicalColumn(columnIndex);
      }
      var numberOfSourceRows = this.instance.countSourceRows();
      var nrOfColumns = this.instance.countCols();
      var numberOfCreatedCols = 0;
      var currentIndex = physicalColumnIndex;
      while (numberOfCreatedCols < amount && nrOfColumns < maxCols) {
        if (typeof columnIndex !== "number" || columnIndex >= nrOfColumns) {
          if (numberOfSourceRows > 0) {
            for (var row = 0; row < numberOfSourceRows; row += 1) {
              if (typeof dataSource[row] === "undefined") {
                dataSource[row] = [];
              }
              dataSource[row].push(null);
            }
          } else {
            dataSource.push([null]);
          }
        } else {
          for (var _row = 0; _row < numberOfSourceRows; _row++) {
            dataSource[_row].splice(currentIndex, 0, null);
          }
        }
        numberOfCreatedCols += 1;
        currentIndex += 1;
        nrOfColumns += 1;
      }
      this.instance.columnIndexMapper.insertIndexes(columnIndex, numberOfCreatedCols);
      this.instance.runHooks("afterCreateCol", columnIndex, numberOfCreatedCols, source);
      this.instance.forceFullRender = true;
      return numberOfCreatedCols;
    }
    /**
     * Removes row from the data array.
     *
     * @fires Hooks#beforeRemoveRow
     * @fires Hooks#afterRemoveRow
     * @param {number} [index] Visual index of the row to be removed. If not provided, the last row will be removed.
     * @param {number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed.
     * @param {string} [source] Source of method call.
     * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.
     */
  }, {
    key: "removeRow",
    value: function removeRow(index2) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      var rowIndex = Number.isInteger(index2) ? index2 : -amount;
      var removedPhysicalIndexes = this.visualRowsToPhysical(rowIndex, amount);
      var sourceRowsLength = this.instance.countSourceRows();
      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;
      var actionWasNotCancelled = this.instance.runHooks("beforeRemoveRow", rowIndex, removedPhysicalIndexes.length, removedPhysicalIndexes, source);
      if (actionWasNotCancelled === false) {
        return false;
      }
      var numberOfRemovedIndexes = removedPhysicalIndexes.length;
      this.filterData(rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes);
      if (rowIndex < this.instance.countRows()) {
        this.instance.rowIndexMapper.removeIndexes(removedPhysicalIndexes);
        var customDefinedColumns = isDefined(this.tableMeta.columns) || isDefined(this.tableMeta.dataSchema);
        if (this.instance.rowIndexMapper.getNotTrimmedIndexesLength() === 0 && customDefinedColumns === false) {
          this.instance.columnIndexMapper.setIndexesSequence([]);
        }
      }
      this.instance.runHooks("afterRemoveRow", rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes, source);
      this.instance.forceFullRender = true;
      return true;
    }
    /**
     * Removes column from the data array.
     *
     * @fires Hooks#beforeRemoveCol
     * @fires Hooks#afterRemoveCol
     * @param {number} [index] Visual index of the column to be removed. If not provided, the last column will be removed.
     * @param {number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed.
     * @param {string} [source] Source of method call.
     * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.
     */
  }, {
    key: "removeCol",
    value: function removeCol(index2) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      if (this.instance.dataType === "object" || this.tableMeta.columns) {
        throw new Error("cannot remove column with object data source or columns option specified");
      }
      var columnIndex = typeof index2 !== "number" ? -amount : index2;
      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();
      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);
      var descendingLogicColumns = logicColumns.slice(0).sort(function(a, b2) {
        return b2 - a;
      });
      var actionWasNotCancelled = this.instance.runHooks("beforeRemoveCol", columnIndex, amount, logicColumns, source);
      if (actionWasNotCancelled === false) {
        return false;
      }
      var isTableUniform = true;
      var removedColumnsCount = descendingLogicColumns.length;
      var data2 = this.dataSource;
      for (var c2 = 0; c2 < removedColumnsCount; c2++) {
        if (isTableUniform && logicColumns[0] !== logicColumns[c2] - c2) {
          isTableUniform = false;
        }
      }
      if (isTableUniform) {
        for (var r2 = 0, rlen = this.instance.countSourceRows(); r2 < rlen; r2++) {
          data2[r2].splice(logicColumns[0], amount);
        }
      } else {
        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {
          for (var _c = 0; _c < removedColumnsCount; _c++) {
            data2[_r].splice(descendingLogicColumns[_c], 1);
          }
        }
      }
      if (columnIndex < this.instance.countCols()) {
        this.instance.columnIndexMapper.removeIndexes(logicColumns);
        if (this.instance.columnIndexMapper.getNotTrimmedIndexesLength() === 0) {
          this.instance.rowIndexMapper.setIndexesSequence([]);
        }
      }
      this.instance.runHooks("afterRemoveCol", columnIndex, amount, logicColumns, source);
      this.instance.forceFullRender = true;
      return true;
    }
    /**
     * Add/Removes data from the column.
     *
     * @param {number} col Physical index of column in which do you want to do splice.
     * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
     * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
     * @param {Array} [elements] The new columns to add.
     * @returns {Array} Returns removed portion of columns.
     */
  }, {
    key: "spliceCol",
    value: function spliceCol(col, index2, amount) {
      var colData = this.instance.getDataAtCol(col);
      var removed = colData.slice(index2, index2 + amount);
      var after = colData.slice(index2 + amount);
      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        elements[_key - 3] = arguments[_key];
      }
      extendArray(elements, after);
      var i = 0;
      while (i < amount) {
        elements.push(null);
        i += 1;
      }
      to2dArray(elements);
      this.instance.populateFromArray(index2, col, elements, null, null, "spliceCol");
      return removed;
    }
    /**
     * Add/Removes data from the row.
     *
     * @param {number} row Physical index of row in which do you want to do splice.
     * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
     * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
     * @param {Array} [elements] The new rows to add.
     * @returns {Array} Returns removed portion of rows.
     */
  }, {
    key: "spliceRow",
    value: function spliceRow(row, index2, amount) {
      var rowData = this.instance.getSourceDataAtRow(row);
      var removed = rowData.slice(index2, index2 + amount);
      var after = rowData.slice(index2 + amount);
      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        elements[_key2 - 3] = arguments[_key2];
      }
      extendArray(elements, after);
      var i = 0;
      while (i < amount) {
        elements.push(null);
        i += 1;
      }
      this.instance.populateFromArray(row, index2, [elements], null, null, "spliceRow");
      return removed;
    }
    /**
     * Add/remove row(s) to/from the data source.
     *
     * @param {number} index Physical index of the element to add/remove.
     * @param {number} deleteCount Number of rows to remove.
     * @param {Array<object>} elements Row elements to be added.
     */
  }, {
    key: "spliceData",
    value: function spliceData(index2, deleteCount, elements) {
      var _this3 = this;
      var continueSplicing = this.instance.runHooks("beforeDataSplice", index2, deleteCount, elements);
      if (continueSplicing !== false) {
        var newData = [].concat(_toConsumableArray$m(this.dataSource.slice(0, index2)), _toConsumableArray$m(elements), _toConsumableArray$m(this.dataSource.slice(index2)));
        this.dataSource.length = 0;
        newData.forEach(function(row) {
          return _this3.dataSource.push(row);
        });
      }
    }
    /**
     * Filter unwanted data elements from the data source.
     *
     * @param {number} index Visual index of the element to remove.
     * @param {number} amount Number of rows to add/remove.
     * @param {number} physicalRows Physical row indexes.
     */
  }, {
    key: "filterData",
    value: function filterData(index2, amount, physicalRows) {
      var data2 = this.instance.runHooks("filterData", index2, amount, physicalRows);
      if (Array.isArray(data2) === false) {
        data2 = this.dataSource.filter(function(row, rowIndex) {
          return physicalRows.indexOf(rowIndex) === -1;
        });
      }
      this.dataSource.length = 0;
      Array.prototype.push.apply(this.dataSource, data2);
    }
    /**
     * Returns single value from the data array.
     *
     * @param {number} row Visual row index.
     * @param {number} prop The column property.
     * @returns {*}
     */
  }, {
    key: "get",
    value: function get2(row, prop) {
      var physicalRow = this.instance.toPhysicalRow(row);
      var dataRow = this.dataSource[physicalRow];
      var modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
      var value = null;
      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty$2(dataRow, prop)) {
        value = dataRow[prop];
      } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
        var sliced = prop.split(".");
        var out = dataRow;
        if (!out) {
          return null;
        }
        for (var i = 0, ilen = sliced.length; i < ilen; i++) {
          out = out[sliced[i]];
          if (typeof out === "undefined") {
            return null;
          }
        }
        value = out;
      } else if (typeof prop === "function") {
        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);
      }
      if (this.instance.hasHook("modifyData")) {
        var valueHolder = createObjectPropListener(value);
        this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "get");
        if (valueHolder.isTouched()) {
          value = valueHolder.value;
        }
      }
      return value;
    }
    /**
     * Returns single value from the data array (intended for clipboard copy to an external application).
     *
     * @param {number} row Physical row index.
     * @param {number} prop The column property.
     * @returns {string}
     */
  }, {
    key: "getCopyable",
    value: function getCopyable(row, prop) {
      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
        return this.get(row, prop);
      }
      return "";
    }
    /**
     * Saves single value to the data array.
     *
     * @param {number} row Visual row index.
     * @param {number} prop The column property.
     * @param {string} value The value to set.
     */
  }, {
    key: "set",
    value: function set2(row, prop, value) {
      var physicalRow = this.instance.toPhysicalRow(row);
      var newValue = value;
      var dataRow = this.dataSource[physicalRow];
      var modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
      if (this.instance.hasHook("modifyData")) {
        var valueHolder = createObjectPropListener(newValue);
        this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "set");
        if (valueHolder.isTouched()) {
          newValue = valueHolder.value;
        }
      }
      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty$2(dataRow, prop)) {
        dataRow[prop] = newValue;
      } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
        var sliced = prop.split(".");
        var out = dataRow;
        var i = 0;
        var ilen;
        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {
          if (typeof out[sliced[i]] === "undefined") {
            out[sliced[i]] = {};
          }
          out = out[sliced[i]];
        }
        out[sliced[i]] = newValue;
      } else if (typeof prop === "function") {
        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);
      } else {
        dataRow[prop] = newValue;
      }
    }
    /**
     * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.
     * The trick is, the physical row id (stored in settings.data) is not necessary the same
     * as the visual (displayed) row id (e.g. When sorting is applied).
     *
     * @param {number} index Visual row index.
     * @param {number} amount An amount of rows to translate.
     * @returns {number}
     */
  }, {
    key: "visualRowsToPhysical",
    value: function visualRowsToPhysical(index2, amount) {
      var totalRows = this.instance.countSourceRows();
      var logicRows = [];
      var physicRow = (totalRows + index2) % totalRows;
      var rowsToRemove = amount;
      var row;
      while (physicRow < totalRows && rowsToRemove) {
        row = this.instance.toPhysicalRow(physicRow);
        logicRows.push(row);
        rowsToRemove -= 1;
        physicRow += 1;
      }
      return logicRows;
    }
    /**
     *
     * @param {number} index Visual column index.
     * @param {number} amount An amount of rows to translate.
     * @returns {Array}
     */
  }, {
    key: "visualColumnsToPhysical",
    value: function visualColumnsToPhysical(index2, amount) {
      var totalCols = this.instance.countCols();
      var visualCols = [];
      var physicalCol = (totalCols + index2) % totalCols;
      var colsToRemove = amount;
      while (physicalCol < totalCols && colsToRemove) {
        var col = this.instance.toPhysicalColumn(physicalCol);
        visualCols.push(col);
        colsToRemove -= 1;
        physicalCol += 1;
      }
      return visualCols;
    }
    /**
     * Clears the data array.
     */
  }, {
    key: "clear",
    value: function clear2() {
      for (var r2 = 0; r2 < this.instance.countSourceRows(); r2++) {
        for (var c2 = 0; c2 < this.instance.countCols(); c2++) {
          this.set(r2, this.colToProp(c2), "");
        }
      }
    }
    /**
     * Get data length.
     *
     * @returns {number}
     */
  }, {
    key: "getLength",
    value: function getLength() {
      var maxRowsFromSettings = this.tableMeta.maxRows;
      var maxRows;
      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {
        maxRows = 0;
      } else {
        maxRows = maxRowsFromSettings || Infinity;
      }
      var length = this.instance.rowIndexMapper.getNotTrimmedIndexesLength();
      return Math.min(length, maxRows);
    }
    /**
     * Returns the data array.
     *
     * @returns {Array}
     */
  }, {
    key: "getAll",
    value: function getAll2() {
      var start = {
        row: 0,
        col: 0
      };
      var end = {
        row: Math.max(this.instance.countRows() - 1, 0),
        col: Math.max(this.instance.countCols() - 1, 0)
      };
      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {
        return [];
      }
      return this.getRange(start, end, DataMap2.DESTINATION_RENDERER);
    }
    /**
     * Count the number of columns cached in the `colToProp` cache.
     *
     * @returns {number} Amount of cached columns.
     */
  }, {
    key: "countCachedColumns",
    value: function countCachedColumns() {
      return this.colToPropCache.length;
    }
    /**
     * Returns data range as array.
     *
     * @param {object} [start] Start selection position. Visual indexes.
     * @param {object} [end] End selection position. Visual indexes.
     * @param {number} destination Destination of datamap.get.
     * @returns {Array}
     */
  }, {
    key: "getRange",
    value: function getRange(start, end, destination) {
      var output = [];
      var r2;
      var c2;
      var row;
      var maxRows = this.tableMeta.maxRows;
      var maxCols = this.tableMeta.maxCols;
      if (maxRows === 0 || maxCols === 0) {
        return [];
      }
      var getFn = destination === DataMap2.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));
      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));
      for (r2 = Math.min(start.row, end.row); r2 <= rlen; r2++) {
        row = [];
        var physicalRow = r2 >= 0 ? this.instance.toPhysicalRow(r2) : r2;
        for (c2 = Math.min(start.col, end.col); c2 <= clen; c2++) {
          if (physicalRow === null) {
            break;
          }
          row.push(getFn.call(this, r2, this.colToProp(c2)));
        }
        if (physicalRow !== null) {
          output.push(row);
        }
      }
      return output;
    }
    /**
     * Return data as text (tab separated columns).
     *
     * @param {object} [start] Start selection position. Visual indexes.
     * @param {object} [end] End selection position. Visual indexes.
     * @returns {string}
     */
  }, {
    key: "getText",
    value: function getText(start, end) {
      return stringify(this.getRange(start, end, DataMap2.DESTINATION_RENDERER));
    }
    /**
     * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).
     *
     * @param {object} [start] Start selection position. Visual indexes.
     * @param {object} [end] End selection position. Visual indexes.
     * @returns {string}
     */
  }, {
    key: "getCopyableText",
    value: function getCopyableText(start, end) {
      return stringify(this.getRange(start, end, DataMap2.DESTINATION_CLIPBOARD_GENERATOR));
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.instance = null;
      this.tableMeta = null;
      this.dataSource = null;
      this.duckSchema = null;
      this.colToPropCache.length = 0;
      this.propToColCache.clear();
      this.propToColCache = void 0;
    }
  }], [{
    key: "DESTINATION_RENDERER",
    get: (
      /**
       * @type {number}
       */
      function get2() {
        return 1;
      }
    )
    /**
     * @type {number}
     */
  }, {
    key: "DESTINATION_CLIPBOARD_GENERATOR",
    get: function get2() {
      return 2;
    }
  }]);
  return DataMap2;
}();
const DataMap$1 = DataMap;
function expandMetaType(type, metaObject) {
  var validType = typeof type === "string" ? _getItem(type) : type;
  if (!isObject$7(validType)) {
    return;
  }
  var preventSourceOverwrite = isObject$7(metaObject);
  var expandedType = {};
  objectEach(validType, function(value, property) {
    if (property !== "CELL_TYPE" && (!preventSourceOverwrite || preventSourceOverwrite && !hasOwnProperty$2(metaObject, property))) {
      expandedType[property] = value;
    }
  });
  return expandedType;
}
function columnFactory(TableMeta2) {
  var conflictList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  function ColumnMeta2() {
  }
  inherit(ColumnMeta2, TableMeta2);
  for (var i = 0; i < conflictList.length; i++) {
    ColumnMeta2.prototype[conflictList[i]] = void 0;
  }
  return ColumnMeta2;
}
function isUnsignedNumber(value) {
  return Number.isInteger(value) && value >= 0;
}
function assert(condition2, errorMessage) {
  if (!condition2()) {
    throw new Error("Assertion failed: ".concat(errorMessage));
  }
}
function isNullish(variable) {
  return variable === null || variable === void 0;
}
function _typeof$14(obj) {
  "@babel/helpers - typeof";
  return _typeof$14 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$14(obj);
}
const metaSchemaFactory = function() {
  return {
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * The `activeHeaderClassName` option lets you add a CSS class name
     * to every currently-active, currently-selected header (when a whole column or row is selected).
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @since 0.38.2
     * @default 'ht__active_highlight'
     * @category Core
     *
     * @example
     * ```js
     * // add an `ht__active_highlight` CSS class name
     * // to every currently-active, currently-selected header
     * activeHeaderClassName: 'ht__active_highlight',
     * ```
     */
    activeHeaderClassName: "ht__active_highlight",
    /**
     * The `allowEmpty` option determines whether Handsontable accepts the following values:
     * - `null`
     * - `undefined`
     * - `''`
     *
     * You can set the `allowEmpty` option to one of the following:
     *
     * | Setting          | Description                                                                                                                          |
     * | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
     * | `true` (default) | - Accept `null`, `undefined` and `''` values<br>- Mark cells that contain `null`, `undefined` or `''` values as `valid`              |
     * | `false`          | - Don't accept `null`, `undefined` and `''` values<br>- Mark cells that contain `null`, `undefined` or `''` values with as `invalid` |
     *
     * ::: tip
     * To use the [`allowEmpty`](#allowempty) option, you need to set the [`validator`](#validator) option (or the [`type`](#type) option).
     * :::
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // allow empty values in each cell of the entire grid
     * allowEmpty: true,
     *
     * // or
     * columns: [
     *   {
     *     type: 'date',
     *     dateFormat: 'DD/MM/YYYY',
     *     // allow empty values in each cell of the 'date' column
     *     allowEmpty: true
     *   }
     * ],
     * ```
     */
    allowEmpty: true,
    /**
     * The `allowHtml` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) cells' [`source`](#source) data
     * is treated as HTML.
     *
     * You can set the `allowHtml` option to one of the following:
     *
     * | Setting           | Description                                         |
     * | ----------------- | --------------------------------------------------- |
     * | `false` (default) | The [`source`](#source) data is not treated as HTML |
     * | `true`            | The [`source`](#source) data is treated as HTML     |
     *
     * __Warning:__ Setting the `allowHtml` option to `true` can cause serious XSS vulnerabilities.
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     * - [`source`](#source)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['<strong>foo</strong>', '<strong>bar</strong>']
     *   // use HTML in the `source` list
     *   allowHtml: true,
     *   },
     * ],
     * ```
     */
    allowHtml: false,
    /**
     * If set to `true`, the `allowInsertColumn` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Insert column left**
     * - **Insert column right**
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Insert column left' and 'Insert column right' menu items from the context menu
     * allowInsertColumn: false,
     * ```
     */
    allowInsertColumn: true,
    /**
     * If set to `true`, the `allowInsertRow` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Insert row above**
     * - **Insert row below**
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Insert row above' and 'Insert row below' menu items from the context menu
     * allowInsertRow: false,
     * ```
     */
    allowInsertRow: true,
    /**
     * The `allowInvalid` option determines whether Handsontable accepts values
     * that were marked as `invalid` by the [cell validator](@/guides/cell-functions/cell-validator.md).
     *
     * You can set the `allowInvalid` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                        |
     * | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | - Accept `invalid` values<br>- Allow the user to close the [cell editor](@/guides/cell-functions/cell-editor.md) with `invalid` values<br>- Save `invalid` values into the data source                   |
     * | `false`          | - Don't accept `invalid` values<br>- Don't allow the user to close the [cell editor](@/guides/cell-functions/cell-editor.md) with `invalid` values<br>- Don't save `invalid` values into the data source |
     *
     * Setting the `allowInvalid` option to `false` can be useful when used with the [Autocomplete strict mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode).
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [Autocomplete strict mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // don't accept `invalid` values
     * // don't allow the user to close the cell editor
     * // don't save `invalid` values into the data source
     * allowInvalid: false,
     * ```
     */
    allowInvalid: true,
    /**
     * If set to `true`, the `allowRemoveColumn` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Remove column**
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Remove column' menu item from the context menu
     * allowRemoveColumn: false,
     * ```
     */
    allowRemoveColumn: true,
    /**
     * If set to `true`, the `allowRemoveRow` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Remove row**
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Remove row' menu item from the context menu
     * allowRemoveRow: false,
     * ```
     */
    allowRemoveRow: true,
    /**
     * The `autoColumnSize` option configures the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin.
     *
     * You can set the `autoColumnSize` option to one of the following:
     *
     * | Setting   | Description                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin                               |
     * | `true`    | Enable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin with the default configuration |
     * | An object | Enable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin and modify the plugin options  |
     *
     * If you set the `autoColumnSize` option to an object, you can set the following [`AutoColumnSize`](@/api/autoColumnSize.md) plugin options:
     *
     * | Property                | Possible values                 | Description                                                                                                    |
     * | ----------------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------- |
     * | `syncLimit`             | A number \| A percentage string | The number/percentage of columns to keep in sync<br>(default: `50`)                                            |
     * | `useHeaders`            | `true` \| `false`               | When calculating column widths:<br>`true`: use column headers<br>`false`: don't use column headers          |
     * | `samplingRatio`         | A number                        | The number of samples of the same length to be used in column width calculations                               |
     * | `allowSampleDuplicates` | `true` \| `false`               | When calculating column widths:<br>`true`: Allow duplicate samples<br>`false`: Don't allow duplicate samples |
     *
     * By default, the `autoColumnSize` option is set to `undefined`,
     * but the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin acts as enabled.
     * To disable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin completely,
     * set the `autoColumnSize` option to `false`.
     *
     * Using the [`colWidths`](#colWidths) option forcibly disables the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin.
     *
     * Read more:
     * - [Plugins: `AutoColumnSize`](@/api/autoColumnSize.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default undefined
     * @category AutoColumnSize
     *
     * @example
     * ```js
     * autoColumnSize: {
     *   // keep 40% of columns in sync (the rest of columns: async)
     *   syncLimit: '40%',
     *   // when calculating column widths, use column headers
     *   useHeaders: true,
     *   // when calculating column widths, use 10 samples of the same length
     *   samplingRatio: 10,
     *   // when calculating column widths, allow duplicate samples
     *   allowSampleDuplicates: true
     * },
     * ```
     */
    autoColumnSize: void 0,
    /**
     * The `autoRowSize` option configures the [`AutoRowSize`](@/api/autoRowSize.md) plugin.
     *
     * You can set the `autoRowSize` option to one of the following:
     *
     * | Setting   | Description                                                                            |
     * | --------- | -------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`AutoRowSize`](@/api/autoRowSize.md) plugin                               |
     * | `true`    | Enable the [`AutoRowSize`](@/api/autoRowSize.md) plugin with the default configuration |
     * | An object | Enable the [`AutoRowSize`](@/api/autoRowSize.md) plugin and modify the plugin options  |
     *
     * To give Handsontable's [scrollbar](https://handsontable.com/docs/8.0.0/demo-scrolling.html)
     * a proper size, set the `autoRowSize` option to `true`.
     *
     * If you set the `autoRowSize` option to an object, you can set the following [`AutoRowSize`](@/api/autoRowSize.md) plugin options:
     *
     * | Property    | Possible values                 | Description                                                       |
     * | ----------- | ------------------------------- | ----------------------------------------------------------------- |
     * | `syncLimit` | A number \| A percentage string | The number/percentage of rows to keep in sync<br>(default: `500`) |
     *
     * Using the [`rowHeights`](#rowHeights) option forcibly disables the [`AutoRowSize`](@/api/autoRowSize.md) plugin.
     *
     * Read more:
     * - [Plugins: `AutoRowSize`](@/api/autoRowSize.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default undefined
     * @category AutoRowSize
     *
     * @example
     * ```js
     * autoRowSize: {
     *   // keep 40% of rows in sync (the rest of rows: async)
     *   syncLimit: '40%'
     * },
     * ```
     */
    autoRowSize: void 0,
    /**
     * The `autoWrapCol` option determines what happens to current cell selection when you navigate to the grid's top or bottom edge.
     *
     * You can set the `autoWrapCol` option to one of the following:
     *
     * | Setting           | Description                                                                                                             |
     * | ----------------- | ----------------------------------------------------------------------------------------------------------------------- |
     * | `true`            | On reaching the grid's top or bottom edge<br>- Jump to the opposite edge<br>- Select a cell in the previous/next column |
     * | `false` (default) | On reaching the grid's top or bottom edge, stop                                                                         |
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // on reaching the grid's top or bottom edge, jump to the opposite edge
     * autoWrapCol: true,
     * ```
     */
    autoWrapCol: false,
    /**
     * The `autoWrapRow` option determines what happens to current cell selection when you navigate to the grid's left or right edge.
     *
     * You can set the `autoWrapRow` option to one of the following:
     *
     * | Setting           | Description                                                                                                                  |
     * | ----------------- | ---------------------------------------------------------------------------------------------------------------------------- |
     * | `true`            | On reaching the grid's left or right edge:<br>- Jump to the grid's opposite edge<br>- Select a cell in the previous/next row |
     * | `false` (default) | On reaching the grid's left or right edge, stop                                                                              |
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // on reaching the grid's left or right edge, jump to the opposite edge
     * autoWrapRow: true,
     * ```
     */
    autoWrapRow: false,
    /**
     * @description
     * The `bindRowsWithHeaders` option configures the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin.
     *
     * You can set the `bindRowsWithHeaders` option to one of the following:
     *
     * | Setting | Description                                                                  |
     * | ------- | ---------------------------------------------------------------------------- |
     * | `false` | Disable the the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin |
     * | `true`  | Enable the the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin  |
     *
     * Read more:
     * - [Plugins: `BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md)
     *
     * @memberof Options#
     * @type {boolean|string}
     * @default undefined
     * @category BindRowsWithHeaders
     *
     * @example
     * ```js
     * // enable the `BindRowsWithHeaders` plugin
     * bindRowsWithHeaders: true
     * ```
     */
    bindRowsWithHeaders: void 0,
    /**
     * The `cell` option lets you apply [configuration options](@/guides/getting-started/setting-options.md) to individual cells.
     *
     * The `cell` option overwrites the [top-level grid options](@/guides/getting-started/setting-options.md#setting-grid-options),
     * and the [`columns`](#columns) options.
     *
     * Read more:
     * - [Configuration options: Setting cell options](@/guides/getting-started/setting-options.md#setting-cell-options)
     * - [`columns`](#columns)
     *
     * @memberof Options#
     * @type {Array[]}
     * @default []
     * @category Core
     *
     * @example
     * ```js
     * // set the `cell` option to an array of objects
     * cell: [
     *   // make the cell with coordinates (0, 0) read-only
     *   {
     *     row: 0,
     *     col: 0,
     *     readOnly: true
     *   }
     * ],
     * ```
     */
    cell: [],
    /**
     * @description
     * The `cells` option lets you apply any other [configuration options](@/guides/getting-started/setting-options.md) to
     * individual grid elements (columns, rows, cells), based on any logic you implement.
     *
     * The `cells` option overwrites all other options (including options set by [`columns`](#columns) and [`cell`](#cell)).
     * It takes the following parameters:
     *
     * | Parameter | Required | Type             | Description                                                                                                                                                                                                                                                                                                                             |
     * | --------- | -------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `row`     | Yes      | Number           | A physical row index                                                                                                                                                                                                                                                                                                                    |
     * | `column`  | Yes      | Number           | A physical column index                                                                                                                                                                                                                                                                                                                 |
     * | `prop`    | No       | String \| Number | If [`data`](#data) is set to an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), `prop` is the same number as `column`.<br><br>If [`data`](#data) is set to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), `prop` is a property name for the column's data object. |
     *
     * Read more:
     * - [Configuration options: Implementing custom logic](@/guides/getting-started/setting-options.md#implementing-custom-logic)
     * - [Configuration options: Setting row options](@/guides/getting-started/setting-options.md#setting-row-options)
     * - [`columns`](#columns)
     * - [`cell`](#cell)
     *
     * @memberof Options#
     * @type {Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the `cells` option to your custom function
     * cells(row, column, prop) {
     *   const cellProperties = { readOnly: false };
     *   const visualRowIndex = this.instance.toVisualRow(row);
     *   const visualColIndex = this.instance.toVisualColumn(column);
     *
     *   if (visualRowIndex === 0 && visualColIndex === 0) {
     *     cellProperties.readOnly = true;
     *   }
     *
     *   return cellProperties;
     * },
     * ```
     */
    cells: void 0,
    /**
     * The `checkedTemplate` option lets you configure what value
     * a checked [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell has.
     *
     * You can set the `checkedTemplate` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                              |
     * | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns `true`                  |
     * | A string         | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns a string of your choice |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox template](@/guides/cell-types/checkbox-cell-type.md#checkbox-template)
     * - [`getDataAtCell()`](@/api/core.md#getDataAtCell)
     * - [`uncheckedTemplate`](#uncheckedTemplate)
     *
     * @memberof Options#
     * @type {boolean|string|number}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when checked, the cell's value is `true`
     *     // when unchecked, the cell's value is `false`
     *     type: 'checkbox',
     *   },
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     type: 'checkbox',
     *     // when checked, the cell's value is `'Yes'`
     *     checkedTemplate: 'Yes',
     *     // when unchecked, the cell's value is `'No'`
     *     uncheckedTemplate: 'No'
     *  }
     * ],
     * ```
     */
    checkedTemplate: void 0,
    /**
     * The `className` option lets you add CSS class names to every currently-selected element.
     *
     * You can set the `className` option to one of the following:
     *
     * | Setting             | Description                                                      |
     * | ------------------- | ---------------------------------------------------------------- |
     * | A string            | Add a single CSS class name to every currently-selected element  |
     * | An array of strings | Add multiple CSS class names to every currently-selected element |
     *
     * To apply different CSS class names on different levels, use Handsontable's [cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration).
     *
     * Read more:
     * - [Configuration options: Cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`TableClassName`](#TableClassName)
     *
     * @memberof Options#
     * @type {string|string[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to every currently-selected element
     * className: 'your-class-name',
     *
     * // add `first-class-name` and `second-class-name` CSS class names
     * // to every currently-selected element
     * className: ['first-class-name', 'second-class-name'],
     * ```
     */
    className: void 0,
    /**
     * The `colHeaders` option configures your grid's column headers.
     *
     * You can set the `colHeaders` option to one of the following:
     *
     * | Setting  | Description                                                          |
     * | -------- | -------------------------------------------------------------------- |
     * | `true`   | Enable the default column headers ('A', 'B', 'C', ...)               |
     * | `false`  | Disable column headers                                               |
     * | An array | Define your own column headers (e.g. `['One', 'Two', 'Three', ...]`) |
     * | A function | Define your own column headers, using a function                     |
     *
     * Read more:
     * - [Column header](@/guides/columns/column-header.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|Function}
     * @default null
     * @category Core
     *
     * @example
     * ```js
     * // enable the default column headers
     * colHeaders: true,
     *
     * // set your own column headers
     * colHeaders: ['One', 'Two', 'Three'],
     *
     * // set your own column headers, using a function
     * colHeaders: function(visualColumnIndex) {
     *   return `${visualColumnIndex} + : AB`;
     * },
     * ```
     */
    colHeaders: null,
    /**
     * @description
     * The `collapsibleColumns` option configures the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin.
     *
     * You can set the `collapsibleColumns` option to one of the following:
     *
     * | Setting              | Description                                                                                       |
     * | -------------------- | ------------------------------------------------------------------------------------------------- |
     * | `false`              | Disable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                            |
     * | `true`               | Enable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                             |
     * | An array of objects  | Enable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin for selected column headers |
     *
     * Read more:
     * - [Plugins: `CollapsibleColumns`](@/api/collapsibleColumns.md)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default undefined
     * @category CollapsibleColumns
     *
     * @example
     * ```js
     * // enable column collapsing for all headers
     * collapsibleColumns: true,
     *
     * // enable column collapsing for selected headers
     * collapsibleColumns: [
     *   {row: -4, col: 1, collapsible: true},
     *   {row: -3, col: 5, collapsible: true}
     * ],
     * ```
     */
    collapsibleColumns: void 0,
    /**
     * @description
     * The `columnHeaderHeight` option configures the height of column headers.
     *
     * You can set the `columnHeaderHeight` option to one of the following:
     *
     * | Setting  | Description                                         |
     * | -------- | --------------------------------------------------- |
     * | A number | Set the same height for every column header         |
     * | An array | Set different heights for individual column headers |
     *
     * @memberof Options#
     * @type {number|number[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the same height for every column header
     * columnHeaderHeight: 25,
     *
     * // set different heights for individual column headers
     * columnHeaderHeight: [25, 30, 55],
     * ```
     */
    columnHeaderHeight: void 0,
    /**
     * @description
     * The `columns` option lets you apply any other [configuration options](@/guides/getting-started/setting-options.md) to individual columns (or ranges of columns).
     *
     * You can set the `columns` option to one of the following:
     * - An array of objects (each object represents one column)
     * - A function that returns an array of objects
     *
     * The `columns` option overwrites the [top-level grid options](@/guides/getting-started/setting-options.md#setting-grid-options).
     *
     * When you use `columns`, the [`startCols`](#startCols), [`minCols`](#minCols), and [`maxCols`](#maxCols) options are ignored.
     *
     * Read more:
     * - [Configuration options: Setting column options](@/guides/getting-started/setting-options.md#setting-column-options)
     * - [`startCols`](#startCols)
     * - [`minCols`](#minCols)
     * - [`maxCols`](#maxCols)
     * - [`data`](#data)
     *
     * @memberof Options#
     * @type {object[]|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the `columns` option to an array of objects
     * // each object represents one column
     * columns: [
     *   {
     *     // column options for the first (by physical index) column
     *     type: 'numeric',
     *     numericFormat: {
     *       pattern: '0,0.00 $'
     *     }
     *   },
     *   {
     *     // column options for the second (by physical index) column
     *     type: 'text',
     *     readOnly: true
     *   }
     * ],
     *
     * // or set the `columns` option to a function, based on physical indexes
     * columns(index) {
     *   return {
     *     type: index > 0 ? 'numeric' : 'text',
     *     readOnly: index < 1
     *   }
     * }
     * ```
     */
    columns: void 0,
    /**
     * @description
     * The `columnSorting` option configures the [`ColumnSorting`](@/api/columnSorting.md) plugin.
     *
     * You can set the `columnSorting` option to one of the following:
     *
     * | Setting    | Description                                                                                                                            |
     * | ---------- | -------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`     | Enable the [`ColumnSorting`](@/api/columnSorting.md) plugin with the default configuration                                             |
     * | `false`    | Disable the [`ColumnSorting`](@/api/columnSorting.md) plugin                                                                           |
     * | An object  | - Enable the [`ColumnSorting`](@/api/columnSorting.md) plugin<br>- Modify the [`ColumnSorting`](@/api/columnSorting.md) plugin options |
     *
     * If you set the `columnSorting` option to an object,
     * you can set the following [`ColumnSorting`](@/api/columnSorting.md) plugin options:
     *
     * | Option                   | Possible settings                                                                                                                                |
     * | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `indicator`              | `true`: Display an arrow icon in the column header, to indicate a sortable column<br>`false`: Don't display the arrow icon in the column header  |
     * | `headerAction`           | `true`: Enable clicking on the column header to sort the column<br>`false`: Disable clicking on the column header to sort the column             |
     * | `sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place empty cells at the end                                                                        |
     * | `compareFunctionFactory` | A [custom compare function](@/guides/rows/row-sorting.md#custom-compare-functions)                                                                |
     *
     * If you set the `columnSorting` option to an object,
     * you can also sort individual columns at Handsontable's initialization.
     * In the `columnSorting` object, add an object named `initialConfig`,
     * with the following properties:
     *
     * | Option      | Possible settings   | Description                                                      |
     * | ----------- | ------------------- | ---------------------------------------------------------------- |
     * | `column`    | A number            | The index of the column that you want to sort at initialization  |
     * | `sortOrder` | `'asc'` \| `'desc'` | The sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |
     *
     * Read more:
     * - [Row sorting](@/guides/rows/row-sorting.md)
     * - [Row sorting: Custom compare functions](@/guides/rows/row-sorting.md#custom-compare-functions)
     * - [`multiColumnSorting`](#multiColumnSorting)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category ColumnSorting
     *
     * @example
     * ```js
     * // enable the `ColumnSorting` plugin
     * columnSorting: true
     *
     * // enable the `ColumnSorting` plugin with custom configuration
     * columnSorting: {
     *   // sort empty cells as well
     *   sortEmptyCells: true,
     *   // display an arrow icon in the column header
     *   indicator: true,
     *   // disable clicking on the column header to sort the column
     *   headerAction: false,
     *   // add a custom compare function
     *   compareFunctionFactory(sortOrder, columnMeta) {
     *     return function(value, nextValue) {
     *       // some value comparisons which will return -1, 0 or 1...
     *     }
     *   }
     * }
     *
     * // enable the `ColumnSorting` plugin
     * columnSorting: {
     *   // at initialization, sort column 1 in ascending order
     *   initialConfig: {
     *     column: 1,
     *     sortOrder: 'asc'
     *   },
     *   // at initialization, sort column 2 in descending order
     *   initialConfig: {
     *     column: 2,
     *     sortOrder: 'desc'
     *   }
     * }
     * ```
     */
    columnSorting: void 0,
    /**
     * @description
     * The `columnSummary` option configures the [`ColumnSummary`](@/api/columnSummary.md) plugin.
     *
     * You can set the `columnSummary` option to an array of objects.
     * Each object configures a single column summary, using the following properties:
     *
     * | Property                 | Possible values                                                         | Description                                                                                                                  |
     * | ------------------------ | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
     * | `sourceColumn`           | A number                                                                | [Column to summarize](@/guides/columns/column-summary.md#step-2-select-cells-that-you-want-to-summarize)                     |
     * | `ranges`                 | An array                                                                | [Ranges of rows to summarize](@/guides/columns/column-summary.md#step-2-select-cells-that-you-want-to-summarize)             |
     * | `type`                   | `'sum'` \| `'min'` \| `'max'` \| `'count'` \| `'average'` \| `'custom'` | [Summary function](@/guides/columns/column-summary.md#step-3-calculate-your-summary)                                         |
     * | `destinationRow`         | A number                                                                | [Destination cell's row coordinate](@/guides/columns/column-summary.md#step-4-provide-the-destination-cell-s-coordinates)    |
     * | `destinationColumn`      | A number                                                                | [Destination cell's column coordinate](@/guides/columns/column-summary.md#step-4-provide-the-destination-cell-s-coordinates) |
     * | `forceNumeric`           | `true`  \| `false`                                                      | [Treat non-numerics as numerics](@/guides/columns/column-summary.md#forcing-numeric-values)                                  |
     * | `reversedRowCoords`      | `true`  \| `false`                                                      | [Reverse row coordinates](@/guides/columns/column-summary.md#step-5-make-room-for-the-destination-cell)                      |
     * | `suppressDataTypeErrors` | `true`  \| `false`                                                      | [Suppress data type errors](@/guides/columns/column-summary.md#throwing-data-type-errors)                                    |
     * | `readOnly`               | `true`  \| `false`                                                      | Make summary cell read-only                                                                                                  |
     * | `roundFloat`             | `true`  \| `false`                                                      | [Round summary result](@/guides/columns/column-summary.md#rounding-a-column-summary-result)                                  |
     * | `customFunction`         | A function                                                              | [Custom summary function](@/guides/columns/column-summary.md#implementing-a-custom-summary-function)                         |
     *
     * Read more:
     * - [Column summary](@/guides/columns/column-summary.md)
     * - [Plugins: `ColumnSummary`](@/api/columnSummary.md)
     *
     * @memberof Options#
     * @type {object[]|Function}
     * @default undefined
     * @category ColumnSummary
     *
     * @example
     * ```js
     * columnSummary: [
     *   {
     *     sourceColumn: 0,
     *     ranges: [
     *       [0, 2], [4], [6, 8]
     *     ],
     *     type: 'custom',
     *     destinationRow: 4,
     *     destinationColumn: 1,
     *     forceNumeric: true,
     *     reversedRowCoords: true,
     *     suppressDataTypeErrors: false,
     *     readOnly: true,
     *     roundFloat: false,
     *     customFunction(endpoint) {
     *        return 100;
     *     }
     *   }
     * ],
     * ```
     */
    columnSummary: void 0,
    /**
     * The `colWidths` option sets columns' widths, in pixels.
     *
     * In the rendering process, the default column width is 50px. To change it,
     * set the `colWidths` option to one of the following:
     *
     * | Setting     | Description                                                                                          | Example                                                           |
     * | ----------- | ---------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
     * | A number    | Set the same width for every column                                                                  | `colWidths: 100`                                                  |
     * | A string    | Set the same width for every column                                                                  | `colWidths: '100px'`                                              |
     * | An array    | Set widths separately for each column                                                                | `colWidths: [100, 120, undefined]`                                |
     * | A function  | Set column widths dynamically,<br>on each render                                                     | `colWidths(visualColumnIndex) { return visualColumnIndex * 10; }` |
     * | `undefined` | Used by the [modifyColWidth](@/api/hooks.md#modifyColWidth) hook,<br>to detect column width changes. | `colWidths: undefined`                                            |
     *
     * Setting the `colWidths` option disables the {@link AutoColumnSize} plugin.
     *
     * Read more:
     * - [Column width](@/guides/columns/column-width.md)
     * - [Hooks: `modifyColWidth`](@/api/hooks.md#modifyColWidth)
     * - [`autoColumnSize`](#autoColumnSize)
     *
     * @memberof Options#
     * @type {number|number[]|string|string[]|Array<undefined>|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set every column's width to 100px
     * colWidths: 100,
     *
     * // set every column's width to 100px
     * colWidths: '100px',
     *
     * // set the first (by visual index) column's width to 100
     * // set the second (by visual index) column's width to 120
     * // set the third (by visual index) column's width to `undefined`
     * // set any other column's width to the default 50px
     * colWidths: [100, 120, undefined],
     *
     * // set each column's width individually, using a function
     * colWidths(visualColumnIndex) {
     *   return visualColumnIndex * 10;
     * },
     * ```
     */
    colWidths: void 0,
    /**
     * The `commentedCellClassName` option lets you add a CSS class name to cells
     * that have comments.
     *
     * Read more:
     * - [Comments](@/guides/cell-features/comments.md)
     * - [`comments`](#comments)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htCommentCell'
     * @category Core
     *
     * @example
     * ```js
     * // add a `has-comment` CSS class name
     * // to each cell that has a comment
     * commentedCellClassName: 'has-comment',
     * ```
     */
    commentedCellClassName: "htCommentCell",
    /**
     * @description
     * The `comments` option configures the [`Comments`](@/api/comments.md) plugin.
     *
     * You can set the `comments` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                           |
     * | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`    | - Enable the [`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md)                                 |
     * | `false`   | Disable the [`Comments`](@/api/comments.md) plugin                                                                                                                                    |
     * | An object | - Enable the [`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md)<br>- Configure comment settings |
     *
     * If you set the `comments` option to an object, you can configure the following comment options:
     *
     * | Option         | Possible settings           | Description                                         |
     * | -------------- | --------------------------- | --------------------------------------------------- |
     * | `displayDelay` | A number (default: `250`)   | Display comments after a delay (in milliseconds)    |
     * | `readOnly`     | `true` \| `false` (default) | `true`: Make comments read-only                     |
     * | `style`        | An object                   | Set comment boxes' `width` and `height` (in pixels) |
     *
     * Read more:
     * - [Comments](@/guides/cell-features/comments.md)
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [`width`](#width)
     * - [`height`](#height)
     * - [`readOnly`](#readOnly)
     * - [`commentedCellClassName`](#commentedCellClassName)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category Comments
     *
     * @example
     * ```js
     * // enable the `Comments` plugin
     * comments: true,
     *
     * // enable the `Comments` plugin
     * // and configure its settings
     * comments: {
     *   // display all comments with a 1-second delay
     *   displayDelay: 1000,
     *   // make all comments read-only
     *   readOnly: true,
     *   // set the default size of all comment boxes
     *   style: {
     *     width: 300,
     *     height: 100
     *   }
     * }
     * ```
     */
    comments: false,
    /**
     * @description
     * The `contextMenu` option configures the [`ContextMenu`](@/api/contextMenu.md) plugin.
     *
     * You can set the `contextMenu` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                                             |
     * | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`ContextMenu`](@/api/contextMenu.md) plugin                                                                                                                                                |
     * | `true`    | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Use the [default context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-default-options)                 |
     * | An array  | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Modify [individual context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-specific-options)              |
     * | An object | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Apply a [custom context menu configuration](@/guides/accessories-and-menus/context-menu.md#context-menu-with-fully-custom-configuration) |
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [Context menu: Context menu with default options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-default-options)
     * - [Context menu: Context menu with specific options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-specific-options)
     * - [Context menu: Context menu with fully custom configuration options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-fully-custom-configuration)
     * - [Plugins: `ContextMenu`](@/api/contextMenu.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|object}
     * @default undefined
     * @category ContextMenu
     *
     * @example
     * ```js
     * // enable the `ContextMenu` plugin
     * // use the default context menu options
     * contextMenu: true,
     *
     * // enable the `ContextMenu` plugin
     * // and modify individual context menu options
     * contextMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],
     *
     * // enable the `ContextMenu` plugin
     * // and apply a custom context menu configuration
     * contextMenu: {
     *   items: {
     *     'option1': {
     *       name: 'option1'
     *     },
     *     'option2': {
     *       name: 'option2',
     *       submenu: {
     *         items: [
     *           {
     *             key: 'option2:suboption1',
     *             name: 'option2:suboption1',
     *             callback: function(key, options) {
     *               ...
     *             }
     *           },
     *           ...
     *         ]
     *       }
     *     }
     *   }
     * },
     * ```
     */
    contextMenu: void 0,
    /**
     * @description
     * The `copyable` option determines whether a cell's value can be copied to the clipboard or not.
     *
     * You can set the `copyable` option to one of the following:
     *
     * | Setting                                                                                                        | Description                                                                                                            |
     * | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default)                                                                                               | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd> + <kbd>**C**</kbd>, add the cell's value to the clipboard         |
     * | `false`<br>(default for the [`password`](@/guides/cell-types/password-cell-type.md) [cell type](#type))        | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd> + <kbd>**C**</kbd>, add an empty string (`""`) to the clipboard   |
     *
     * Read more:
     * - [Clipboard](@/guides/cell-features/clipboard.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration)
     * - [Password cell type](@/guides/cell-types/password-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // enable copying for each cell of the entire grid
     * copyable: true,
     *
     * // enable copying for individual columns
     * columns: [
     *   {
     *     // enable copying for each cell of this column
     *     copyable: true
     *   },
     *   {
     *     // disable copying for each cell of this column
     *     copyable: false
     *   }
     * ]
     *
     * // enable copying for specific cells
     * cells: [
     *   {
     *     cell: 0,
     *     row: 0,
     *     // disable copying for cell (0, 0)
     *     copyable: false,
     *   }
     * ],
     * ```
     */
    copyable: true,
    /**
     * The `copyPaste` option configures the [`CopyPaste`](@/api/copyPaste.md) plugin.
     *
     * You can set the `copyPaste` option to one of the following:
     *
     * | Setting           | Description                                                                                                            |
     * | ----------------- | ---------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default)  | Enable the [`CopyPaste`](@/api/copyPaste.md) plugin with the default configuration                                     |
     * | `false`           | Disable the [`CopyPaste`](@/api/copyPaste.md) plugin                                                                   |
     * | An object         | - Enable the [`CopyPaste`](@/api/copyPaste.md) plugin<br>- Modify the [`CopyPaste`](@/api/copyPaste.md) plugin options |
     *
     * If you set the `copyPaste` option to an object, you can set the following `CopyPaste` plugin options:
     *
     * | Option         | Possible settings                                  | Description                                                                                                                                                                             |
     * | -------------- | -------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `columnsLimit` | A number (default: `Infinity`)                       | A maximum number of columns that can be copied                                                                                                                                        |
     * | `rowsLimit`    | A number (default: `Infinity`)                       | A maximum number of columns that can be copied                                                                                                                                        |
     * | `pasteMode`    | `'overwrite'` \| `'shift_down'` \| `'shift_right'` | When pasting:<br>`'overwrite'`: overwrite currently-selected cells<br>`'shift_down'`: move currently-selected cells down<br>`'shift_right'`: move currently-selected cells to the right |
     * | `uiContainer`  | An HTML element                                    | A UI container for the secondary focusable element                                                                                                                                      |
     *
     * Read more:
     * - [Plugins: `CopyPaste`](@/api/copyPaste.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default true
     * @category CopyPaste
     *
     * @example
     * ```js
     * // disable the `CopyPaste` plugin
     * copyPaste: false,
     *
     * // enable the `CopyPaste` plugin
     * // and modify the `CopyPaste` plugin options
     * copyPaste: {
     *   // set the maximum number of columns that can be copied
     *   columnsLimit: 25,
     *   // set the maximum number of rows that can be copied
     *   rowsLimit: 50,
     *   // set the paste behavior
     *   pasteMode: 'shift_down',
     *   // set the UI container
     *   uiContainer: document.body,
     * },
     * ```
     */
    copyPaste: true,
    /**
     * The `correctFormat` option configures whether incorrectly-formatted times and dates are amended or not.
     *
     * When the user enters dates and times, Handsontable can automatically adjust their format
     * to match the [`dateFormat`](#dateFormat) and [`timeFormat`](@/guides/cell-types/time-cell-type.md) settings.
     *
     * You can set the `correctFormat` option to one of the following:
     *
     * | Setting           | Description                                                                                                                                               |
     * | ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Don't correct the format of the entered date or time (treat the entered date or time as invalid)                                                          |
     * | `true`            | Correct the format of the entered date or time to match the [`dateFormat`](#dateFormat) or [`timeFormat`](@/guides/cell-types/time-cell-type.md) settings |
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type.md)
     * - [Time cell type](@/guides/cell-types/time-cell-type.md)
     * - [`dateFormat`](#dateFormat)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `date`
     *   type: 'date',
     *   // for every `date` cell of this column, set the date format to `YYYY-MM-DD`
     *   dateFormat: 'YYYY-MM-DD',
     *   // enforce the `YYYY-MM-DD` date format
     *   correctFormat: true
     *   },
     *
     *   {
     *   // set the `type` of each cell in this column to `time`
     *   type: 'time',
     *   // for every `time` cell of this column, set the time format to `h:mm:ss a`
     *   timeFormat: 'h:mm:ss a',
     *   // enforce the `h:mm:ss a` time format
     *   correctFormat: true
     *   },
     * ],
     * ```
     */
    correctFormat: false,
    /**
     * The `currentColClassName` option lets you add a CSS class name
     * to each cell of the currently-visible, currently-selected columns.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to each cell of the currently-visible, currently-selected columns
     * currentColClassName: 'your-class-name',
     * ```
     */
    currentColClassName: void 0,
    /**
     * The `currentHeaderClassName` option lets you add a CSS class name
     * to every currently-visible, currently-selected header.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'ht__highlight'
     * @category Core
     *
     * @example
     * ```js
     * // add an `ht__highlight` CSS class name
     * // to every currently-visible, currently-selected header
     * currentHeaderClassName: 'ht__highlight',
     * ```
     */
    currentHeaderClassName: "ht__highlight",
    /**
     * The `currentRowClassName` option lets you add a CSS class name
     * to each cell of the currently-visible, currently-selected rows.
     *
     * Read more:
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to each cell of the currently-visible, currently-selected rows
     * currentRowClassName: 'your-class-name',
     * ```
     */
    currentRowClassName: void 0,
    /**
     * @description
     * The `customBorders` option configures the [`CustomBorders`](@/api/customBorders.md) plugin.
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * (and add its menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md)),
     * set the `customBorders` option to `true`.
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * and add a predefined border around a particular cell,
     * set the `customBorders` option to an array of objects.
     * Each object represents a border configuration for one cell, and has the following properties:
     *
     * | Property | Sub-properties     | Types                              | Description                                                       |
     * | -------- | ------------------ | ---------------------------------- | ----------------------------------------------------------------- |
     * | `row`    | -                  | `row`: Number                      | The cell's row coordinate.                                        |
     * | `col`    | -                  | `col`: Number                      | The cell's column coordinate.                                     |
     * | `start`  | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `start` sets the width (`width`) and color (`color`) of the left-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `start` sets the width (`width`) and color (`color`) of the right-hand border. |
     * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `end` sets the width (`width`) and color (`color`) of the right-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `end` sets the width (`width`) and color (`color`) of the left-hand border. |
     * | `top`    | `width`<br>`color` | `width`: Number<br>`color`: String | Sets the width (`width`) and color (`color`) of the top border. |
     * | `bottom` | `width`<br>`color` | `width`: Number<br>`color`: String | Sets the width (`width`) and color (`color`) of the bottom border. |
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * and add a predefined border around a range of cells,
     * set the `customBorders` option to an array of objects.
     * Each object represents a border configuration for a single range of cells, and has the following properties:
     *
     * | Property | Sub-properties                               | Types                                                            | Description                                                                                  |
     * | -------- | -------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------- |
     * | `range`  | `from` {`row`, `col`}<br>`to` {`row`, `col`} | `from`: Object<br>`to`: Object<br>`row`: Number<br>`col`: Number | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default):<br>- `from` selects the range's top-left corner.<br>- `to` selects the range's bottom-right corner.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: <br>- `from` selects the range's top-right corner.<br>- `to` selects the range's bottom-left corner. |
     * | `start`  | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `start` sets the width (`width`) and color (`color`) of the left-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `start` sets the width (`width`) and color (`color`) of the right-hand border. |
     * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `end` sets the width (`width`) and color (`color`) of the right-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `end` sets the width (`width`) and color (`color`) of the left-hand border. |
     * | `top`    | `width`<br>`color`                           | `width`: Number<br>`color`: String                               | Sets the width (`width`) and color (`color`) of the top border. |
     * | `bottom` | `width`<br>`color`                           | `width`: Number<br>`color`: String                               | Sets the width (`width`) and color (`color`) of the bottom border. |
     *
     * Read more:
     * - [Formatting cells: Custom cell borders](@/guides/cell-features/formatting-cells.md#custom-cell-borders)
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [Plugins: `CustomBorders`](@/api/customBorders.md)
     * - [Layout direction](@/guides/internationalization/layout-direction.md)
     * - [`layoutDirection`](#layoutDirection)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category CustomBorders
     *
     * @example
     * ```js
     * // enable the `CustomBorders` plugin
     * customBorders: true,
     *
     * // enable the `CustomBorders` plugin
     * // and add a predefined border for a particular cell
     * customBorders: [
     *   // add an object with a border configuration for one cell
     *   {
     *     // set the cell's row coordinate
     *     row: 2,
     *     // set the cell's column coordinate
     *     col: 2,
     *     // set the left/right border's width and color
     *     start: {
     *       width: 2,
     *       color: 'red'
     *     },
     *     // set the right/left border's width and color
     *     end: {
     *       width: 1,
     *       color: 'green'
     *     },
     *     // set the top border's width and color
     *     top: '',
     *     // set the bottom border's width and color
     *     bottom: ''
     *   }
     * ],
     *
     * // enable the `CustomBorders` plugin
     * // and add a predefined border for a range of cells
     * customBorders: [
     *   // add an object with a border configuration for one range of cells
     *   {
     *     // select a range of cells
     *     range: {
     *       // set the range's top-left corner
     *       from: {
     *         row: 1,
     *         col: 1
     *       },
     *       // set the range's bottom-right corner
     *       to: {
     *         row: 3,
     *         col: 4
     *       }
     *     },
     *     // set the left/right border's width and color
     *     start: {
     *       width: 2,
     *       color: 'red'
     *     },
     *     // set the right/left border's width and color
     *     end: {},
     *     // set the top border's width and color
     *     top: {},
     *     // set the bottom border's width and color
     *     bottom: {}
     *   }
     * ],
     * ```
     */
    customBorders: false,
    /**
     * @description
     * The `data` option sets the initial [data](@/guides/getting-started/binding-to-data.md) of your Handsontable instance.
     *
     * Handsontable's data is bound to your source data by reference (i.e. when you edit Handsontable's data, your source data alters as well).
     *
     * You can set the `data` option:
     * - Either to an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).
     * - Or to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects).
     *
     * If you don't set the `data` option (or set it to `null`), Handsontable renders as an empty 5x5 grid by default.
     *
     * Read more:
     * - [Binding to data](@/guides/getting-started/binding-to-data.md)
     * - [`dataSchema`](#dataSchema)
     * - [`startRows`](#startRows)
     * - [`startCols`](#startCols)
     *
     * @memberof Options#
     * @type {Array[]|object[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // as an array of arrays
     * data: [
     *   ['A', 'B', 'C'],
     *   ['D', 'E', 'F'],
     *   ['G', 'H', 'J']
     * ]
     *
     * // as an array of objects
     * data: [
     *   {id: 1, name: 'Ted Right'},
     *   {id: 2, name: 'Frank Honest'},
     *   {id: 3, name: 'Joan Well'},
     *   {id: 4, name: 'Gail Polite'},
     *   {id: 5, name: 'Michael Fair'},
     * ]
     * ```
     */
    data: void 0,
    /**
     * @description
     * When the [`data`](#data) option is set to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects)
     * (or is empty), the `dataSchema` option defines the structure of new rows.
     *
     * Using the `dataSchema` option, you can start out with an empty grid.
     *
     * You can set the `dataSchema` option to one of the following:
     * - An object
     * - A function
     *
     * Read more:
     * - [Binding to data: Array of objects with custom data schema](@/guides/getting-started/binding-to-data.md#array-of-objects-with-custom-data-schema)
     * - [Binding to data: Function data source and schema](@/guides/getting-started/binding-to-data.md#function-data-source-and-schema)
     * - [`data`](#data)
     *
     * @memberof Options#
     * @type {object|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // with `dataSchema`, you can start with an empty grid
     * data: null,
     * dataSchema: {id: null, name: {first: null, last: null}, address: null},
     * colHeaders: ['ID', 'First Name', 'Last Name', 'Address'],
     * columns: [
     *   {data: 'id'},
     *   {data: 'name.first'},
     *   {data: 'name.last'},
     *   {data: 'address'}
     * ],
     * startRows: 5,
     * minSpareRows: 1
     * ```
     */
    dataSchema: void 0,
    /**
     * The `dateFormat` option configures the date format accepted by [`date`](@/guides/cell-types/date-cell-type.md) cells.
     *
     * You can set the `dateFormat` option to a string with a proper date format. The default value is: `'DD/MM/YYYY'`.
     *
     * To automatically correct dates whose format doesn't match the `dateFormat` setting, use the [`correctFormat`](#correctFormat) option.
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type.md)
     * - [`correctFormat`](#correctFormat)
     * - [`defaultDate`](#defaultDate)
     *
     * @memberof Options#
     * @type {string}
     * @default 'DD/MM/YYYY'
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `date`
     *   type: 'date',
     *   // for every `date` cell of this column, set the date format to `YYYY-MM-DD`
     *   dateFormat: 'YYYY-MM-DD',
     *   },
     * ],
     * ```
     */
    dateFormat: "DD/MM/YYYY",
    /**
     * The `datePickerConfig` option configures the `date` [cell editor](@/guides/cell-functions/cell-editor.md)'s date picker, which uses an external dependency: [Pikaday](https://github.com/Pikaday/Pikaday/tree/1.8.2).
     *
     * You can set the `datePickerConfig` option to an object with any of the available [Pikaday options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration),
     * except for the following, which are always overwritten by the `date` [cell editor](@/guides/cell-functions/cell-editor.md):
     * - `bound`
     * - `container`
     * - `field`
     * - `trigger`
     *
     * If the `datePickerConfig` option is not defined, the `date` [cell editor](@/guides/cell-functions/cell-editor.md) overwrites the following [Pikaday options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration) as well:
     *
     * | Pikaday option       | Handsontable's setting |
     * | -------------------- | ---------------------- |
     * | `format`             | `'DD/MM/YYYY'`         |
     * | `reposition`         | `false`                |
     *
     * Read more:
     * - [`editor`](#editor)
     * - [`dateFormat`](#dateFormat)
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [All Pikaday options &#8594;](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Core
     */
    datePickerConfig: void 0,
    /**
     * The `defaultDate` option configures the date displayed
     * in empty [`date`](@/guides/cell-types/date-cell-type.md) cells.
     *
     * You can set the `defaultDate` option to a string.
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type.md)
     * - [`dateFormat`](#dateFormat)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `date`
     *     type: 'date',
     *     // in every empty `date` cell of this column, display `2015-02-02`
     *     defaultDate: '2015-02-02'
     *   }
     * ],
     * ```
     */
    defaultDate: void 0,
    /**
     * @description
     * The `disableVisualSelection` option configures how
     * [selection](@/guides/cell-features/selection.md) is shown.
     *
     * You can set the `disableVisualSelection` option to one of the following:
     *
     * | Setting           | Description                                                                                         |
     * | ----------------- | --------------------------------------------------------------------------------------------------- |
     * | `false` (default) | - Show single-cell selection<br>- Show range selection<br>- Show header selection                   |
     * | `true`            | - Don't show single-cell selection<br>- Don't show range selection<br>- Don't show header selection |
     * | `'current'`       | - Don't show single-cell selection<br>- Show range selection<br>- Show header selection             |
     * | `'area'`          | - Show single-cell selection<br>- Don't show range selection<br>- Show header selection             |
     * | `'header'`        | - Show single-cell selection<br>- Show range selection<br>- Don't show header selection             |
     * | An array          | A combination of `'current'`, `'area'`, and/or `'header'`                                           |
     *
     * Read more:
     * - [Selection](@/guides/cell-features/selection.md)
     *
     * @memberof Options#
     * @type {boolean|string|string[]}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // don't show single-cell selection
     * // don't show range selection
     * // don't show header selection
     * disableVisualSelection: true,
     *
     * // don't show single-cell selection
     * // show range selection
     * // show header selection
     * disableVisualSelection: 'current',
     *
     * // don't show single-cell selection
     * // don't show range selection
     * // show header selection
     * disableVisualSelection: ['current', 'area'],
     * ```
     */
    disableVisualSelection: false,
    /**
     * @description
     * The `dragToScroll` option configures the [`DragToScroll`](@/api/dragToScroll.md) plugin.
     *
     * You can set the `dragToScroll` option to one of the following:
     *
     * | Setting          | Description                                                                 |
     * | ---------------- | --------------------------------------------------------------------------- |
     * | `true` (default) | When selection reaches the edge of the grid's viewport, scroll the viewport |
     * | `false`          | Don't scroll the viewport                                                   |
     *
     * Read more:
     * - [Plugins: `DragToScroll`](@/api/dragToScroll.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category DragToScroll
     *
     * @example
     * ```js
     * // when selection reaches the edge of the grid's viewport, scroll the viewport
     * dragToScroll: true,
     * ```
     */
    dragToScroll: true,
    /**
     * The `dropdownMenu` option configures the [`DropdownMenu`](@/api/dropdownMenu.md) plugin.
     *
     * You can set the `dropdownMenu` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin                                                                                                                                   |
     * | `true`    | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Use the [default context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-default-options)    |
     * | An array  | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Modify [individual context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-specific-options) |
     * | An object | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Apply a custom dropdown menu configuration                                                                                  |
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [Plugins: `DropdownMenu`](@/api/dropdownMenu.md)
     *
     * @memberof Options#
     * @type {boolean|object|string[]}
     * @default undefined
     * @category DropdownMenu
     *
     * @example
     * ```js
     * // enable the `DropdownMenu` plugin
     * // use the default context menu options
     * dropdownMenu: true,
     *
     * // enable the `DropdownMenu` plugin
     * // and modify individual context menu options
     * dropdownMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],
     *
     * // enable the `DropdownMenu` plugin
     * // and apply a custom dropdown menu configuration
     * dropdownMenu: {
     *   items: {
     *     'option1': {
     *       name: 'option1'
     *     },
     *     'option2': {
     *       name: 'option2',
     *       submenu: {
     *         items: [
     *           {
     *             key: 'option2:suboption1',
     *             name: 'option2:suboption1',
     *             callback(key, options) {
     *               ...
     *             }
     *           },
     *           ...
     *         ]
     *       }
     *     }
     *   }
     * },
     * ```
     */
    dropdownMenu: void 0,
    /**
     * The `editor` option sets a [cell editor](@/guides/cell-functions/cell-editor.md) for a cell.
     *
     * You can set the `editor` option to one of the following [cell editor aliases](@/guides/cell-functions/cell-editor.md):
     *
     * | Alias               | Cell editor function                                                       |
     * | ------------------- | -------------------------------------------------------------------------- |
     * | A custom alias      | Your [custom cell editor](@/guides/cell-functions/cell-editor.md) function |
     * | `'autocomplete'`    | `AutocompleteEditor`                                                       |
     * | `'base'`            | `BaseEditor`                                                               |
     * | `'checkbox'`        | `CheckboxEditor`                                                           |
     * | `'date'`            | `DateEditor`                                                               |
     * | `'dropdown'`        | `DropdownEditor`                                                           |
     * | `'handsontable'`    | `HandsontableEditor`                                                       |
     * | `'numeric'`         | `NumericEditor`                                                            |
     * | `'password'`        | `PasswordEditor`                                                           |
     * | `'select'`          | `SelectEditor`                                                             |
     * | `'text'`            | `TextEditor`                                                               |
     * | `'time'`            | `TimeEditor`                                                               |
     *
     * To disable editing cells through cell editors,
     * set the `editor` option to `false`.
     * You'll still be able to change cells' content through Handsontable's API
     * or through plugins (e.g. [`CopyPaste`](@/api/copyPaste.md)), though.
     *
     * To set the [`editor`](#editor), [`renderer`](#renderer), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {string|Function|boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // use the `numeric` editor for each cell of the entire grid
     * editor: 'numeric',
     *
     * // apply the `editor` option to individual columns
     * columns: [
     *   {
     *     // use the `autocomplete` editor for each cell of this column
     *     editor: 'autocomplete'
     *   },
     *   {
     *     // disable editing cells through cell editors for each cell of this column
     *     editor: false
     *   }
     * ]
     * ```
     */
    editor: void 0,
    /**
     * The `enterBeginsEditing` option configures the action of the <kbd>**Enter**</kbd> key.
     *
     * You can set the `enterBeginsEditing` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                                               |
     * | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | - On pressing <kbd>**Enter**</kbd> once, enter the editing mode of the active cell<br>- On pressing <kbd>**Enter**</kbd> twice, move to another cell,<br>as configured by the [`enterMoves`](#enterMoves) setting |
     * | `false`          | - On pressing <kbd>**Enter**</kbd> once, move to another cell,<br>as configured by the [`enterMoves`](#enterMoves) setting                                                                                    |
     *
     * Read more:
     * - [`enterMoves`](#enterMoves)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // press Enter once to start editing
     * // press Enter twice to move to another cell
     * enterBeginsEditing: true,
     *
     * // press Enter once to move to another cell
     * enterBeginsEditing: false,
     * ```
     */
    enterBeginsEditing: true,
    /**
     * The `enterMoves` option configures the action of the <kbd>**Enter**</kbd> key.
     *
     * If the [`enterBeginsEditing`](#enterBeginsEditing) option is set to `true`,
     * the `enterMoves` setting applies to the **second** pressing of the <kbd>**Enter**</kbd> key.
     *
     * If the [`enterBeginsEditing`](#enterBeginsEditing) option is set to `false`,
     * the `enterMoves` setting applies to the **first** pressing of the <kbd>**Enter**</kbd> key.
     *
     * You can set the `enterMoves` option to an object with the following properties
     * (or to a function that returns such an object):
     *
     * | Property | Type   | Description                                                                                                                                              |
     * | -------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `col`    | Number | - On pressing <kbd>**Enter**</kbd>, move selection `col` columns right<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Enter**</kbd>, move selection `col` columns left |
     * | `row`    | Number | - On pressing <kbd>**Enter**</kbd>, move selection `row` rows down<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Enter**</kbd>, move selection `row` rows up          |
     *
     * Read more:
     * - [`enterBeginsEditing`](#enterBeginsEditing)
     *
     * @memberof Options#
     * @type {object|Function}
     * @default {col: 0, row: 1}
     * @category Core
     *
     * @example
     * ```js
     * // on pressing Enter, move selection 1 column right and 1 row down
     * // on pressing Shift+Enter, move selection 1 column left and 1 row up
     * enterMoves: {col: 1, row: 1},
     *
     * // the same setting, as a function
     * // `event` is a DOM Event object received on pressing Enter
     * // you can use it to check whether the user pressed Enter or Shift+Enter
     * enterMoves(event) {
     *   return {col: 1, row: 1};
     * },
     * ```
     */
    enterMoves: {
      col: 0,
      row: 1
    },
    /**
     * The `fillHandle` option configures the [Autofill](@/api/autofill.md) plugin.
     *
     * You can set the `fillHandle` option to one the following:
     *
     * | Setting        | Description                                                                |
     * | -------------- | -------------------------------------------------------------------------- |
     * | `true`         | - Enable autofill in all directions<br>- Add the fill handle               |
     * | `false`        | Disable autofill                                                           |
     * | `'vertical'`   | - Enable vertical autofill<br>- Add the fill handle                        |
     * | `'horizontal'` | - Enable horizontal autofill<br>- Add the fill handle                      |
     * | An object      | - Enable autofill<br>- Add the fill handle<br>- Configure autofill options |
     *
     * If you set the `fillHandle` option to an object, you can configure the following autofill options:
     *
     * | Option          | Possible settings              | Description                                                                                               |
     * | --------------- | ------------------------------ | --------------------------------------------------------------------------------------------------------- |
     * | `autoInsertRow` | `true` (default) \| `false`    | `true`: When you reach the grid's bottom, add new rows<br>`false`: When you reach the grid's bottom, stop |
     * | `direction`     | `'vertical'` \| `'horizontal'` | `'vertical'`: Enable vertical autofill<br>`'horizontal'`: Enable horizontal autofill                      |
     *
     * Read more:
     * - [AutoFill values](@/guides/cell-features/autofill-values.md)
     *
     * @memberof Options#
     * @type {boolean|string|object}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // enable autofill in all directions
     * // with `autoInsertRow` enabled
     * fillHandle: true,
     *
     * // enable vertical autofill
     * // with `autoInsertRow` enabled
     * fillHandle: 'vertical',
     *
     * // enable horizontal autofill
     * // with `autoInsertRow` enabled
     * fillHandle: 'horizontal',
     *
     * // enable autofill in all directions
     * // with `autoInsertRow` disabled
     * fillHandle: {
     *   autoInsertRow: false,
     * },
     *
     * // enable vertical autofill
     * // with `autoInsertRow` disabled
     * fillHandle: {
     *   autoInsertRow: false,
     *   direction: 'vertical'
     * },
     * ```
     */
    fillHandle: {
      autoInsertRow: false
    },
    /**
     * The `filter` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'
     * lists are updated by the end user's input.
     *
     * You can set the `filter` option to one of the following:
     *
     * | Setting          | Description                                                                                                           |
     * | ---------------- | --------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | When the end user types into the input area, only options matching the input are displayed                            |
     * | `false`          | When the end user types into the input area, all options are displayed<br>(options matching the input are put in bold |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [`source`](#source)
     * - [`filteringCaseSensitive`](#filteringCaseSensitive)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C'],
     *   // when the end user types in `A`, display only the A option
     *   // when the end user types in `B`, display only the B option
     *   // when the end user types in `C`, display only the C option
     *   filter: true
     * }],
     * ```
     */
    filter: true,
    /**
     * The `filteringCaseSensitive` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'
     * input is case-sensitive.
     *
     * You can set the `filteringCaseSensitive` option to one of the following:
     *
     * | Setting           | Description                                                                                        |
     * | ----------------- | -------------------------------------------------------------------------------------------------- |
     * | `false` (default) | [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells' input is not case-sensitive |
     * | `true`            | [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells' input is case-sensitive     |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [`source`](#source)
     * - [`filter`](#filter)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     source: [ ... ],
     *     // match case while searching autocomplete options
     *     filteringCaseSensitive: true
     *   }
     * ],
     * ```
     */
    filteringCaseSensitive: false,
    /**
     * The `filters` option configures the [`Filters`](@/api/filters.md) plugin.
     *
     * You can set the `filters` option to one of the following:
     *
     * | Setting | Description                                      |
     * | ------- | ------------------------------------------------ |
     * | `false` | Disable the [`Filters`](@/api/filters.md) plugin |
     * | `true`  | Enable the [`Filters`](@/api/filters.md) plugin  |
     *
     * Read more:
     * - [Column filter](@/guides/columns/column-filter.md)
     * - [Plugins: `Filters`](@/api/filters.md)
     * - [`dropdownMenu`](#dropdownMenu)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Filters
     *
     * @example
     * ```js
     * // enable the `Filters` plugin
     * filters: true,
     * ```
     */
    filters: void 0,
    /**
     * `fixedColumnsLeft` is a legacy option.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default), `fixedColumnsLeft` acts like the [`fixedColumnsStart`](#fixedColumnsStart) option.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is RTL, using `fixedColumnsLeft` throws an error.
     *
     * Use [`fixedColumnsStart`](#fixedColumnsStart), which works in any layout direction.
     *
     * Read more:
     * - [`fixedColumnsStart`](#fixedcolumnsstart)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the first 3 columns from the left
     * fixedColumnsLeft: 3,
     * ```
     */
    fixedColumnsLeft: 0,
    /**
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default), the `fixedColumnsStart` option sets the number of [frozen columns](@/guides/columns/column-freezing.md) at the left-hand edge of the grid.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is RTL, the `fixedColumnsStart` option sets the number of [frozen columns](@/guides/columns/column-freezing.md) at the right-hand edge of the grid.
     *
     * Read more:
     * - [Column freezing](@/guides/columns/column-freezing.md)
     * - [Layout direction](@/guides/internationalization/layout-direction.md)
     * - [`fixedColumnsLeft`](#fixedcolumnsleft)
     * - [`layoutDirection`](#layoutDirection)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // when `layoutDirection` is set to `inherit` (default)
     * // freeze the first 3 columns from the left or from the right
     * // depending on your HTML document's `dir` attribute
     * layoutDirection: 'inherit',
     * fixedColumnsStart: 3,
     *
     * // when `layoutDirection` is set to `rtl`
     * // freeze the first 3 columns from the right
     * // regardless of your HTML document's `dir` attribute
     * layoutDirection: 'rtl',
     * fixedColumnsStart: 3,
     *
     * // when `layoutDirection` is set to `ltr`
     * // freeze the first 3 columns from the left
     * // regardless of your HTML document's `dir` attribute
     * layoutDirection: 'ltr',
     * fixedColumnsStart: 3,
     * ```
     */
    fixedColumnsStart: 0,
    /**
     * The `fixedRowsBottom` option sets the number of [frozen rows](@/guides/rows/row-freezing.md)
     * at the bottom of the grid.
     *
     * Read more:
     * - [Row freezing](@/guides/rows/row-freezing.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the bottom 3 rows
     * fixedRowsBottom: 3,
     * ```
     */
    fixedRowsBottom: 0,
    /**
     * The `fixedRowsTop` option sets the number of [frozen rows](@/guides/rows/row-freezing.md) at the top of the grid.
     *
     * Read more:
     * - [Row freezing](@/guides/rows/row-freezing.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the top 3 rows
     * fixedRowsTop: 3,
     * ```
     */
    fixedRowsTop: 0,
    /**
     * The `formulas` option configures the [`Formulas`](@/api/formulas.md) plugin.
     *
     * The [`Formulas`](@/api/formulas.md) plugin uses the [HyperFormula](https://handsontable.github.io/hyperformula/) calculation engine.
     * To install [HyperFormula](https://handsontable.github.io/hyperformula/), read the following:
     * - [Formula calculation: Initialization methods](@/guides/formulas/formula-calculation.md#initialization-methods)
     *
     * You can set the `formulas` option to an object with the following properties:
     *
     * | Property    | Possible values                                                                                                                                                                                                        |
     * | ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `engine`    | `HyperFormula` \|<br>A [HyperFormula](https://handsontable.github.io/hyperformula/) instance \|<br>A [HyperFormula configuration](https://handsontable.github.io/hyperformula/api/interfaces/configparams.html) object |
     * | `sheetId`   | A number                                                                                                                                                                                                               |
     * | `sheetName` | A string                                                                                                                                                                                                               |
     *
     * Read more:
     * - [Plugins: `Formulas`](@/api/formulas.md)
     * - [Formula calculation](@/guides/formulas/formula-calculation.md)
     * - [HyperFormula documentation: Client-side installation](https://handsontable.github.io/hyperformula/guide/client-side-installation)
     * - [HyperFormula documentation: Configuration options](https://handsontable.github.io/hyperformula/api/interfaces/configparams.html)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Formulas
     *
     * @example
     * ```js
     * // either add the `HyperFormula` class
     * formulas: {
     *   // set `engine` to `HyperFormula`
     *   engine: HyperFormula,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // or, add a HyperFormula instance
     * // initialized with the `'internal-use-in-handsontable'` license key
     * const hyperformulaInstance = HyperFormula.buildEmpty({
     *   licenseKey: 'internal-use-in-handsontable',
     * });
     *
     * formulas: {
     *   // set `engine` to a HyperFormula instance
     *   engine: hyperFormulaInstance,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // or, add a HyperFormula configuration object
     * formulas: {
     *   // set `engine` to a HyperFormula configuration object
     *   engine: {
     *     hyperformula: HyperFormula // or `engine: hyperFormulaInstance`
     *     leapYear1900: false,       // this option comes from HyperFormula
     *     // add more HyperFormula configuration options
     *   },
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // use the same HyperFormula instance in multiple Handsontable instances
     *
     * // a Handsontable instance `hot1`
     * formulas: {
     *   engine: HyperFormula,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // a Handsontable instance `hot2`
     * formulas: {
     *   engine: hot1.getPlugin('formulas').engine,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     * ```
     */
    formulas: void 0,
    /**
     * The `fragmentSelection` option configures text selection settings.
     *
     * You can set the `fragmentSelection` option to one of the following:
     *
     * | Setting           | Decription                                        |
     * | ----------------- | ------------------------------------------------- |
     * | `false` (default) | Disable text selection                            |
     * | `true`            | Enable text selection in multiple cells at a time |
     * | `'cell'`          | Enable text selection in one cell at a time       |
     *
     * @memberof Options#
     * @type {boolean|string}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // enable text selection in multiple cells at a time
     * fragmentSelection: true,
     *
     * // enable text selection in one cell a time
     * fragmentSelection: 'cell',
     * ```
     */
    fragmentSelection: false,
    /**
     * The `height` option configures the height of your grid.
     *
     * You can set `height` option to one of the following:
     *
     * | Setting                                                                    | Example                    |
     * | -------------------------------------------------------------------------- | -------------------------- |
     * | A number of pixels                                                         | `height: 500`              |
     * | A string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | `height: '75vw'`           |
     * | A function that returns a valid number or string                           | `height() { return 500; }` |
     *
     * Read more:
     * - [Grid size](@/guides/getting-started/grid-size.md)
     *
     * @memberof Options#
     * @type {number|string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the grid's height to 500px
     * height: 500,
     *
     * // set the grid's height to 75vh
     * height: '75vh',
     *
     * // set the grid's height to 500px, using a function
     * height() {
     *   return 500;
     * },
     * ```
     */
    height: void 0,
    /**
     * The `hiddenColumns` option configures the [`HiddenColumns`](@/api/hiddenColumns.md) plugin.
     *
     * You can set the `hiddenColumns` option to one of the following:
     *
     * | Setting   | Description                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin                                 |
     * | `true`    | Enable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin with the default plugin options  |
     * | An object | - Enable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin<br>- Modify the plugin options |
     *
     * If you set the `hiddenColumns` to an object, you can set the following [`HiddenColumns`](@/api/hiddenColumns.md) plugin options:
     *
     * | Property           | Possible values     | Description                                                                                                                                             |
     * | ------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `columns`          | An array of indexes | An array of indexes of columns that are hidden at initialization                                                                                        |
     * | `copyPasteEnabled` | `true` \| `false`   | `true`: when copying or pasting data, take hidden columns into account<br>`false`: when copying or pasting data, don't take hidden columns into account |
     * | `indicators`       | `true` \| `false`   | `true`: display UI markers to indicate the presence of hidden columns<br>`false`: display UI markers                                                    |
     *
     * Read more:
     * - [Plugins: `HiddenColumns`](@/api/hiddenColumns.md)
     * - [Column hiding](@/guides/columns/column-hiding.md)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category HiddenColumns
     *
     * @example
     * ```js
     * // enable the `HiddenColumns` plugin
     * hiddenColumns: true,
     *
     * // enable `HiddenColumns` plugin, and modify the plugin options
     * hiddenColumns: {
     *   // set columns that are hidden by default
     *   columns: [5, 10, 15],
     *   // when copying or pasting data, take hidden columns into account
     *   copyPasteEnabled: true,
     *   // show where hidden columns are
     *   indicators: true
     * }
     * ```
     */
    hiddenColumns: void 0,
    /**
     * The `hiddenRows` option configures the [`HiddenRows`](@/api/hiddenRows.md) plugin.
     *
     * You can set the `hiddenRows` option to one of the following:
     *
     * | Setting   | Description                                                                            |
     * | --------- | -------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`HiddenRows`](@/api/hiddenRows.md) plugin                                 |
     * | `true`    | Enable the [`HiddenRows`](@/api/hiddenRows.md) plugin with the default plugin options  |
     * | An object | - Enable the [`HiddenRows`](@/api/hiddenRows.md) plugin<br>- Modify the plugin options |
     *
     * If you set the `hiddenRows` to an object, you can set the following [`HiddenRows`](@/api/hiddenRows.md) plugin options:
     *
     * | Property           | Possible values     | Description                                                                                                                                       |
     * | ------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `rows   `          | An array of indexes | An array of indexes of rows that are hidden at initialization                                                                                     |
     * | `copyPasteEnabled` | `true` \| `false`   | `true`: when copying or pasting data, take hidden rows into account<br>`false`: when copying or pasting data, don't take hidden rows into account |
     * | `indicators`       | `true` \| `false`   | `true`: display UI markers to indicate the presence of hidden rows<br>`false`: display UI markers                                                 |
     *
     * Read more:
     * - [Plugins: `HiddenRows`](@/api/hiddenRows.md)
     * - [Row hiding](@/guides/rows/row-hiding.md)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category HiddenRows
     *
     * @example
     * ```js
     * // enable the `HiddenRows` plugin
     * hiddenRows: true,
     *
     * // enable `HiddenRows` plugin, and modify the plugin options
     * hiddenRows: {
     *   // set rows that are hidden by default
     *   rows: [5, 10, 15],
     *   // when copying or pasting data, take hidden rows into account
     *   copyPasteEnabled: true,
     *   // show where hidden rows are
     *   indicators: true
     * }
     * ```
     */
    hiddenRows: void 0,
    /**
     * The `invalidCellClassName` option lets you add a CSS class name to cells
     * that were marked as `invalid` by the [cell validator](@/guides/cell-functions/cell-validator.md).
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htInvalid'
     * @category Core
     *
     * @example
     * ```js
     * // add a `highlight-error` CSS class name
     * // to every `invalid` cell`
     * invalidCellClassName: 'highlight-error',
     * ```
     */
    invalidCellClassName: "htInvalid",
    /**
     * The `isEmptyCol` option lets you define your own custom method
     * for checking if a column at a given visual index is empty.
     *
     * The `isEmptyCol` setting overwrites the built-in [`isEmptyCol`](@/api/core.md#isEmptyCol) method.
     *
     * @memberof Options#
     * @type {Function}
     * @param {number} col Visual column index.
     * @returns {boolean}
     * @category Core
     *
     * @example
     * ```js
     * // overwrite the built-in `isEmptyCol` method
     * isEmptyCol(visualColumnIndex) {
     *    // your custom method
     *    ...
     * },
     * ```
     */
    isEmptyCol: function isEmptyCol(col) {
      var row;
      var rowLen;
      var value;
      for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {
        value = this.getDataAtCell(row, col);
        if (isEmpty(value) === false) {
          return false;
        }
      }
      return true;
    },
    /**
     * The `isEmptyRow` option lets you define your own custom method
     * for checking if a row at a given visual index is empty.
     *
     * The `isEmptyRow` setting overwrites the built-in [`isEmptyRow`](@/api/core.md#isEmptyRow) method.
     *
     * @memberof Options#
     * @type {Function}
     * @param {number} row Visual row index.
     * @returns {boolean}
     * @category Core
     *
     * @example
     * ```js
     * // overwrite the built-in `isEmptyRow` method
     * isEmptyRow(visualRowIndex) {
     *    // your custom method
     *    ...
     * },
     * ```
     */
    isEmptyRow: function isEmptyRow(row) {
      var col;
      var colLen;
      var value;
      var meta2;
      for (col = 0, colLen = this.countCols(); col < colLen; col++) {
        value = this.getDataAtCell(row, col);
        if (isEmpty(value) === false) {
          if (_typeof$14(value) === "object") {
            meta2 = this.getCellMeta(row, col);
            return isObjectEqual(this.getSchema()[meta2.prop], value);
          }
          return false;
        }
      }
      return true;
    },
    /**
     * @description
     * The `label` option configures [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cells` labels.
     *
     * You can set the `label` option to an object with the following properties:
     *
     * | Property    | Possible values                   | Description                                                                                                                                                                                                             |
     * | ----------- | --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `position`  | `'after'` (default) \| `'before'` | `'after'`: place the label to the right of the checkbox<br>`'before'`: place the label to the left of the checkbox                                                                                                      |
     * | `value`     | A string \| A function            | The label's text                                                                                                                                                                                                        |
     * | `separated` | `false` (default) \| `true`       | `false`: don't separate the label from the checkbox<br>`true`: separate the label from the checkbox                                                                                                                     |
     * | `property`  | A string                          | - A [`data`](#data) object property name that's used as the label's text <br>- Works only when the [`data`](#data) option is set to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects) |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox labels](@/guides/cell-types/checkbox-cell-type.md#checkbox-labels)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   type: 'checkbox',
     *   // add 'My label:' after the checkbox
     *   label: { position: 'after', value: 'My label: ', separated: true }
     * }],
     * ```
     */
    label: void 0,
    /**
     * The `language` option configures Handsontable's [language](@/guides/internationalization/language.md) settings.
     *
     * You can set the `language` option to one of the following:
     *
     * | Setting             | Description                 |
     * | ------------------- | --------------------------- |
     * | `'en-US'` (default) | English - United States     |
     * | `'ar-AR'`           | Arabic - Global.<br><br>To properly render this language, set the [layout direction](@/guides/internationalization/layout-direction.md) to RTL. |
     * | `'cs-CZ'`           | Czech - Czech Republic      |
     * | `'de-CH'`           | German - Switzerland        |
     * | `'de-DE'`           | German - Germany            |
     * | `'es-MX'`           | Spanish - Mexico            |
     * | `'fr-FR'`           | French - France             |
     * | `'it-IT'`           | Italian - Italy             |
     * | `'ja-JP'`           | Japanese - Japan            |
     * | `'ko-KR'`           | Korean - Korea              |
     * | `'lv-LV'`           | Latvian - Latvia            |
     * | `'nb-NO'`           | Norwegian (BokmÃ¥l) - Norway |
     * | `'nl-NL'`           | Dutch - Netherlands         |
     * | `'pl-PL'`           | Polish - Poland             |
     * | `'pt-BR'`           | Portuguese - Brazil         |
     * | `'ru-RU'`           | Russian - Russia            |
     * | `'sr-SP'`           | Serbian (Latin) - Serbia    |
     * | `'zh-CN'`           | Chinese - China             |
     * | `'zh-TW'`           | Chinese - Taiwan            |
     *
     * Read more:
     * - [Language](@/guides/internationalization/language.md)
     * - [`locale`](#locale)
     * - [`layoutDirection`](#layoutdirection)
     *
     * @memberof Options#
     * @type {string}
     * @default 'en-US'
     * @category Core
     *
     * @example
     * ```js
     * // set Handsontable's language to Polish
     * language: 'pl-PL',
     * ```
     */
    language: "en-US",
    /**
     * The `layoutDirection` option configures whether Handsontable renders from the left to the right, or from the right to the left.
     *
     * You can set the layout direction only at Handsontable's [initialization](@/guides/getting-started/installation.md#initialize-handsontable). Any change of the `layoutDirection` option after the initialization (e.g. using the [`updateSettings()`](@/api/core.md#updatesettings) method) is ignored.
     *
     * You can set the `layoutDirection` option only [for the entire grid](@/guides/getting-started/setting-options.md#setting-grid-options).
     * You can't set it for individual columns, rows, or cells.
     *
     * You can set the `layoutDirection` option to one of the following strings:
     *
     * | Setting             | Description                                                                                                                                                                                  |
     * | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `inherit` (default) | Set Handsontable's layout direction automatically,<br>based on the value of your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute  |
     * | `rtl`               | Render Handsontable from the right to the left,<br>even when your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute is set to `ltr` |
     * | `ltr`               | Render Handsontable from the left to the right,<br>even when your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute is set to `rtl` |
     *
     * Read more:
     * - [Layout direction](@/guides/internationalization/layout-direction.md)
     * - [Language](@/guides/internationalization/language.md)
     * - [`language`](#language)
     * - [`locale`](#locale)
     * - [`fixedColumnsStart`](#fixedcolumnsstart)
     * - [`customBorders`](#customBorders)
     *
     * @memberof Options#
     * @type {string}
     * @default 'inherit'
     * @category Core
     *
     * @example
     * ```js
     * // inherit Handsontable's layout direction
     * // from the value of your HTML document's `dir` attribute
     * layoutDirection: 'inherit',
     *
     * // render Handsontable from the right to the left
     * // regardless of your HTML document's `dir`
     * layoutDirection: 'rtl',
     *
     * // render Handsontable from the left to the right
     * // regardless of your HTML document's `dir`
     * layoutDirection: 'ltr',
     * ```
     */
    layoutDirection: "inherit",
    /**
     * The `licenseKey` option sets your Handsontable license key.
     *
     * You can set the `licenseKey` option to one of the following:
     *
     * | Setting                                                                                                 | Description                                                                                       |
     * | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
     * | A string with your [commercial license key](@/guides/getting-started/license-key.md#commercial-license) | For [commercial use](@/guides/technical-specification/software-license.md#commercial-use)         |
     * | `'non-commercial-and-evaluation'`                                                                       | For [non-commercial use](@/guides/technical-specification/software-license.md#non-commercial-use) |
     *
     * Read more:
     * - [License key](@/guides/getting-started/license-key.md)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // for commercial use
     * licenseKey: 'xxxxx-xxxxx-xxxxx-xxxxx-xxxxx', // your commercial license key
     *
     * // for non-commercial use
     * licenseKey: 'non-commercial-and-evaluation',
     * ```
     */
    licenseKey: void 0,
    /**
     * The `locale` option configures Handsontable's [locale](@/guides/internationalization/locale.md) settings.
     *
     * You can set the `locale` option to any valid and canonicalized Unicode BCP 47 locale tag,
     * both for the [entire grid](@/guides/internationalization/locale.md#setting-the-grid-s-locale),
     * and for [individual columns](@/guides/internationalization/locale.md#setting-a-column-s-locale).
     *
     * Read more:
     * - [Locale](@/guides/internationalization/locale.md)
     * - [`language`](#language)
     * - [`layoutDirection`](#layoutdirection)
     *
     * @memberof Options#
     * @type {string}
     * @default 'en-US'
     * @category Core
     *
     * @example
     * ```js
     * // set the entire grid's locale to Polish
     * locale: 'pl-PL',
     *
     * // set individual columns' locales
     * columns: [
     *   {
     *     // set the first column's locale to Polish
     *     locale: 'pl-PL',
     *   },
     *   {
     *     // set the second column's locale to German
     *     locale: 'de-DE',
     *   },
     * ],
     * ```
     */
    locale: "en-US",
    /**
     * The `manualColumnFreeze` option configures the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin.
     *
     * You can set the `manualColumnFreeze` option to one of the following:
     *
     * | Setting  | Description                                                            |
     * | -------- | ---------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin  |
     * | `false`  | Disable the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin |
     *
     * Read more:
     * - [Column freezing](@/guides/columns/column-freezing.md#user-triggered-freeze)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category ManualColumnFreeze
     *
     * @example
     * ```js
     * // enable the `ManualColumnFreeze` plugin
     * manualColumnFreeze: true,
     * ```
     */
    manualColumnFreeze: void 0,
    /**
     * The `manualColumnMove` option configures the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin.
     *
     * You can set the `manualColumnMove` option to one of the following:
     *
     * | Setting  | Description                                                                                                        |
     * | -------- | ------------------------------------------------------------------------------------------------------------------ |
     * | `true`   | Enable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin                                                  |
     * | `false`  | Disable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin                                                 |
     * | An array | - Enable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin<br>- Move individual columns at initialization |
     *
     * Read more:
     * - [Column moving](@/guides/columns/column-moving.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualColumnMove
     *
     * @example
     * ```js
     * // enable the `ManualColumnMove` plugin
     * manualColumnMove: true,
     *
     * // enable the `ManualColumnMove` plugin
     * // at initialization, move column 0 to 1
     * // at initialization, move column 1 to 4
     * // at initialization, move column 2 to 6
     * manualColumnMove: [1, 4, 6],
     * ```
     */
    manualColumnMove: void 0,
    /**
     * @description
     * The `manualColumnResize` option configures the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin.
     *
     * You can set the `manualColumnResize` option to one of the following:
     *
     * | Setting  | Description                                                                                                           |
     * | -------- | --------------------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin                                                 |
     * | `false`  | Disable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin                                                |
     * | An array | - Enable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin<br>- Set initial widths of individual columns |
     *
     * Read more:
     * - [Column width: Column stretching](@/guides/columns/column-width.md#column-stretching)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualColumnResize
     *
     * @example
     * ```js
     * // enable the `manualColumnResize` plugin
     * manualColumnResize: true,
     *
     * // enable the `manualColumnResize` plugin
     * // set the initial width of column 0 to 40 pixels
     * // set the initial width of column 1 to 50 pixels
     * // set the initial width of column 2 to 60 pixels
     * manualColumnResize: [40, 50, 60],
     * ```
     */
    manualColumnResize: void 0,
    /**
     * @description
     * The `manualRowMove` option configures the [`ManualRowMove`](@/api/manualRowMove.md) plugin.
     *
     * You can set the `manualRowMove` option to one of the following:
     *
     * | Setting  | Description                                                                                               |
     * | -------- | --------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualRowMove`](@/api/manualRowMove.md) plugin                                               |
     * | `false`  | Disable the [`ManualRowMove`](@/api/manualRowMove.md) plugin                                              |
     * | An array | - Enable the [`ManualRowMove`](@/api/manualRowMove.md) plugin<br>- Move individual rows at initialization |
     *
     * Read more:
     * - [Row moving](@/guides/rows/row-moving.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualRowMove
     *
     * @example
     * ```js
     * // enable the `ManualRowMove` plugin
     * manualRowMove: true,
     *
     * // enable the `ManualRowMove` plugin
     * // at initialization, move row 0 to 1
     * // at initialization, move row 1 to 4
     * // at initialization, move row 2 to 6
     * manualColumnMove: [1, 4, 6],
     * ```
     */
    manualRowMove: void 0,
    /**
     * @description
     * The `manualRowResize` option configures the [`ManualRowResize`](@/api/manualRowResize.md) plugin.
     *
     * You can set the `manualRowResize` option to one of the following:
     *
     * | Setting  | Description                                                                                                   |
     * | -------- | ------------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualRowResize`](@/api/manualRowResize.md) plugin                                               |
     * | `false`  | Disable the [`ManualRowResize`](@/api/manualRowResize.md) plugin                                              |
     * | An array | - Enable the [`ManualRowResize`](@/api/manualRowResize.md) plugin<br>- Set initial heights of individual rows |
     *
     * Read more:
     * - [Row height: Adjust the row height manually](@/guides/rows/row-height.md#adjust-the-row-height-manually)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualRowResize
     *
     * @example
     * ```js
     * // enable the `ManualRowResize` plugin
     * manualColumnResize: true,
     *
     * // enable the `ManualRowResize` plugin
     * // set the initial height of row 0 to 40 pixels
     * // set the initial height of row 1 to 50 pixels
     * // set the initial height of row 2 to 60 pixels
     * manualColumnResize: [40, 50, 60],
     * ```
     */
    manualRowResize: void 0,
    /**
     * The `maxCols` option sets a maximum number of columns.
     *
     * The `maxCols` option is used:
     * - At initialization: if the `maxCols` value is lower than the initial number of columns,
     * Handsontable trims columns from the right.
     * - At runtime: for example, when inserting columns.
     *
     * @memberof Options#
     * @type {number}
     * @default Infinity
     * @category Core
     *
     * @example
     * ```js
     * // set the maximum number of columns to 300
     * maxCols: 300,
     * ```
     */
    maxCols: Infinity,
    /**
     * The `maxRows` option sets a maximum number of rows.
     *
     * The `maxRows` option is used:
     * - At initialization: if the `maxRows` value is lower than the initial number of columns,
     * Handsontable trims rows from the bottom.
     * - At runtime: for example, when inserting rows.
     *
     * @memberof Options#
     * @type {number}
     * @default Infinity
     * @category Core
     *
     * @example
     * ```js
     * // set the maximum number of rows to 300
     * maxRows: 300,
     * ```
     */
    maxRows: Infinity,
    /**
     * @description
     * The `mergeCells` option configures the [`MergeCells`](@/api/mergeCells.md) plugin.
     *
     * You can set the `mergeCells` option to one of the following:
     *
     * | Setting             | Description                                                                                         |
     * | ------------------- | --------------------------------------------------------------------------------------------------- |
     * | `true`              | Enable the [`MergeCells`](@/api/mergeCells.md) plugin                                               |
     * | `false`             | Disable the [`MergeCells`](@/api/mergeCells.md) plugin                                              |
     * | An array of objects | - Enable the [`MergeCells`](@/api/mergeCells.md) plugin<br>- Merge specific cells at initialization |
     *
     * To merge specific cells at Handsontable's initialization,
     * set the `mergeCells` option to an array of objects, with the following properties:
     *
     * | Property  | Description                                                |
     * | --------- | ---------------------------------------------------------- |
     * | `row`     | The row index of the merged section's beginning            |
     * | `col`     | The column index of the merged section's beginning         |
     * | `rowspan` | The width (as a number of rows) of the merged section      |
     * | `colspan` | The height (as a number of columns ) of the merged section |
     *
     * Read more:
     * - [Merge cells](@/guides/cell-features/merge-cells.md)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category MergeCells
     *
     * @example
     * ```js
     * // enable the `MergeCells` plugin
     * mergeCells: true,
     *
     * // enable the `MergeCells` plugin
     * // and merge specific cells at initialization
     * mergeCells: [
     *   // merge cells from cell (1,1) to cell (3,3)
     *   {row: 1, col: 1, rowspan: 3, colspan: 3},
     *   // merge cells from cell (3,4) to cell (2,2)
     *   {row: 3, col: 4, rowspan: 2, colspan: 2},
     *   // merge cells from cell (5,6) to cell (3,3)
     *   {row: 5, col: 6, rowspan: 3, colspan: 3}
     * ],
     * ```
     */
    mergeCells: false,
    /**
     * The `minCols` option sets a minimum number of columns.
     *
     * The `minCols` option is used:
     * - At initialization: if the `minCols` value is higher than the initial number of columns,
     * Handsontable adds empty columns to the right.
     * - At runtime: for example, when removing columns.
     *
     * The `minCols` option works only when your [`data`](#data) is an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).
     * When your [`data`](#data) is an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects),
     * you can only have as many columns as defined in:
     * - The first data row
     * - The [`dataSchema`](#dataSchema) option
     * - The [`columns`](#columns) option
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // set the minimum number of columns to 10
     * minCols: 10,
     * ```
     */
    minCols: 0,
    /**
     * The `minRows` option sets a minimum number of rows.
     *
     * The `minRows` option is used:
     * - At initialization: if the `minRows` value is higher than the initial number of rows,
     * Handsontable adds empty rows at the bottom.
     * - At runtime: for example, when removing rows.
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // set the minimum number of rows to 10
     * minRows: 10,
     * ```
     */
    minRows: 0,
    /**
     * The `minSpareCols` option sets a minimum number of empty columns
     * at the grid's right-hand end.
     *
     * If there already are other empty columns at the grid's right-hand end,
     * they are counted into the `minSpareCols` value.
     *
     * The total number of columns can't exceed the [`maxCols`](#maxCols) value.
     *
     * The `minSpareCols` option works only when your [`data`](#data) is an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).
     * When your [`data`](#data) is an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects),
     * you can only have as many columns as defined in:
     * - The first data row
     * - The [`dataSchema`](#dataSchema) option
     * - The [`columns`](#columns) option
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // at Handsontable's initialization, add at least 3 empty columns on the right
     * minSpareCols: 3,
     * ```
     */
    minSpareCols: 0,
    /**
     * The `minSpareRows` option sets a minimum number of empty rows
     * at the bottom of the grid.
     *
     * If there already are other empty rows at the bottom,
     * they are counted into the `minSpareRows` value.
     *
     * The total number of rows can't exceed the [`maxRows`](#maxRows) value.
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // at Handsontable's initialization, add at least 3 empty rows at the bottom
     * minSpareRows: 3,
     * ```
     */
    minSpareRows: 0,
    /**
     * @description
     * The `multiColumnSorting` option configures the [`MultiColumnSorting`](@/api/columnSorting.md) plugin.
     *
     * You can set the `multiColumnSorting` option to one of the following:
     *
     * | Setting    | Description                                                                                                                                                |
     * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`     | Enable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin with the default configuration                                                       |
     * | `false`    | Disable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin                                                                                     |
     * | An object  | - Enable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin<br>- Modify the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin options |
     *
     * If you set the `multiColumnSorting` option to an object,
     * you can set the following [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin options:
     *
     * | Option                   | Possible settings                                                                                                                                |
     * | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `indicator`              | `true`: Display an arrow icon in the column header, to indicate a sortable column<br>`false`: Don't display the arrow icon in the column header  |
     * | `headerAction`           | `true`: Enable clicking on the column header to sort the column<br>`false`: Disable clicking on the column header to sort the column             |
     * | `sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place empty cells at the end                                                                        |
     * | `compareFunctionFactory` | A [custom compare function](@/guides/rows/row-sorting.md#custom-compare-functions)                                                                |
     *
     * If you set the `multiColumnSorting` option to an object,
     * you can also sort individual columns at Handsontable's initialization.
     * In the `multiColumnSorting` object, add an object named `initialConfig`,
     * with the following properties:
     *
     * | Option      | Possible settings   | Description                                                      |
     * | ----------- | ------------------- | ---------------------------------------------------------------- |
     * | `column`    | A number            | The index of the column that you want to sort at initialization  |
     * | `sortOrder` | `'asc'` \| `'desc'` | The sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |
     *
     * Read more:
     * - [Row sorting](@/guides/rows/row-sorting.md)
     * - [`columnSorting`](#columnSorting)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category MultiColumnSorting
     *
     * @example
     * ```js
     * // enable the `MultiColumnSorting` plugin
     * multiColumnSorting: true
     *
     * // enable the `MultiColumnSorting` plugin with custom configuration
     * multiColumnSorting: {
     *   // sort empty cells as well
     *   sortEmptyCells: true,
     *   // display an arrow icon in the column header
     *   indicator: true,
     *   // disable clicking on the column header to sort the column
     *   headerAction: false,
     *   // add a custom compare function
     *   compareFunctionFactory(sortOrder, columnMeta) {
     *     return function(value, nextValue) {
     *       // some value comparisons which will return -1, 0 or 1...
     *     }
     *   }
     * }
     *
     * // enable the `MultiColumnSorting` plugin
     * multiColumnSorting: {
     *   // at initialization, sort column 1 in ascending order
     *   initialConfig: {
     *     column: 1,
     *     sortOrder: 'asc'
     *   },
     *   // at initialization, sort column 2 in descending order
     *   initialConfig: {
     *     column: 2,
     *     sortOrder: 'desc'
     *   }
     * }
     * ```
     */
    multiColumnSorting: void 0,
    /**
     * @description
     * The `nestedHeaders` option configures the [`NestedHeaders`](@/api/nestedHeaders.md) plugin.
     *
     * You can set the `nestedHeaders` option to an array of arrays:
     * - Each array configures one set of nested headers.
     * - Each array element configures one header, and can be one of the following:
     *
     * | Array element | Description                                                                                  |
     * | ------------- | -------------------------------------------------------------------------------------------- |
     * | A string      | The header's label                                                                           |
     * | An object     | Properties:<br>`label` (string): the header's label<br>`colspan` (integer): the column width |
     *
     * Read more:
     * - [Plugins: `NestedHeaders`](@/api/nestedHeaders.md)
     * - [Column groups: Nested headers](@/guides/columns/column-groups.md#nested-headers)
     *
     * @memberof Options#
     * @type {Array[]}
     * @default undefined
     * @category NestedHeaders
     *
     * @example
     * ```js
     * nestedHeaders: [
     *   ['A', {label: 'B', colspan: 8}, 'C'],
     *   ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],
     *   ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T']
     * ],
     * ```
     */
    nestedHeaders: void 0,
    /**
     * @description
     * The `nestedRows` option configures the [`NestedRows`](@/api/nestedRows.md) plugin.
     *
     * You can set the `nestedRows` option to one of the following:
     *
     * | Setting           | Description                                            |
     * | ----------------- | ------------------------------------------------------ |
     * | `false` (default) | Disable the [`NestedRows`](@/api/nestedRows.md) plugin |
     * | `true`            | Enable the [`NestedRows`](@/api/nestedRows.md) plugin  |
     *
     * Read more:
     * - [Plugins: `NestedRows`](@/api/nestedRows.md)
     *
     * @example
     * ```js
     * // enable the `NestedRows` plugin
     * nestedRows: true,
     * ```
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category NestedRows
     */
    nestedRows: void 0,
    /**
     * The `noWordWrapClassName` option lets you add a CSS class name
     * to each cell that has the [`wordWrap`](#wordWrap) option set to `false`.
     *
     * Read more:
     * - [`wordWrap`](#wordWrap)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htNoWrap'
     * @category Core
     *
     * @example
     * ```js
     * // add an `is-noWrapCell` CSS class name
     * // to each cell that doesn't wrap content
     * noWordWrapClassName: 'is-noWrapCell',
     * ```
     */
    noWordWrapClassName: "htNoWrap",
    /**
     * The `numericFormat` option configures the number format and the currency format
     * of [`numeric`](@/guides/cell-types/numeric-cell-type.md) cells` displayed output
     * in the numeric cell renderer.
     *
     * You can set the `numericFormat` option to an object with the following properties:
     *
     * | Property    | Possible values                                                               | Description     |
     * | ----------- | ----------------------------------------------------------------------------- | --------------- |
     * | `pattern`   | All [`numbro.js` number formats](https://numbrojs.com/format.html#numbers)    | Number format   |
     * | `culture`   | All [`numbro.js` currency formats](https://numbrojs.com/format.html#currency) | Currency format |
     *
     * The `numericFormat` option as no effect on the numeric cell editor.
     *
     * In the source data, numeric data is stored as JavaScript numbers.
     *
     * Read more:
     * - [Numeric cell type](@/guides/cell-types/numeric-cell-type.md)
     * - [Third-party licenses](@/guides/technical-specification/third-party-licenses.md)
     *
     * @memberof Options#
     * @since 0.35.0
     * @type {object}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `numeric`
     *     type: 'numeric',
     *     // set the `numericFormat` option for every `numeric` cell of this column
     *     numericFormat: {
     *       // set the number format
     *       pattern: '0,00',
     *       // set the currency format
     *       culture: 'en-US'
     *     }
     *   }
     * ],
     * ```
     */
    numericFormat: void 0,
    /**
     * If the `observeDOMVisibility` option is set to `true`,
     * Handsontable rerenders every time it detects that the grid was made visible in the DOM.
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // don't rerender the grid on visibility changes
     * observeDOMVisibility: false,
     * ```
     */
    observeDOMVisibility: true,
    /**
     * The `outsideClickDeselects` option determines what happens to the current [selection](@/guides/cell-features/selection.md)
     * when you click outside of the grid.
     *
     * You can set the `outsideClickDeselects` option to one of the following:
     *
     * | Setting          | Description                                                                                              |
     * | ---------------- | -------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | On a mouse click outside of the grid, clear the current [selection](@/guides/cell-features/selection.md) |
     * | `false`          | On a mouse click outside of the grid, keep the current [selection](@/guides/cell-features/selection.md)  |
     * | A function       | A function that takes the click event target and returns a boolean                                       |
     *
     * @memberof Options#
     * @type {boolean|Function}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // on a mouse click outside of the grid, clear the current selection
     * outsideClickDeselects: true,
     *
     * // on a mouse click outside of the grid, keep the current selection
     * outsideClickDeselects: false,
     *
     * // take the click event target and return `false`
     * outsideClickDeselects(event) {
     *   return false;
     * }
     *
     * // take the click event target and return `true`
     * outsideClickDeselects(event) {
     *   return false;
     * }
     * ```
     */
    outsideClickDeselects: true,
    /**
     * @description
     * The `persistentState` option configures the [`PersistentState`](@/api/persistentState.md) plugin.
     *
     * You can set the `persistentState` to one of the following:
     *
     * | Setting           | Description                                                      |
     * | ----------------- | ---------------------------------------------------------------- |
     * | `false` (default) | Disable the [`PersistentState`](@/api/persistentState.md) plugin |
     * | `true`            | Enable the [`PersistentState`](@/api/persistentState.md) plugin  |
     *
     * Read more:
     * - [Saving data: Saving data locally](@/guides/getting-started/saving-data.md#saving-data-locally)
     * - [Plugins: `PersistentState`](@/api/persistentState.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category PersistentState
     *
     * @example
     * ```js
     * // enable the `PersistentState` plugin
     * persistentState: true,
     * ```
     */
    persistentState: void 0,
    /**
     * The `placeholder` option lets you display placeholder text in every empty cell.
     *
     * You can set the `placeholder` option to one of the following:
     *
     * | Setting            | Example        | Description                                                           |
     * | ------------------ | -------------- | --------------------------------------------------------------------- |
     * | A non-empty string | `'Empty cell'` | Display `Empty cell` text in empty cells                              |
     * | A non-string value | `000`          | Display `000` text in empty cells (non-string values get stringified) |
     *
     * Read more:
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // display 'Empty cell' text
     * // in every empty cell of the entire grid
     * placeholder: 'Empty cell',
     *
     * // or
     * columns: [
     *   {
     *     data: 'date',
     *     dateFormat: 'DD/MM/YYYY',
     *     // display 'Empty date cell' text
     *     // in every empty cell of the `date` column
     *     placeholder: 'Empty date cell'
     *   }
     * ],
     * ```
     */
    placeholder: void 0,
    /**
     * The `placeholderCellClassName` option lets you add a CSS class name to cells
     * that contain [`placeholder`](#placeholder) text.
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [`placeholder`](#placeholder)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htPlaceholder'
     * @category Core
     *
     * @example
     * ```js
     * // add a `has-placeholder` CSS class name
     * // to each cell that contains `placeholder` text
     * placeholderCellClassName: 'has-placeholder',
     * ```
     */
    placeholderCellClassName: "htPlaceholder",
    /**
     * The `preventOverflow` option configures preventing Handsontable
     * from overflowing outside of its parent element.
     *
     * You can set the `preventOverflow` option to one of the following:
     *
     * | Setting           | Description                      |
     * | ----------------- | -------------------------------- |
     * | `false` (default) | Don't prevent overflowing        |
     * | `'horizontal'`      | Prevent horizontal overflowing |
     * | `'vertical'`        | Prevent vertical overflowing   |
     *
     * @memberof Options#
     * @type {string|boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // prevent horizontal overflowing
     * preventOverflow: 'horizontal',
     * ```
     */
    preventOverflow: false,
    /**
     * The `preventWheel` option configures preventing the `wheel` event's default action
     * on overlays.
     *
     * You can set the `preventWheel` option to one of the following:
     *
     * | Setting           | Description                                      |
     * | ----------------- | ------------------------------------------------ |
     * | `false` (default) | Don't prevent the `wheel` event's default action |
     * | `true`            | Prevent the `wheel` event's default action       |
     *
     * @memberof Options#
     * @private
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // don't prevent the `wheel` event's default action
     * preventWheel: false,
     * ```
     */
    preventWheel: false,
    /**
     * @description
     * The `readOnly` option determines whether a cell, column or comment is editable or not.
     *
     * You can set the `readOnly` option to one of the following:
     *
     * | Setting           | Decription                                                                                                                |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Set as editable                                                                                                           |
     * | `true`            | - Set as read-only<br>- Add the [`readOnlyCellClassName`](#readOnlyCellClassName) CSS class name (by default: `htDimmed`) |
     *
     * `readOnly` cells can't be changed by the [`populateFromArray()`](@/api/core.md#populatefromarray) method.
     *
     * Read more:
     * - [Configuration options: Cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // set as read-only
     * readOnly: true,
     * ```
     */
    readOnly: false,
    /**
     * The `readOnlyCellClassName` option lets you add a CSS class name to [read-only](#readOnly) cells.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`TableClassName`](#TableClassName)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htDimmed'
     * @category Core
     *
     * @example
     * ```js
     * // add a `is-readOnly` CSS class name
     * // to every read-only cell
     * readOnlyCellClassName: 'is-readOnly',
     * ```
     */
    readOnlyCellClassName: "htDimmed",
    /**
     * The `renderAllRows` option configures Handsontable's [row virtualization](@/guides/rows/row-virtualization.md).
     *
     * You can set the `renderAllRows` option to one of the following:
     *
     * | Setting           | Description                                                                                        |
     * | ----------------- | -------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Enable [row virtualization](@/guides/rows/row-virtualization.md)                                   |
     * | `true`            | Disable [row virtualization](@/guides/rows/row-virtualization.md)<br>(render all rows of the grid) |
     *
     * Read more:
     * - [Row virtualization](@/guides/rows/row-virtualization.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // disable row virtualization
     * renderAllRows: true,
     * ```
     */
    renderAllRows: void 0,
    /**
     * @description
     * The `renderer` option sets a [cell renderer](@/guides/cell-functions/cell-renderer.md) for a cell.
     *
     * You can set the `renderer` option to one of the following:
     * - A custom renderer function
     * - One of the following [cell renderer aliases](@/guides/cell-functions/cell-renderer.md):
     *
     * | Alias               | Cell renderer function                                                         |
     * | ------------------- | ------------------------------------------------------------------------------ |
     * | A custom alias      | Your [custom cell renderer](@/guides/cell-functions/cell-renderer.md) function |
     * | `'autocomplete'`    | `AutocompleteRenderer`                                                         |
     * | `'base'`            | `BaseRenderer`                                                                 |
     * | `'checkbox'`        | `CheckboxRenderer`                                                             |
     * | `'date'`            | `DateRenderer`                                                                 |
     * | `'dropdown'`        | `DropdownRenderer`                                                             |
     * | `'html'`            | `HtmlRenderer`                                                                 |
     * | `'numeric'`         | `NumericRenderer`                                                              |
     * | `'password'`        | `PasswordRenderer`                                                             |
     * | `'text'`            | `TextRenderer`                                                                 |
     * | `'time'`            | `TimeRenderer`                                                                 |
     *
     * To set the [`renderer`](#renderer), [`editor`](#editor), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell renderer](@/guides/cell-functions/cell-renderer.md)
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // use the `numeric` renderer for each cell of the entire grid
     * renderer: `'numeric'`,
     *
     * // add a custom renderer function
     * renderer(hotInstance, td, row, column, prop, value, cellProperties) {
     *   // your custom renderer's logic
     *   ...
     * }
     *
     * // apply the `renderer` option to individual columns
     * columns: [
     *   {
     *     // use the `autocomplete` renderer for each cell of this column
     *     renderer: 'autocomplete'
     *   },
     *   {
     *     // use the `myCustomRenderer` renderer for each cell of this column
     *     renderer: 'myCustomRenderer'
     *   }
     * ]
     * ```
     */
    renderer: void 0,
    /**
     * The `rowHeaders` option configures your grid's row headers.
     *
     * You can set the `rowHeaders` option to one of the following:
     *
     * | Setting    | Description                                                       |
     * | ---------- | ----------------------------------------------------------------- |
     * | `true`     | Enable the default row headers ('1', '2', '3', ...)               |
     * | `false`    | Disable row headers                                               |
     * | An array   | Define your own row headers (e.g. `['One', 'Two', 'Three', ...]`) |
     * | A function | Define your own row headers, using a function                     |
     *
     * Read more:
     * - [Row header](@/guides/rows/row-header.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // enable the default row headers
     * rowHeaders: true,
     *
     * // set your own row headers
     * rowHeaders: ['One', 'Two', 'Three'],
     *
     * // set your own row headers, using a function
     * rowHeaders: function(visualRowIndex) {
     *   return `${visualRowIndex}: AB`;
     * },
     * ```
     */
    rowHeaders: void 0,
    /**
     * @description
     * The `rowHeaderWidth` option configures the width of row headers.
     *
     * You can set the `rowHeaderWidth` option to one of the following:
     *
     * | Setting  | Description                                     |
     * | -------- | ----------------------------------------------- |
     * | A number | Set the same width for every row header         |
     * | An array | Set different widths for individual row headers |
     *
     * @memberof Options#
     * @type {number|number[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the same width for every row header
     * rowHeaderWidth: 25,
     *
     * // set different widths for individual row headers
     * rowHeaderWidth: [25, 30, 55],
     * ```
     */
    rowHeaderWidth: void 0,
    /**
     * The `rowHeights` option sets rows' heights, in pixels.
     *
     * In the rendering process, the default row height is 23px.
     * You can change it to equal or greater than 23px, by setting the `rowHeights` option to one of the following:
     *
     * | Setting     | Description                                                                                         | Example                                                      |
     * | ----------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
     * | A number    | Set the same height for every row                                                                   | `rowHeights: 100`                                            |
     * | A string    | Set the same height for every row                                                                   | `rowHeights: '100px'`                                        |
     * | An array    | Set heights separately for each row                                                                 | `rowHeights: [100, 120, undefined]`                          |
     * | A function  | Set row heights dynamically,<br>on each render                                                      | `rowHeights(visualRowIndex) { return visualRowIndex * 10; }` |
     * | `undefined` | Used by the [modifyRowHeight](@/api/hooks.md#modifyRowHeight) hook,<br>to detect row height changes | `rowHeights: undefined`                                      |
     *
     * The `rowHeights` option also sets the minimum row height that can be set
     * via the {@link ManualRowResize} and {@link AutoRowSize} plugins (if they are enabled).
     *
     * Read more:
     * - [Row height](@/guides/rows/row-height.md)
     *
     * @memberof Options#
     * @type {number|number[]|string|string[]|Array<undefined>|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set every row's height to 100px
     * rowHeights: 100,
     *
     * // set every row's height to 100px
     * rowHeights: '100px',
     *
     * // set the first (by visual index) row's height to 100
     * // set the second (by visual index) row's height to 120
     * // set the third (by visual index) row's height to `undefined`
     * // set any other row's height to the default 23px
     * rowHeights: [100, 120, undefined],
     *
     * // set each row's height individually, using a function
     * rowHeights(visualRowIndex) {
     *   return visualRowIndex * 10;
     * },
     * ```
     */
    rowHeights: void 0,
    /**
     * @description
     * The `search` option configures the [`Search`](@/api/search.md) plugin.
     *
     * You can set the `search` option to one of the following:
     *
     * | Setting           | Description                                                                          |
     * | ----------------- | ------------------------------------------------------------------------------------ |
     * | `false` (default) | Disable the [`Search`](@/api/search.md) plugin                                       |
     * | `true`            | Enable the [`Search`](@/api/search.md) plugin with the default configuration         |
     * | An object         | - Enable the [`Search`](@/api/search.md) plugin<br>- Apply your custom configuration |
     *
     * If you set the `search` option to an object, you can configure the following search options:
     *
     * | Option              | Possible settings | Description                                                                                          |
     * | ------------------- | ----------------- | ---------------------------------------------------------------------------------------------------- |
     * | `searchResultClass` | A string          | Add a custom CSS class name to search results                                                        |
     * | `queryMethod`       | A function        | Add a [custom query method](@/guides/accessories-and-menus/searching-values.md#custom-query-method)  |
     * | `callback`          | A function        | Add a [custom callback function](@/guides/accessories-and-menus/searching-values.md#custom-callback) |
     *
     * Read more:
     * - [Searching values](@/guides/accessories-and-menus/searching-values.md)
     * - [Searching values: Custom query method](@/guides/accessories-and-menus/searching-values.md#custom-query-method)
     * - [Searching values: Custom callback](@/guides/accessories-and-menus/searching-values.md#custom-callback)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default false
     * @category Search
     *
     * @example
     * ```js
     * // enable the `Search` plugin with the default configuration
     * search: true,
     *
     * // enable the `Search` plugin with a custom configuration
     * search: {
     *   // add a `customClass` CSS class name to search results
     *   searchResultClass: 'customClass',
     *   // add a custom query method
     *   queryMethod(queryStr, value) {
     *     ...
     *   },
     *   // add a custom callback function
     *   callback(instance, row, column, value, result) {
     *     ...
     *   }
     * }
     * ```
     */
    search: false,
    /**
     * @description
     * The `selectionMode` option configures how [selection](@/guides/cell-features/selection.md) works.
     *
     * You can set the `selectionMode` option to one of the following:
     *
     * | Setting      | Description                                                  |
     * | ------------ | ------------------------------------------------------------ |
     * | `'single'`   | Allow the user to select only one cell at a time.            |
     * | `'range'`    | Allow the user to select one range of cells at a time.       |
     * | `'multiple'` | Allow the user to select multiple ranges of cells at a time. |
     *
     * Read more:
     * - [Selection: Selecting ranges](@/guides/cell-features/selection.md#selecting-ranges)
     *
     * @memberof Options#
     * @type {string}
     * @default 'multiple'
     * @category Core
     *
     * @example
     * ```js
     * // you can only select one cell at at a time
     * selectionMode: 'single',
     *
     * // you can select one range of cells at a time
     * selectionMode: 'range',
     *
     * // you can select multiple ranges of cells at a time
     * selectionMode: 'multiple',
     * ```
     */
    selectionMode: "multiple",
    /**
     * The `selectOptions` option configures options that the end user can choose from in [`select`](@/guides/cell-types/select-cell-type.md) cells.
     *
     * You can set the `selectOptions` option to one of the following:
     *
     * | Setting                         | Description                                                                   |
     * | ------------------------------- | ----------------------------------------------------------------------------- |
     * | An array of strings             | Each string is one option's value and label                                   |
     * | An object with key-string pairs | - Each key is one option's value<br>- The key's string is that option's label |
     * | A function                      | A function that returns an object with key-string pairs                       |
     *
     * Read more:
     * - [Select cell type](@/guides/cell-types/select-cell-type.md)
     *
     * @memberof Options#
     * @type {string[]|object|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     // set the first option's value and label to `A`
     *     // set the second option's value and label to `B`
     *     // set the third option's value and label to `C`
     *     selectOptions: ['A', 'B', 'C'],
     *   },
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     selectOptions: {
     *       // set the first option's value to `value1` and label to `Label 1`
     *       value1: 'Label 1',
     *       // set the second option's value to `value2` and label to `Label 2`
     *       value2: 'Label 2',
     *       // set the third option's value to `value3` and label to `Label 3`
     *       value3: 'Label 3',
     *     },
     *   },
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     // set `selectOption` to a function that returns available options as an object
     *     selectOptions(visualRow, visualColumn, prop) {
     *       return {
     *         value1: 'Label 1',
     *         value2: 'Label 2',
     *         value3: 'Label 3',
     *       };
     *   },
     * ],
     * ```
     */
    selectOptions: void 0,
    /**
     * @description
     * The `skipColumnOnPaste` option determines whether you can paste data into a given column.
     *
     * You can only apply the `skipColumnOnPaste` option to an entire column, using the [`columns`](#columns) option.
     *
     * You can set the `skipColumnOnPaste` option to one of the following:
     *
     * | Setting           | Description                                                                                           |
     * | ----------------- | ----------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Enable pasting data into this column                                                                  |
     * | `true`            | - Disable pasting data into this column<br>- On pasting, paste data into the next column to the right |
     *
     * Read more:
     * - [Configuration options: Setting column options](@/guides/getting-started/setting-options.md#setting-column-options)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // disable pasting data into this column
     *     skipColumnOnPaste: true
     *   }
     * ],
     * ```
     */
    skipColumnOnPaste: false,
    /**
     * @description
     *
     * The `skipRowOnPaste` option determines whether you can paste data into a given row.
     *
     * You can only apply the `skipRowOnPaste` option to an entire row, using the [`cells`](#cells) option.
     *
     * You can set the `skipRowOnPaste` option to one of the following:
     *
     * | Setting           | Description                                                                         |
     * | ----------------- | ----------------------------------------------------------------------------------- |
     * | `false` (default) | Enable pasting data into this row                                                   |
     * | `true`            | - Disable pasting data into this row<br>- On pasting, paste data into the row below |
     *
     * Read more:
     * - [Configuration options: Setting row options](@/guides/getting-started/setting-options.md#setting-row-options)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * cells(row, column) {
     *  const cellProperties = {};
     *
     *  // disable pasting data into row 1
     *  if (row === 1) {
     *    cellProperties.skipRowOnPaste = true;
     *  }
     *
     *  return cellProperties;
     * }
     * ```
     */
    skipRowOnPaste: false,
    /**
     * The `sortByRelevance` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'
     * lists are sorted in the same order as provided in the [`source`](#source) option.
     *
     * You can set the `sortByRelevance` option to one of the following:
     *
     * | Setting          | Description                                                                  |
     * | ---------------- | ---------------------------------------------------------------------------- |
     * | `true` (default) | Sort options in the same order as provided in the [`source`](#source) option |
     * | `false`          | Sort options alphabetically                                                  |
     *
     * Read more:
     * - [`source`](#source)
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['D', 'C', 'B', 'A'],
     *   // sort the `autocomplete` option in this order: D, C, B, A
     *   sortByRelevance: true
     * }],
     * ```
     */
    sortByRelevance: true,
    /**
     * The `source` option sets options available in [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) cells.
     *
     * You can set the `source` option to one of the following:
     *
     * - An array
     * - A function
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     * - [`strict`](#strict)
     * - [`allowHtml`](#allowHtml)
     * - [`filter`](#filter)
     * - [`sortByRelevance`](#sortByRelevance)
     *
     * @memberof Options#
     * @type {Array|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set `source` to an array
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C', 'D']
     * }],
     *
     * // set `source` to a function
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // for every `autocomplete` cell in this column, fetch data from an external source
     *   source(query, callback) {
     *     fetch('https://example.com/query?q=' + query, function(response) {
     *       callback(response.items);
     *     })
     *   }
     * }],
     * ```
     */
    source: void 0,
    /**
     * @description
     * If the [`data`](#data) option is not set, the `startCols` option sets the initial number of empty columns.
     *
     * The `startCols` option works only in Handsontable's constructor.
     *
     * @memberof Options#
     * @type {number}
     * @default 5
     * @category Core
     *
     * @example
     * ```js
     * // start with 15 empty columns
     * startCols: 15,
     * ```
     */
    startCols: 5,
    /**
     * @description
     * If the [`data`](#data) option is not set, the `startRows` option sets the initial number of empty rows.
     *
     * The `startRows` option works only in Handsontable's constructor.
     *
     * @memberof Options#
     * @type {number}
     * @default 5
     * @category Core
     *
     * @example
     * ```js
     * // start with 15 empty rows
     * startRows: 15,
     * ```
     */
    startRows: 5,
    /**
     * @description
     * The `stretchH` option determines what happens when the declared grid width
     * is different from the calculated sum of all column widths.
     *
     * You can set the `stretchH` option to one of the following:
     *
     * | Setting            | Description                                                       |
     * | ------------------ | ----------------------------------------------------------------- |
     * | `'none'` (default) | Don't fit the grid to the container (disable column stretching)   |
     * | `'last'`           | Fit the grid to the container, by stretching only the last column |
     * | `'all'`            | Fit the grid to the container, by stretching all columns evenly   |
     *
     * Read more:
     * - [Column width: Column stretching](@/guides/columns/column-width.md#column-stretching)
     *
     * @memberof Options#
     * @type {string}
     * @default 'none'
     * @category Core
     *
     * @example
     * ```js
     * // fit the grid to the container
     * // by stretching all columns evenly
     * stretchH: 'all',
     * ```
     */
    stretchH: "none",
    /**
     * The `strict` option configures the behavior of [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells.
     *
     * You can set the `strict` option to one of the following:
     *
     * | Setting | Mode                                                                                          | Description                                                                                |
     * | ------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
     * | `true`  | [Strict mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode)         | The end user:<br>- Can only choose one of suggested values<br>- Can't enter a custom value |
     * | `false` | [Flexible mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-flexible-mode)     | The end user:<br>- Can choose one of suggested values<br>- Can enter a custom value        |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [`source`](#source)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C'],
     *   // values entered must match `A`, `B`, or `C`
     *   strict: true
     *   },
     * ],
     * ```
     */
    strict: void 0,
    /**
     * The `tableClassName` option lets you add CSS class names
     * to every Handsontable instance inside the `container` element.
     *
     * You can set the `tableClassName` option to one of the following:
     *
     * | Setting             | Description                                                                                |
     * | ------------------- | ------------------------------------------------------------------------------------------ |
     * | A string            | Add a single CSS class name to every Handsontable instance inside the `container` element  |
     * | An array of strings | Add multiple CSS class names to every Handsontable instance inside the `container` element |
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string|string[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to every Handsontable instance inside the `container` element
     * tableClassName: 'your-class-name',
     *
     * // add `first-class-name` and `second-class-name` CSS class names
     * // to every Handsontable instance inside the `container` element
     * tableClassName: ['first-class-name', 'second-class-name'],
     * ```
     */
    tableClassName: void 0,
    /**
     * The `tabMoves` option configures the action of the <kbd>**Tab**</kbd> key.
     *
     * You can set the `tabMoves` option to an object with the following properties
     * (or to a function that returns such an object):
     *
     * | Property | Type   | Description                                                                                                                                              |
     * | -------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `row`    | Number | - On pressing <kbd>**Tab**</kbd>, move selection `row` rows down<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Tab**</kbd>, move selection `row` rows up              |
     * | `col`    | Number | - On pressing <kbd>**Tab**</kbd>, move selection `col` columns right<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Tab**</kbd>, move selection `col` columns left     |
     *
     * @memberof Options#
     * @type {object|Function}
     * @default {row: 0, col: 1}
     * @category Core
     *
     * @example
     * ```js
     * // on pressing Tab, move selection 2 rows down and 2 columns right
     * // on pressing Shift+Tab, move selection 2 rows up and 2 columns left
     * tabMoves: {row: 2, col: 2},
     *
     * // the same setting, as a function
     * // `event` is a DOM Event object received on pressing Tab
     * // you can use it to check whether the user pressed Tab or Shift+Tab
     * tabMoves(event) {
     *   return {row: 2, col: 2};
     * },
     * ```
     */
    tabMoves: {
      row: 0,
      col: 1
    },
    /**
     * @description
     * The `title` option configures [column header](@/guides/columns/column-header.md) names.
     *
     * You can set the `title` option to a string.
     *
     * Read more:
     * - [Column header](@/guides/columns/column-header.md)
     * - [`columns`](#columns)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the first column header name to `First name`
     *     title: 'First name',
     *     type: 'text',
     *   },
     *   {
     *     // set the second column header name to `Last name`
     *     title: 'Last name',
     *     type: 'text',
     *   }
     * ],
     * ```
     */
    title: void 0,
    /**
     * The `trimDropdown` option configures the width of the [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) lists.
     *
     * You can set the `trimDropdown` option to one of the following:
     *
     * | Setting          | Description                                                                     |
     * | ---------------- | ------------------------------------------------------------------------------- |
     * | `true` (default) | Make the dropdown/autocomplete list's width the same as the edited cell's width |
     * | `false`          | Scale the dropdown/autocomplete list's width to the list's content              |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     // for each cell of this column
     *     // make the `autocomplete` list's width the same as the edited cell's width
     *     trimDropdown: true,
     *   },
     *   {
     *     type: 'dropdown',
     *     // for each cell of this column
     *     // scale the `dropdown` list's width to the list's content
     *     trimDropdown: false,
     *   }
     * ],
     * ```
     */
    trimDropdown: true,
    /**
     * @description
     * The `trimRows` option configures the [`TrimRows`](@/api/trimRows.md) plugin.
     *
     * You can set the `trimRows` option to one of the following:
     *
     * | Setting                          | Description                                                                                   |
     * | -------------------------------- | --------------------------------------------------------------------------------------------- |
     * | `false`                          | Disable the [`TrimRows`](@/api/trimRows.md) plugin                                            |
     * | `true`                           | Enable the [`TrimRows`](@/api/trimRows.md) plugin                                             |
     * | An array of physical row indexes | - Enable the [`TrimRows`](@/api/trimRows.md) plugin<br>- Trim selected rows at initialization |
     *
     * Read more:
     * - [Plugins: `TrimRows`](@/api/trimRows.md)
     * - [Row trimming](@/guides/rows/row-trimming.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category TrimRows
     *
     * @example
     * ```js
     * // enable the `TrimRows` plugin
     * trimRows: true,
     *
     * // enable the `TrimRows` plugin
     * // at Handsontable's initialization, trim rows 5, 10, and 15
     * trimRows: [5, 10, 15],
     * ```
     */
    trimRows: void 0,
    /**
     * The `trimWhitespace` option configures automatic whitespace removal. This option
     * affects the cell renderer and the cell editor.
     *
     * You can set the `trimWhitespace` option to one of the following:
     *
     * | Setting          | Description                                                     |
     * | ---------------- | --------------------------------------------------------------- |
     * | `true` (default) | Remove whitespace at the beginning and at the end of each cell |
     * | `false`          | Don't remove whitespace                                         |
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // don't remove whitespace
     *     // from any cell of this column
     *     trimWhitespace: false
     *   }
     * ]
     * ```
     */
    trimWhitespace: true,
    /**
     * @description
     * The `type` option lets you set the [`renderer`](#renderer), [`editor`](#editor), and [`validator`](#validator)
     * options all at once, by selecting a [cell type](@/guides/cell-types/cell-type.md).
     *
     * You can set the `type` option to one of the following:
     *
     * | Cell type                                                         | Renderer, editor & validator                                                                                                                                                                                                                       |
     * | ----------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | A [custom cell type](@/guides/cell-types/cell-type.md)            | Renderer: your [custom cell renderer](@/guides/cell-functions/cell-renderer.md)<br>Editor: your [custom cell editor](@/guides/cell-functions/cell-editor.md)<br>Validator: your [custom cell validator](@/guides/cell-functions/cell-validator.md) |
     * | [`'autocomplete'`](@/guides/cell-types/autocomplete-cell-type.md) | Renderer: `AutocompleteRenderer`<br>Editor: `AutocompleteEditor`<br>Validator: `AutocompleteValidator`                                                                         |
     * | [`'checkbox'`](@/guides/cell-types/checkbox-cell-type.md)         | Renderer: `CheckboxRenderer`<br>Editor: `CheckboxEditor`<br>Validator: -                                                                                                                               |
     * | [`'date'`](@/guides/cell-types/date-cell-type.md)                 | Renderer: `DateRenderer`<br>Editor: `DateEditor`<br>Validator: `DateValidator`                                                                                                 |
     * | [`'dropdown'`](@/guides/cell-types/dropdown-cell-type.md)         | Renderer: `DropdownRenderer`<br>Editor: `DropdownEditor`<br>Validator: `DropdownValidator`                                                                                     |
     * | [`'handsontable'`](@/guides/cell-types/handsontable-cell-type.md) | Renderer: `AutocompleteRenderer`<br>Editor: `HandsontableEditor`<br>Validator: -                                                                                                                       |
     * | [`'numeric'`](@/guides/cell-types/numeric-cell-type.md)           | Renderer: `NumericRenderer`<br>Editor: `NumericEditor`<br>Validator: `NumericValidator`                                                                                        |
     * | [`'password'`](@/guides/cell-types/password-cell-type.md)         | Renderer: `PasswordRenderer`<br>Editor: `PasswordEditor`<br>Validator: -                                                                                                                               |
     * | `'text'`                                                          | Renderer: `TextRenderer`<br>Editor: `TextEditor`<br>Validator: -                                                                                                                                       |
     * | [`'time`'](@/guides/cell-types/time-cell-type.md)                 | Renderer: `TimeRenderer`<br>Editor: `TimeEditor`<br>Validator: `TimeValidator`                                                                                                 |
     *
     * Read more:
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Cell renderer](@/guides/cell-functions/cell-renderer.md)
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration)
     * - [`renderer`](#renderer)
     * - [`editor`](#editor)
     * - [`validator`](#validator)
     *
     * @memberof Options#
     * @type {string}
     * @default 'text'
     * @category Core
     *
     * @example
     * ```js
     * // set the `numeric` cell type for each cell of the entire grid
     * type: `'numeric'`,
     *
     * // apply the `type` option to individual columns
     * columns: [
     *   {
     *     // set the `autocomplete` cell type for each cell of this column
     *     type: 'autocomplete'
     *   },
     *   {
     *     // set the `myCustomCellType` cell type for each cell of this column
     *     type: 'myCustomCellType'
     *   }
     * ]
     * ```
     */
    type: "text",
    /**
     * The `uncheckedTemplate` option lets you configure what value
     * an unchecked [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell has.
     *
     * You can set the `uncheckedTemplate` option to one of the following:
     *
     * | Setting           | Description                                                                                                                                                                                |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `false` (default) | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns `false`                 |
     * | A string          | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns a string of your choice |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox template](@/guides/cell-types/checkbox-cell-type.md#checkbox-template)
     * - [`getDataAtCell()`](@/api/core.md#getDataAtCell)
     * - [`checkedTemplate`](#checkedTemplate)
     *
     * @memberof Options#
     * @type {boolean|string|number}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when unchecked, the cell's value is `false`
     *     // when checked, the cell's value is `true`
     *     type: 'checkbox',
     *   },
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when unchecked, the cell's value is `'No'`
     *     // when checked, the cell's value is `'Yes'`
     *     type: 'checkbox',
     *     uncheckedTemplate: 'No'
     *     checkedTemplate: 'Yes',
     *  }
     * ],
     * ```
     */
    uncheckedTemplate: void 0,
    /**
     * The `undo` option configures the [`UndoRedo`](@/api/undoRedo.md) plugin.
     *
     * You can set the `undo` option to one of the following:
     *
     * | Setting | Description                                        |
     * | ------- | -------------------------------------------------- |
     * | `true`  | Enable the [`UndoRedo`](@/api/undoRedo.md) plugin  |
     * | `false` | Disable the [`UndoRedo`](@/api/undoRedo.md) plugin |
     *
     * By default, the `undo` option is set to `undefined`,
     * but the [`UndoRedo`](@/api/undoRedo.md) plugin acts as enabled.
     * To disable the [`UndoRedo`](@/api/undoRedo.md) plugin completely,
     * set the `undo` option to `false`.
     *
     * Read more:
     * - [Undo and redo](@/guides/accessories-and-menus/undo-redo.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category UndoRedo
     *
     * @example
     * ```js
     * // enable the `UndoRedo` plugin
     * undo: true,
     * ```
     */
    undo: void 0,
    /**
     * @description
     * The `validator` option sets a [cell validator](@/guides/cell-functions/cell-validator.md) for a cell.
     *
     * You can set the `validator` option to one of the following:
     *
     * | Setting              | Description                                                                      |
     * | -------------------- | -------------------------------------------------------------------------------- |
     * | A string             | A [cell validator alias](@/guides/cell-functions/cell-validator.md)              |
     * | A function           | Your [custom cell validator function](@/guides/cell-functions/cell-validator.md) |
     * | A regular expression | A regular expression used for cell validation                                    |
     *
     * By setting the `validator` option to a string,
     * you can use one of the following [cell validator aliases](@/guides/cell-functions/cell-validator.md):
     *
     * | Alias               | Cell validator function                                                 |
     * | ------------------- | ----------------------------------------------------------------------- |
     * | A custom alias      | Your [custom cell validator](@/guides/cell-functions/cell-validator.md) |
     * | `'autocomplete'`    | `AutocompleteValidator`                                                 |
     * | `'date'`            | `DateValidator`                                                         |
     * | `'dropdown'`        | `DropdownValidator`                                                     |
     * | `'numeric'`         | `NumericValidator`                                                      |
     * | `'time'`            | `TimeValidator`                                                         |
     *
     * To set the [`editor`](#editor), [`renderer`](#renderer), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/setting-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {Function|RegExp|string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *    {
     *      // use a built-in `numeric` cell validator
     *      validator: 'numeric'
     *    },
     *    {
     *      // validate against a regular expression
     *      validator: /^[0-9]$/
     *    },
     *    {
     *      // add a custom cell validator function
     *      validator(value, callback) {
     *          ...
     *      }
     *    },
     * ],
     * ```
     */
    validator: void 0,
    /**
     * @description
     * The `viewportColumnRenderingOffset` option configures the number of columns
     * to be rendered outside of the grid's viewport.
     *
     * You can set the `viewportColumnRenderingOffset` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto` (default)   | Use the offset calculated automatically by Handsontable |
     * | A number           | Set the offset manually                                 |
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     *
     * @memberof Options#
     * @type {number|string}
     * @default 'auto'
     * @category Core
     *
     * @example
     * ```js
     * // render 70 columns outside of the grid's viewport
     * viewportColumnRenderingOffset: 70,
     * ```
     */
    viewportColumnRenderingOffset: "auto",
    /**
     * @description
     * The `viewportRowRenderingOffset` option configures the number of rows
     * to be rendered outside of the grid's viewport.
     *
     * You can set the `viewportRowRenderingOffset` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto` (default)   | Use the offset calculated automatically by Handsontable |
     * | A number           | Set the offset manually                                 |
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     * - [Column virtualization](@/guides/columns/column-virtualization.md)
     *
     * @memberof Options#
     * @type {number|string}
     * @default 'auto'
     * @category Core
     *
     * @example
     * ```js
     * // render 70 rows outside of the grid's viewport
     * viewportRowRenderingOffset: 70,
     * ```
     */
    viewportRowRenderingOffset: "auto",
    /**
     * The `visibleRows` option sets the height of the [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) lists.
     *
     * When the number of list options exceeds the `visibleRows` number, a scrollbar appears.
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 10
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     // set the `autocomplete` list's height to 15 options
     *     // for each cell of this column
     *     visibleRows: 15,
     *   },
     *   {
     *     type: 'dropdown',
     *     // set the `dropdown` list's height to 5 options
     *     // for each cell of this column
     *     visibleRows: 5,
     *   }
     * ],
     * ```
     */
    visibleRows: 10,
    /**
     * The `width` option configures the width of your grid.
     *
     * You can set the `width` option to one of the following:
     *
     * | Setting                                                                    | Example                   |
     * | -------------------------------------------------------------------------- | ------------------------- |
     * | A number of pixels                                                         | `width: 500`              |
     * | A string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | `width: '75vw'`           |
     * | A function that returns a valid number or string                           | `width() { return 500; }` |
     *
     * Read more:
     * - [Grid size](@/guides/getting-started/grid-size.md)
     *
     * @memberof Options#
     * @type {number|string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the grid's width to 500px
     * width: 500,
     *
     * // set the grid's width to 75vw
     * width: '75vw',
     *
     * // set the grid's width to 500px, using a function
     * width() {
     *   return 500;
     * },
     * ```
     */
    width: void 0,
    /**
     * The `wordWrap` option configures whether content that exceeds a column's width is wrapped or not.
     *
     * You can set the `wordWrap` option to one of the following:
     *
     * | Setting          | Description                                             |
     * | ---------------- | ------------------------------------------------------- |
     * | `true` (default) | If content exceeds the column's width, wrap the content |
     * | `false`          | Don't wrap content                                      |
     *
     * To style cells that don't wrap content, use the [`noWordWrapClassName`](#noWordWrapClassName) option.
     *
     * Read more:
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // set column width for every column of the entire grid
     * colWidths: 100,
     *
     * columns: [
     *   {
     *     // don't wrap content in this column
     *     wordWrap: false,
     *   },
     *   {
     *     // if content exceeds this column's width, wrap the content
     *     wordWrap: true,
     *   }
     * ],
     * ```
     */
    wordWrap: true
    /* eslint-enable jsdoc/require-description-complete-sentence */
  };
};
function _defineProperties$1H(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1H(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1H(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1H(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$1H(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function createTableMetaEmptyClass() {
  return /* @__PURE__ */ _createClass$1H(function TableMeta2() {
    _classCallCheck$1H(this, TableMeta2);
  });
}
var GlobalMeta = /* @__PURE__ */ function() {
  function GlobalMeta2(hot) {
    _classCallCheck$1H(this, GlobalMeta2);
    this.metaCtor = createTableMetaEmptyClass();
    this.meta = this.metaCtor.prototype;
    extend(this.meta, metaSchemaFactory());
    this.meta.instance = hot;
  }
  _createClass$1H(GlobalMeta2, [{
    key: "getMetaConstructor",
    value: function getMetaConstructor() {
      return this.metaCtor;
    }
    /**
     * Gets settings object for this layer.
     *
     * @returns {object}
     */
  }, {
    key: "getMeta",
    value: function getMeta() {
      return this.meta;
    }
    /**
     * Updates global settings object by merging settings with the current state.
     *
     * @param {object} settings An object to merge with.
     */
  }, {
    key: "updateMeta",
    value: function updateMeta(settings) {
      extend(this.meta, settings);
      extend(this.meta, expandMetaType(settings.type, settings));
    }
  }]);
  return GlobalMeta2;
}();
function _classCallCheck$1G(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1G(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1G(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1G(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1G(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var TableMeta = /* @__PURE__ */ function() {
  function TableMeta2(globalMeta) {
    _classCallCheck$1G(this, TableMeta2);
    var MetaCtor = globalMeta.getMetaConstructor();
    this.meta = new MetaCtor();
  }
  _createClass$1G(TableMeta2, [{
    key: "getMeta",
    value: function getMeta() {
      return this.meta;
    }
    /**
     * Updates table settings object by merging settings with the current state.
     *
     * @param {object} settings An object to merge with.
     */
  }, {
    key: "updateMeta",
    value: function updateMeta(settings) {
      extend(this.meta, settings);
      extend(this.meta, expandMetaType(settings.type, settings));
    }
  }]);
  return TableMeta2;
}();
function _toConsumableArray$l(arr) {
  return _arrayWithoutHoles$l(arr) || _iterableToArray$n(arr) || _unsupportedIterableToArray$U(arr) || _nonIterableSpread$l();
}
function _nonIterableSpread$l() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$U(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$U(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$U(o, minLen);
}
function _iterableToArray$n(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$l(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$U(arr);
}
function _arrayLikeToArray$U(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1F(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1F(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1F(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1F(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1F(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var LazyFactoryMap = /* @__PURE__ */ function(_Symbol$iterator) {
  function LazyFactoryMap2(valueFactory) {
    _classCallCheck$1F(this, LazyFactoryMap2);
    this.valueFactory = valueFactory;
    this.data = [];
    this.index = [];
    this.holes = /* @__PURE__ */ new Set();
  }
  _createClass$1F(LazyFactoryMap2, [{
    key: "obtain",
    value: function obtain(key) {
      assert(function() {
        return isUnsignedNumber(key);
      }, "Expecting an unsigned number.");
      var dataIndex = this._getStorageIndexByKey(key);
      var result;
      if (dataIndex >= 0) {
        result = this.data[dataIndex];
        if (result === void 0) {
          result = this.valueFactory(key);
          this.data[dataIndex] = result;
        }
      } else {
        result = this.valueFactory(key);
        if (this.holes.size > 0) {
          var reuseIndex = this.holes.values().next().value;
          this.holes.delete(reuseIndex);
          this.data[reuseIndex] = result;
          this.index[key] = reuseIndex;
        } else {
          this.data.push(result);
          this.index[key] = this.data.length - 1;
        }
      }
      return result;
    }
    /**
     * Inserts an empty data to the map. This method creates an empty space for obtaining
     * new data.
     *
     * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.
     * @param {number} [amount=1] Ammount of data to insert.
     */
  }, {
    key: "insert",
    value: function insert(key) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      assert(function() {
        return isUnsignedNumber(key) || isNullish(key);
      }, "Expecting an unsigned number or null/undefined argument.");
      var newIndexes = [];
      var dataLength = this.data.length;
      for (var i = 0; i < amount; i++) {
        newIndexes.push(dataLength + i);
        this.data.push(void 0);
      }
      var insertionIndex = isNullish(key) ? this.index.length : key;
      this.index = [].concat(_toConsumableArray$l(this.index.slice(0, insertionIndex)), newIndexes, _toConsumableArray$l(this.index.slice(insertionIndex)));
    }
    /**
     * Removes (soft remove) data from "index" and according to the amount of data.
     *
     * @param {number} key The key as volatile zero-based index at which to begin removing the data.
     * @param {number} [amount=1] Ammount data to remove.
     */
  }, {
    key: "remove",
    value: function remove(key) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      assert(function() {
        return isUnsignedNumber(key) || isNullish(key);
      }, "Expecting an unsigned number or null/undefined argument.");
      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);
      for (var i = 0; i < removed.length; i++) {
        var removedIndex = removed[i];
        if (typeof removedIndex === "number") {
          this.holes.add(removedIndex);
        }
      }
    }
    /**
     * Returns the size of the data which this map holds.
     *
     * @returns {number}
     */
  }, {
    key: "size",
    value: function size() {
      return this.data.length - this.holes.size;
    }
    /**
     * Returns a new Iterator object that contains the values for each item in the LazyMap object.
     *
     * @returns {Iterator}
     */
  }, {
    key: "values",
    value: function values3() {
      var _this = this;
      return arrayFilter(this.data, function(_, index2) {
        return !_this.holes.has(index2);
      })[Symbol.iterator]();
    }
    /**
     * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.
     *
     * @returns {Iterator}
     */
  }, {
    key: "entries",
    value: function entries() {
      var validEntries = [];
      for (var i = 0; i < this.data.length; i++) {
        var keyIndex = this._getKeyByStorageIndex(i);
        if (keyIndex !== -1) {
          validEntries.push([keyIndex, this.data[i]]);
        }
      }
      var dataIndex = 0;
      return {
        next: function next2() {
          if (dataIndex < validEntries.length) {
            var value = validEntries[dataIndex];
            dataIndex += 1;
            return {
              value,
              done: false
            };
          }
          return {
            done: true
          };
        }
      };
    }
    /**
     * Clears the map.
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.data = [];
      this.index = [];
      this.holes.clear();
    }
    /**
     * Gets storage index calculated from the key associated with the specified value.
     *
     * @param {number} key Volatile zero-based index.
     * @returns {number} Returns index 0-N or -1 if no storage index found.
     */
  }, {
    key: "_getStorageIndexByKey",
    value: function _getStorageIndexByKey(key) {
      return this.index.length > key ? this.index[key] : -1;
    }
    /**
     * Gets the key associated with the specified value calculated from storage index.
     *
     * @param {number} dataIndex Zero-based storage index.
     * @returns {number} Returns index 0-N or -1 if no key found.
     */
  }, {
    key: "_getKeyByStorageIndex",
    value: function _getKeyByStorageIndex(dataIndex) {
      return this.index.indexOf(dataIndex);
    }
    /**
     * Makes this object iterable.
     *
     * @returns {Iterator}
     */
  }, {
    key: _Symbol$iterator,
    value: function value() {
      return this.entries();
    }
  }]);
  return LazyFactoryMap2;
}(Symbol.iterator);
function _classCallCheck$1E(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1E(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1E(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1E(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1E(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var COLUMNS_PROPS_CONFLICTS = ["data", "width"];
var ColumnMeta = /* @__PURE__ */ function() {
  function ColumnMeta2(globalMeta) {
    var _this = this;
    _classCallCheck$1E(this, ColumnMeta2);
    this.globalMeta = globalMeta;
    this.metas = new LazyFactoryMap(function() {
      return _this._createMeta();
    });
  }
  _createClass$1E(ColumnMeta2, [{
    key: "updateMeta",
    value: function updateMeta(physicalColumn, settings) {
      var meta2 = this.getMeta(physicalColumn);
      extend(meta2, settings);
      extend(meta2, expandMetaType(settings.type, meta2));
    }
    /**
     * Creates one or more columns at specific position.
     *
     * @param {number} physicalColumn The physical column index which points from what position the column is added.
     * @param {number} amount An amount of columns to add.
     */
  }, {
    key: "createColumn",
    value: function createColumn(physicalColumn, amount) {
      this.metas.insert(physicalColumn, amount);
    }
    /**
     * Removes one or more columns from the collection.
     *
     * @param {number} physicalColumn The physical column index which points from what position the column is removed.
     * @param {number} amount An amount columns to remove.
     */
  }, {
    key: "removeColumn",
    value: function removeColumn(physicalColumn, amount) {
      this.metas.remove(physicalColumn, amount);
    }
    /**
     * Gets settings object for this layer.
     *
     * @param {number} physicalColumn The physical column index.
     * @returns {object}
     */
  }, {
    key: "getMeta",
    value: function getMeta(physicalColumn) {
      return this.metas.obtain(physicalColumn);
    }
    /**
     * Gets constructor of the column meta object. Necessary for inheritance - creating the next meta layers.
     *
     * @param {number} physicalColumn The physical column index.
     * @returns {Function}
     */
  }, {
    key: "getMetaConstructor",
    value: function getMetaConstructor(physicalColumn) {
      return this.metas.obtain(physicalColumn).constructor;
    }
    /**
     * Clears all saved column meta objects.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.metas.clear();
    }
    /**
     * Creates and returns new column meta object with properties inherited from the global meta layer.
     *
     * @private
     * @returns {object}
     */
  }, {
    key: "_createMeta",
    value: function _createMeta() {
      return columnFactory(this.globalMeta.getMetaConstructor(), COLUMNS_PROPS_CONFLICTS).prototype;
    }
  }]);
  return ColumnMeta2;
}();
function _toConsumableArray$k(arr) {
  return _arrayWithoutHoles$k(arr) || _iterableToArray$m(arr) || _unsupportedIterableToArray$T(arr) || _nonIterableSpread$k();
}
function _nonIterableSpread$k() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$T(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$T(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$T(o, minLen);
}
function _iterableToArray$m(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$k(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$T(arr);
}
function _arrayLikeToArray$T(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1D(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1D(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1D(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1D(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1D(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var CellMeta = /* @__PURE__ */ function() {
  function CellMeta2(columnMeta) {
    var _this = this;
    _classCallCheck$1D(this, CellMeta2);
    this.columnMeta = columnMeta;
    this.metas = new LazyFactoryMap(function() {
      return _this._createRow();
    });
  }
  _createClass$1D(CellMeta2, [{
    key: "updateMeta",
    value: function updateMeta(physicalRow, physicalColumn, settings) {
      var meta2 = this.getMeta(physicalRow, physicalColumn);
      extend(meta2, settings);
      extend(meta2, expandMetaType(settings.type, meta2));
    }
    /**
     * Creates one or more rows at specific position.
     *
     * @param {number} physicalRow The physical row index which points from what position the row is added.
     * @param {number} amount An amount of rows to add.
     */
  }, {
    key: "createRow",
    value: function createRow(physicalRow, amount) {
      this.metas.insert(physicalRow, amount);
    }
    /**
     * Creates one or more columns at specific position.
     *
     * @param {number} physicalColumn The physical column index which points from what position the column is added.
     * @param {number} amount An amount of columns to add.
     */
  }, {
    key: "createColumn",
    value: function createColumn(physicalColumn, amount) {
      for (var i = 0; i < this.metas.size(); i++) {
        this.metas.obtain(i).insert(physicalColumn, amount);
      }
    }
    /**
     * Removes one or more rows from the collection.
     *
     * @param {number} physicalRow The physical row index which points from what position the row is removed.
     * @param {number} amount An amount of rows to remove.
     */
  }, {
    key: "removeRow",
    value: function removeRow(physicalRow, amount) {
      this.metas.remove(physicalRow, amount);
    }
    /**
     * Removes one or more columns from the collection.
     *
     * @param {number} physicalColumn The physical column index which points from what position the column is removed.
     * @param {number} amount An amount of columns to remove.
     */
  }, {
    key: "removeColumn",
    value: function removeColumn(physicalColumn, amount) {
      for (var i = 0; i < this.metas.size(); i++) {
        this.metas.obtain(i).remove(physicalColumn, amount);
      }
    }
    /**
     * Gets settings object for this layer.
     *
     * @param {number} physicalRow The physical row index.
     * @param {number} physicalColumn The physical column index.
     * @param {string} [key] If the key exists its value will be returned, otherwise the whole cell meta object.
     * @returns {object}
     */
  }, {
    key: "getMeta",
    value: function getMeta(physicalRow, physicalColumn, key) {
      var cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
      if (key === void 0) {
        return cellMeta;
      }
      return cellMeta[key];
    }
    /**
     * Sets settings object for this layer defined by "key" property.
     *
     * @param {number} physicalRow The physical row index.
     * @param {number} physicalColumn The physical column index.
     * @param {string} key The property name to set.
     * @param {*} value Value to save.
     */
  }, {
    key: "setMeta",
    value: function setMeta(physicalRow, physicalColumn, key, value) {
      var cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
      cellMeta[key] = value;
    }
    /**
     * Removes a property defined by the "key" argument from the cell meta object.
     *
     * @param {number} physicalRow The physical row index.
     * @param {number} physicalColumn The physical column index.
     * @param {string} key The property name to remove.
     */
  }, {
    key: "removeMeta",
    value: function removeMeta(physicalRow, physicalColumn, key) {
      var cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
      delete cellMeta[key];
    }
    /**
     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta
     * objects are created lazy, the length of the returned collection depends on how and when the
     * table has asked for access to that meta objects.
     *
     * @returns {object[]}
     */
  }, {
    key: "getMetas",
    value: function getMetas() {
      var metas = [];
      var rows = Array.from(this.metas.values());
      for (var row = 0; row < rows.length; row++) {
        metas.push.apply(metas, _toConsumableArray$k(rows[row].values()));
      }
      return metas;
    }
    /**
     * Returns all cell meta objects that were created during the Handsontable operation but for
     * specyfic row index.
     *
     * @param {number} physicalRow The physical row index.
     * @returns {object[]}
     */
  }, {
    key: "getMetasAtRow",
    value: function getMetasAtRow(physicalRow) {
      assert(function() {
        return isUnsignedNumber(physicalRow);
      }, "Expecting an unsigned number.");
      var rowsMeta = new Map(this.metas);
      return rowsMeta.has(physicalRow) ? Array.from(rowsMeta.get(physicalRow).values()) : [];
    }
    /**
     * Clears all saved cell meta objects.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.metas.clear();
    }
    /**
     * Creates and returns new structure for cell meta objects stored in columnar axis.
     *
     * @private
     * @returns {object}
     */
  }, {
    key: "_createRow",
    value: function _createRow() {
      var _this2 = this;
      return new LazyFactoryMap(function(physicalColumn) {
        return _this2._createMeta(physicalColumn);
      });
    }
    /**
     * Creates and returns new cell meta object with properties inherited from the column meta layer.
     *
     * @private
     * @param {number} physicalColumn The physical column index.
     * @returns {object}
     */
  }, {
    key: "_createMeta",
    value: function _createMeta(physicalColumn) {
      var ColumnMeta2 = this.columnMeta.getMetaConstructor(physicalColumn);
      return new ColumnMeta2();
    }
  }]);
  return CellMeta2;
}();
function _classCallCheck$1C(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1C(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1C(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1C(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1C(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var MetaManager = /* @__PURE__ */ function() {
  function MetaManager2(hot) {
    var _this = this;
    var customSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var metaMods = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    _classCallCheck$1C(this, MetaManager2);
    this.hot = hot;
    this.globalMeta = new GlobalMeta(hot);
    this.tableMeta = new TableMeta(this.globalMeta);
    this.columnMeta = new ColumnMeta(this.globalMeta);
    this.cellMeta = new CellMeta(this.columnMeta);
    metaMods.forEach(function(ModifierClass) {
      return new ModifierClass(_this);
    });
    this.globalMeta.updateMeta(customSettings);
  }
  _createClass$1C(MetaManager2, [{
    key: "getGlobalMeta",
    value: function getGlobalMeta() {
      return this.globalMeta.getMeta();
    }
    /**
     * Updates global settings object by merging settings with the current state.
     *
     * @param {object} settings An object to merge with.
     */
  }, {
    key: "updateGlobalMeta",
    value: function updateGlobalMeta(settings) {
      this.globalMeta.updateMeta(settings);
    }
    /**
     * Gets settings object that was passed in the Handsontable constructor. That layer contains all
     * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.
     * Adding, removing, or changing property in that object has no direct reflection on any other layers.
     *
     * @returns {TableMeta}
     */
  }, {
    key: "getTableMeta",
    value: function getTableMeta() {
      return this.tableMeta.getMeta();
    }
    /**
     * Updates table settings object by merging settings with the current state.
     *
     * @param {object} settings An object to merge with.
     */
  }, {
    key: "updateTableMeta",
    value: function updateTableMeta(settings) {
      this.tableMeta.updateMeta(settings);
    }
    /**
     * Gets column meta object that is a root of all settings defined in the column property of the Handsontable
     * settings. Each column in the Handsontable is associated with a unique meta object which identified by
     * the physical column index. Adding, removing, or changing property in that object has a direct reflection
     * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower
     * layers (prototype lookup).
     *
     * @param {number} physicalColumn The physical column index.
     * @returns {object}
     */
  }, {
    key: "getColumnMeta",
    value: function getColumnMeta(physicalColumn) {
      return this.columnMeta.getMeta(physicalColumn);
    }
    /**
     * Updates column meta object by merging settings with the current state.
     *
     * @param {number} physicalColumn The physical column index which points what column meta object is updated.
     * @param {object} settings An object to merge with.
     */
  }, {
    key: "updateColumnMeta",
    value: function updateColumnMeta(physicalColumn, settings) {
      this.columnMeta.updateMeta(physicalColumn, settings);
    }
    /**
     * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by
     * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't
     * exist in that layer, it is looked up through a prototype to the highest layer. Starting
     * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,
     * removing, or changing property in that object has no direct reflection on any other layers.
     *
     * @param {number} physicalRow The physical row index.
     * @param {number} physicalColumn The physical column index.
     * @param {object} options Additional options that are used to extend the cell meta object.
     * @param {number} options.visualRow The visual row index of the currently requested cell meta object.
     * @param {number} options.visualColumn The visual column index of the currently requested cell meta object.
     * @returns {object}
     */
  }, {
    key: "getCellMeta",
    value: function getCellMeta(physicalRow, physicalColumn, _ref2) {
      var visualRow = _ref2.visualRow, visualColumn = _ref2.visualColumn;
      var cellMeta = this.cellMeta.getMeta(physicalRow, physicalColumn);
      cellMeta.visualRow = visualRow;
      cellMeta.visualCol = visualColumn;
      cellMeta.row = physicalRow;
      cellMeta.col = physicalColumn;
      this.runLocalHooks("afterGetCellMeta", cellMeta);
      return cellMeta;
    }
    /**
     * Gets a value (defined by the `key` property) from the cell meta object.
     *
     * @param {number} physicalRow The physical row index.
     * @param {number} physicalColumn The physical column index.
     * @param {string} key Defines the value that will be returned from the cell meta object.
     * @returns {*}
     */
  }, {
    key: "getCellMetaKeyValue",
    value: function getCellMetaKeyValue(physicalRow, physicalColumn, key) {
      if (typeof key !== "string") {
        throw new Error("The passed cell meta object key is not a string");
      }
      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);
    }
    /**
     * Sets settings object for cell meta object defined by "key" property.
     *
     * @param {number} physicalRow The physical row index.
     * @param {number} physicalColumn The physical column index.
     * @param {string} key The property name to set.
     * @param {*} value Value to save.
     */
  }, {
    key: "setCellMeta",
    value: function setCellMeta(physicalRow, physicalColumn, key, value) {
      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);
    }
    /**
     * Updates cell meta object by merging settings with the current state.
     *
     * @param {number} physicalRow The physical row index which points what cell meta object is updated.
     * @param {number} physicalColumn The physical column index which points what cell meta object is updated.
     * @param {object} settings An object to merge with.
     */
  }, {
    key: "updateCellMeta",
    value: function updateCellMeta(physicalRow, physicalColumn, settings) {
      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);
    }
    /**
     * Removes a property defined by the "key" argument from the cell meta object.
     *
     * @param {number} physicalRow The physical row index.
     * @param {number} physicalColumn The physical column index.
     * @param {string} key The property name to remove.
     */
  }, {
    key: "removeCellMeta",
    value: function removeCellMeta(physicalRow, physicalColumn, key) {
      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);
    }
    /**
     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta
     * objects are created lazy, the length of the returned collection depends on how and when the
     * table has asked for access to that meta objects.
     *
     * @returns {object[]}
     */
  }, {
    key: "getCellsMeta",
    value: function getCellsMeta() {
      return this.cellMeta.getMetas();
    }
    /**
     * Returns all cell meta objects that were created during the Handsontable operation but for
     * specyfic row index.
     *
     * @param {number} physicalRow The physical row index.
     * @returns {object[]}
     */
  }, {
    key: "getCellsMetaAtRow",
    value: function getCellsMetaAtRow(physicalRow) {
      return this.cellMeta.getMetasAtRow(physicalRow);
    }
    /**
     * Creates one or more rows at specific position.
     *
     * @param {number} physicalRow The physical row index which points from what position the row is added.
     * @param {number} [amount=1] An amount of rows to add.
     */
  }, {
    key: "createRow",
    value: function createRow(physicalRow) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.createRow(physicalRow, amount);
    }
    /**
     * Removes one or more rows from the collection.
     *
     * @param {number} physicalRow The physical row index which points from what position the row is removed.
     * @param {number} [amount=1] An amount rows to remove.
     */
  }, {
    key: "removeRow",
    value: function removeRow(physicalRow) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.removeRow(physicalRow, amount);
    }
    /**
     * Creates one or more columns at specific position.
     *
     * @param {number} physicalColumn The physical column index which points from what position the column is added.
     * @param {number} [amount=1] An amount of columns to add.
     */
  }, {
    key: "createColumn",
    value: function createColumn(physicalColumn) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.createColumn(physicalColumn, amount);
      this.columnMeta.createColumn(physicalColumn, amount);
    }
    /**
     * Removes one or more columns from the collection.
     *
     * @param {number} physicalColumn The physical column index which points from what position the column is removed.
     * @param {number} [amount=1] An amount of columns to remove.
     */
  }, {
    key: "removeColumn",
    value: function removeColumn(physicalColumn) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.removeColumn(physicalColumn, amount);
      this.columnMeta.removeColumn(physicalColumn, amount);
    }
    /**
     * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.
     */
  }, {
    key: "clearCellsCache",
    value: function clearCellsCache() {
      this.cellMeta.clearCache();
    }
    /**
     * Clears all saved cell and columns meta objects.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.cellMeta.clearCache();
      this.columnMeta.clearCache();
    }
  }]);
  return MetaManager2;
}();
mixin(MetaManager, localHooks$1);
function _typeof$13(obj) {
  "@babel/helpers - typeof";
  return _typeof$13 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$13(obj);
}
function replaceData(data2, setDataMapFunction, callbackFunction, config) {
  var hotInstance = config.hotInstance, dataMap = config.dataMap, dataSource = config.dataSource, internalSource = config.internalSource, source = config.source, firstRun = config.firstRun;
  var capitalizedInternalSource = toUpperCaseFirst(internalSource);
  var tableMeta = hotInstance.getSettings();
  if (Array.isArray(tableMeta.dataSchema)) {
    hotInstance.dataType = "array";
  } else if (isFunction(tableMeta.dataSchema)) {
    hotInstance.dataType = "function";
  } else {
    hotInstance.dataType = "object";
  }
  if (dataMap) {
    dataMap.destroy();
  }
  data2 = hotInstance.runHooks("before".concat(capitalizedInternalSource), data2, firstRun, source);
  var newDataMap = new DataMap$1(hotInstance, data2, tableMeta);
  setDataMapFunction(newDataMap);
  if (_typeof$13(data2) === "object" && data2 !== null) {
    if (!(data2.push && data2.splice)) {
      data2 = [data2];
    }
  } else if (data2 === null) {
    var dataSchema = newDataMap.getSchema();
    data2 = [];
    var row;
    var r2 = 0;
    var rlen = 0;
    for (r2 = 0, rlen = tableMeta.startRows; r2 < rlen; r2++) {
      if ((hotInstance.dataType === "object" || hotInstance.dataType === "function") && tableMeta.dataSchema) {
        row = deepClone(dataSchema);
        data2.push(row);
      } else if (hotInstance.dataType === "array") {
        row = deepClone(dataSchema[0]);
        data2.push(row);
      } else {
        row = [];
        for (var c2 = 0, clen = tableMeta.startCols; c2 < clen; c2++) {
          row.push(null);
        }
        data2.push(row);
      }
    }
  } else {
    throw new Error("".concat(internalSource, " only accepts array of objects or array of arrays (").concat(_typeof$13(data2), " given)"));
  }
  if (Array.isArray(data2[0])) {
    hotInstance.dataType = "array";
  }
  tableMeta.data = data2;
  newDataMap.dataSource = data2;
  dataSource.data = data2;
  dataSource.dataType = hotInstance.dataType;
  dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);
  dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);
  dataSource.countCachedColumns = newDataMap.countCachedColumns.bind(newDataMap);
  callbackFunction(newDataMap);
  hotInstance.runHooks("after".concat(capitalizedInternalSource), data2, firstRun, source);
  if (!firstRun) {
    hotInstance.runHooks("afterChange", null, internalSource);
    hotInstance.render();
  }
}
function _classCallCheck$1B(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1B(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1B(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1B(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1B(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DynamicCellMetaMod = /* @__PURE__ */ function() {
  function DynamicCellMetaMod2(metaManager) {
    var _this = this;
    _classCallCheck$1B(this, DynamicCellMetaMod2);
    this.metaManager = metaManager;
    this.metaSyncMemo = /* @__PURE__ */ new Map();
    metaManager.addLocalHook("afterGetCellMeta", function(cellMeta) {
      return _this.extendCellMeta(cellMeta);
    });
    Hooks$1.getSingleton().add("beforeRender", function(forceFullRender) {
      if (forceFullRender) {
        _this.metaSyncMemo.clear();
      }
    }, this.metaManager.hot);
  }
  _createClass$1B(DynamicCellMetaMod2, [{
    key: "extendCellMeta",
    value: function extendCellMeta(cellMeta) {
      var _this$metaSyncMemo$ge;
      var physicalRow = cellMeta.row, physicalColumn = cellMeta.col;
      if ((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && _this$metaSyncMemo$ge !== void 0 && _this$metaSyncMemo$ge.has(physicalColumn)) {
        return;
      }
      var visualRow = cellMeta.visualRow, visualCol = cellMeta.visualCol;
      var hot = this.metaManager.hot;
      var prop = hot.colToProp(visualCol);
      cellMeta.prop = prop;
      hot.runHooks("beforeGetCellMeta", visualRow, visualCol, cellMeta);
      var cellType = hasOwnProperty$2(cellMeta, "type") ? cellMeta.type : null;
      var cellSettings = isFunction(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, prop) : null;
      if (cellType) {
        if (cellSettings) {
          var _cellSettings$type;
          cellSettings.type = (_cellSettings$type = cellSettings.type) !== null && _cellSettings$type !== void 0 ? _cellSettings$type : cellType;
        } else {
          cellSettings = {
            type: cellType
          };
        }
      }
      if (cellSettings) {
        this.metaManager.updateCellMeta(physicalRow, physicalColumn, cellSettings);
      }
      hot.runHooks("afterGetCellMeta", visualRow, visualCol, cellMeta);
      if (!this.metaSyncMemo.has(physicalRow)) {
        this.metaSyncMemo.set(physicalRow, /* @__PURE__ */ new Set());
      }
      this.metaSyncMemo.get(physicalRow).add(physicalColumn);
    }
  }]);
  return DynamicCellMetaMod2;
}();
function _classCallCheck$1A(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1A(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1A(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1A(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1A(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ExtendMetaPropertiesMod = /* @__PURE__ */ function() {
  function ExtendMetaPropertiesMod2(metaManager) {
    _classCallCheck$1A(this, ExtendMetaPropertiesMod2);
    this.metaManager = metaManager;
    this.usageTracker = /* @__PURE__ */ new Set();
    this.propDescriptors = /* @__PURE__ */ new Map([["fixedColumnsLeft", {
      target: "fixedColumnsStart",
      onChange: function onChange2(propName) {
        var isRtl = this.metaManager.hot.isRtl();
        if (isRtl && propName === "fixedColumnsLeft") {
          throw new Error("The `fixedColumnsLeft` is not supported for RTL. Please use option `fixedColumnsStart`.");
        }
        if (this.usageTracker.has("fixedColumnsLeft") && this.usageTracker.has("fixedColumnsStart")) {
          throw new Error("The `fixedColumnsLeft` and `fixedColumnsStart` should not be used together. Please use only the option `fixedColumnsStart`.");
        }
      }
    }], ["layoutDirection", {
      onChange: function onChange2(propName, value, isInitialChange) {
        if (!isInitialChange) {
          throw new Error("The `".concat(propName, "` option can not be updated after the Handsontable is initialized."));
        }
      }
    }]]);
    this.extendMetaProps();
  }
  _createClass$1A(ExtendMetaPropertiesMod2, [{
    key: "extendMetaProps",
    value: function extendMetaProps() {
      var _this = this;
      this.propDescriptors.forEach(function(descriptor, alias) {
        var target = descriptor.target, _descriptor$onChange = descriptor.onChange, onChange2 = _descriptor$onChange === void 0 ? function() {
        } : _descriptor$onChange;
        var hasTarget = typeof target === "string";
        var targetProp = hasTarget ? target : alias;
        var origProp = "_".concat(targetProp);
        _this.metaManager.globalMeta.meta[origProp] = _this.metaManager.globalMeta.meta[targetProp];
        _this.installPropWatcher(alias, origProp, onChange2);
        if (hasTarget) {
          _this.installPropWatcher(target, origProp, onChange2);
        }
      });
    }
    /**
     * Installs the property watcher to the `propName` option and forwards getter and setter to
     * the new one.
     *
     * @param {string} propName The property to watch.
     * @param {string} origProp The property from/to the value is forwarded.
     * @param {Function} onChange The callback.
     */
  }, {
    key: "installPropWatcher",
    value: function installPropWatcher(propName, origProp, onChange2) {
      var self2 = this;
      Object.defineProperty(this.metaManager.globalMeta.meta, propName, {
        get: function get2() {
          return this[origProp];
        },
        set: function set2(value) {
          var isInitialChange = !self2.usageTracker.has(propName);
          self2.usageTracker.add(propName);
          onChange2.call(self2, propName, value, isInitialChange);
          this[origProp] = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }]);
  return ExtendMetaPropertiesMod2;
}();
var mappings = /* @__PURE__ */ new Map([
  [" ", "space"],
  // custom mapping
  ["spacebar", "space"],
  ["scroll", "scrolllock"],
  ["del", "delete"],
  ["esc", "escape"],
  ["medianexttrack", "mediatracknext"],
  ["mediaprevioustrack", "mediatrackprevious"],
  ["volumeup", "audiovolumeup"],
  ["volumedown", "audiovolumedown"],
  ["volumemute", "audiovolumemute"],
  ["multiply", "*"],
  ["add", "+"],
  ["divide", "/"],
  ["subtract", "-"],
  ["left", "arrowleft"],
  ["right", "arrowright"],
  ["up", "arrowup"],
  ["down", "arrowdown"]
]);
var normalizeKeys = function normalizeKeys2(keys3) {
  return keys3.map(function(key) {
    var lowercaseKey = key.toLowerCase();
    if (mappings.has(lowercaseKey)) {
      return mappings.get(lowercaseKey);
    }
    return lowercaseKey;
  }).sort().join("+");
};
var getKeysList = function getKeysList2(normalizedKeys) {
  return normalizedKeys.split("+");
};
var normalizeEventKey = function normalizeEventKey2(key) {
  return key.toLowerCase();
};
var _templateObject$b;
function _toConsumableArray$j(arr) {
  return _arrayWithoutHoles$j(arr) || _iterableToArray$l(arr) || _unsupportedIterableToArray$S(arr) || _nonIterableSpread$j();
}
function _nonIterableSpread$j() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$l(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$j(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$S(arr);
}
function _slicedToArray$C(arr, i) {
  return _arrayWithHoles$E(arr) || _iterableToArrayLimit$C(arr, i) || _unsupportedIterableToArray$S(arr, i) || _nonIterableRest$E();
}
function _nonIterableRest$E() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$S(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$S(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$S(o, minLen);
}
function _arrayLikeToArray$S(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$C(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$E(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _taggedTemplateLiteral$b(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
var createContext = function createContext2(name) {
  var SHORTCUTS = createUniqueMap({
    errorIdExists: function errorIdExists(keys3) {
      return 'The "'.concat(keys3, '" shortcut is already registered in the "').concat(name, '" context.');
    }
  });
  var addShortcut = function addShortcut2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, keys3 = _ref2.keys, callback = _ref2.callback, group = _ref2.group, _ref$runOnlyIf = _ref2.runOnlyIf, runOnlyIf = _ref$runOnlyIf === void 0 ? function() {
      return true;
    } : _ref$runOnlyIf, _ref$captureCtrl = _ref2.captureCtrl, captureCtrl = _ref$captureCtrl === void 0 ? false : _ref$captureCtrl, _ref$preventDefault = _ref2.preventDefault, preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault, _ref$stopPropagation = _ref2.stopPropagation, stopPropagation = _ref$stopPropagation === void 0 ? false : _ref$stopPropagation, relativeToGroup = _ref2.relativeToGroup, position = _ref2.position;
    if (isUndefined(group)) {
      throw new Error("You need to define the shortcut's group.");
    }
    if (isFunction(callback) === false) {
      throw new Error("The shortcut's callback needs to be a function.");
    }
    if (Array.isArray(keys3) === false) {
      throw new Error(toSingleLine(_templateObject$b || (_templateObject$b = _taggedTemplateLiteral$b(["Pass the shortcut's keys as an array of arrays, \n      using the KeyboardEvent.key properties: \n      https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values."], ["Pass the shortcut\\'s keys as an array of arrays,\\x20\n      using the KeyboardEvent.key properties:\\x20\n      https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values."]))));
    }
    var newShortcut = {
      callback,
      group,
      runOnlyIf,
      captureCtrl,
      preventDefault,
      stopPropagation
    };
    if (isDefined(relativeToGroup)) {
      var _ref22 = [relativeToGroup, position];
      newShortcut.relativeToGroup = _ref22[0];
      newShortcut.position = _ref22[1];
    }
    keys3.forEach(function(keyCombination) {
      var normalizedKeys = normalizeKeys(keyCombination);
      var hasKeyCombination = SHORTCUTS.hasItem(normalizedKeys);
      if (hasKeyCombination) {
        var shortcuts = SHORTCUTS.getItem(normalizedKeys);
        var insertionIndex = shortcuts.findIndex(function(shortcut) {
          return shortcut.group === relativeToGroup;
        });
        if (insertionIndex !== -1) {
          if (position === "before") {
            insertionIndex -= 1;
          } else {
            insertionIndex += 1;
          }
        } else {
          insertionIndex = shortcuts.length;
        }
        shortcuts.splice(insertionIndex, 0, newShortcut);
      } else {
        SHORTCUTS.addItem(normalizedKeys, [newShortcut]);
      }
    });
  };
  var addShortcuts = function addShortcuts2(shortcuts) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    shortcuts.forEach(function(shortcut) {
      objectEach(options, function(value, key) {
        if (Object.prototype.hasOwnProperty.call(shortcut, key) === false) {
          shortcut[key] = options[key];
        }
      });
      addShortcut(shortcut);
    });
  };
  var removeShortcutsByKeys = function removeShortcutsByKeys2(keys3) {
    var normalizedKeys = normalizeKeys(keys3);
    SHORTCUTS.removeItem(normalizedKeys);
  };
  var removeShortcutsByGroup = function removeShortcutsByGroup2(group) {
    var shortcuts = SHORTCUTS.getItems();
    shortcuts.forEach(function(_ref3) {
      var _ref4 = _slicedToArray$C(_ref3, 2), normalizedKeys = _ref4[0], shortcutOptions = _ref4[1];
      var leftOptions = shortcutOptions.filter(function(option) {
        return option.group !== group;
      });
      if (leftOptions.length === 0) {
        removeShortcutsByKeys(getKeysList(normalizedKeys));
      } else {
        shortcutOptions.length = 0;
        shortcutOptions.push.apply(shortcutOptions, _toConsumableArray$j(leftOptions));
      }
    });
  };
  var getShortcuts = function getShortcuts2(keys3) {
    var normalizedKeys = normalizeKeys(keys3);
    var shortcuts = SHORTCUTS.getItem(normalizedKeys);
    return isDefined(shortcuts) ? shortcuts.slice() : [];
  };
  var hasShortcut = function hasShortcut2(keys3) {
    var normalizedKeys = normalizeKeys(keys3);
    return SHORTCUTS.hasItem(normalizedKeys);
  };
  return {
    addShortcut,
    addShortcuts,
    getShortcuts,
    hasShortcut,
    removeShortcutsByKeys,
    removeShortcutsByGroup
  };
};
function createKeysObserver() {
  var PRESSED_KEYS = /* @__PURE__ */ new Set();
  return {
    /**
     * Press a key.
     *
     * @param {string} key Names of the shortcut's keys,
     * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),
     * in lowercase or uppercase, unified across browsers
     */
    press: function press(key) {
      PRESSED_KEYS.add(key);
    },
    /**
     * Release a pressed key.
     *
     * @param {string} key Names of the shortcut's keys,
     * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),
     * in lowercase or uppercase, unified across browsers
     */
    release: function release(key) {
      PRESSED_KEYS.delete(key);
    },
    /**
     * Release all pressed keys.
     */
    releaseAll: function releaseAll() {
      PRESSED_KEYS.clear();
    },
    /**
     * Check if a key is pressed.
     *
     * @param {string} key Names of the shortcut's keys,
     * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),
     * in lowercase or uppercase, unified across browsers
     * @returns {boolean}
     */
    isPressed: function isPressed(key) {
      return PRESSED_KEYS.has(key);
    }
  };
}
var MODIFIER_KEYS = ["meta", "alt", "shift", "control"];
var modifierKeysObserver = createKeysObserver();
function useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, callback) {
  var isModifierKey = function isModifierKey2(pressedKey) {
    return MODIFIER_KEYS.includes(pressedKey);
  };
  var getPressedModifierKeys = function getPressedModifierKeys2(event2) {
    var mergeMetaKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var pressedModifierKeys = [];
    if (event2.altKey) {
      pressedModifierKeys.push("alt");
    }
    if (mergeMetaKeys && (event2.ctrlKey || event2.metaKey)) {
      pressedModifierKeys.push("control/meta");
    } else {
      if (event2.ctrlKey) {
        pressedModifierKeys.push("control");
      }
      if (event2.metaKey) {
        pressedModifierKeys.push("meta");
      }
    }
    if (event2.shiftKey) {
      pressedModifierKeys.push("shift");
    }
    return pressedModifierKeys;
  };
  var onkeydown = function onkeydown2(event2) {
    if (handleEvent(event2) === false) {
      return;
    }
    var result = beforeKeyDown(event2);
    if (event2.keyCode === 229 || result === false || isImmediatePropagationStopped(event2)) {
      return;
    }
    var pressedKey = normalizeEventKey(event2.key);
    var extraModifierKeys = [];
    if (isModifierKey(pressedKey)) {
      modifierKeysObserver.press(pressedKey);
    } else {
      extraModifierKeys = getPressedModifierKeys(event2);
    }
    var pressedKeys = [pressedKey].concat(extraModifierKeys);
    var isExecutionCancelled = callback(event2, pressedKeys);
    if (!isExecutionCancelled && (isMacOS() && extraModifierKeys.includes("meta") || !isMacOS() && extraModifierKeys.includes("control"))) {
      callback(event2, [pressedKey].concat(getPressedModifierKeys(event2, true)));
    }
    afterKeyDown(event2);
  };
  var onkeyup = function onkeyup2(event2) {
    if (handleEvent(event2) === false) {
      return;
    }
    var pressedKey = normalizeEventKey(event2.key);
    if (isModifierKey(pressedKey) === false) {
      return;
    }
    modifierKeysObserver.release(pressedKey);
  };
  var onblur = function onblur2() {
    modifierKeysObserver.releaseAll();
  };
  var mount = function mount2() {
    var eventTarget = ownerWindow;
    while (eventTarget) {
      eventTarget.document.documentElement.addEventListener("keydown", onkeydown);
      eventTarget.document.documentElement.addEventListener("keyup", onkeyup);
      eventTarget.document.documentElement.addEventListener("blur", onblur);
      eventTarget = getParentWindow(eventTarget);
    }
  };
  var unmount = function unmount2() {
    var eventTarget = ownerWindow;
    while (eventTarget) {
      eventTarget.document.documentElement.removeEventListener("keydown", onkeydown);
      eventTarget.document.documentElement.removeEventListener("keyup", onkeyup);
      eventTarget.document.documentElement.removeEventListener("blur", onblur);
      eventTarget = getParentWindow(eventTarget);
    }
  };
  return {
    mount,
    unmount,
    isPressed: function isPressed(key) {
      return modifierKeysObserver.isPressed(key);
    }
  };
}
var createShortcutManager = function createShortcutManager2(_ref2) {
  var ownerWindow = _ref2.ownerWindow, handleEvent = _ref2.handleEvent, beforeKeyDown = _ref2.beforeKeyDown, afterKeyDown = _ref2.afterKeyDown;
  var CONTEXTS = createUniqueMap({
    errorIdExists: function errorIdExists(keys3) {
      return 'The "'.concat(keys3, '" context name is already registered.');
    }
  });
  var activeContextName = "grid";
  var addContext = function addContext2(contextName) {
    var context = createContext(contextName);
    CONTEXTS.addItem(contextName, context);
    return context;
  };
  var getActiveContextName = function getActiveContextName2() {
    return activeContextName;
  };
  var getContext = function getContext2(contextName) {
    return CONTEXTS.getItem(contextName);
  };
  var setActiveContextName = function setActiveContextName2(contextName) {
    activeContextName = contextName;
  };
  var isCtrlKeySilenced = false;
  var keyRecorder = useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, function(event2, keys3) {
    var activeContext = getContext(getActiveContextName());
    var isExecutionCancelled = false;
    if (!activeContext.hasShortcut(keys3)) {
      return isExecutionCancelled;
    }
    var shortcuts = activeContext.getShortcuts(keys3);
    for (var index2 = 0; index2 < shortcuts.length; index2++) {
      var _shortcuts$index = shortcuts[index2], callback = _shortcuts$index.callback, runOnlyIf = _shortcuts$index.runOnlyIf, preventDefault = _shortcuts$index.preventDefault, stopPropagation = _shortcuts$index.stopPropagation, captureCtrl = _shortcuts$index.captureCtrl;
      if (runOnlyIf(event2) !== false) {
        isCtrlKeySilenced = captureCtrl;
        isExecutionCancelled = callback(event2, keys3) === false;
        isCtrlKeySilenced = false;
        if (preventDefault) {
          event2.preventDefault();
        }
        if (stopPropagation) {
          event2.stopPropagation();
        }
        if (isExecutionCancelled) {
          break;
        }
      }
    }
    return isExecutionCancelled;
  });
  keyRecorder.mount();
  return {
    addContext,
    getActiveContextName,
    getContext,
    setActiveContextName,
    /**
     * Returns whether `control` or `meta` keys are pressed.
     *
     * @memberof ShortcutManager#
     * @type {Function}
     * @returns {boolean}
     */
    isCtrlPressed: function isCtrlPressed() {
      return !isCtrlKeySilenced && (keyRecorder.isPressed("control") || keyRecorder.isPressed("meta"));
    },
    /**
     * Destroy a context manager instance.
     *
     * @type {Function}
     * @memberof ShortcutManager#
     */
    destroy: function destroy() {
      return keyRecorder.unmount();
    }
  };
};
function _typeof$12(obj) {
  "@babel/helpers - typeof";
  return _typeof$12 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$12(obj);
}
function _slicedToArray$B(arr, i) {
  return _arrayWithHoles$D(arr) || _iterableToArrayLimit$B(arr, i) || _unsupportedIterableToArray$R(arr, i) || _nonIterableRest$D();
}
function _nonIterableRest$D() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$B(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$D(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$i(arr) {
  return _arrayWithoutHoles$i(arr) || _iterableToArray$k(arr) || _unsupportedIterableToArray$R(arr) || _nonIterableSpread$i();
}
function _nonIterableSpread$i() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$R(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$R(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$R(o, minLen);
}
function _iterableToArray$k(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$i(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$R(arr);
}
function _arrayLikeToArray$R(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var SHORTCUTS_GROUP$7 = "gridDefault";
var activeGuid = null;
function Core(rootElement, userSettings) {
  var _userSettings$layoutD, _this = this;
  var rootInstanceSymbol2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var preventScrollingToCell = false;
  var instance = this;
  var eventManager = new EventManager$1(instance);
  var datamap;
  var dataSource;
  var grid;
  var editorManager;
  var firstRun = true;
  if (hasValidParameter(rootInstanceSymbol2)) {
    registerAsRootInstance(this);
  }
  this.rootElement = rootElement;
  this.rootDocument = rootElement.ownerDocument;
  this.rootWindow = this.rootDocument.defaultView;
  this.isDestroyed = false;
  this.renderSuspendedCounter = 0;
  this.executionSuspendedCounter = 0;
  var layoutDirection = (_userSettings$layoutD = userSettings === null || userSettings === void 0 ? void 0 : userSettings.layoutDirection) !== null && _userSettings$layoutD !== void 0 ? _userSettings$layoutD : "inherit";
  var rootElementDirection = ["rtl", "ltr"].includes(layoutDirection) ? layoutDirection : this.rootWindow.getComputedStyle(this.rootElement).direction;
  this.rootElement.setAttribute("dir", rootElementDirection);
  this.isRtl = function() {
    return rootElementDirection === "rtl";
  };
  this.isLtr = function() {
    return !instance.isRtl();
  };
  this.getDirectionFactor = function() {
    return instance.isLtr() ? 1 : -1;
  };
  userSettings.language = getValidLanguageCode(userSettings.language);
  var metaManager = new MetaManager(instance, userSettings, [DynamicCellMetaMod, ExtendMetaPropertiesMod]);
  var tableMeta = metaManager.getTableMeta();
  var globalMeta = metaManager.getGlobalMeta();
  var pluginsRegistry = createUniqueMap();
  this.container = this.rootDocument.createElement("div");
  this.renderCall = false;
  rootElement.insertBefore(this.container, rootElement.firstChild);
  if (isRootInstance(this)) {
    _injectProductInfo(userSettings.licenseKey, rootElement);
  }
  this.guid = "ht_".concat(randomString());
  this.columnIndexMapper = new IndexMapper();
  this.rowIndexMapper = new IndexMapper();
  dataSource = new DataSource$1(instance);
  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === "ht_") {
    this.rootElement.id = this.guid;
  }
  var visualToRenderableCoords = function visualToRenderableCoords2(coords) {
    var visualRow = coords.row, visualColumn = coords.col;
    return instance._createCellCoords(
      // We just store indexes for rows and columns without headers.
      visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow,
      visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn
    );
  };
  var renderableToVisualCoords = function renderableToVisualCoords2(coords) {
    var renderableRow = coords.row, renderableColumn = coords.col;
    return instance._createCellCoords(
      // We just store indexes for rows and columns without headers.
      renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow,
      renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn
      // eslint-disable-line max-len
    );
  };
  var selection = new Selection$1(tableMeta, {
    rowIndexMapper: function rowIndexMapper() {
      return instance.rowIndexMapper;
    },
    columnIndexMapper: function columnIndexMapper() {
      return instance.columnIndexMapper;
    },
    countCols: function countCols() {
      return instance.countCols();
    },
    countRows: function countRows() {
      return instance.countRows();
    },
    propToCol: function propToCol(prop) {
      return datamap.propToCol(prop);
    },
    isEditorOpened: function isEditorOpened() {
      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;
    },
    countColsTranslated: function countColsTranslated() {
      return _this.view.countRenderableColumns();
    },
    countRowsTranslated: function countRowsTranslated() {
      return _this.view.countRenderableRows();
    },
    getShortcutManager: function getShortcutManager() {
      return instance.getShortcutManager();
    },
    createCellCoords: function createCellCoords(row, column) {
      return instance._createCellCoords(row, column);
    },
    createCellRange: function createCellRange(highlight, from3, to) {
      return instance._createCellRange(highlight, from3, to);
    },
    visualToRenderableCoords,
    renderableToVisualCoords,
    isDisabledCellSelection: function isDisabledCellSelection(visualRow, visualColumn) {
      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;
    }
  });
  this.selection = selection;
  var onIndexMapperCacheUpdate = function onIndexMapperCacheUpdate2(_ref2) {
    var hiddenIndexesChanged = _ref2.hiddenIndexesChanged;
    if (hiddenIndexesChanged) {
      _this.selection.refresh();
    }
  };
  this.columnIndexMapper.addLocalHook("cacheUpdated", onIndexMapperCacheUpdate);
  this.rowIndexMapper.addLocalHook("cacheUpdated", onIndexMapperCacheUpdate);
  this.selection.addLocalHook("beforeSetRangeStart", function(cellCoords) {
    _this.runHooks("beforeSetRangeStart", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeStartOnly", function(cellCoords) {
    _this.runHooks("beforeSetRangeStartOnly", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeEnd", function(cellCoords) {
    _this.runHooks("beforeSetRangeEnd", cellCoords);
    if (cellCoords.row < 0) {
      cellCoords.row = _this.view._wt.wtTable.getFirstVisibleRow();
    }
    if (cellCoords.col < 0) {
      cellCoords.col = _this.view._wt.wtTable.getFirstVisibleColumn();
    }
  });
  this.selection.addLocalHook("afterSetRangeEnd", function(cellCoords) {
    var preventScrolling = createObjectPropListener(false);
    var selectionRange = _this.selection.getSelectedRange();
    var _selectionRange$curre = selectionRange.current(), from3 = _selectionRange$curre.from, to = _selectionRange$curre.to;
    var selectionLayerLevel = selectionRange.size() - 1;
    _this.runHooks("afterSelection", from3.row, from3.col, to.row, to.col, preventScrolling, selectionLayerLevel);
    _this.runHooks("afterSelectionByProp", from3.row, instance.colToProp(from3.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel);
    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();
    var currentSelectedRange = _this.selection.selectedRange.current();
    var scrollToCell = true;
    if (preventScrollingToCell) {
      scrollToCell = false;
    }
    if (preventScrolling.isTouched()) {
      scrollToCell = !preventScrolling.value;
    }
    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();
    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();
    if (scrollToCell !== false) {
      if (!isSelectedByAnyHeader) {
        if (currentSelectedRange && !_this.selection.isMultiple()) {
          _this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from));
        } else {
          _this.view.scrollViewport(visualToRenderableCoords(cellCoords));
        }
      } else if (isSelectedByRowHeader) {
        _this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromVisualIndex(cellCoords.row));
      } else if (isSelectedByColumnHeader) {
        _this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderableFromVisualIndex(cellCoords.col));
      }
    }
    if (isSelectedByRowHeader && isSelectedByColumnHeader) {
      addClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    } else if (isSelectedByRowHeader) {
      removeClass(_this.rootElement, "ht__selection--columns");
      addClass(_this.rootElement, "ht__selection--rows");
    } else if (isSelectedByColumnHeader) {
      removeClass(_this.rootElement, "ht__selection--rows");
      addClass(_this.rootElement, "ht__selection--columns");
    } else {
      removeClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    }
    _this._refreshBorders(null);
  });
  this.selection.addLocalHook("afterSelectionFinished", function(cellRanges) {
    var selectionLayerLevel = cellRanges.length - 1;
    var _cellRanges$selection = cellRanges[selectionLayerLevel], from3 = _cellRanges$selection.from, to = _cellRanges$selection.to;
    _this.runHooks("afterSelectionEnd", from3.row, from3.col, to.row, to.col, selectionLayerLevel);
    _this.runHooks("afterSelectionEndByProp", from3.row, instance.colToProp(from3.col), to.row, instance.colToProp(to.col), selectionLayerLevel);
  });
  this.selection.addLocalHook("afterIsMultipleSelection", function(isMultiple) {
    var changedIsMultiple = _this.runHooks("afterIsMultipleSelection", isMultiple.value);
    if (isMultiple.value) {
      isMultiple.value = changedIsMultiple;
    }
  });
  this.selection.addLocalHook("beforeModifyTransformStart", function(cellCoordsDelta) {
    _this.runHooks("modifyTransformStart", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformStart", function(coords, rowTransformDir, colTransformDir) {
    _this.runHooks("afterModifyTransformStart", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("beforeModifyTransformEnd", function(cellCoordsDelta) {
    _this.runHooks("modifyTransformEnd", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformEnd", function(coords, rowTransformDir, colTransformDir) {
    _this.runHooks("afterModifyTransformEnd", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("afterDeselect", function() {
    editorManager.destroyEditor();
    _this._refreshBorders();
    removeClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    _this.runHooks("afterDeselect");
  });
  this.selection.addLocalHook("insertRowRequire", function(totalRows) {
    _this.alter("insert_row", totalRows, 1, "auto");
  });
  this.selection.addLocalHook("insertColRequire", function(totalCols) {
    _this.alter("insert_col", totalCols, 1, "auto");
  });
  grid = {
    /**
     * Inserts or removes rows and columns.
     *
     * @private
     * @param {string} action Possible values: "insert_row", "insert_col", "remove_row", "remove_col".
     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.
     *                             Alter actions such as "remove_row" and "remove_col" support array indexes in the
     *                             format `[[index, amount], [index, amount]...]` this can be used to remove
     *                             non-consecutive columns or rows in one call.
     * @param {number} [amount=1] Ammount rows or columns to remove.
     * @param {string} [source] Optional. Source of hook runner.
     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
     */
    alter: function alter(action, index2) {
      var amount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var source = arguments.length > 3 ? arguments[3] : void 0;
      var keepEmptyRows = arguments.length > 4 ? arguments[4] : void 0;
      var delta;
      var normalizeIndexesGroup = function normalizeIndexesGroup2(indexes) {
        if (indexes.length === 0) {
          return [];
        }
        var sortedIndexes = _toConsumableArray$i(indexes);
        sortedIndexes.sort(function(_ref2, _ref3) {
          var _ref4 = _slicedToArray$B(_ref2, 1), indexA = _ref4[0];
          var _ref5 = _slicedToArray$B(_ref3, 1), indexB = _ref5[0];
          if (indexA === indexB) {
            return 0;
          }
          return indexA > indexB ? 1 : -1;
        });
        var normalizedIndexes = arrayReduce$1(sortedIndexes, function(acc, _ref6) {
          var _ref7 = _slicedToArray$B(_ref6, 2), groupIndex = _ref7[0], groupAmount = _ref7[1];
          var previousItem = acc[acc.length - 1];
          var _previousItem = _slicedToArray$B(previousItem, 2), prevIndex = _previousItem[0], prevAmount = _previousItem[1];
          var prevLastIndex = prevIndex + prevAmount;
          if (groupIndex <= prevLastIndex) {
            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);
            previousItem[1] += amountToAdd;
          } else {
            acc.push([groupIndex, groupAmount]);
          }
          return acc;
        }, [sortedIndexes[0]]);
        return normalizedIndexes;
      };
      switch (action) {
        case "insert_row":
          var numberOfSourceRows = instance.countSourceRows();
          if (tableMeta.maxRows === numberOfSourceRows) {
            return;
          }
          index2 = isDefined(index2) ? index2 : numberOfSourceRows;
          delta = datamap.createRow(index2, amount, source);
          if (delta) {
            metaManager.createRow(instance.toPhysicalRow(index2), amount);
            var currentSelectedRange = selection.selectedRange.current();
            var currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;
            var currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row;
            if (isDefined(currentFromRow) && currentFromRow >= index2) {
              var _currentSelectedRange = currentSelectedRange.to, currentToRow = _currentSelectedRange.row, currentToColumn = _currentSelectedRange.col;
              var currentFromColumn = currentFromRange.col;
              if (selection.isSelectedByRowHeader()) {
                currentFromColumn = -1;
              }
              selection.getSelectedRange().pop();
              selection.setRangeStartOnly(instance._createCellCoords(currentFromRow + delta, currentFromColumn), true);
              selection.setRangeEnd(instance._createCellCoords(currentToRow + delta, currentToColumn));
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "insert_col":
          delta = datamap.createCol(index2, amount, source);
          if (delta) {
            metaManager.createColumn(instance.toPhysicalColumn(index2), amount);
            if (Array.isArray(tableMeta.colHeaders)) {
              var spliceArray = [index2, 0];
              spliceArray.length += delta;
              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray);
            }
            var _currentSelectedRange2 = selection.selectedRange.current();
            var _currentFromRange = _currentSelectedRange2 === null || _currentSelectedRange2 === void 0 ? void 0 : _currentSelectedRange2.from;
            var _currentFromColumn = _currentFromRange === null || _currentFromRange === void 0 ? void 0 : _currentFromRange.col;
            if (isDefined(_currentFromColumn) && _currentFromColumn >= index2) {
              var _currentSelectedRange3 = _currentSelectedRange2.to, _currentToRow = _currentSelectedRange3.row, _currentToColumn = _currentSelectedRange3.col;
              var _currentFromRow = _currentFromRange.row;
              if (selection.isSelectedByColumnHeader()) {
                _currentFromRow = -1;
              }
              selection.getSelectedRange().pop();
              selection.setRangeStartOnly(instance._createCellCoords(_currentFromRow, _currentFromColumn + delta), true);
              selection.setRangeEnd(instance._createCellCoords(_currentToRow, _currentToColumn + delta));
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "remove_row":
          var removeRow = function removeRow2(indexes) {
            var offset2 = 0;
            arrayEach(indexes, function(_ref8) {
              var _ref9 = _slicedToArray$B(_ref8, 2), groupIndex = _ref9[0], groupAmount = _ref9[1];
              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset2, 0);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset2, 0);
              }
              var wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              metaManager.removeRow(instance.toPhysicalRow(calcIndex), groupAmount);
              var totalRows = instance.countRows();
              var fixedRowsTop = tableMeta.fixedRowsTop;
              if (fixedRowsTop >= calcIndex + 1) {
                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);
              }
              var fixedRowsBottom = tableMeta.fixedRowsBottom;
              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {
                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);
              }
              offset2 += groupAmount;
            });
          };
          if (Array.isArray(index2)) {
            removeRow(normalizeIndexesGroup(index2));
          } else {
            removeRow([[index2, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        case "remove_col":
          var removeCol = function removeCol2(indexes) {
            var offset2 = 0;
            arrayEach(indexes, function(_ref10) {
              var _ref11 = _slicedToArray$B(_ref10, 2), groupIndex = _ref11[0], groupAmount = _ref11[1];
              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset2, 0);
              var physicalColumnIndex = instance.toPhysicalColumn(calcIndex);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset2, 0);
              }
              var wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              metaManager.removeColumn(physicalColumnIndex, groupAmount);
              var fixedColumnsStart = tableMeta.fixedColumnsStart;
              if (fixedColumnsStart >= calcIndex + 1) {
                tableMeta.fixedColumnsStart -= Math.min(groupAmount, fixedColumnsStart - calcIndex);
              }
              if (Array.isArray(tableMeta.colHeaders)) {
                if (typeof physicalColumnIndex === "undefined") {
                  physicalColumnIndex = -1;
                }
                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);
              }
              offset2 += groupAmount;
            });
          };
          if (Array.isArray(index2)) {
            removeCol(normalizeIndexesGroup(index2));
          } else {
            removeCol([[index2, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        default:
          throw new Error('There is no such action "'.concat(action, '"'));
      }
      if (!keepEmptyRows) {
        grid.adjustRowsAndCols();
      }
    },
    /**
     * Makes sure there are empty rows at the bottom of the table.
     *
     * @private
     */
    adjustRowsAndCols: function adjustRowsAndCols() {
      var minRows = tableMeta.minRows;
      var minSpareRows = tableMeta.minSpareRows;
      var minCols = tableMeta.minCols;
      var minSpareCols = tableMeta.minSpareCols;
      if (minRows) {
        var nrOfRows = instance.countRows();
        if (nrOfRows < minRows) {
          datamap.createRow(nrOfRows, minRows - nrOfRows, "auto");
        }
      }
      if (minSpareRows) {
        var emptyRows = instance.countEmptyRows(true);
        if (emptyRows < minSpareRows) {
          var emptyRowsMissing = minSpareRows - emptyRows;
          var rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows());
          datamap.createRow(instance.countRows(), rowsToCreate, "auto");
        }
      }
      {
        var emptyCols;
        if (minCols || minSpareCols) {
          emptyCols = instance.countEmptyCols(true);
        }
        var nrOfColumns = instance.countCols();
        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {
          var colsToCreate = minCols - nrOfColumns;
          emptyCols += colsToCreate;
          datamap.createCol(nrOfColumns, colsToCreate, "auto");
        }
        if (minSpareCols && !tableMeta.columns && instance.dataType === "array" && emptyCols < minSpareCols) {
          nrOfColumns = instance.countCols();
          var emptyColsMissing = minSpareCols - emptyCols;
          var _colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns);
          datamap.createCol(nrOfColumns, _colsToCreate, "auto");
        }
      }
      var rowCount = instance.countRows();
      var colCount = instance.countCols();
      if (rowCount === 0 || colCount === 0) {
        selection.deselect();
      }
      if (selection.isSelected()) {
        arrayEach(selection.selectedRange, function(range) {
          var selectionChanged = false;
          var fromRow = range.from.row;
          var fromCol = range.from.col;
          var toRow = range.to.row;
          var toCol = range.to.col;
          if (fromRow > rowCount - 1) {
            fromRow = rowCount - 1;
            selectionChanged = true;
            if (toRow > fromRow) {
              toRow = fromRow;
            }
          } else if (toRow > rowCount - 1) {
            toRow = rowCount - 1;
            selectionChanged = true;
            if (fromRow > toRow) {
              fromRow = toRow;
            }
          }
          if (fromCol > colCount - 1) {
            fromCol = colCount - 1;
            selectionChanged = true;
            if (toCol > fromCol) {
              toCol = fromCol;
            }
          } else if (toCol > colCount - 1) {
            toCol = colCount - 1;
            selectionChanged = true;
            if (fromCol > toCol) {
              fromCol = toCol;
            }
          }
          if (selectionChanged) {
            instance.selectCell(fromRow, fromCol, toRow, toCol);
          }
        });
      }
      if (instance.view) {
        instance.view.adjustElementsSize();
      }
    },
    /**
     * Populate the data from the provided 2d array from the given cell coordinates.
     *
     * @private
     * @param {object} start Start selection position. Visual indexes.
     * @param {Array} input 2d data array.
     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.
     * @param {string} [source="populateFromArray"] Source information string.
     * @param {string} [method="overwrite"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.
     * @param {string} direction (left|right|up|down) String specifying the direction.
     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.
     *                       Useful **only** when the type of handled cells is `numeric`.
     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).
     */
    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {
      var r2;
      var rlen;
      var c2;
      var clen;
      var setData = [];
      var current = {};
      var newDataByColumns = [];
      var startRow = start.row;
      var startColumn = start.col;
      rlen = input.length;
      if (rlen === 0) {
        return false;
      }
      var columnsPopulationEnd = 0;
      var rowsPopulationEnd = 0;
      if (isObject$7(end)) {
        columnsPopulationEnd = end.col - startColumn + 1;
        rowsPopulationEnd = end.row - startRow + 1;
      }
      switch (method) {
        case "shift_down":
          var populatedDataByColumns = pivot(input);
          var numberOfDataColumns = populatedDataByColumns.length;
          var numberOfColumnsToPopulate = Math.max(numberOfDataColumns, columnsPopulationEnd);
          var pushedDownDataByRows = instance.getData().slice(startRow);
          var pushedDownDataByColumns = pivot(pushedDownDataByRows).slice(startColumn, startColumn + numberOfColumnsToPopulate);
          for (c2 = 0; c2 < numberOfColumnsToPopulate; c2 += 1) {
            if (c2 < numberOfDataColumns) {
              for (r2 = 0, rlen = populatedDataByColumns[c2].length; r2 < rowsPopulationEnd - rlen; r2 += 1) {
                populatedDataByColumns[c2].push(populatedDataByColumns[c2][r2 % rlen]);
              }
              if (c2 < pushedDownDataByColumns.length) {
                newDataByColumns.push(populatedDataByColumns[c2].concat(pushedDownDataByColumns[c2]));
              } else {
                newDataByColumns.push(populatedDataByColumns[c2].concat(new Array(pushedDownDataByRows.length).fill(null)));
              }
            } else {
              newDataByColumns.push(populatedDataByColumns[c2 % numberOfDataColumns].concat(pushedDownDataByColumns[c2]));
            }
          }
          instance.populateFromArray(startRow, startColumn, pivot(newDataByColumns));
          break;
        case "shift_right":
          var numberOfDataRows = input.length;
          var numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);
          var pushedRightDataByRows = instance.getData().slice(startRow).map(function(rowData) {
            return rowData.slice(startColumn);
          });
          for (r2 = 0; r2 < numberOfRowsToPopulate; r2 += 1) {
            if (r2 < numberOfDataRows) {
              for (c2 = 0, clen = input[r2].length; c2 < columnsPopulationEnd - clen; c2 += 1) {
                input[r2].push(input[r2][c2 % clen]);
              }
              if (r2 < pushedRightDataByRows.length) {
                for (var i = 0; i < pushedRightDataByRows[r2].length; i += 1) {
                  input[r2].push(pushedRightDataByRows[r2][i]);
                }
              } else {
                var _input$r;
                (_input$r = input[r2]).push.apply(_input$r, _toConsumableArray$i(new Array(pushedRightDataByRows[0].length).fill(null)));
              }
            } else {
              input.push(input[r2 % rlen].slice(0, numberOfRowsToPopulate).concat(pushedRightDataByRows[r2]));
            }
          }
          instance.populateFromArray(startRow, startColumn, input);
          break;
        case "overwrite":
        default:
          current.row = start.row;
          current.col = start.col;
          var selected = {
            // selected range
            row: end && start ? end.row - start.row + 1 : 1,
            col: end && start ? end.col - start.col + 1 : 1
          };
          var skippedRow = 0;
          var skippedColumn = 0;
          var pushData = true;
          var cellMeta;
          var getInputValue = function getInputValue2(row) {
            var col = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var rowValue = input[row % input.length];
            if (col !== null) {
              return rowValue[col % rowValue.length];
            }
            return rowValue;
          };
          var rowInputLength = input.length;
          var rowSelectionLength = end ? end.row - start.row + 1 : 0;
          if (end) {
            rlen = rowSelectionLength;
          } else {
            rlen = Math.max(rowInputLength, rowSelectionLength);
          }
          for (r2 = 0; r2 < rlen; r2++) {
            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {
              break;
            }
            var visualRow = r2 - skippedRow;
            var colInputLength = getInputValue(visualRow).length;
            var colSelectionLength = end ? end.col - start.col + 1 : 0;
            if (end) {
              clen = colSelectionLength;
            } else {
              clen = Math.max(colInputLength, colSelectionLength);
            }
            current.col = start.col;
            cellMeta = instance.getCellMeta(current.row, current.col);
            if ((source === "CopyPaste.paste" || source === "Autofill.fill") && cellMeta.skipRowOnPaste) {
              skippedRow += 1;
              current.row += 1;
              rlen += 1;
              continue;
            }
            skippedColumn = 0;
            for (c2 = 0; c2 < clen; c2++) {
              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {
                break;
              }
              cellMeta = instance.getCellMeta(current.row, current.col);
              if ((source === "CopyPaste.paste" || source === "Autofill.fill") && cellMeta.skipColumnOnPaste) {
                skippedColumn += 1;
                current.col += 1;
                clen += 1;
                continue;
              }
              if (cellMeta.readOnly && source !== "UndoRedo.undo") {
                current.col += 1;
                continue;
              }
              var visualColumn = c2 - skippedColumn;
              var value = getInputValue(visualRow, visualColumn);
              var orgValue = instance.getDataAtCell(current.row, current.col);
              var index2 = {
                row: visualRow,
                col: visualColumn
              };
              if (source === "Autofill.fill") {
                var result = instance.runHooks("beforeAutofillInsidePopulate", index2, direction, input, deltas, {}, selected);
                if (result) {
                  value = isUndefined(result.value) ? value : result.value;
                }
              }
              if (value !== null && _typeof$12(value) === "object") {
                if (Array.isArray(value) && orgValue === null)
                  orgValue = [];
                if (orgValue === null || _typeof$12(orgValue) !== "object") {
                  pushData = false;
                } else {
                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);
                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);
                  if (isObjectEqual(orgValueSchema, valueSchema)) {
                    value = deepClone(value);
                  } else {
                    pushData = false;
                  }
                }
              } else if (orgValue !== null && _typeof$12(orgValue) === "object") {
                pushData = false;
              }
              if (pushData) {
                setData.push([current.row, current.col, value]);
              }
              pushData = true;
              current.col += 1;
            }
            current.row += 1;
          }
          instance.setDataAtCell(setData, null, null, source || "populateFromArray");
          break;
      }
    }
  };
  function setLanguage(languageCode) {
    var normalizedLanguageCode = normalizeLanguageCode(languageCode);
    if (hasLanguageDictionary(normalizedLanguageCode)) {
      instance.runHooks("beforeLanguageChange", normalizedLanguageCode);
      globalMeta.language = normalizedLanguageCode;
      instance.runHooks("afterLanguageChange", normalizedLanguageCode);
    } else {
      warnUserAboutLanguageRegistration(languageCode);
    }
  }
  function setClassName(className, classSettings) {
    var element = className === "className" ? instance.rootElement : instance.table;
    if (firstRun) {
      addClass(element, classSettings);
    } else {
      var globalMetaSettingsArray = [];
      var settingsArray = [];
      if (globalMeta[className]) {
        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);
      }
      if (classSettings) {
        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);
      }
      var classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);
      var classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);
      if (classNameToRemove.length) {
        removeClass(element, classNameToRemove);
      }
      if (classNameToAdd.length) {
        addClass(element, classNameToAdd);
      }
    }
    globalMeta[className] = classSettings;
  }
  this.init = function() {
    dataSource.setData(tableMeta.data);
    instance.runHooks("beforeInit");
    if (isMobileBrowser() || isIpadOS()) {
      addClass(instance.rootElement, "mobile");
    }
    this.updateSettings(tableMeta, true);
    this.view = new TableView$1(this);
    editorManager = EditorManager$1.getInstance(instance, tableMeta, selection);
    instance.runHooks("init");
    this.forceFullRender = true;
    this.view.render();
    if (_typeof$12(firstRun) === "object") {
      instance.runHooks("afterChange", firstRun[0], firstRun[1]);
      firstRun = false;
    }
    instance.runHooks("afterInit");
  };
  function ValidatorsQueue() {
    var resolved = false;
    return {
      validatorsInQueue: 0,
      valid: true,
      addValidatorToQueue: function addValidatorToQueue() {
        this.validatorsInQueue += 1;
        resolved = false;
      },
      removeValidatorFormQueue: function removeValidatorFormQueue() {
        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
        this.checkIfQueueIsEmpty();
      },
      onQueueEmpty: function onQueueEmpty() {
      },
      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {
        if (this.validatorsInQueue === 0 && resolved === false) {
          resolved = true;
          this.onQueueEmpty(this.valid);
        }
      }
    };
  }
  function getParsedNumber(numericData) {
    var unifiedNumericData = numericData.replace(",", ".");
    if (isNaN(parseFloat(unifiedNumericData)) === false) {
      return parseFloat(unifiedNumericData);
    }
    return numericData;
  }
  function validateChanges(changes, source, callback) {
    if (!changes.length) {
      return;
    }
    var activeEditor = instance.getActiveEditor();
    var beforeChangeResult = instance.runHooks("beforeChange", changes, source || "edit");
    var shouldBeCanceled = true;
    if (beforeChangeResult === false) {
      if (activeEditor) {
        activeEditor.cancelChanges();
      }
      return;
    }
    var waitingForValidator = new ValidatorsQueue();
    waitingForValidator.onQueueEmpty = function(isValid) {
      if (activeEditor && shouldBeCanceled) {
        activeEditor.cancelChanges();
      }
      callback(isValid);
    };
    for (var i = changes.length - 1; i >= 0; i--) {
      if (changes[i] === null) {
        changes.splice(i, 1);
      } else {
        var _changes$i = _slicedToArray$B(changes[i], 4), row = _changes$i[0], prop = _changes$i[1], newValue = _changes$i[3];
        var col = datamap.propToCol(prop);
        var cellProperties = instance.getCellMeta(row, col);
        if (cellProperties.type === "numeric" && typeof newValue === "string" && isNumericLike(newValue)) {
          changes[i][3] = getParsedNumber(newValue);
        }
        if (instance.getCellValidator(cellProperties)) {
          waitingForValidator.addValidatorToQueue();
          instance.validateCell(changes[i][3], cellProperties, function(index2, cellPropertiesReference) {
            return function(result) {
              if (typeof result !== "boolean") {
                throw new Error("Validation error: result is not boolean");
              }
              if (result === false && cellPropertiesReference.allowInvalid === false) {
                shouldBeCanceled = false;
                changes.splice(index2, 1);
                cellPropertiesReference.valid = true;
                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);
                if (cell !== null) {
                  removeClass(cell, tableMeta.invalidCellClassName);
                }
              }
              waitingForValidator.removeValidatorFormQueue();
            };
          }(i, cellProperties), source);
        }
      }
    }
    waitingForValidator.checkIfQueueIsEmpty();
  }
  function applyChanges(changes, source) {
    var i = changes.length - 1;
    if (i < 0) {
      return;
    }
    for (; i >= 0; i--) {
      var skipThisChange = false;
      if (changes[i] === null) {
        changes.splice(i, 1);
        continue;
      }
      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {
        continue;
      }
      if (tableMeta.allowInsertRow) {
        while (changes[i][0] > instance.countRows() - 1) {
          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);
          if (numberOfCreatedRows >= 1) {
            metaManager.createRow(null, numberOfCreatedRows);
          } else {
            skipThisChange = true;
            break;
          }
        }
      }
      if (instance.dataType === "array" && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {
        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);
          if (numberOfCreatedColumns >= 1) {
            metaManager.createColumn(null, numberOfCreatedColumns);
          } else {
            skipThisChange = true;
            break;
          }
        }
      }
      if (skipThisChange) {
        continue;
      }
      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
    }
    instance.forceFullRender = true;
    grid.adjustRowsAndCols();
    instance.runHooks("beforeChangeRender", changes, source);
    editorManager.lockEditor();
    instance._refreshBorders(null);
    editorManager.unlockEditor();
    instance.view.adjustElementsSize();
    instance.runHooks("afterChange", changes, source || "edit");
    var activeEditor = instance.getActiveEditor();
    if (activeEditor && isDefined(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  }
  this._createCellCoords = function(row, column) {
    return instance.view._wt.createCellCoords(row, column);
  };
  this._createCellRange = function(highlight, from3, to) {
    return instance.view._wt.createCellRange(highlight, from3, to);
  };
  this.validateCell = function(value, cellProperties, callback, source) {
    var validator = instance.getCellValidator(cellProperties);
    function done(valid) {
      var canBeValidated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!canBeValidated || cellProperties.hidden === true) {
        callback(valid);
        return;
      }
      var col = cellProperties.visualCol;
      var row = cellProperties.visualRow;
      var td = instance.getCell(row, col, true);
      if (td && td.nodeName !== "TH") {
        var renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);
        var renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);
        instance.view._wt.getSetting("cellRenderer", renderableRow, renderableColumn, td);
      }
      callback(valid);
    }
    if (isRegExp(validator)) {
      validator = function(expression) {
        return function(cellValue, validatorCallback) {
          validatorCallback(expression.test(cellValue));
        };
      }(validator);
    }
    if (isFunction(validator)) {
      value = instance.runHooks("beforeValidate", value, cellProperties.visualRow, cellProperties.prop, source);
      instance._registerImmediate(function() {
        validator.call(cellProperties, value, function(valid) {
          if (!instance) {
            return;
          }
          valid = instance.runHooks("afterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
          cellProperties.valid = valid;
          done(valid);
          instance.runHooks("postAfterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
        });
      });
    } else {
      instance._registerImmediate(function() {
        cellProperties.valid = true;
        done(cellProperties.valid, false);
      });
    }
  };
  function setDataInputToArray(row, propOrCol, value) {
    if (Array.isArray(row)) {
      return row;
    }
    return [[row, propOrCol, value]];
  }
  this.setDataAtCell = function(row, column, value, source) {
    var input = setDataInputToArray(row, column, value);
    var changes = [];
    var changeSource = source;
    var i;
    var ilen;
    var prop;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      if (_typeof$12(input[i]) !== "object") {
        throw new Error("Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter");
      }
      if (typeof input[i][1] !== "number") {
        throw new Error("Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`");
      }
      if (input[i][1] >= this.countCols()) {
        prop = input[i][1];
      } else {
        prop = datamap.colToProp(input[i][1]);
      }
      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && _typeof$12(row) === "object") {
      changeSource = column;
    }
    instance.runHooks("afterSetDataAtCell", changes, changeSource);
    validateChanges(changes, changeSource, function() {
      applyChanges(changes, changeSource);
    });
  };
  this.setDataAtRowProp = function(row, prop, value, source) {
    var input = setDataInputToArray(row, prop, value);
    var changes = [];
    var changeSource = source;
    var i;
    var ilen;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && _typeof$12(row) === "object") {
      changeSource = prop;
    }
    instance.runHooks("afterSetDataAtRowProp", changes, changeSource);
    validateChanges(changes, changeSource, function() {
      applyChanges(changes, changeSource);
    });
  };
  this.listen = function() {
    if (instance && !instance.isListening()) {
      activeGuid = instance.guid;
      instance.runHooks("afterListen");
    }
  };
  this.unlisten = function() {
    if (this.isListening()) {
      activeGuid = null;
      instance.runHooks("afterUnlisten");
    }
  };
  this.isListening = function() {
    return activeGuid === instance.guid;
  };
  this.destroyEditor = function() {
    var revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);
  };
  this.populateFromArray = function(row, column, input, endRow, endCol, source, method, direction, deltas) {
    if (!(_typeof$12(input) === "object" && _typeof$12(input[0]) === "object")) {
      throw new Error("populateFromArray parameter `input` must be an array of arrays");
    }
    var c2 = typeof endRow === "number" ? instance._createCellCoords(endRow, endCol) : null;
    return grid.populateFromArray(instance._createCellCoords(row, column), input, c2, source, method, direction, deltas);
  };
  this.spliceCol = function(column, index2, amount) {
    var _datamap;
    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      elements[_key - 3] = arguments[_key];
    }
    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index2, amount].concat(elements));
  };
  this.spliceRow = function(row, index2, amount) {
    var _datamap2;
    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      elements[_key2 - 3] = arguments[_key2];
    }
    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index2, amount].concat(elements));
  };
  this.getSelected = function() {
    if (selection.isSelected()) {
      return arrayMap(selection.getSelectedRange(), function(_ref12) {
        var from3 = _ref12.from, to = _ref12.to;
        return [from3.row, from3.col, to.row, to.col];
      });
    }
  };
  this.getSelectedLast = function() {
    var selected = this.getSelected();
    var result;
    if (selected && selected.length > 0) {
      result = selected[selected.length - 1];
    }
    return result;
  };
  this.getSelectedRange = function() {
    if (selection.isSelected()) {
      return Array.from(selection.getSelectedRange());
    }
  };
  this.getSelectedRangeLast = function() {
    var selectedRange = this.getSelectedRange();
    var result;
    if (selectedRange && selectedRange.length > 0) {
      result = selectedRange[selectedRange.length - 1];
    }
    return result;
  };
  this.emptySelectedCells = function(source) {
    var _this2 = this;
    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {
      return;
    }
    var changes = [];
    arrayEach(selection.getSelectedRange(), function(cellRange) {
      var topStart = cellRange.getTopStartCorner();
      var bottomEnd = cellRange.getBottomEndCorner();
      rangeEach(topStart.row, bottomEnd.row, function(row) {
        rangeEach(topStart.col, bottomEnd.col, function(column) {
          if (!_this2.getCellMeta(row, column).readOnly) {
            changes.push([row, column, null]);
          }
        });
      });
    });
    if (changes.length > 0) {
      this.setDataAtCell(changes, source);
    }
  };
  this.isRenderSuspended = function() {
    return this.renderSuspendedCounter > 0;
  };
  this.suspendRender = function() {
    this.renderSuspendedCounter += 1;
  };
  this.resumeRender = function() {
    var nextValue = this.renderSuspendedCounter - 1;
    this.renderSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {
      if (this.renderCall) {
        this.render();
      } else {
        this._refreshBorders(null);
      }
    }
  };
  this.render = function() {
    if (this.view) {
      this.renderCall = true;
      this.forceFullRender = true;
      if (!this.isRenderSuspended()) {
        editorManager.lockEditor();
        this._refreshBorders(null);
        editorManager.unlockEditor();
      }
    }
  };
  this.batchRender = function(wrappedOperations) {
    this.suspendRender();
    var result = wrappedOperations();
    this.resumeRender();
    return result;
  };
  this.isExecutionSuspended = function() {
    return this.executionSuspendedCounter > 0;
  };
  this.suspendExecution = function() {
    this.executionSuspendedCounter += 1;
    this.columnIndexMapper.suspendOperations();
    this.rowIndexMapper.suspendOperations();
  };
  this.resumeExecution = function() {
    var forceFlushChanges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var nextValue = this.executionSuspendedCounter - 1;
    this.executionSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {
      this.columnIndexMapper.resumeOperations();
      this.rowIndexMapper.resumeOperations();
    }
  };
  this.batchExecution = function(wrappedOperations) {
    var forceFlushChanges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    this.suspendExecution();
    var result = wrappedOperations();
    this.resumeExecution(forceFlushChanges);
    return result;
  };
  this.batch = function(wrappedOperations) {
    this.suspendRender();
    this.suspendExecution();
    var result = wrappedOperations();
    this.resumeExecution();
    this.resumeRender();
    return result;
  };
  this.refreshDimensions = function() {
    if (!instance.view) {
      return;
    }
    var _instance$view$getLas = instance.view.getLastSize(), lastWidth = _instance$view$getLas.width, lastHeight = _instance$view$getLas.height;
    var _instance$rootElement = instance.rootElement.getBoundingClientRect(), width = _instance$rootElement.width, height = _instance$rootElement.height;
    var isSizeChanged = width !== lastWidth || height !== lastHeight;
    var isResizeBlocked = instance.runHooks("beforeRefreshDimensions", {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged) === false;
    if (isResizeBlocked) {
      return;
    }
    if (isSizeChanged || instance.view._wt.wtOverlays.scrollableElement === instance.rootWindow) {
      instance.view.setLastSize(width, height);
      instance.render();
    }
    instance.runHooks("afterRefreshDimensions", {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged);
  };
  this.updateData = function(data2, source) {
    var _this3 = this;
    replaceData(data2, function(newDataMap) {
      datamap = newDataMap;
    }, function(newDataMap) {
      datamap = newDataMap;
      instance.columnIndexMapper.fitToLength(_this3.getInitialColumnCount());
      instance.rowIndexMapper.fitToLength(_this3.countSourceRows());
      grid.adjustRowsAndCols();
    }, {
      hotInstance: instance,
      dataMap: datamap,
      dataSource,
      internalSource: "updateData",
      source,
      firstRun
    });
  };
  this.loadData = function(data2, source) {
    replaceData(data2, function(newDataMap) {
      datamap = newDataMap;
    }, function() {
      metaManager.clearCellsCache();
      instance.initIndexMappers();
      grid.adjustRowsAndCols();
      if (firstRun) {
        firstRun = [null, "loadData"];
      }
    }, {
      hotInstance: instance,
      dataMap: datamap,
      dataSource,
      internalSource: "loadData",
      source,
      firstRun
    });
  };
  this.getInitialColumnCount = function() {
    var columnsSettings = tableMeta.columns;
    var finalNrOfColumns = 0;
    if (Array.isArray(columnsSettings)) {
      finalNrOfColumns = columnsSettings.length;
    } else if (isFunction(columnsSettings)) {
      if (instance.dataType === "array") {
        var nrOfSourceColumns = this.countSourceCols();
        for (var columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {
          if (columnsSettings(columnIndex)) {
            finalNrOfColumns += 1;
          }
        }
      } else if (instance.dataType === "object" || instance.dataType === "function") {
        finalNrOfColumns = datamap.colToPropCache.length;
      }
    } else if (isDefined(tableMeta.dataSchema)) {
      var schema = datamap.getSchema();
      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);
    } else {
      finalNrOfColumns = this.countSourceCols();
    }
    return finalNrOfColumns;
  };
  this.initIndexMappers = function() {
    this.columnIndexMapper.initToLength(this.getInitialColumnCount());
    this.rowIndexMapper.initToLength(this.countSourceRows());
  };
  this.getData = function(row, column, row2, column2) {
    if (isUndefined(row)) {
      return datamap.getAll();
    }
    return datamap.getRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), datamap.DESTINATION_RENDERER);
  };
  this.getCopyableText = function(startRow, startCol, endRow, endCol) {
    return datamap.getCopyableText(instance._createCellCoords(startRow, startCol), instance._createCellCoords(endRow, endCol));
  };
  this.getCopyableData = function(row, column) {
    return datamap.getCopyable(row, datamap.colToProp(column));
  };
  this.getSchema = function() {
    return datamap.getSchema();
  };
  this.updateSettings = function(settings) {
    var init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var dataUpdateFunction = (firstRun ? instance.loadData : instance.updateData).bind(this);
    var columnsAsFunc = false;
    var i;
    var j;
    if (isDefined(settings.rows)) {
      throw new Error('The "rows" setting is no longer supported. Do you mean startRows, minRows or maxRows?');
    }
    if (isDefined(settings.cols)) {
      throw new Error('The "cols" setting is no longer supported. Do you mean startCols, minCols or maxCols?');
    }
    if (isDefined(settings.ganttChart)) {
      throw new Error('Since 8.0.0 the "ganttChart" setting is no longer supported.');
    }
    for (i in settings) {
      if (i === "data")
        ;
      else if (i === "language") {
        setLanguage(settings.language);
      } else if (i === "className") {
        setClassName("className", settings.className);
      } else if (i === "tableClassName" && instance.table) {
        setClassName("tableClassName", settings.tableClassName);
        instance.view._wt.wtOverlays.syncOverlayTableClassNames();
      } else if (Hooks$1.getSingleton().isRegistered(i) || Hooks$1.getSingleton().isDeprecated(i)) {
        if (isFunction(settings[i]) || Array.isArray(settings[i])) {
          settings[i].initialHook = true;
          instance.addHook(i, settings[i]);
        }
      } else if (!init && hasOwnProperty$2(settings, i)) {
        globalMeta[i] = settings[i];
      }
    }
    if (settings.data === void 0 && tableMeta.data === void 0) {
      dataUpdateFunction(null, "updateSettings");
    } else if (settings.data !== void 0) {
      dataUpdateFunction(settings.data, "updateSettings");
    } else if (settings.columns !== void 0) {
      datamap.createMap();
      instance.initIndexMappers();
    }
    var clen = instance.countCols();
    var columnSetting = tableMeta.columns;
    if (columnSetting && isFunction(columnSetting)) {
      columnsAsFunc = true;
    }
    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {
      metaManager.clearCache();
    }
    if (clen > 0) {
      for (i = 0, j = 0; i < clen; i++) {
        if (columnSetting) {
          var column = columnsAsFunc ? columnSetting(i) : columnSetting[j];
          if (column) {
            metaManager.updateColumnMeta(j, column);
          }
        }
        j += 1;
      }
    }
    if (isDefined(settings.cell)) {
      objectEach(settings.cell, function(cell) {
        instance.setCellMetaObject(cell.row, cell.col, cell);
      });
    }
    instance.runHooks("afterCellMetaReset");
    var currentHeight = instance.rootElement.style.height;
    if (currentHeight !== "") {
      currentHeight = parseInt(instance.rootElement.style.height, 10);
    }
    var height = settings.height;
    if (isFunction(height)) {
      height = height();
    }
    if (init) {
      var initialStyle = instance.rootElement.getAttribute("style");
      if (initialStyle) {
        instance.rootElement.setAttribute("data-initialstyle", instance.rootElement.getAttribute("style"));
      }
    }
    if (height === null) {
      var _initialStyle = instance.rootElement.getAttribute("data-initialstyle");
      if (_initialStyle && (_initialStyle.indexOf("height") > -1 || _initialStyle.indexOf("overflow") > -1)) {
        instance.rootElement.setAttribute("style", _initialStyle);
      } else {
        instance.rootElement.style.height = "";
        instance.rootElement.style.overflow = "";
      }
    } else if (height !== void 0) {
      instance.rootElement.style.height = isNaN(height) ? "".concat(height) : "".concat(height, "px");
      instance.rootElement.style.overflow = "hidden";
    }
    if (typeof settings.width !== "undefined") {
      var width = settings.width;
      if (isFunction(width)) {
        width = width();
      }
      instance.rootElement.style.width = isNaN(width) ? "".concat(width) : "".concat(width, "px");
    }
    if (!init) {
      if (instance.view) {
        instance.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();
        instance.view._wt.exportSettingsAsClassNames();
      }
      instance.runHooks("afterUpdateSettings", settings);
    }
    grid.adjustRowsAndCols();
    if (instance.view && !firstRun) {
      instance.forceFullRender = true;
      editorManager.lockEditor();
      instance._refreshBorders(null);
      instance.view._wt.wtOverlays.adjustElementsSize();
      editorManager.unlockEditor();
    }
    if (!init && instance.view && (currentHeight === "" || height === "" || height === void 0) && currentHeight !== height) {
      instance.view._wt.wtOverlays.updateMainScrollableElements();
    }
  };
  this.getValue = function() {
    var sel = instance.getSelectedLast();
    if (tableMeta.getValue) {
      if (isFunction(tableMeta.getValue)) {
        return tableMeta.getValue.call(instance);
      } else if (sel) {
        return instance.getData()[sel[0][0]][tableMeta.getValue];
      }
    } else if (sel) {
      return instance.getDataAtCell(sel[0], sel[1]);
    }
  };
  this.getSettings = function() {
    return tableMeta;
  };
  this.clear = function() {
    this.selectAll();
    this.emptySelectedCells();
  };
  this.alter = function(action, index2, amount, source, keepEmptyRows) {
    grid.alter(action, index2, amount, source, keepEmptyRows);
  };
  this.getCell = function(row, column) {
    var topmost = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var renderableColumnIndex = column;
    var renderableRowIndex = row;
    if (column >= 0) {
      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {
        return null;
      }
      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);
    }
    if (row >= 0) {
      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {
        return null;
      }
      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);
    }
    if (renderableRowIndex === null || renderableColumnIndex === null) {
      return null;
    }
    return instance.view.getCellAtCoords(instance._createCellCoords(renderableRowIndex, renderableColumnIndex), topmost);
  };
  this.getCoords = function(element) {
    var renderableCoords = this.view._wt.wtTable.getCoords(element);
    if (renderableCoords === null) {
      return null;
    }
    var renderableRow = renderableCoords.row, renderableColumn = renderableCoords.col;
    var visualRow = renderableRow;
    var visualColumn = renderableColumn;
    if (renderableRow >= 0) {
      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);
    }
    if (renderableColumn >= 0) {
      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);
    }
    return instance._createCellCoords(visualRow, visualColumn);
  };
  this.colToProp = function(column) {
    return datamap.colToProp(column);
  };
  this.propToCol = function(prop) {
    return datamap.propToCol(prop);
  };
  this.toVisualRow = function(row) {
    return _this.rowIndexMapper.getVisualFromPhysicalIndex(row);
  };
  this.toVisualColumn = function(column) {
    return _this.columnIndexMapper.getVisualFromPhysicalIndex(column);
  };
  this.toPhysicalRow = function(row) {
    return _this.rowIndexMapper.getPhysicalFromVisualIndex(row);
  };
  this.toPhysicalColumn = function(column) {
    return _this.columnIndexMapper.getPhysicalFromVisualIndex(column);
  };
  this.getDataAtCell = function(row, column) {
    return datamap.get(row, datamap.colToProp(column));
  };
  this.getDataAtRowProp = function(row, prop) {
    return datamap.get(row, prop);
  };
  this.getDataAtCol = function(column) {
    var _ref13;
    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray$i(datamap.getRange(instance._createCellCoords(0, column), instance._createCellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER)));
  };
  this.getDataAtProp = function(prop) {
    var _ref14;
    var range = datamap.getRange(instance._createCellCoords(0, datamap.propToCol(prop)), instance._createCellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);
    return (_ref14 = []).concat.apply(_ref14, _toConsumableArray$i(range));
  };
  this.getSourceData = function(row, column, row2, column2) {
    var data2;
    if (row === void 0) {
      data2 = dataSource.getData();
    } else {
      data2 = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2));
    }
    return data2;
  };
  this.getSourceDataArray = function(row, column, row2, column2) {
    var data2;
    if (row === void 0) {
      data2 = dataSource.getData(true);
    } else {
      data2 = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), true);
    }
    return data2;
  };
  this.getSourceDataAtCol = function(column) {
    return dataSource.getAtColumn(column);
  };
  this.setSourceDataAtCell = function(row, column, value, source) {
    var input = setDataInputToArray(row, column, value);
    var isThereAnySetSourceListener = this.hasHook("afterSetSourceDataAtCell");
    var changesForHook = [];
    if (isThereAnySetSourceListener) {
      arrayEach(input, function(_ref15) {
        var _ref16 = _slicedToArray$B(_ref15, 3), changeRow = _ref16[0], changeProp = _ref16[1], changeValue = _ref16[2];
        changesForHook.push([
          changeRow,
          changeProp,
          dataSource.getAtCell(changeRow, changeProp),
          // The previous value.
          changeValue
        ]);
      });
    }
    arrayEach(input, function(_ref17) {
      var _ref18 = _slicedToArray$B(_ref17, 3), changeRow = _ref18[0], changeProp = _ref18[1], changeValue = _ref18[2];
      dataSource.setAtCell(changeRow, changeProp, changeValue);
    });
    if (isThereAnySetSourceListener) {
      this.runHooks("afterSetSourceDataAtCell", changesForHook, source);
    }
    this.render();
    var activeEditor = instance.getActiveEditor();
    if (activeEditor && isDefined(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  };
  this.getSourceDataAtRow = function(row) {
    return dataSource.getAtRow(row);
  };
  this.getSourceDataAtCell = function(row, column) {
    return dataSource.getAtCell(row, column);
  };
  this.getDataAtRow = function(row) {
    var data2 = datamap.getRange(instance._createCellCoords(row, 0), instance._createCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
    return data2[0] || [];
  };
  this.getDataType = function(rowFrom, columnFrom, rowTo, columnTo) {
    var _this4 = this;
    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];
    var rowStart = coords[0], columnStart = coords[1];
    var rowEnd = coords[2], columnEnd = coords[3];
    var previousType = null;
    var currentType = null;
    if (rowEnd === void 0) {
      rowEnd = rowStart;
    }
    if (columnEnd === void 0) {
      columnEnd = columnStart;
    }
    var type = "mixed";
    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), function(row) {
      var isTypeEqual = true;
      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), function(column) {
        var cellType = _this4.getCellMeta(row, column);
        currentType = cellType.type;
        if (previousType) {
          isTypeEqual = previousType === currentType;
        } else {
          previousType = currentType;
        }
        return isTypeEqual;
      });
      type = isTypeEqual ? currentType : "mixed";
      return isTypeEqual;
    });
    return type;
  };
  this.removeCellMeta = function(row, column, key) {
    var _ref19 = [this.toPhysicalRow(row), this.toPhysicalColumn(column)], physicalRow = _ref19[0], physicalColumn = _ref19[1];
    var cachedValue = metaManager.getCellMetaKeyValue(physicalRow, physicalColumn, key);
    var hookResult = instance.runHooks("beforeRemoveCellMeta", row, column, key, cachedValue);
    if (hookResult !== false) {
      metaManager.removeCellMeta(physicalRow, physicalColumn, key);
      instance.runHooks("afterRemoveCellMeta", row, column, key, cachedValue);
    }
    cachedValue = null;
  };
  this.spliceCellsMeta = function(visualIndex) {
    var _this5 = this;
    var deleteAmount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      cellMetaRows[_key3 - 2] = arguments[_key3];
    }
    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {
      throw new Error("The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.");
    }
    if (deleteAmount > 0) {
      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);
    }
    if (cellMetaRows.length > 0) {
      arrayEach(cellMetaRows.reverse(), function(cellMetaRow) {
        metaManager.createRow(_this5.toPhysicalRow(visualIndex));
        arrayEach(cellMetaRow, function(cellMeta, columnIndex) {
          return _this5.setCellMetaObject(visualIndex, columnIndex, cellMeta);
        });
      });
    }
    instance.render();
  };
  this.setCellMetaObject = function(row, column, prop) {
    var _this6 = this;
    if (_typeof$12(prop) === "object") {
      objectEach(prop, function(value, key) {
        _this6.setCellMeta(row, column, key, value);
      });
    }
  };
  this.setCellMeta = function(row, column, key, value) {
    var allowSetCellMeta = instance.runHooks("beforeSetCellMeta", row, column, key, value);
    if (allowSetCellMeta === false) {
      return;
    }
    var physicalRow = row;
    var physicalColumn = column;
    if (row < this.countRows()) {
      physicalRow = this.toPhysicalRow(row);
    }
    if (column < this.countCols()) {
      physicalColumn = this.toPhysicalColumn(column);
    }
    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);
    instance.runHooks("afterSetCellMeta", row, column, key, value);
  };
  this.getCellsMeta = function() {
    return metaManager.getCellsMeta();
  };
  this.getCellMeta = function(row, column) {
    var physicalRow = this.toPhysicalRow(row);
    var physicalColumn = this.toPhysicalColumn(column);
    if (physicalRow === null) {
      physicalRow = row;
    }
    if (physicalColumn === null) {
      physicalColumn = column;
    }
    return metaManager.getCellMeta(physicalRow, physicalColumn, {
      visualRow: row,
      visualColumn: column
    });
  };
  this.getCellMetaAtRow = function(row) {
    return metaManager.getCellsMetaAtRow(row);
  };
  this.isColumnModificationAllowed = function() {
    return !(instance.dataType === "object" || tableMeta.columns);
  };
  var rendererLookup = cellMethodLookupFactory("renderer");
  this.getCellRenderer = function(row, column) {
    return _getItem$2(rendererLookup.call(this, row, column));
  };
  this.getCellEditor = cellMethodLookupFactory("editor");
  var validatorLookup = cellMethodLookupFactory("validator");
  this.getCellValidator = function(row, column) {
    var validator = validatorLookup.call(this, row, column);
    if (typeof validator === "string") {
      validator = _getItem$1(validator);
    }
    return validator;
  };
  this.validateCells = function(callback) {
    this._validateCells(callback);
  };
  this.validateRows = function(rows, callback) {
    if (!Array.isArray(rows)) {
      throw new Error("validateRows parameter `rows` must be an array");
    }
    this._validateCells(callback, rows);
  };
  this.validateColumns = function(columns, callback) {
    if (!Array.isArray(columns)) {
      throw new Error("validateColumns parameter `columns` must be an array");
    }
    this._validateCells(callback, void 0, columns);
  };
  this._validateCells = function(callback, rows, columns) {
    var waitingForValidator = new ValidatorsQueue();
    if (callback) {
      waitingForValidator.onQueueEmpty = callback;
    }
    var i = instance.countRows() - 1;
    while (i >= 0) {
      if (rows !== void 0 && rows.indexOf(i) === -1) {
        i -= 1;
        continue;
      }
      var j = instance.countCols() - 1;
      while (j >= 0) {
        if (columns !== void 0 && columns.indexOf(j) === -1) {
          j -= 1;
          continue;
        }
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function(result) {
          if (typeof result !== "boolean") {
            throw new Error("Validation error: result is not boolean");
          }
          if (result === false) {
            waitingForValidator.valid = false;
          }
          waitingForValidator.removeValidatorFormQueue();
        }, "validateCells");
        j -= 1;
      }
      i -= 1;
    }
    waitingForValidator.checkIfQueueIsEmpty();
  };
  this.getRowHeader = function(row) {
    var rowHeader = tableMeta.rowHeaders;
    var physicalRow = row;
    if (physicalRow !== void 0) {
      physicalRow = instance.runHooks("modifyRowHeader", physicalRow);
    }
    if (physicalRow === void 0) {
      rowHeader = [];
      rangeEach(instance.countRows() - 1, function(i) {
        rowHeader.push(instance.getRowHeader(i));
      });
    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {
      rowHeader = rowHeader[physicalRow];
    } else if (isFunction(rowHeader)) {
      rowHeader = rowHeader(physicalRow);
    } else if (rowHeader && typeof rowHeader !== "string" && typeof rowHeader !== "number") {
      rowHeader = physicalRow + 1;
    }
    return rowHeader;
  };
  this.hasRowHeaders = function() {
    return !!tableMeta.rowHeaders;
  };
  this.hasColHeaders = function() {
    if (tableMeta.colHeaders !== void 0 && tableMeta.colHeaders !== null) {
      return !!tableMeta.colHeaders;
    }
    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {
      if (instance.getColHeader(i)) {
        return true;
      }
    }
    return false;
  };
  this.getColHeader = function(column) {
    var columnIndex = instance.runHooks("modifyColHeader", column);
    var result = tableMeta.colHeaders;
    if (columnIndex === void 0) {
      var out = [];
      var ilen = instance.countCols();
      for (var i = 0; i < ilen; i++) {
        out.push(instance.getColHeader(i));
      }
      result = out;
    } else {
      var translateVisualIndexToColumns = function translateVisualIndexToColumns2(visualColumnIndex) {
        var arr = [];
        var columnsLen = instance.countCols();
        var index2 = 0;
        for (; index2 < columnsLen; index2++) {
          if (isFunction(tableMeta.columns) && tableMeta.columns(index2)) {
            arr.push(index2);
          }
        }
        return arr[visualColumnIndex];
      };
      var physicalColumn = instance.toPhysicalColumn(columnIndex);
      var prop = translateVisualIndexToColumns(physicalColumn);
      if (tableMeta.colHeaders === false) {
        result = null;
      } else if (tableMeta.columns && isFunction(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {
        result = tableMeta.columns(prop).title;
      } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {
        result = tableMeta.columns[physicalColumn].title;
      } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== void 0) {
        result = tableMeta.colHeaders[physicalColumn];
      } else if (isFunction(tableMeta.colHeaders)) {
        result = tableMeta.colHeaders(physicalColumn);
      } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== "string" && typeof tableMeta.colHeaders !== "number") {
        result = spreadsheetColumnLabel(columnIndex);
      }
    }
    return result;
  };
  this._getColWidthFromSettings = function(col) {
    var width;
    if (col >= 0) {
      var cellProperties = instance.getCellMeta(0, col);
      width = cellProperties.width;
    }
    if (width === void 0 || width === tableMeta.width) {
      width = tableMeta.colWidths;
    }
    if (width !== void 0 && width !== null) {
      switch (_typeof$12(width)) {
        case "object":
          width = width[col];
          break;
        case "function":
          width = width(col);
          break;
      }
      if (typeof width === "string") {
        width = parseInt(width, 10);
      }
    }
    return width;
  };
  this.getColWidth = function(column) {
    var width = instance._getColWidthFromSettings(column);
    width = instance.runHooks("modifyColWidth", width, column);
    if (width === void 0) {
      width = ViewportColumnsCalculator$1.DEFAULT_WIDTH;
    }
    return width;
  };
  this._getRowHeightFromSettings = function(row) {
    var height = tableMeta.rowHeights;
    if (height !== void 0 && height !== null) {
      switch (_typeof$12(height)) {
        case "object":
          height = height[row];
          break;
        case "function":
          height = height(row);
          break;
      }
      if (typeof height === "string") {
        height = parseInt(height, 10);
      }
    }
    return height;
  };
  this.getRowHeight = function(row) {
    var height = instance._getRowHeightFromSettings(row);
    height = instance.runHooks("modifyRowHeight", height, row);
    return height;
  };
  this.countSourceRows = function() {
    return dataSource.countRows();
  };
  this.countSourceCols = function() {
    return dataSource.countFirstRowKeys();
  };
  this.countRows = function() {
    return datamap.getLength();
  };
  this.countCols = function() {
    var maxCols = tableMeta.maxCols;
    var dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();
    return Math.min(maxCols, dataLen);
  };
  this.countRenderedRows = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedRowsCount() : -1;
  };
  this.countVisibleRows = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleRowsCount() : -1;
  };
  this.countRenderedCols = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedColumnsCount() : -1;
  };
  this.countVisibleCols = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleColumnsCount() : -1;
  };
  this.countEmptyRows = function() {
    var ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var emptyRows = 0;
    rangeEachReverse(instance.countRows() - 1, function(visualIndex) {
      if (instance.isEmptyRow(visualIndex)) {
        emptyRows += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyRows;
  };
  this.countEmptyCols = function() {
    var ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (instance.countRows() < 1) {
      return 0;
    }
    var emptyColumns = 0;
    rangeEachReverse(instance.countCols() - 1, function(visualIndex) {
      if (instance.isEmptyCol(visualIndex)) {
        emptyColumns += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyColumns;
  };
  this.isEmptyRow = function(row) {
    return tableMeta.isEmptyRow.call(instance, row);
  };
  this.isEmptyCol = function(column) {
    return tableMeta.isEmptyCol.call(instance, column);
  };
  this.selectCell = function(row, column, endRow, endColumn) {
    var scrollToCell = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var changeListener = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    if (isUndefined(row) || isUndefined(column)) {
      return false;
    }
    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);
  };
  this.selectCells = function() {
    var coords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [[]];
    var scrollToCell = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var changeListener = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (scrollToCell === false) {
      preventScrollingToCell = true;
    }
    var wasSelected = selection.selectCells(coords);
    if (wasSelected && changeListener) {
      instance.listen();
    }
    preventScrollingToCell = false;
    return wasSelected;
  };
  this.selectColumns = function(startColumn) {
    var endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
    return selection.selectColumns(startColumn, endColumn);
  };
  this.selectRows = function(startRow) {
    var endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
    return selection.selectRows(startRow, endRow);
  };
  this.deselectCell = function() {
    selection.deselect();
  };
  this.selectAll = function() {
    var includeHeaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    var includeRowHeaders = includeHeaders && this.hasRowHeaders();
    var includeColumnHeaders = includeHeaders && this.hasColHeaders();
    preventScrollingToCell = true;
    selection.selectAll(includeRowHeaders, includeColumnHeaders);
    preventScrollingToCell = false;
  };
  var getIndexToScroll = function getIndexToScroll2(indexMapper, visualIndex) {
    return indexMapper.getNearestNotHiddenIndex(visualIndex, 1, true);
  };
  this.scrollViewportTo = function(row, column) {
    var snapToBottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var snapToRight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var considerHiddenIndexes = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var snapToTop = !snapToBottom;
    var snapToLeft = !snapToRight;
    var renderableRow = row;
    var renderableColumn = column;
    if (considerHiddenIndexes) {
      var _isRowInteger = Number.isInteger(row);
      var _isColumnInteger = Number.isInteger(column);
      var visualRowToScroll = _isRowInteger ? getIndexToScroll(this.rowIndexMapper, row) : void 0;
      var visualColumnToScroll = _isColumnInteger ? getIndexToScroll(this.columnIndexMapper, column) : void 0;
      if (visualRowToScroll === null || visualColumnToScroll === null) {
        return false;
      }
      renderableRow = _isRowInteger ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : void 0;
      renderableColumn = _isColumnInteger ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : void 0;
    }
    var isRowInteger = Number.isInteger(renderableRow);
    var isColumnInteger = Number.isInteger(renderableColumn);
    if (isRowInteger && isColumnInteger) {
      return instance.view.scrollViewport(instance._createCellCoords(renderableRow, renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
    if (isRowInteger && isColumnInteger === false) {
      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);
    }
    if (isColumnInteger && isRowInteger === false) {
      return instance.view.scrollViewportHorizontally(renderableColumn, snapToRight, snapToLeft);
    }
    return false;
  };
  this.destroy = function() {
    instance._clearTimeouts();
    instance._clearImmediates();
    if (instance.view) {
      instance.view.destroy();
    }
    if (dataSource) {
      dataSource.destroy();
    }
    dataSource = null;
    this.getShortcutManager().destroy();
    metaManager.clearCache();
    if (isRootInstance(instance)) {
      var licenseInfo = this.rootDocument.querySelector("#hot-display-license-info");
      if (licenseInfo) {
        licenseInfo.parentNode.removeChild(licenseInfo);
      }
    }
    empty(instance.rootElement);
    eventManager.destroy();
    if (editorManager) {
      editorManager.destroy();
    }
    instance.batchExecution(function() {
      instance.rowIndexMapper.unregisterAll();
      instance.columnIndexMapper.unregisterAll();
      pluginsRegistry.getItems().forEach(function(_ref20) {
        var _ref21 = _slicedToArray$B(_ref20, 2), plugin = _ref21[1];
        plugin.destroy();
      });
      pluginsRegistry.clear();
      instance.runHooks("afterDestroy");
    }, true);
    Hooks$1.getSingleton().destroy(instance);
    objectEach(instance, function(property, key, obj) {
      if (isFunction(property)) {
        obj[key] = postMortem(key);
      } else if (key !== "guid") {
        obj[key] = null;
      }
    });
    instance.isDestroyed = true;
    if (datamap) {
      datamap.destroy();
    }
    instance.rowIndexMapper = null;
    instance.columnIndexMapper = null;
    datamap = null;
    grid = null;
    selection = null;
    editorManager = null;
    instance = null;
  };
  function postMortem(method) {
    return function() {
      throw new Error('The "'.concat(method, '" method cannot be called because this Handsontable instance has been destroyed'));
    };
  }
  this.getActiveEditor = function() {
    return editorManager.getActiveEditor();
  };
  this.getPlugin = function(pluginName) {
    var unifiedPluginName = toUpperCaseFirst(pluginName);
    if (unifiedPluginName === "UndoRedo") {
      return this.undoRedo;
    }
    return pluginsRegistry.getItem(unifiedPluginName);
  };
  this.getPluginName = function(plugin) {
    if (plugin === this.undoRedo) {
      return this.undoRedo.constructor.PLUGIN_KEY;
    }
    return pluginsRegistry.getId(plugin);
  };
  this.getInstance = function() {
    return instance;
  };
  this.addHook = function(key, callback) {
    Hooks$1.getSingleton().add(key, callback, instance);
  };
  this.hasHook = function(key) {
    return Hooks$1.getSingleton().has(key, instance) || Hooks$1.getSingleton().has(key);
  };
  this.addHookOnce = function(key, callback) {
    Hooks$1.getSingleton().once(key, callback, instance);
  };
  this.removeHook = function(key, callback) {
    Hooks$1.getSingleton().remove(key, callback, instance);
  };
  this.runHooks = function(key, p1, p2, p3, p4, p5, p6) {
    return Hooks$1.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);
  };
  this.getTranslatedPhrase = function(dictionaryKey, extraArguments) {
    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);
  };
  this.toHTML = function() {
    return instanceToHTML(_this);
  };
  this.toTableElement = function() {
    var tempElement = _this.rootDocument.createElement("div");
    tempElement.insertAdjacentHTML("afterbegin", instanceToHTML(_this));
    return tempElement.firstElementChild;
  };
  this.timeouts = [];
  this._registerTimeout = function(handle) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var handleFunc = handle;
    if (typeof handleFunc === "function") {
      handleFunc = setTimeout(handleFunc, delay);
    }
    this.timeouts.push(handleFunc);
  };
  this._clearTimeouts = function() {
    arrayEach(this.timeouts, function(handler) {
      clearTimeout(handler);
    });
  };
  this.immediates = [];
  this._registerImmediate = function(callback) {
    this.immediates.push(setImmediate(callback));
  };
  this._clearImmediates = function() {
    arrayEach(this.immediates, function(handler) {
      clearImmediate(handler);
    });
  };
  this._refreshBorders = function() {
    var revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    editorManager.destroyEditor(revertOriginal);
    instance.view.render();
    if (prepareEditorIfNeeded && selection.isSelected()) {
      editorManager.prepareEditor();
    }
  };
  this.isRtl = function() {
    return instance.rootWindow.getComputedStyle(instance.rootElement).direction === "rtl";
  };
  this.isLtr = function() {
    return !instance.isRtl();
  };
  this.getDirectionFactor = function() {
    return instance.isLtr() ? 1 : -1;
  };
  var shortcutManager = createShortcutManager({
    handleEvent: function handleEvent(event2) {
      var isListening = instance.isListening();
      var isKeyboardEventWithKey = (event2 === null || event2 === void 0 ? void 0 : event2.key) !== void 0;
      return isListening && isKeyboardEventWithKey;
    },
    beforeKeyDown: function beforeKeyDown(event2) {
      return _this.runHooks("beforeKeyDown", event2);
    },
    afterKeyDown: function afterKeyDown(event2) {
      if (_this.isDestroyed) {
        return;
      }
      instance.runHooks("afterDocumentKeyDown", event2);
    },
    ownerWindow: this.rootWindow
  });
  this.getShortcutManager = function() {
    return shortcutManager;
  };
  var gridContext = shortcutManager.addContext("grid");
  var gridConfig = {
    runOnlyIf: function runOnlyIf() {
      return isDefined(instance.getSelected()) && instance.countRenderedRows() > 0 && instance.countRenderedCols() > 0;
    },
    group: SHORTCUTS_GROUP$7
  };
  shortcutManager.setActiveContextName("grid");
  gridContext.addShortcuts([{
    keys: [["Control/Meta", "A"]],
    callback: function callback() {
      instance.selectAll();
    }
  }, {
    keys: [["Control/Meta", "Enter"]],
    callback: function callback() {
      var selectedRange = instance.getSelectedRange();
      var _selectedRange$highli = selectedRange[selectedRange.length - 1].highlight, highlightRow = _selectedRange$highli.row, highlightColumn = _selectedRange$highli.col;
      var valueToPopulate = instance.getDataAtCell(highlightRow, highlightColumn);
      var cellValues = /* @__PURE__ */ new Map();
      for (var i = 0; i < selectedRange.length; i++) {
        selectedRange[i].forAll(function(row, column) {
          if (row >= 0 && column >= 0 && (row !== highlightRow || column !== highlightColumn)) {
            var _instance$getCellMeta = instance.getCellMeta(row, column), readOnly = _instance$getCellMeta.readOnly;
            if (!readOnly) {
              cellValues.set("".concat(row, "x").concat(column), [row, column, valueToPopulate]);
            }
          }
        });
      }
      instance.setDataAtCell(Array.from(cellValues.values()));
    },
    runOnlyIf: function runOnlyIf() {
      return instance.getSelectedRangeLast().getCellsCount() > 1;
    }
  }, {
    keys: [["ArrowUp"]],
    callback: function callback() {
      selection.transformStart(-1, 0);
    }
  }, {
    keys: [["ArrowUp", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      selection.setRangeStart(instance._createCellCoords(instance.rowIndexMapper.getNearestNotHiddenIndex(0, 1), instance.getSelectedRangeLast().highlight.col));
    }
  }, {
    keys: [["ArrowUp", "Shift"]],
    callback: function callback() {
      selection.transformEnd(-1, 0);
    }
  }, {
    keys: [["ArrowUp", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var _instance$getSelected = instance.getSelectedRangeLast(), from3 = _instance$getSelected.from, to = _instance$getSelected.to;
      var row = instance.rowIndexMapper.getNearestNotHiddenIndex(0, 1);
      selection.setRangeStart(from3.clone());
      selection.setRangeEnd(instance._createCellCoords(row, to.col));
    },
    runOnlyIf: function runOnlyIf() {
      return !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByColumnHeader());
    }
  }, {
    keys: [["ArrowDown"]],
    callback: function callback() {
      selection.transformStart(1, 0);
    }
  }, {
    keys: [["ArrowDown", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      selection.setRangeStart(instance._createCellCoords(instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - 1, -1), instance.getSelectedRangeLast().highlight.col));
    }
  }, {
    keys: [["ArrowDown", "Shift"]],
    callback: function callback() {
      selection.transformEnd(1, 0);
    }
  }, {
    keys: [["ArrowDown", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var _instance$getSelected2 = instance.getSelectedRangeLast(), from3 = _instance$getSelected2.from, to = _instance$getSelected2.to;
      var row = instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - 1, -1);
      selection.setRangeStart(from3.clone());
      selection.setRangeEnd(instance._createCellCoords(row, to.col));
    },
    runOnlyIf: function runOnlyIf() {
      return !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByColumnHeader());
    }
  }, {
    keys: [["ArrowLeft"]],
    callback: function callback() {
      selection.transformStart(0, -1 * instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowLeft", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var _instance$columnIndex;
      var row = instance.getSelectedRangeLast().highlight.row;
      var column = (_instance$columnIndex = instance.columnIndexMapper).getNearestNotHiddenIndex.apply(_instance$columnIndex, _toConsumableArray$i(instance.isRtl() ? [instance.countCols() - 1, -1] : [0, 1]));
      selection.setRangeStart(instance._createCellCoords(row, column));
    }
  }, {
    keys: [["ArrowLeft", "Shift"]],
    callback: function callback() {
      selection.transformEnd(0, -1 * instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowLeft", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var _instance$columnIndex2;
      var _instance$getSelected3 = instance.getSelectedRangeLast(), from3 = _instance$getSelected3.from, to = _instance$getSelected3.to;
      var column = (_instance$columnIndex2 = instance.columnIndexMapper).getNearestNotHiddenIndex.apply(_instance$columnIndex2, _toConsumableArray$i(instance.isRtl() ? [instance.countCols() - 1, -1] : [0, 1]));
      selection.setRangeStart(from3.clone());
      selection.setRangeEnd(instance._createCellCoords(to.row, column));
    },
    runOnlyIf: function runOnlyIf() {
      return !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByRowHeader());
    }
  }, {
    keys: [["ArrowRight"]],
    callback: function callback() {
      selection.transformStart(0, instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowRight", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var _instance$columnIndex3;
      var row = instance.getSelectedRangeLast().highlight.row;
      var column = (_instance$columnIndex3 = instance.columnIndexMapper).getNearestNotHiddenIndex.apply(_instance$columnIndex3, _toConsumableArray$i(instance.isRtl() ? [0, 1] : [instance.countCols() - 1, -1]));
      selection.setRangeStart(instance._createCellCoords(row, column));
    }
  }, {
    keys: [["ArrowRight", "Shift"]],
    callback: function callback() {
      selection.transformEnd(0, instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowRight", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var _instance$columnIndex4;
      var _instance$getSelected4 = instance.getSelectedRangeLast(), from3 = _instance$getSelected4.from, to = _instance$getSelected4.to;
      var column = (_instance$columnIndex4 = instance.columnIndexMapper).getNearestNotHiddenIndex.apply(_instance$columnIndex4, _toConsumableArray$i(instance.isRtl() ? [0, 1] : [instance.countCols() - 1, -1]));
      selection.setRangeStart(from3.clone());
      selection.setRangeEnd(instance._createCellCoords(to.row, column));
    },
    runOnlyIf: function runOnlyIf() {
      return !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByRowHeader());
    }
  }, {
    keys: [["Home"]],
    captureCtrl: true,
    callback: function callback() {
      var fixedColumns = parseInt(instance.getSettings().fixedColumnsStart, 10);
      var row = instance.getSelectedRangeLast().highlight.row;
      var column = instance.columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, 1);
      selection.setRangeStart(instance._createCellCoords(row, column));
    },
    runOnlyIf: function runOnlyIf() {
      return instance.view.isMainTableNotFullyCoveredByOverlays();
    }
  }, {
    keys: [["Home", "Shift"]],
    callback: function callback() {
      selection.setRangeEnd(instance._createCellCoords(selection.selectedRange.current().from.row, instance.columnIndexMapper.getNearestNotHiddenIndex(0, 1)));
    }
  }, {
    keys: [["Home", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var fixedRows = parseInt(instance.getSettings().fixedRowsTop, 10);
      var fixedColumns = parseInt(instance.getSettings().fixedColumnsStart, 10);
      var row = instance.rowIndexMapper.getNearestNotHiddenIndex(fixedRows, 1);
      var column = instance.columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, 1);
      selection.setRangeStart(instance._createCellCoords(row, column));
    },
    runOnlyIf: function runOnlyIf() {
      return instance.view.isMainTableNotFullyCoveredByOverlays();
    }
  }, {
    keys: [["End"]],
    captureCtrl: true,
    callback: function callback() {
      selection.setRangeStart(instance._createCellCoords(instance.getSelectedRangeLast().highlight.row, instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, -1)));
    },
    runOnlyIf: function runOnlyIf() {
      return instance.view.isMainTableNotFullyCoveredByOverlays();
    }
  }, {
    keys: [["End", "Shift"]],
    callback: function callback() {
      selection.setRangeEnd(instance._createCellCoords(selection.selectedRange.current().from.row, instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, -1)));
    }
  }, {
    keys: [["End", "Control/Meta"]],
    captureCtrl: true,
    callback: function callback() {
      var fixedRows = parseInt(instance.getSettings().fixedRowsBottom, 10);
      var row = instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - fixedRows - 1, -1);
      var column = instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, -1);
      selection.setRangeStart(instance._createCellCoords(row, column));
    },
    runOnlyIf: function runOnlyIf() {
      return instance.view.isMainTableNotFullyCoveredByOverlays();
    }
  }, {
    keys: [["PageUp"]],
    callback: function callback() {
      selection.transformStart(-instance.countVisibleRows(), 0);
    }
  }, {
    keys: [["PageUp", "Shift"]],
    callback: function callback() {
      var _instance$getSelected5 = instance.getSelectedRangeLast(), to = _instance$getSelected5.to;
      var nextRowIndexToSelect = Math.max(to.row - instance.countVisibleRows(), 0);
      var row = instance.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, 1);
      if (row !== null) {
        var coords = instance._createCellCoords(row, to.col);
        var scrollPadding = to.row - instance.view.getFirstFullyVisibleRow();
        var nextVerticalScroll = Math.max(coords.row - scrollPadding, 0);
        selection.setRangeEnd(coords);
        instance.scrollViewportTo(nextVerticalScroll);
      }
    }
  }, {
    keys: [["PageDown"]],
    callback: function callback() {
      selection.transformStart(instance.countVisibleRows(), 0);
    }
  }, {
    keys: [["PageDown", "Shift"]],
    callback: function callback() {
      var _instance$getSelected6 = instance.getSelectedRangeLast(), to = _instance$getSelected6.to;
      var nextRowIndexToSelect = Math.min(to.row + instance.countVisibleRows(), instance.countRows() - 1);
      var row = instance.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, -1);
      if (row !== null) {
        var coords = instance._createCellCoords(row, to.col);
        var scrollPadding = to.row - instance.view.getFirstFullyVisibleRow();
        var nextVerticalScroll = Math.min(coords.row - scrollPadding, instance.countRows() - 1);
        selection.setRangeEnd(coords);
        instance.scrollViewportTo(nextVerticalScroll);
      }
    }
  }, {
    keys: [["Tab"]],
    callback: function callback(event2) {
      var tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
      selection.transformStart(tabMoves.row, tabMoves.col, true);
    }
  }, {
    keys: [["Shift", "Tab"]],
    callback: function callback(event2) {
      var tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
      selection.transformStart(-tabMoves.row, -tabMoves.col);
    }
  }], gridConfig);
  getPluginsNames().forEach(function(pluginName) {
    var PluginClass = getPlugin(pluginName);
    pluginsRegistry.addItem(pluginName, new PluginClass(_this));
  });
  Hooks$1.getSingleton().run(instance, "construct");
}
var MIXIN_NAME = "hooksRefRegisterer";
var hooksRefRegisterer = {
  /**
   * Internal hooks storage.
   */
  _hooksStorage: /* @__PURE__ */ Object.create(null),
  /**
   * Add hook to the collection.
   *
   * @param {string} key The hook name.
   * @param {Function} callback The hook callback.
   * @returns {object}
   */
  addHook: function addHook(key, callback) {
    if (!this._hooksStorage[key]) {
      this._hooksStorage[key] = [];
    }
    this.hot.addHook(key, callback);
    this._hooksStorage[key].push(callback);
    return this;
  },
  /**
   * Remove all hooks listeners by hook name.
   *
   * @param {string} key The hook name.
   */
  removeHooksByKey: function removeHooksByKey(key) {
    var _this = this;
    arrayEach(this._hooksStorage[key] || [], function(callback) {
      _this.hot.removeHook(key, callback);
    });
  },
  /**
   * Clear all added hooks.
   */
  clearHooks: function clearHooks() {
    var _this2 = this;
    objectEach(this._hooksStorage, function(callbacks, name) {
      return _this2.removeHooksByKey(name);
    });
    this._hooksStorage = {};
  }
};
defineGetter(hooksRefRegisterer, "MIXIN_NAME", MIXIN_NAME, {
  writable: false,
  enumerable: false
});
const hooksRefRegisterer$1 = hooksRefRegisterer;
function _typeof$11(obj) {
  "@babel/helpers - typeof";
  return _typeof$11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$11(obj);
}
function _slicedToArray$A(arr, i) {
  return _arrayWithHoles$C(arr) || _iterableToArrayLimit$A(arr, i) || _unsupportedIterableToArray$Q(arr, i) || _nonIterableRest$C();
}
function _nonIterableRest$C() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$Q(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$Q(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$Q(o, minLen);
}
function _arrayLikeToArray$Q(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$A(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$C(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _inherits$$(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$$(subClass, superClass);
}
function _setPrototypeOf$$(o, p2) {
  _setPrototypeOf$$ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$$(o, p2);
}
function _createSuper$$(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$$();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$$(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$$(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$$(this, result);
  };
}
function _possibleConstructorReturn$$(self2, call2) {
  if (call2 && (_typeof$11(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$$(self2);
}
function _assertThisInitialized$$(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$$() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$$(o) {
  _getPrototypeOf$$ = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$$(o);
}
function _classCallCheck$1z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1z(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var EDITOR_TYPE$a = "base";
var EDITOR_STATE = Object.freeze({
  VIRGIN: "STATE_VIRGIN",
  // before editing
  EDITING: "STATE_EDITING",
  WAITING: "STATE_WAITING",
  // waiting for async validation
  FINISHED: "STATE_FINISHED"
});
var SHORTCUTS_GROUP_EDITOR$1 = "baseEditor";
var BaseEditor = /* @__PURE__ */ function() {
  function BaseEditor2(instance) {
    _classCallCheck$1z(this, BaseEditor2);
    this.hot = instance;
    this.instance = instance;
    this.state = EDITOR_STATE.VIRGIN;
    this._opened = false;
    this._fullEditMode = false;
    this._closeCallback = null;
    this.TD = null;
    this.row = null;
    this.col = null;
    this.prop = null;
    this.originalValue = null;
    this.cellProperties = null;
    this.init();
  }
  _createClass$1z(BaseEditor2, [{
    key: "_fireCallbacks",
    value: function _fireCallbacks(result) {
      if (this._closeCallback) {
        this._closeCallback(result);
        this._closeCallback = null;
      }
    }
    /**
     * Initializes an editor's intance.
     */
  }, {
    key: "init",
    value: function init() {
    }
    /**
     * Required method to get current value from editable element.
     */
  }, {
    key: "getValue",
    value: function getValue() {
      throw Error("Editor getValue() method unimplemented");
    }
    /**
     * Required method to set new value into editable element.
     */
  }, {
    key: "setValue",
    value: function setValue() {
      throw Error("Editor setValue() method unimplemented");
    }
    /**
     * Required method to open editor.
     */
  }, {
    key: "open",
    value: function open() {
      throw Error("Editor open() method unimplemented");
    }
    /**
     * Required method to close editor.
     */
  }, {
    key: "close",
    value: function close() {
      throw Error("Editor close() method unimplemented");
    }
    /**
     * Prepares editor's meta data.
     *
     * @param {number} row The visual row index.
     * @param {number} col The visual column index.
     * @param {number|string} prop The column property (passed when datasource is an array of objects).
     * @param {HTMLTableCellElement} td The rendered cell element.
     * @param {*} value The rendered value.
     * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
     */
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      this.TD = td;
      this.row = row;
      this.col = col;
      this.prop = prop;
      this.originalValue = value;
      this.cellProperties = cellProperties;
      this.state = EDITOR_STATE.VIRGIN;
    }
    /**
     * Fallback method to provide extendable editors in ES5.
     *
     * @returns {Function}
     */
  }, {
    key: "extend",
    value: function extend2() {
      return /* @__PURE__ */ function(_this$constructor) {
        _inherits$$(Editor, _this$constructor);
        var _super = _createSuper$$(Editor);
        function Editor() {
          _classCallCheck$1z(this, Editor);
          return _super.apply(this, arguments);
        }
        return _createClass$1z(Editor);
      }(this.constructor);
    }
    /**
     * Saves value from editor into data storage.
     *
     * @param {*} value The editor value.
     * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.
     */
  }, {
    key: "saveValue",
    value: function saveValue(value, ctrlDown) {
      var _this = this;
      var visualRowFrom;
      var visualColumnFrom;
      var visualRowTo;
      var visualColumnTo;
      if (ctrlDown) {
        var selectedLast = this.hot.getSelectedLast();
        visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0);
        visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0);
        visualRowTo = Math.max(selectedLast[0], selectedLast[2]);
        visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);
      } else {
        var _ref2 = [this.row, this.col, null, null];
        visualRowFrom = _ref2[0];
        visualColumnFrom = _ref2[1];
        visualRowTo = _ref2[2];
        visualColumnTo = _ref2[3];
      }
      var modifiedCellCoords = this.hot.runHooks("modifyGetCellCoords", visualRowFrom, visualColumnFrom);
      if (Array.isArray(modifiedCellCoords)) {
        var _modifiedCellCoords = _slicedToArray$A(modifiedCellCoords, 2);
        visualRowFrom = _modifiedCellCoords[0];
        visualColumnFrom = _modifiedCellCoords[1];
      }
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      var contextConfig = {
        runOnlyIf: function runOnlyIf() {
          return isDefined(_this.hot.getSelected());
        },
        group: SHORTCUTS_GROUP_EDITOR$1
      };
      if (this.isInFullEditMode()) {
        editorContext.addShortcuts([{
          keys: [["ArrowUp"]],
          callback: function callback() {
            _this.hot.selection.transformStart(-1, 0);
          }
        }, {
          keys: [["ArrowDown"]],
          callback: function callback() {
            _this.hot.selection.transformStart(1, 0);
          }
        }, {
          keys: [["ArrowLeft"]],
          callback: function callback() {
            _this.hot.selection.transformStart(0, -1 * _this.hot.getDirectionFactor());
          }
        }, {
          keys: [["ArrowRight"]],
          callback: function callback() {
            _this.hot.selection.transformStart(0, _this.hot.getDirectionFactor());
          }
        }], contextConfig);
      }
      this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, "edit");
    }
    /**
     * Begins editing on a highlighted cell and hides fillHandle corner if was present.
     *
     * @param {*} newInitialValue The initial editor value.
     * @param {Event} event The keyboard event object.
     */
  }, {
    key: "beginEditing",
    value: function beginEditing(newInitialValue, event2) {
      if (this.state !== EDITOR_STATE.VIRGIN) {
        return;
      }
      var hotInstance = this.hot;
      var renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);
      var renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);
      hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));
      this.state = EDITOR_STATE.EDITING;
      if (this.isInFullEditMode()) {
        var stringifiedInitialValue = typeof newInitialValue === "string" ? newInitialValue : stringify$1(this.originalValue);
        this.setValue(stringifiedInitialValue);
      }
      this.open(event2);
      this._opened = true;
      this.focus();
      hotInstance.view.render();
      hotInstance.runHooks("afterBeginEditing", this.row, this.col);
    }
    /**
     * Finishes editing and start saving or restoring process for editing cell or last selected range.
     *
     * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
     * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
     * @param {Function} callback The callback function, fired after editor closing.
     */
  }, {
    key: "finishEditing",
    value: function finishEditing(restoreOriginalValue, ctrlDown, callback) {
      var _this2 = this;
      var val;
      if (callback) {
        var previousCloseCallback = this._closeCallback;
        this._closeCallback = function(result) {
          if (previousCloseCallback) {
            previousCloseCallback(result);
          }
          callback(result);
          _this2.hot.view.render();
        };
      }
      if (this.isWaiting()) {
        return;
      }
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR$1);
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);
      if (this.state === EDITOR_STATE.VIRGIN) {
        this.hot._registerTimeout(function() {
          _this2._fireCallbacks(true);
        });
        return;
      }
      if (this.state === EDITOR_STATE.EDITING) {
        if (restoreOriginalValue) {
          this.cancelChanges();
          this.hot.view.render();
          return;
        }
        var value = this.getValue();
        if (this.cellProperties.trimWhitespace) {
          val = [[typeof value === "string" ? String.prototype.trim.call(value || "") : value]];
        } else {
          val = [[value]];
        }
        this.state = EDITOR_STATE.WAITING;
        this.saveValue(val, ctrlDown);
        if (this.hot.getCellValidator(this.cellProperties)) {
          this.hot.addHookOnce("postAfterValidate", function(result) {
            _this2.state = EDITOR_STATE.FINISHED;
            _this2.discardEditor(result);
          });
        } else {
          this.state = EDITOR_STATE.FINISHED;
          this.discardEditor(true);
        }
      }
    }
    /**
     * Finishes editing without singout saving value.
     */
  }, {
    key: "cancelChanges",
    value: function cancelChanges() {
      this.state = EDITOR_STATE.FINISHED;
      this.discardEditor();
    }
    /**
     * Verifies result of validation or closes editor if user's cancelled changes.
     *
     * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,
     *                                   then an editor won't be closed until validation is passed.
     */
  }, {
    key: "discardEditor",
    value: function discardEditor(result) {
      if (this.state !== EDITOR_STATE.FINISHED) {
        return;
      }
      if (result === false && this.cellProperties.allowInvalid !== true) {
        this.hot.selectCell(this.row, this.col);
        this.focus();
        this.state = EDITOR_STATE.EDITING;
        this._fireCallbacks(false);
      } else {
        this.close();
        this._opened = false;
        this._fullEditMode = false;
        this.state = EDITOR_STATE.VIRGIN;
        this._fireCallbacks(true);
        var shortcutManager = this.hot.getShortcutManager();
        shortcutManager.setActiveContextName("grid");
      }
    }
    /**
     * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated
     * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.
     */
  }, {
    key: "enableFullEditMode",
    value: function enableFullEditMode() {
      this._fullEditMode = true;
    }
    /**
     * Checks if editor is in full edit mode.
     *
     * @returns {boolean}
     */
  }, {
    key: "isInFullEditMode",
    value: function isInFullEditMode() {
      return this._fullEditMode;
    }
    /**
     * Returns information whether the editor is open.
     *
     * @returns {boolean}
     */
  }, {
    key: "isOpened",
    value: function isOpened() {
      return this._opened;
    }
    /**
     * Returns information whether the editor is waiting, eg.: for async validation.
     *
     * @returns {boolean}
     */
  }, {
    key: "isWaiting",
    value: function isWaiting() {
      return this.state === EDITOR_STATE.WAITING;
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * Gets the object that provides information about the edited cell size and its position
     * relative to the table viewport.
     *
     * The rectangle has six integer properties:
     *  - `top` The top position relative to the table viewport
     *  - `start` The left (or right in RTL) position relative to the table viewport
     *  - `width` The cell's current width;
     *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport
     *  - `height` The cell's current height;
     *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport
     *
     * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}
     */
  }, {
    key: "getEditedCellRect",
    value: function getEditedCellRect() {
      var _wtOverlays$getParent;
      var TD = this.getEditedCell();
      if (!TD) {
        return;
      }
      var _this$hot$view$_wt = this.hot.view._wt, wtOverlays = _this$hot$view$_wt.wtOverlays, wtViewport = _this$hot$view$_wt.wtViewport;
      var rootWindow = this.hot.rootWindow;
      var currentOffset = offset(TD);
      var cellWidth = outerWidth(TD);
      var containerOffset = offset(this.hot.rootElement);
      var containerWidth = outerWidth(this.hot.rootElement);
      var scrollableContainerTop = wtOverlays.topOverlay.holder;
      var scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;
      var containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;
      var containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;
      var gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;
      var _ref2 = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt, overlayTable = _ref2.wtTable;
      var overlayName = overlayTable.name;
      var scrollTop = ["master", "inline_start"].includes(overlayName) ? containerScrollTop : 0;
      var scrollLeft = ["master", "top", "bottom"].includes(overlayName) ? containerScrollLeft : 0;
      var editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;
      var topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;
      var inlineStartPos = 0;
      if (this.hot.isRtl()) {
        inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;
      } else {
        inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;
      }
      if (["top", "top_inline_start_corner"].includes(overlayName)) {
        topPos += wtOverlays.topOverlay.getOverlayOffset();
      }
      if (["inline_start", "top_inline_start_corner"].includes(overlayName)) {
        inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());
      }
      var hasColumnHeaders = this.hot.hasColHeaders();
      var renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);
      var renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);
      var nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();
      var firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting("fixedRowsBottom");
      if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {
        topPos += 1;
      }
      if (renderableColumn <= 0) {
        inlineStartPos += 1;
      }
      var firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;
      var firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;
      var horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());
      var verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();
      var scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);
      var cellTopOffset = TD.offsetTop + firstRowOffset - verticalScrollPosition;
      var cellStartOffset = 0;
      if (this.hot.isRtl()) {
        var cellOffset = TD.offsetLeft;
        if (cellOffset >= 0) {
          cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;
        } else {
          cellStartOffset = Math.abs(cellOffset);
        }
        cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;
      } else {
        cellStartOffset = TD.offsetLeft + firstColumnOffset - horizontalScrollPosition;
      }
      var cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
      var borderPhysicalWidthProp = this.hot.isRtl() ? "borderRightWidth" : "borderLeftWidth";
      var inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;
      var topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;
      var width = outerWidth(TD) + inlineStartBorderCompensation;
      var height = outerHeight(TD) + topBorderCompensation;
      var actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;
      var actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;
      var maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;
      var maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);
      return {
        top: topPos,
        start: inlineStartPos,
        height,
        maxHeight,
        width,
        maxWidth
      };
    }
    /* eslint-enable jsdoc/require-description-complete-sentence */
    /**
     * Gets className of the edited cell if exist.
     *
     * @returns {string}
     */
  }, {
    key: "getEditedCellsLayerClass",
    value: function getEditedCellsLayerClass() {
      var editorSection = this.checkEditorSection();
      switch (editorSection) {
        case "inline-start":
          return "ht_clone_left ht_clone_inline_start";
        case "bottom":
          return "ht_clone_bottom";
        case "bottom-inline-start-corner":
          return "ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner";
        case "top":
          return "ht_clone_top";
        case "top-inline-start-corner":
          return "ht_clone_top_left_corner ht_clone_top_inline_start_corner";
        default:
          return "ht_clone_master";
      }
    }
    /**
     * Gets HTMLTableCellElement of the edited cell if exist.
     *
     * @returns {HTMLTableCellElement|null}
     */
  }, {
    key: "getEditedCell",
    value: function getEditedCell() {
      return this.hot.getCell(this.row, this.col, true);
    }
    /**
     * Returns name of the overlay, where editor is placed.
     *
     * @private
     * @returns {string}
     */
  }, {
    key: "checkEditorSection",
    value: function checkEditorSection() {
      var totalRows = this.hot.countRows();
      var section = "";
      if (this.row < this.hot.getSettings().fixedRowsTop) {
        if (this.col < this.hot.getSettings().fixedColumnsStart) {
          section = "top-inline-start-corner";
        } else {
          section = "top";
        }
      } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {
        if (this.col < this.hot.getSettings().fixedColumnsStart) {
          section = "bottom-inline-start-corner";
        } else {
          section = "bottom";
        }
      } else if (this.col < this.hot.getSettings().fixedColumnsStart) {
        section = "inline-start";
      }
      return section;
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$a;
    }
  }]);
  return BaseEditor2;
}();
mixin(BaseEditor, hooksRefRegisterer$1);
function autoResize() {
  var defaults = {
    minHeight: 200,
    maxHeight: 300,
    minWidth: 100,
    maxWidth: 300
  }, el, body = document.body, text2 = document.createTextNode(""), span = document.createElement("SPAN"), observe = function observe2(element, event2, handler) {
    element.addEventListener(event2, handler, false);
  }, _unObserve = function unObserve(element, event2, handler) {
    element.removeEventListener(event2, handler, false);
  }, resize = function resize2(newChar) {
    var width, scrollHeight;
    if (!newChar) {
      newChar = "";
    } else if (!/^[a-zA-Z \.,\\\/\|0-9]$/.test(newChar)) {
      newChar = ".";
    }
    if (text2.textContent !== void 0) {
      text2.textContent = el.value + newChar;
    } else {
      text2.data = el.value + newChar;
    }
    span.style.fontSize = getComputedStyle2(el).fontSize;
    span.style.fontFamily = getComputedStyle2(el).fontFamily;
    span.style.whiteSpace = "pre";
    body.appendChild(span);
    width = span.clientWidth + 2;
    body.removeChild(span);
    el.style.height = defaults.minHeight + "px";
    if (defaults.minWidth > width) {
      el.style.width = defaults.minWidth + "px";
    } else if (width > defaults.maxWidth) {
      el.style.width = defaults.maxWidth + "px";
    } else {
      el.style.width = width + "px";
    }
    scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : 0;
    if (defaults.minHeight > scrollHeight) {
      el.style.height = defaults.minHeight + "px";
    } else if (defaults.maxHeight < scrollHeight) {
      el.style.height = defaults.maxHeight + "px";
      el.style.overflowY = "visible";
    } else {
      el.style.height = scrollHeight + "px";
    }
  }, delayedResize = function delayedResize2() {
    window.setTimeout(resize, 0);
  }, extendDefaults = function extendDefaults2(config) {
    if (config && config.minHeight) {
      if (config.minHeight == "inherit") {
        defaults.minHeight = el.clientHeight;
      } else {
        var minHeight = parseInt(config.minHeight);
        if (!isNaN(minHeight)) {
          defaults.minHeight = minHeight;
        }
      }
    }
    if (config && config.maxHeight) {
      if (config.maxHeight == "inherit") {
        defaults.maxHeight = el.clientHeight;
      } else {
        var maxHeight = parseInt(config.maxHeight);
        if (!isNaN(maxHeight)) {
          defaults.maxHeight = maxHeight;
        }
      }
    }
    if (config && config.minWidth) {
      if (config.minWidth == "inherit") {
        defaults.minWidth = el.clientWidth;
      } else {
        var minWidth = parseInt(config.minWidth);
        if (!isNaN(minWidth)) {
          defaults.minWidth = minWidth;
        }
      }
    }
    if (config && config.maxWidth) {
      if (config.maxWidth == "inherit") {
        defaults.maxWidth = el.clientWidth;
      } else {
        var maxWidth = parseInt(config.maxWidth);
        if (!isNaN(maxWidth)) {
          defaults.maxWidth = maxWidth;
        }
      }
    }
    if (!span.firstChild) {
      span.className = "autoResize";
      span.style.display = "inline-block";
      span.appendChild(text2);
    }
  }, _init = function init(el_, config, doObserve) {
    el = el_;
    extendDefaults(config);
    if (el.nodeName == "TEXTAREA") {
      el.style.resize = "none";
      el.style.overflowY = "";
      el.style.height = defaults.minHeight + "px";
      el.style.minWidth = defaults.minWidth + "px";
      el.style.maxWidth = defaults.maxWidth + "px";
      el.style.overflowY = "hidden";
    }
    if (doObserve) {
      observe(el, "change", resize);
      observe(el, "cut", delayedResize);
      observe(el, "paste", delayedResize);
      observe(el, "drop", delayedResize);
      observe(el, "keydown", delayedResize);
      observe(el, "focus", resize);
      observe(el, "compositionstart", delayedResize);
      observe(el, "compositionupdate", delayedResize);
      observe(el, "compositionend", delayedResize);
    }
    resize();
  };
  function getComputedStyle2(element) {
    return element.currentStyle || document.defaultView.getComputedStyle(element);
  }
  return {
    init: function init(el_, config, doObserve) {
      _init(el_, config, doObserve);
    },
    unObserve: function unObserve() {
      _unObserve(el, "change", resize);
      _unObserve(el, "cut", delayedResize);
      _unObserve(el, "paste", delayedResize);
      _unObserve(el, "drop", delayedResize);
      _unObserve(el, "keydown", delayedResize);
      _unObserve(el, "focus", resize);
      _unObserve(el, "compositionstart", delayedResize);
      _unObserve(el, "compositionupdate", delayedResize);
      _unObserve(el, "compositionend", delayedResize);
    },
    resize
  };
}
function updateCaretPosition(actionName, textareaElement) {
  var caretPosition = getCaretPosition(textareaElement);
  var textLines = textareaElement.value.split("\n");
  var newCaretPosition = caretPosition;
  var lineStartIndex = 0;
  for (var i = 0; i < textLines.length; i++) {
    var textLine = textLines[i];
    if (i !== 0) {
      lineStartIndex += textLines[i - 1].length + 1;
    }
    var lineEndIndex = lineStartIndex + textLine.length;
    if (actionName === "home") {
      newCaretPosition = lineStartIndex;
    } else if (actionName === "end") {
      newCaretPosition = lineEndIndex;
    }
    if (caretPosition <= lineEndIndex) {
      break;
    }
  }
  setCaretPosition(textareaElement, newCaretPosition);
}
function _typeof$10(obj) {
  "@babel/helpers - typeof";
  return _typeof$10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$10(obj);
}
function _slicedToArray$z(arr, i) {
  return _arrayWithHoles$B(arr) || _iterableToArrayLimit$z(arr, i) || _unsupportedIterableToArray$P(arr, i) || _nonIterableRest$B();
}
function _nonIterableRest$B() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$P(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$P(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$P(o, minLen);
}
function _arrayLikeToArray$P(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$z(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$B(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1y(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$P() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$P = Reflect.get.bind();
  } else {
    _get$P = function _get2(target, property, receiver) {
      var base = _superPropBase$P(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$P.apply(this, arguments);
}
function _superPropBase$P(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$_(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$_(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$_(subClass, superClass);
}
function _setPrototypeOf$_(o, p2) {
  _setPrototypeOf$_ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$_(o, p2);
}
function _createSuper$_(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$_();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$_(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$_(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$_(this, result);
  };
}
function _possibleConstructorReturn$_(self2, call2) {
  if (call2 && (_typeof$10(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$_(self2);
}
function _assertThisInitialized$_(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$_() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$_(o) {
  _getPrototypeOf$_ = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$_(o);
}
var EDITOR_VISIBLE_CLASS_NAME$1 = "ht_editor_visible";
var EDITOR_HIDDEN_CLASS_NAME = "ht_editor_hidden";
var SHORTCUTS_GROUP$6 = "textEditor";
var EDITOR_TYPE$9 = "text";
var TextEditor = /* @__PURE__ */ function(_BaseEditor) {
  _inherits$_(TextEditor2, _BaseEditor);
  var _super = _createSuper$_(TextEditor2);
  function TextEditor2(instance) {
    var _this;
    _classCallCheck$1y(this, TextEditor2);
    _this = _super.call(this, instance);
    _this.eventManager = new EventManager$1(_assertThisInitialized$_(_this));
    _this.autoResize = autoResize();
    _this.TEXTAREA = void 0;
    _this.textareaStyle = void 0;
    _this.TEXTAREA_PARENT = void 0;
    _this.textareaParentStyle = void 0;
    _this.layerClass = void 0;
    _this.createElements();
    _this.bindEvents();
    _this.hot.addHookOnce("afterDestroy", function() {
      return _this.destroy();
    });
    return _this;
  }
  _createClass$1y(TextEditor2, [{
    key: "getValue",
    value: function getValue() {
      return this.TEXTAREA.value;
    }
    /**
     * Sets new value into editable element.
     *
     * @param {*} newValue The editor value.
     */
  }, {
    key: "setValue",
    value: function setValue(newValue) {
      this.TEXTAREA.value = newValue;
    }
    /**
     * Opens the editor and adjust its size.
     */
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;
      this.refreshDimensions();
      this.showEditableElement();
      var shortcutManager = this.hot.getShortcutManager();
      shortcutManager.setActiveContextName("editor");
      this.addHook("afterDocumentKeyDown", function(event2) {
        return _this2.onAfterDocumentKeyDown(event2);
      });
      this.registerShortcuts();
    }
    /**
     * Closes the editor.
     */
  }, {
    key: "close",
    value: function close() {
      this.autoResize.unObserve();
      if (this.hot.rootDocument.activeElement === this.TEXTAREA) {
        this.hot.listen();
      }
      this.hideEditableElement();
      this.unregisterShortcuts();
      this.removeHooksByKey("afterDocumentKeyDown");
    }
    /**
     * Prepares editor's meta data.
     *
     * @param {number} row The visual row index.
     * @param {number} col The visual column index.
     * @param {number|string} prop The column property (passed when datasource is an array of objects).
     * @param {HTMLTableCellElement} td The rendered cell element.
     * @param {*} value The rendered value.
     * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
     */
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      var previousState = this.state;
      _get$P(_getPrototypeOf$_(TextEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
      if (!cellProperties.readOnly) {
        this.refreshDimensions(true);
        var allowInvalid = cellProperties.allowInvalid, fragmentSelection = cellProperties.fragmentSelection;
        if (allowInvalid) {
          this.TEXTAREA.value = "";
        }
        if (previousState !== EDITOR_STATE.FINISHED) {
          this.hideEditableElement();
        }
        var restoreFocus = !fragmentSelection;
        if (restoreFocus && !isMobileBrowser()) {
          this.focus();
        }
      }
    }
    /**
     * Begins editing on a highlighted cell and hides fillHandle corner if was present.
     *
     * @param {*} newInitialValue The editor initial value.
     * @param {Event} event The keyboard event object.
     */
  }, {
    key: "beginEditing",
    value: function beginEditing(newInitialValue, event2) {
      if (this.state !== EDITOR_STATE.VIRGIN) {
        return;
      }
      this.TEXTAREA.value = "";
      _get$P(_getPrototypeOf$_(TextEditor2.prototype), "beginEditing", this).call(this, newInitialValue, event2);
    }
    /**
     * Sets focus state on the select element.
     */
  }, {
    key: "focus",
    value: function focus() {
      this.TEXTAREA.select();
      setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
    }
    /**
     * Creates an editor's elements and adds necessary CSS classnames.
     */
  }, {
    key: "createElements",
    value: function createElements() {
      var rootDocument = this.hot.rootDocument;
      this.TEXTAREA = rootDocument.createElement("TEXTAREA");
      this.TEXTAREA.setAttribute("data-hot-input", "");
      this.TEXTAREA.tabIndex = -1;
      addClass(this.TEXTAREA, "handsontableInput");
      this.textareaStyle = this.TEXTAREA.style;
      this.textareaStyle.width = 0;
      this.textareaStyle.height = 0;
      this.textareaStyle.overflowY = "visible";
      this.TEXTAREA_PARENT = rootDocument.createElement("DIV");
      addClass(this.TEXTAREA_PARENT, "handsontableInputHolder");
      if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {
        removeClass(this.TEXTAREA_PARENT, this.layerClass);
      }
      addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
      this.textareaParentStyle = this.TEXTAREA_PARENT.style;
      this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
      this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);
    }
    /**
     * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.
     *
     * @private
     */
  }, {
    key: "hideEditableElement",
    value: function hideEditableElement() {
      if (isIE() || isEdge()) {
        this.textareaStyle.textIndent = "-99999px";
      }
      this.textareaStyle.overflowY = "visible";
      this.textareaParentStyle.opacity = "0";
      this.textareaParentStyle.height = "1px";
      removeClass(this.TEXTAREA_PARENT, this.layerClass);
      addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
    }
    /**
     * Resets an editable element position.
     *
     * @private
     */
  }, {
    key: "showEditableElement",
    value: function showEditableElement() {
      this.textareaParentStyle.height = "";
      this.textareaParentStyle.overflow = "";
      this.textareaParentStyle.position = "";
      this.textareaParentStyle[this.hot.isRtl() ? "left" : "right"] = "auto";
      this.textareaParentStyle.opacity = "1";
      this.textareaStyle.textIndent = "";
      this.textareaStyle.overflowY = "hidden";
      var childNodes = this.TEXTAREA_PARENT.childNodes;
      var hasClassHandsontableEditor = false;
      rangeEach(childNodes.length - 1, function(index2) {
        var childNode = childNodes[index2];
        if (hasClass(childNode, "handsontableEditor")) {
          hasClassHandsontableEditor = true;
          return false;
        }
      });
      if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {
        removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
      }
      if (hasClassHandsontableEditor) {
        this.layerClass = EDITOR_VISIBLE_CLASS_NAME$1;
        addClass(this.TEXTAREA_PARENT, this.layerClass);
      } else {
        this.layerClass = this.getEditedCellsLayerClass();
        addClass(this.TEXTAREA_PARENT, this.layerClass);
      }
    }
    /**
     * Refreshes editor's value using source data.
     *
     * @private
     */
  }, {
    key: "refreshValue",
    value: function refreshValue() {
      var physicalRow = this.hot.toPhysicalRow(this.row);
      var sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);
      this.originalValue = sourceData;
      this.setValue(sourceData);
      this.refreshDimensions();
    }
    /**
     * Refreshes editor's size and position.
     *
     * @private
     * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.
     */
  }, {
    key: "refreshDimensions",
    value: function refreshDimensions() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (this.state !== EDITOR_STATE.EDITING && !force) {
        return;
      }
      this.TD = this.getEditedCell();
      if (!this.TD) {
        if (!force) {
          this.close();
        }
        return;
      }
      var _this$getEditedCellRe = this.getEditedCellRect(), top2 = _this$getEditedCellRe.top, start = _this$getEditedCellRe.start, width = _this$getEditedCellRe.width, maxWidth = _this$getEditedCellRe.maxWidth, height = _this$getEditedCellRe.height, maxHeight = _this$getEditedCellRe.maxHeight;
      this.textareaParentStyle.top = "".concat(top2, "px");
      this.textareaParentStyle[this.hot.isRtl() ? "right" : "left"] = "".concat(start, "px");
      this.showEditableElement();
      var cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
      this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
      this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;
      this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;
      var textareaComputedStyle = getComputedStyle(this.TEXTAREA);
      var horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);
      var verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);
      var finalWidth = width - horizontalPadding;
      var finalHeight = height - verticalPadding;
      var finalMaxWidth = maxWidth - horizontalPadding;
      var finalMaxHeight = maxHeight - verticalPadding;
      this.autoResize.init(this.TEXTAREA, {
        minWidth: Math.min(finalWidth, finalMaxWidth),
        minHeight: Math.min(finalHeight, finalMaxHeight),
        // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
        maxWidth: finalMaxWidth,
        maxHeight: finalMaxHeight
      }, true);
    }
    /**
     * Binds events and hooks.
     *
     * @private
     */
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this3 = this;
      this.eventManager.addEventListener(this.TEXTAREA, "cut", function(event2) {
        return event2.stopPropagation();
      });
      this.eventManager.addEventListener(this.TEXTAREA, "paste", function(event2) {
        return event2.stopPropagation();
      });
      if (isIOS()) {
        this.eventManager.addEventListener(this.TEXTAREA, "focusout", function() {
          return _this3.finishEditing(false);
        });
      }
      this.addHook("afterScrollHorizontally", function() {
        return _this3.refreshDimensions();
      });
      this.addHook("afterScrollVertically", function() {
        return _this3.refreshDimensions();
      });
      this.addHook("afterColumnResize", function() {
        _this3.refreshDimensions();
        _this3.focus();
      });
      this.addHook("afterRowResize", function() {
        _this3.refreshDimensions();
        _this3.focus();
      });
    }
    /**
     * Ugly hack for autocompleteEditor.
     *
     * @private
     */
  }, {
    key: "allowKeyEventPropagation",
    value: function allowKeyEventPropagation() {
    }
    /**
     * Destroys the internal event manager and clears attached hooks.
     *
     * @private
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroy();
      this.clearHooks();
    }
    /**
     * Register shortcuts responsible for handling editor.
     *
     * @private
     */
  }, {
    key: "registerShortcuts",
    value: function registerShortcuts() {
      var _this4 = this;
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      var contextConfig = {
        runOnlyIf: function runOnlyIf() {
          return isDefined(_this4.hot.getSelected());
        },
        group: SHORTCUTS_GROUP$6
      };
      var insertNewLine = function insertNewLine2() {
        _this4.hot.rootDocument.execCommand("insertText", false, "\n");
      };
      editorContext.addShortcuts([{
        keys: [["Tab"]],
        // TODO: Duplicated part of code (callback to shortcut).
        callback: function callback(event2) {
          var tableMeta = _this4.hot.getSettings();
          var tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
          _this4.hot.selection.transformStart(tabMoves.row, tabMoves.col, true);
        }
      }, {
        keys: [["Shift", "Tab"]],
        // TODO: Duplicated part of code (callback to shortcut).
        callback: function callback(event2) {
          var tableMeta = _this4.hot.getSettings();
          var tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
          _this4.hot.selection.transformStart(-tabMoves.row, -tabMoves.col);
        }
      }, {
        keys: [["Control", "Enter"]],
        callback: function callback() {
          insertNewLine();
          return false;
        },
        runOnlyIf: function runOnlyIf(event2) {
          return !_this4.hot.selection.isMultiple() && // We trigger a data population for multiple selection.
          // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
          !event2.altKey;
        },
        relativeToGroup: SHORTCUTS_GROUP_EDITOR$2,
        position: "before"
      }, {
        keys: [["Meta", "Enter"]],
        callback: function callback() {
          insertNewLine();
          return false;
        },
        runOnlyIf: function runOnlyIf() {
          return !_this4.hot.selection.isMultiple();
        },
        // We trigger a data population for multiple selection.
        relativeToGroup: SHORTCUTS_GROUP_EDITOR$2,
        position: "before"
      }, {
        keys: [["Alt", "Enter"]],
        callback: function callback() {
          insertNewLine();
          return false;
        },
        relativeToGroup: SHORTCUTS_GROUP_EDITOR$2,
        position: "before"
      }, {
        // TODO: Duplicated part of code (callback to shortcut)
        keys: [["PageUp"]],
        callback: function callback() {
          _this4.hot.selection.transformStart(-_this4.hot.countVisibleRows(), 0);
        }
      }, {
        // TODO: Duplicated part of code (callback to shortcut)
        keys: [["PageDown"]],
        callback: function callback() {
          _this4.hot.selection.transformStart(_this4.hot.countVisibleRows(), 0);
        }
      }, {
        keys: [["Home"]],
        callback: function callback(event2, _ref2) {
          var _ref22 = _slicedToArray$z(_ref2, 1), keyName = _ref22[0];
          updateCaretPosition(keyName, _this4.TEXTAREA);
        }
      }, {
        keys: [["End"]],
        callback: function callback(event2, _ref3) {
          var _ref4 = _slicedToArray$z(_ref3, 1), keyName = _ref4[0];
          updateCaretPosition(keyName, _this4.TEXTAREA);
        }
      }, {
        keys: [["Control/Meta", "Z"]],
        preventDefault: false,
        callback: function callback() {
          _this4.hot._registerTimeout(function() {
            _this4.autoResize.resize();
          }, 10);
        }
      }, {
        keys: [["Control/Meta", "Shift", "Z"]],
        preventDefault: false,
        callback: function callback() {
          _this4.hot._registerTimeout(function() {
            _this4.autoResize.resize();
          }, 10);
        }
      }], contextConfig);
    }
    /**
     * Unregister shortcuts responsible for handling editor.
     *
     * @private
     */
  }, {
    key: "unregisterShortcuts",
    value: function unregisterShortcuts() {
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP$6);
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR$1);
    }
    /**
     * OnAfterDocumentKeyDown callback.
     *
     * @private
     * @param {KeyboardEvent} event The keyboard event object.
     */
  }, {
    key: "onAfterDocumentKeyDown",
    value: function onAfterDocumentKeyDown(event2) {
      var arrowKeyCodes = [KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT];
      if (arrowKeyCodes.indexOf(event2.keyCode) === -1) {
        this.autoResize.resize(String.fromCharCode(event2.keyCode));
      }
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$9;
    }
  }]);
  return TextEditor2;
}(BaseEditor);
var CELL_TYPE$8 = "text";
var TextCellType = {
  CELL_TYPE: CELL_TYPE$8,
  editor: TextEditor,
  renderer: textRenderer
};
_register(TextCellType);
Handsontable.editors = {
  BaseEditor
};
function Handsontable(rootElement, userSettings) {
  var instance = new Core(rootElement, userSettings || {}, rootInstanceSymbol);
  instance.init();
  return instance;
}
Handsontable.Core = function(rootElement) {
  var userSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Core(rootElement, userSettings, rootInstanceSymbol);
};
Handsontable.DefaultSettings = metaSchemaFactory();
Handsontable.hooks = Hooks$1.getSingleton();
Handsontable.packageName = "handsontable";
Handsontable.buildDate = "22/09/2022 09:54:36";
Handsontable.version = "12.1.3";
Handsontable.languages = {
  dictionaryKeys,
  getLanguageDictionary,
  getLanguagesDictionaries,
  registerLanguageDictionary,
  getTranslatedPhrase
};
function ownKeys$9(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
      _defineProperty$j(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof$$(obj) {
  "@babel/helpers - typeof";
  return _typeof$$ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$$(obj);
}
function _classCallCheck$1x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1x(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1x(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1x(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits$Z(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$Z(subClass, superClass);
}
function _getPrototypeOf$Z(o) {
  _getPrototypeOf$Z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$Z(o);
}
function _setPrototypeOf$Z(o, p2) {
  _setPrototypeOf$Z = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$Z(o, p2);
}
function _isNativeReflectConstruct$Z() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized$Z(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$Z(self2, call2) {
  if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$Z(self2);
}
function _createSuper$Z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$Z(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$Z(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$Z(this, result);
  };
}
var bulkComponentContainer = null;
var AUTOSIZE_WARNING = "Your `HotTable` configuration includes `autoRowSize`/`autoColumnSize` options, which are not compatible with  the component-based renderers`. Disable `autoRowSize` and `autoColumnSize` to prevent row and column misalignment.";
var HOT_DESTROYED_WARNING = "The Handsontable instance bound to this component was destroyed and cannot be used properly.";
var GLOBAL_EDITOR_SCOPE = "global";
var DEFAULT_CLASSNAME = "hot-wrapper-editor-container";
function warn() {
  if (typeof console !== "undefined") {
    var _console;
    (_console = console).warn.apply(_console, arguments);
  }
}
function getChildElementByType(children, type) {
  var childrenArray = React.Children.toArray(children);
  var childrenCount = React.Children.count(children);
  var wantedChild = null;
  if (childrenCount !== 0) {
    if (childrenCount === 1 && childrenArray[0].props[type]) {
      wantedChild = childrenArray[0];
    } else {
      wantedChild = childrenArray.find(function(child) {
        return child.props[type] !== void 0;
      });
    }
  }
  return wantedChild || null;
}
function getOriginalEditorClass(editorElement) {
  if (!editorElement) {
    return null;
  }
  return editorElement.type.WrappedComponent ? editorElement.type.WrappedComponent : editorElement.type;
}
function removeEditorContainers() {
  var doc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  doc.querySelectorAll('[class^="'.concat(DEFAULT_CLASSNAME, '"]')).forEach(function(domNode) {
    if (domNode.parentNode) {
      domNode.parentNode.removeChild(domNode);
    }
  });
}
function createEditorPortal() {
  var doc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  var editorElement = arguments.length > 1 ? arguments[1] : void 0;
  if (editorElement === null) {
    return;
  }
  var editorContainer = doc.createElement("DIV");
  var _getContainerAttribut = getContainerAttributesProps(editorElement.props, false), id2 = _getContainerAttribut.id, className = _getContainerAttribut.className, style = _getContainerAttribut.style;
  if (id2) {
    editorContainer.id = id2;
  }
  editorContainer.className = [DEFAULT_CLASSNAME, className].join(" ");
  if (style) {
    Object.assign(editorContainer.style, style);
  }
  doc.body.appendChild(editorContainer);
  return ReactDOM.createPortal(editorElement, editorContainer);
}
function getExtendedEditorElement(children, editorCache) {
  var editorColumnScope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : GLOBAL_EDITOR_SCOPE;
  var editorElement = getChildElementByType(children, "hot-editor");
  var editorClass = getOriginalEditorClass(editorElement);
  if (!editorElement) {
    return null;
  }
  return React.cloneElement(editorElement, {
    emitEditorInstance: function emitEditorInstance(editorInstance, editorColumnScope2) {
      if (!editorCache.get(editorClass)) {
        editorCache.set(editorClass, /* @__PURE__ */ new Map());
      }
      var cacheEntry = editorCache.get(editorClass);
      cacheEntry.set(editorColumnScope2 !== null && editorColumnScope2 !== void 0 ? editorColumnScope2 : GLOBAL_EDITOR_SCOPE, editorInstance);
    },
    editorColumnScope,
    isEditor: true
  });
}
function createPortal(rElement, props, callback) {
  var ownerDocument = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : document;
  if (!ownerDocument) {
    ownerDocument = document;
  }
  if (!bulkComponentContainer) {
    bulkComponentContainer = ownerDocument.createDocumentFragment();
  }
  var portalContainer = ownerDocument.createElement("DIV");
  bulkComponentContainer.appendChild(portalContainer);
  var extendedRendererElement = React.cloneElement(rElement, _objectSpread2({
    key: "".concat(props.row, "-").concat(props.col)
  }, props));
  return {
    portal: ReactDOM.createPortal(extendedRendererElement, portalContainer, "".concat(props.row, "-").concat(props.col, "-").concat(Math.random())),
    portalContainer
  };
}
function getContainerAttributesProps(props) {
  var randomizeId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return {
    id: props.id || (randomizeId ? "hot-" + Math.random().toString(36).substring(5) : void 0),
    className: props.className || "",
    style: props.style || {}
  };
}
function addUnsafePrefixes(instance) {
  var reactSemverArray = React.version.split(".").map(function(v2) {
    return parseInt(v2);
  });
  var shouldPrefix = reactSemverArray[0] >= 16 && reactSemverArray[1] >= 3 || reactSemverArray[0] >= 17;
  if (shouldPrefix) {
    instance.UNSAFE_componentWillUpdate = instance.componentWillUpdate;
    instance.componentWillUpdate = void 0;
    instance.UNSAFE_componentWillMount = instance.componentWillMount;
    instance.componentWillMount = void 0;
  }
}
var SettingsMapper = /* @__PURE__ */ function() {
  function SettingsMapper2() {
    _classCallCheck$1x(this, SettingsMapper2);
  }
  _createClass$1x(SettingsMapper2, null, [{
    key: "getSettings",
    value: (
      /**
       * Parse component settings into Handosntable-compatible settings.
       *
       * @param {Object} properties Object containing properties from the HotTable object.
       * @returns {Object} Handsontable-compatible settings object.
       */
      function getSettings(properties) {
        var newSettings = {};
        if (properties.settings) {
          var settings = properties.settings;
          for (var key in settings) {
            if (settings.hasOwnProperty(key)) {
              newSettings[key] = settings[key];
            }
          }
        }
        for (var _key in properties) {
          if (_key !== "settings" && _key !== "children" && properties.hasOwnProperty(_key)) {
            newSettings[_key] = properties[_key];
          }
        }
        return newSettings;
      }
    )
  }]);
  return SettingsMapper2;
}();
var HotColumn = /* @__PURE__ */ function(_React$Component) {
  _inherits$Z(HotColumn2, _React$Component);
  var _super = _createSuper$Z(HotColumn2);
  function HotColumn2(props, context) {
    var _this;
    _classCallCheck$1x(this, HotColumn2);
    _this = _super.call(this, props, context);
    _this.localEditorPortal = null;
    addUnsafePrefixes(_assertThisInitialized$Z(_this));
    return _this;
  }
  _createClass$1x(HotColumn2, [{
    key: "getLocalEditorPortal",
    value: function getLocalEditorPortal() {
      return this.localEditorPortal;
    }
    /**
     * Set the local editor portal cache property.
     *
     * @param {ReactPortal} portal Local editor portal.
     */
  }, {
    key: "setLocalEditorPortal",
    value: function setLocalEditorPortal(portal) {
      this.localEditorPortal = portal;
    }
    /**
     * Filter out all the internal properties and return an object with just the Handsontable-related props.
     *
     * @returns {Object}
     */
  }, {
    key: "getSettingsProps",
    value: function getSettingsProps() {
      var _this2 = this;
      this.internalProps = ["__componentRendererColumns", "_emitColumnSettings", "_columnIndex", "_getChildElementByType", "_getRendererWrapper", "_getEditorClass", "_getEditorCache", "_getOwnerDocument", "hot-renderer", "hot-editor", "children"];
      return Object.keys(this.props).filter(function(key) {
        return !_this2.internalProps.includes(key);
      }).reduce(function(obj, key) {
        obj[key] = _this2.props[key];
        return obj;
      }, {});
    }
    /**
     * Check whether the HotColumn component contains a provided prop.
     *
     * @param {String} propName Property name.
     * @returns {Boolean}
     */
  }, {
    key: "hasProp",
    value: function hasProp(propName) {
      return !!this.props[propName];
    }
    /**
     * Get the editor element for the current column.
     *
     * @returns {React.ReactElement} React editor component element.
     */
  }, {
    key: "getLocalEditorElement",
    value: function getLocalEditorElement() {
      return getExtendedEditorElement(this.props.children, this.props._getEditorCache(), this.props._columnIndex);
    }
    /**
     * Create the column settings based on the data provided to the `HotColumn` component and it's child components.
     */
  }, {
    key: "createColumnSettings",
    value: function createColumnSettings() {
      var rendererElement = this.props._getChildElementByType(this.props.children, "hot-renderer");
      var editorElement = this.getLocalEditorElement();
      this.columnSettings = SettingsMapper.getSettings(this.getSettingsProps());
      if (rendererElement !== null) {
        this.columnSettings.renderer = this.props._getRendererWrapper(rendererElement);
        this.props._componentRendererColumns.set(this.props._columnIndex, true);
      } else if (this.hasProp("renderer")) {
        this.columnSettings.renderer = this.props.renderer;
      } else {
        this.columnSettings.renderer = void 0;
      }
      if (editorElement !== null) {
        this.columnSettings.editor = this.props._getEditorClass(editorElement, this.props._columnIndex);
      } else if (this.hasProp("editor")) {
        this.columnSettings.editor = this.props.editor;
      } else {
        this.columnSettings.editor = void 0;
      }
    }
    /**
     * Create the local editor portal and its destination HTML element if needed.
     *
     * @param {React.ReactNode} [children] Children of the HotTable instance. Defaults to `this.props.children`.
     */
  }, {
    key: "createLocalEditorPortal",
    value: function createLocalEditorPortal() {
      var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.children;
      var editorCache = this.props._getEditorCache();
      var localEditorElement = getExtendedEditorElement(children, editorCache, this.props._columnIndex);
      if (localEditorElement) {
        this.setLocalEditorPortal(createEditorPortal(this.props._getOwnerDocument(), localEditorElement, editorCache));
      }
    }
    /**
     * Emit the column settings to the parent using a prop passed from the parent.
     */
  }, {
    key: "emitColumnSettings",
    value: function emitColumnSettings() {
      this.props._emitColumnSettings(this.columnSettings, this.props._columnIndex);
    }
    /*
    ---------------------------------------
    ------- React lifecycle methods -------
    ---------------------------------------
    */
    /**
     * Logic performed before the mounting of the HotColumn component.
     */
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.createLocalEditorPortal();
    }
    /**
     * Logic performed after the mounting of the HotColumn component.
     */
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.createColumnSettings();
      this.emitColumnSettings();
    }
    /**
     * Logic performed before the updating of the HotColumn component.
     */
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState, nextContext) {
      this.createLocalEditorPortal(nextProps.children);
    }
    /**
     * Logic performed after the updating of the HotColumn component.
     */
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.createColumnSettings();
      this.emitColumnSettings();
    }
    /**
     * Render the portals of the editors, if there are any.
     *
     * @returns {React.ReactElement}
     */
  }, {
    key: "render",
    value: function render() {
      return React.createElement(React.Fragment, null, this.getLocalEditorPortal());
    }
  }]);
  return HotColumn2;
}(React.Component);
var PortalManager = /* @__PURE__ */ function(_React$Component) {
  _inherits$Z(PortalManager2, _React$Component);
  var _super = _createSuper$Z(PortalManager2);
  function PortalManager2(props) {
    var _this;
    _classCallCheck$1x(this, PortalManager2);
    _this = _super.call(this, props);
    _this.state = {
      portals: []
    };
    return _this;
  }
  _createClass$1x(PortalManager2, [{
    key: "render",
    value: function render() {
      return React.createElement(React.Fragment, null, this.state.portals);
    }
  }]);
  return PortalManager2;
}(React.Component);
var version = "12.1.3";
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol["for"], c = b ? Symbol["for"]("react.element") : 60103, d = b ? Symbol["for"]("react.portal") : 60106, e = b ? Symbol["for"]("react.fragment") : 60107, f = b ? Symbol["for"]("react.strict_mode") : 60108, g = b ? Symbol["for"]("react.profiler") : 60114, h = b ? Symbol["for"]("react.provider") : 60109, k = b ? Symbol["for"]("react.context") : 60110, l = b ? Symbol["for"]("react.async_mode") : 60111, m = b ? Symbol["for"]("react.concurrent_mode") : 60111, n = b ? Symbol["for"]("react.forward_ref") : 60112, p = b ? Symbol["for"]("react.suspense") : 60113, q = b ? Symbol["for"]("react.suspense_list") : 60120, r = b ? Symbol["for"]("react.memo") : 60115, t = b ? Symbol["for"]("react.lazy") : 60116, v = b ? Symbol["for"]("react.block") : 60121, w = b ? Symbol["for"]("react.fundamental") : 60117, x = b ? Symbol["for"]("react.responder") : 60118, y = b ? Symbol["for"]("react.scope") : 60119;
function z(a) {
  if ("object" === _typeof$$(a) && null !== a) {
    var u = a.$$typeof;
    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;
              default:
                return u;
            }
        }
      case d:
        return u;
    }
  }
}
function A(a) {
  return z(a) === m;
}
var AsyncMode = l;
var ConcurrentMode = m;
var ContextConsumer = k;
var ContextProvider = h;
var Element = c;
var ForwardRef = n;
var Fragment = e;
var Lazy = t;
var Memo = r;
var Portal = d;
var Profiler = g;
var StrictMode = f;
var Suspense = p;
var isAsyncMode = function isAsyncMode2(a) {
  return A(a) || z(a) === l;
};
var isConcurrentMode = A;
var isContextConsumer = function isContextConsumer2(a) {
  return z(a) === k;
};
var isContextProvider = function isContextProvider2(a) {
  return z(a) === h;
};
var isElement = function isElement2(a) {
  return "object" === _typeof$$(a) && null !== a && a.$$typeof === c;
};
var isForwardRef = function isForwardRef2(a) {
  return z(a) === n;
};
var isFragment = function isFragment2(a) {
  return z(a) === e;
};
var isLazy = function isLazy2(a) {
  return z(a) === t;
};
var isMemo = function isMemo2(a) {
  return z(a) === r;
};
var isPortal = function isPortal2(a) {
  return z(a) === d;
};
var isProfiler = function isProfiler2(a) {
  return z(a) === g;
};
var isStrictMode = function isStrictMode2(a) {
  return z(a) === f;
};
var isSuspense = function isSuspense2(a) {
  return z(a) === p;
};
var isValidElementType = function isValidElementType2(a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === _typeof$$(a) && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
var typeOf = z;
var reactIs_production_min = {
  AsyncMode,
  ConcurrentMode,
  ContextConsumer,
  ContextProvider,
  Element,
  ForwardRef,
  Fragment,
  Lazy,
  Memo,
  Portal,
  Profiler,
  StrictMode,
  Suspense,
  isAsyncMode,
  isConcurrentMode,
  isContextConsumer,
  isContextProvider,
  isElement,
  isForwardRef,
  isFragment,
  isLazy,
  isMemo,
  isPortal,
  isProfiler,
  isStrictMode,
  isSuspense,
  isValidElementType,
  typeOf
};
var reactIs_development = createCommonjsModule(function(module, exports) {
});
reactIs_development.AsyncMode;
reactIs_development.ConcurrentMode;
reactIs_development.ContextConsumer;
reactIs_development.ContextProvider;
reactIs_development.Element;
reactIs_development.ForwardRef;
reactIs_development.Fragment;
reactIs_development.Lazy;
reactIs_development.Memo;
reactIs_development.Portal;
reactIs_development.Profiler;
reactIs_development.StrictMode;
reactIs_development.Suspense;
reactIs_development.isAsyncMode;
reactIs_development.isConcurrentMode;
reactIs_development.isContextConsumer;
reactIs_development.isContextProvider;
reactIs_development.isElement;
reactIs_development.isForwardRef;
reactIs_development.isFragment;
reactIs_development.isLazy;
reactIs_development.isMemo;
reactIs_development.isPortal;
reactIs_development.isProfiler;
reactIs_development.isStrictMode;
reactIs_development.isSuspense;
reactIs_development.isValidElementType;
reactIs_development.typeOf;
createCommonjsModule(function(module) {
  {
    module.exports = reactIs_production_min;
  }
});
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols2 = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
shouldUseNative() ? Object.assign : function(target, source) {
  var from3;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from3 = Object(arguments[s]);
    for (var key in from3) {
      if (hasOwnProperty.call(from3, key)) {
        to[key] = from3[key];
      }
    }
    if (getOwnPropertySymbols2) {
      symbols = getOwnPropertySymbols2(from3);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from3, symbols[i])) {
          to[symbols[i]] = from3[symbols[i]];
        }
      }
    }
  }
  return to;
};
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
Function.call.bind(Object.prototype.hasOwnProperty);
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function factoryWithThrowingShims2() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
var propTypes = createCommonjsModule(function(module) {
  {
    module.exports = factoryWithThrowingShims();
  }
});
var PropTypes = propTypes;
var HotTable = /* @__PURE__ */ function(_React$Component) {
  _inherits$Z(HotTable2, _React$Component);
  var _super = _createSuper$Z(HotTable2);
  function HotTable2(props, context) {
    var _this;
    _classCallCheck$1x(this, HotTable2);
    _this = _super.call(this, props, context);
    _this.id = null;
    _this.__hotInstance = null;
    _this.hotElementRef = null;
    _this.columnSettings = [];
    _this.portalManager = null;
    _this.portalCacheArray = [];
    _this.globalEditorPortal = null;
    _this.renderedCellCache = /* @__PURE__ */ new Map();
    _this.editorCache = /* @__PURE__ */ new Map();
    _this.componentRendererColumns = /* @__PURE__ */ new Map();
    addUnsafePrefixes(_assertThisInitialized$Z(_this));
    return _this;
  }
  _createClass$1x(HotTable2, [{
    key: "hotInstance",
    get: (
      /**
       * Getter for the property storing the Handsontable instance.
       */
      function get2() {
        if (!this.__hotInstance || this.__hotInstance && !this.__hotInstance.isDestroyed) {
          return this.__hotInstance;
        } else {
          console.warn(HOT_DESTROYED_WARNING);
          return null;
        }
      }
    ),
    set: function set2(hotInstance) {
      this.__hotInstance = hotInstance;
    }
    /**
     * Get the rendered table cell cache.
     *
     * @returns {Map}
     */
  }, {
    key: "getRenderedCellCache",
    value: function getRenderedCellCache() {
      return this.renderedCellCache;
    }
    /**
     * Get the editor cache and return it.
     *
     * @returns {Map}
     */
  }, {
    key: "getEditorCache",
    value: function getEditorCache() {
      return this.editorCache;
    }
    /**
     * Get the global editor portal property.
     *
     * @return {React.ReactPortal} The global editor portal.
     */
  }, {
    key: "getGlobalEditorPortal",
    value: function getGlobalEditorPortal() {
      return this.globalEditorPortal;
    }
    /**
     * Set the private editor portal cache property.
     *
     * @param {React.ReactPortal} portal Global editor portal.
     */
  }, {
    key: "setGlobalEditorPortal",
    value: function setGlobalEditorPortal(portal) {
      this.globalEditorPortal = portal;
    }
    /**
     * Clear both the editor and the renderer cache.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      var renderedCellCache = this.getRenderedCellCache();
      this.setGlobalEditorPortal(null);
      removeEditorContainers(this.getOwnerDocument());
      this.getEditorCache().clear();
      renderedCellCache.clear();
      this.componentRendererColumns.clear();
    }
    /**
     * Get the `Document` object corresponding to the main component element.
     *
     * @returns The `Document` object used by the component.
     */
  }, {
    key: "getOwnerDocument",
    value: function getOwnerDocument() {
      return this.hotElementRef ? this.hotElementRef.ownerDocument : document;
    }
    /**
     * Set the reference to the main Handsontable DOM element.
     *
     * @param {HTMLElement} element The main Handsontable DOM element.
     */
  }, {
    key: "setHotElementRef",
    value: function setHotElementRef(element) {
      this.hotElementRef = element;
    }
    /**
     * Return a renderer wrapper function for the provided renderer component.
     *
     * @param {React.ReactElement} rendererElement React renderer component.
     * @returns {Handsontable.renderers.Base} The Handsontable rendering function.
     */
  }, {
    key: "getRendererWrapper",
    value: function getRendererWrapper(rendererElement) {
      var hotTableComponent = this;
      return function(instance, TD, row, col, prop, value, cellProperties) {
        var renderedCellCache = hotTableComponent.getRenderedCellCache();
        if (renderedCellCache.has("".concat(row, "-").concat(col))) {
          TD.innerHTML = renderedCellCache.get("".concat(row, "-").concat(col)).innerHTML;
        }
        if (TD && !TD.getAttribute("ghost-table")) {
          var _createPortal = createPortal(rendererElement, {
            TD,
            row,
            col,
            prop,
            value,
            cellProperties,
            isRenderer: true
          }, function() {
          }, TD.ownerDocument), portal = _createPortal.portal, portalContainer = _createPortal.portalContainer;
          while (TD.firstChild) {
            TD.removeChild(TD.firstChild);
          }
          TD.appendChild(portalContainer);
          hotTableComponent.portalCacheArray.push(portal);
        }
        renderedCellCache.set("".concat(row, "-").concat(col), TD);
        return TD;
      };
    }
    /**
     * Create a fresh class to be used as an editor, based on the provided editor React element.
     *
     * @param {React.ReactElement} editorElement React editor component.
     * @param {string|number} [editorColumnScope] The editor scope (column index or a 'global' string). Defaults to
     * 'global'.
     * @returns {Function} A class to be passed to the Handsontable editor settings.
     */
  }, {
    key: "getEditorClass",
    value: function getEditorClass(editorElement) {
      var _editorCache$get;
      var editorColumnScope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GLOBAL_EDITOR_SCOPE;
      var editorClass = getOriginalEditorClass(editorElement);
      var editorCache = this.getEditorCache();
      var cachedComponent = (_editorCache$get = editorCache.get(editorClass)) === null || _editorCache$get === void 0 ? void 0 : _editorCache$get.get(editorColumnScope);
      return this.makeEditorClass(cachedComponent);
    }
    /**
     * Create a class to be passed to the Handsontable's settings.
     *
     * @param {React.ReactElement} editorComponent React editor component.
     * @returns {Function} A class to be passed to the Handsontable editor settings.
     */
  }, {
    key: "makeEditorClass",
    value: function makeEditorClass(editorComponent) {
      var customEditorClass = /* @__PURE__ */ function(_Handsontable$editors) {
        _inherits$Z(CustomEditor, _Handsontable$editors);
        var _super2 = _createSuper$Z(CustomEditor);
        function CustomEditor(hotInstance) {
          var _this2;
          _classCallCheck$1x(this, CustomEditor);
          _this2 = _super2.call(this, hotInstance);
          editorComponent.hotCustomEditorInstance = _assertThisInitialized$Z(_this2);
          _this2.editorComponent = editorComponent;
          return _this2;
        }
        _createClass$1x(CustomEditor, [{
          key: "focus",
          value: function focus() {
          }
        }, {
          key: "getValue",
          value: function getValue() {
          }
        }, {
          key: "setValue",
          value: function setValue() {
          }
        }, {
          key: "open",
          value: function open() {
          }
        }, {
          key: "close",
          value: function close() {
          }
        }]);
        return CustomEditor;
      }(Handsontable.editors.BaseEditor);
      Object.getOwnPropertyNames(Handsontable.editors.BaseEditor.prototype).forEach(function(propName) {
        if (propName === "constructor") {
          return;
        }
        customEditorClass.prototype[propName] = function() {
          var _editorComponent$prop;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return (_editorComponent$prop = editorComponent[propName]).call.apply(_editorComponent$prop, [editorComponent].concat(args));
        };
      });
      return customEditorClass;
    }
    /**
     * Get the renderer element for the entire HotTable instance.
     *
     * @returns {React.ReactElement} React renderer component element.
     */
  }, {
    key: "getGlobalRendererElement",
    value: function getGlobalRendererElement() {
      var hotTableSlots = this.props.children;
      return getChildElementByType(hotTableSlots, "hot-renderer");
    }
    /**
     * Get the editor element for the entire HotTable instance.
     *
     * @param {React.ReactNode} [children] Children of the HotTable instance. Defaults to `this.props.children`.
     * @returns {React.ReactElement} React editor component element.
     */
  }, {
    key: "getGlobalEditorElement",
    value: function getGlobalEditorElement() {
      var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.children;
      return getExtendedEditorElement(children, this.getEditorCache());
    }
    /**
     * Create the global editor portal and its destination HTML element if needed.
     *
     * @param {React.ReactNode} [children] Children of the HotTable instance. Defaults to `this.props.children`.
     */
  }, {
    key: "createGlobalEditorPortal",
    value: function createGlobalEditorPortal() {
      var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.children;
      var globalEditorElement = this.getGlobalEditorElement(children);
      if (globalEditorElement) {
        this.setGlobalEditorPortal(createEditorPortal(this.getOwnerDocument(), globalEditorElement, this.getEditorCache()));
      }
    }
    /**
     * Create a new settings object containing the column settings and global editors and renderers.
     *
     * @returns {Handsontable.GridSettings} New global set of settings for Handsontable.
     */
  }, {
    key: "createNewGlobalSettings",
    value: function createNewGlobalSettings() {
      var newSettings = SettingsMapper.getSettings(this.props);
      var globalRendererNode = this.getGlobalRendererElement();
      var globalEditorNode = this.getGlobalEditorElement();
      newSettings.columns = this.columnSettings.length ? this.columnSettings : newSettings.columns;
      if (globalEditorNode) {
        newSettings.editor = this.getEditorClass(globalEditorNode, GLOBAL_EDITOR_SCOPE);
      } else {
        newSettings.editor = this.props.editor || (this.props.settings ? this.props.settings.editor : void 0);
      }
      if (globalRendererNode) {
        newSettings.renderer = this.getRendererWrapper(globalRendererNode);
        this.componentRendererColumns.set("global", true);
      } else {
        newSettings.renderer = this.props.renderer || (this.props.settings ? this.props.settings.renderer : void 0);
      }
      return newSettings;
    }
    /**
     * Detect if `autoRowSize` or `autoColumnSize` is defined, and if so, throw an incompatibility warning.
     *
     * @param {Handsontable.GridSettings} newGlobalSettings New global settings passed as Handsontable config.
     */
  }, {
    key: "displayAutoSizeWarning",
    value: function displayAutoSizeWarning(newGlobalSettings) {
      var _this$hotInstance$get, _this$hotInstance$get2;
      if (this.hotInstance && ((_this$hotInstance$get = this.hotInstance.getPlugin("autoRowSize")) !== null && _this$hotInstance$get !== void 0 && _this$hotInstance$get.enabled || (_this$hotInstance$get2 = this.hotInstance.getPlugin("autoColumnSize")) !== null && _this$hotInstance$get2 !== void 0 && _this$hotInstance$get2.enabled)) {
        if (this.componentRendererColumns.size > 0) {
          warn(AUTOSIZE_WARNING);
        }
      }
    }
    /**
     * Sets the column settings based on information received from HotColumn.
     *
     * @param {HotTableProps} columnSettings Column settings object.
     * @param {Number} columnIndex Column index.
     */
  }, {
    key: "setHotColumnSettings",
    value: function setHotColumnSettings(columnSettings, columnIndex) {
      this.columnSettings[columnIndex] = columnSettings;
    }
    /**
     * Handsontable's `beforeViewRender` hook callback.
     */
  }, {
    key: "handsontableBeforeViewRender",
    value: function handsontableBeforeViewRender() {
      this.getRenderedCellCache().clear();
    }
    /**
     * Handsontable's `afterViewRender` hook callback.
     */
  }, {
    key: "handsontableAfterViewRender",
    value: function handsontableAfterViewRender() {
      var _this3 = this;
      this.portalManager.setState(function() {
        return Object.assign({}, {
          portals: _this3.portalCacheArray
        });
      }, function() {
        _this3.portalCacheArray.length = 0;
      });
    }
    /**
     * Call the `updateSettings` method for the Handsontable instance.
     *
     * @param {Object} newSettings The settings object.
     */
  }, {
    key: "updateHot",
    value: function updateHot(newSettings) {
      if (this.hotInstance) {
        this.hotInstance.updateSettings(newSettings, false);
      }
    }
    /**
     * Set the portal manager ref.
     *
     * @param {React.ReactComponent} pmComponent The PortalManager component.
     */
  }, {
    key: "setPortalManagerRef",
    value: function setPortalManagerRef(pmComponent) {
      this.portalManager = pmComponent;
    }
    /*
    ---------------------------------------
    ------- React lifecycle methods -------
    ---------------------------------------
    */
    /**
     * Logic performed before the mounting of the component.
     */
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.clearCache();
      this.createGlobalEditorPortal();
    }
    /**
     * Initialize Handsontable after the component has mounted.
     */
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var hotTableComponent = this;
      var newGlobalSettings = this.createNewGlobalSettings();
      this.hotInstance = new Handsontable.Core(this.hotElementRef, newGlobalSettings);
      this.hotInstance.addHook("beforeViewRender", function(isForced2) {
        hotTableComponent.handsontableBeforeViewRender();
      });
      this.hotInstance.addHook("afterViewRender", function() {
        hotTableComponent.handsontableAfterViewRender();
      });
      this.hotInstance.init();
      this.displayAutoSizeWarning(newGlobalSettings);
    }
    /**
     * Logic performed before the component update.
     */
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState, nextContext) {
      this.clearCache();
      removeEditorContainers(this.getOwnerDocument());
      this.createGlobalEditorPortal(nextProps.children);
    }
    /**
     * Logic performed after the component update.
     */
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var newGlobalSettings = this.createNewGlobalSettings();
      this.updateHot(newGlobalSettings);
      this.displayAutoSizeWarning(newGlobalSettings);
    }
    /**
     * Destroy the Handsontable instance when the parent component unmounts.
     */
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.hotInstance) {
        this.hotInstance.destroy();
      }
      removeEditorContainers(this.getOwnerDocument());
    }
    /**
     * Render the component.
     */
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      var _getContainerAttribut = getContainerAttributesProps(this.props), id2 = _getContainerAttribut.id, className = _getContainerAttribut.className, style = _getContainerAttribut.style;
      var isHotColumn = function isHotColumn2(childNode) {
        return childNode.type === HotColumn;
      };
      var children = React.Children.toArray(this.props.children);
      children = children.filter(function(childNode) {
        return isHotColumn(childNode);
      });
      var childClones = children.map(function(childNode, columnIndex) {
        return React.cloneElement(childNode, {
          _componentRendererColumns: _this4.componentRendererColumns,
          _emitColumnSettings: _this4.setHotColumnSettings.bind(_this4),
          _columnIndex: columnIndex,
          _getChildElementByType: getChildElementByType.bind(_this4),
          _getRendererWrapper: _this4.getRendererWrapper.bind(_this4),
          _getEditorClass: _this4.getEditorClass.bind(_this4),
          _getOwnerDocument: _this4.getOwnerDocument.bind(_this4),
          _getEditorCache: _this4.getEditorCache.bind(_this4),
          children: childNode.props.children
        });
      });
      childClones.push(this.getGlobalEditorPortal());
      return React.createElement(React.Fragment, null, React.createElement("div", {
        ref: this.setHotElementRef.bind(this),
        id: id2,
        className,
        style
      }, childClones), React.createElement(PortalManager, {
        ref: this.setPortalManagerRef.bind(this)
      }));
    }
  }], [{
    key: "version",
    get: function get2() {
      return version;
    }
  }]);
  return HotTable2;
}(React.Component);
HotTable.propTypes = {
  style: PropTypes.object,
  id: PropTypes.string,
  className: PropTypes.string
};
/* @__PURE__ */ (function(_React$Component) {
  _inherits$Z(BaseEditorComponent, _React$Component);
  var _super = _createSuper$Z(BaseEditorComponent);
  function BaseEditorComponent(props) {
    var _this;
    _classCallCheck$1x(this, BaseEditorComponent);
    _this = _super.call(this, props);
    _this.name = "BaseEditorComponent";
    _this.instance = null;
    _this.row = null;
    _this.col = null;
    _this.prop = null;
    _this.TD = null;
    _this.originalValue = null;
    _this.cellProperties = null;
    _this.state = null;
    _this.hotInstance = null;
    _this.hotCustomEditorInstance = null;
    _this.hot = null;
    if (props.emitEditorInstance) {
      props.emitEditorInstance(_assertThisInitialized$Z(_this), props.editorColumnScope);
    }
    return _this;
  }
  _createClass$1x(BaseEditorComponent, [{
    key: "_fireCallbacks",
    value: function _fireCallbacks() {
      var _Handsontable$editors;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_Handsontable$editors = Handsontable.editors.BaseEditor.prototype._fireCallbacks).call.apply(_Handsontable$editors, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "beginEditing",
    value: function beginEditing() {
      var _Handsontable$editors2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return (_Handsontable$editors2 = Handsontable.editors.BaseEditor.prototype.beginEditing).call.apply(_Handsontable$editors2, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "cancelChanges",
    value: function cancelChanges() {
      var _Handsontable$editors3;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return (_Handsontable$editors3 = Handsontable.editors.BaseEditor.prototype.cancelChanges).call.apply(_Handsontable$editors3, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "checkEditorSection",
    value: function checkEditorSection() {
      var _Handsontable$editors4;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return (_Handsontable$editors4 = Handsontable.editors.BaseEditor.prototype.checkEditorSection).call.apply(_Handsontable$editors4, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "close",
    value: function close() {
      var _Handsontable$editors5;
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return (_Handsontable$editors5 = Handsontable.editors.BaseEditor.prototype.close).call.apply(_Handsontable$editors5, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "discardEditor",
    value: function discardEditor() {
      var _Handsontable$editors6;
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return (_Handsontable$editors6 = Handsontable.editors.BaseEditor.prototype.discardEditor).call.apply(_Handsontable$editors6, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "enableFullEditMode",
    value: function enableFullEditMode() {
      var _Handsontable$editors7;
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return (_Handsontable$editors7 = Handsontable.editors.BaseEditor.prototype.enableFullEditMode).call.apply(_Handsontable$editors7, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "extend",
    value: function extend2() {
      var _Handsontable$editors8;
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return (_Handsontable$editors8 = Handsontable.editors.BaseEditor.prototype.extend).call.apply(_Handsontable$editors8, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "finishEditing",
    value: function finishEditing() {
      var _Handsontable$editors9;
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return (_Handsontable$editors9 = Handsontable.editors.BaseEditor.prototype.finishEditing).call.apply(_Handsontable$editors9, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "focus",
    value: function focus() {
      var _Handsontable$editors10;
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return (_Handsontable$editors10 = Handsontable.editors.BaseEditor.prototype.focus).call.apply(_Handsontable$editors10, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "getValue",
    value: function getValue() {
      var _Handsontable$editors11;
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return (_Handsontable$editors11 = Handsontable.editors.BaseEditor.prototype.getValue).call.apply(_Handsontable$editors11, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "init",
    value: function init() {
      var _Handsontable$editors12;
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return (_Handsontable$editors12 = Handsontable.editors.BaseEditor.prototype.init).call.apply(_Handsontable$editors12, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "isInFullEditMode",
    value: function isInFullEditMode() {
      var _Handsontable$editors13;
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return (_Handsontable$editors13 = Handsontable.editors.BaseEditor.prototype.isInFullEditMode).call.apply(_Handsontable$editors13, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "isOpened",
    value: function isOpened() {
      var _Handsontable$editors14;
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return (_Handsontable$editors14 = Handsontable.editors.BaseEditor.prototype.isOpened).call.apply(_Handsontable$editors14, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "isWaiting",
    value: function isWaiting() {
      var _Handsontable$editors15;
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return (_Handsontable$editors15 = Handsontable.editors.BaseEditor.prototype.isWaiting).call.apply(_Handsontable$editors15, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "open",
    value: function open() {
      var _Handsontable$editors16;
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return (_Handsontable$editors16 = Handsontable.editors.BaseEditor.prototype.open).call.apply(_Handsontable$editors16, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, TD, originalValue, cellProperties) {
      this.hotInstance = cellProperties.instance;
      this.row = row;
      this.col = col;
      this.prop = prop;
      this.TD = TD;
      this.originalValue = originalValue;
      this.cellProperties = cellProperties;
      return Handsontable.editors.BaseEditor.prototype.prepare.call(this.hotCustomEditorInstance, row, col, prop, TD, originalValue, cellProperties);
    }
  }, {
    key: "saveValue",
    value: function saveValue() {
      var _Handsontable$editors17;
      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
        args[_key17] = arguments[_key17];
      }
      return (_Handsontable$editors17 = Handsontable.editors.BaseEditor.prototype.saveValue).call.apply(_Handsontable$editors17, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "setValue",
    value: function setValue() {
      var _Handsontable$editors18;
      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        args[_key18] = arguments[_key18];
      }
      return (_Handsontable$editors18 = Handsontable.editors.BaseEditor.prototype.setValue).call.apply(_Handsontable$editors18, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "addHook",
    value: function addHook2() {
      var _Handsontable$editors19;
      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        args[_key19] = arguments[_key19];
      }
      return (_Handsontable$editors19 = Handsontable.editors.BaseEditor.prototype.addHook).call.apply(_Handsontable$editors19, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "removeHooksByKey",
    value: function removeHooksByKey2() {
      var _Handsontable$editors20;
      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        args[_key20] = arguments[_key20];
      }
      return (_Handsontable$editors20 = Handsontable.editors.BaseEditor.prototype.removeHooksByKey).call.apply(_Handsontable$editors20, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "clearHooks",
    value: function clearHooks2() {
      var _Handsontable$editors21;
      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
        args[_key21] = arguments[_key21];
      }
      return (_Handsontable$editors21 = Handsontable.editors.BaseEditor.prototype.clearHooks).call.apply(_Handsontable$editors21, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "getEditedCell",
    value: function getEditedCell() {
      var _Handsontable$editors22;
      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }
      return (_Handsontable$editors22 = Handsontable.editors.BaseEditor.prototype.getEditedCell).call.apply(_Handsontable$editors22, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "getEditedCellRect",
    value: function getEditedCellRect() {
      var _Handsontable$editors23;
      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
        args[_key23] = arguments[_key23];
      }
      return (_Handsontable$editors23 = Handsontable.editors.BaseEditor.prototype.getEditedCellRect).call.apply(_Handsontable$editors23, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "getEditedCellsZIndex",
    value: function getEditedCellsZIndex() {
      var _Handsontable$editors24;
      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
        args[_key24] = arguments[_key24];
      }
      return (_Handsontable$editors24 = Handsontable.editors.BaseEditor.prototype.getEditedCellsZIndex).call.apply(_Handsontable$editors24, [this.hotCustomEditorInstance].concat(args));
    }
  }]);
  return BaseEditorComponent;
})(React.Component);
const handsontable_full = "";
function _typeof$_(obj) {
  "@babel/helpers - typeof";
  return _typeof$_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$_(obj);
}
function _classCallCheck$1w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1w(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$O() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$O = Reflect.get.bind();
  } else {
    _get$O = function _get2(target, property, receiver) {
      var base = _superPropBase$O(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$O.apply(this, arguments);
}
function _superPropBase$O(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$Y(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$Y(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$Y(subClass, superClass);
}
function _setPrototypeOf$Y(o, p2) {
  _setPrototypeOf$Y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$Y(o, p2);
}
function _createSuper$Y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$Y(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$Y(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$Y(this, result);
  };
}
function _possibleConstructorReturn$Y(self2, call2) {
  if (call2 && (_typeof$_(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$Y(self2);
}
function _assertThisInitialized$Y(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$Y() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$Y(o) {
  _getPrototypeOf$Y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$Y(o);
}
var SHORTCUTS_GROUP$5 = "handsontableEditor";
var EDITOR_TYPE$8 = "handsontable";
var HandsontableEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$Y(HandsontableEditor2, _TextEditor);
  var _super = _createSuper$Y(HandsontableEditor2);
  function HandsontableEditor2() {
    _classCallCheck$1w(this, HandsontableEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1w(HandsontableEditor2, [{
    key: "open",
    value: (
      /**
       * Opens the editor and adjust its size.
       */
      function open() {
        _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "open", this).call(this);
        if (this.htEditor) {
          this.htEditor.destroy();
        }
        if (this.htContainer.style.display === "none") {
          this.htContainer.style.display = "";
        }
        this.htEditor = new this.hot.constructor(this.htContainer, this.htOptions);
        this.htEditor.init();
        this.htEditor.rootElement.style.display = "";
        if (this.cellProperties.strict) {
          this.htEditor.selectCell(0, 0);
        } else {
          this.htEditor.deselectCell();
        }
        setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);
        this.refreshDimensions();
      }
    )
    /**
     * Closes the editor.
     */
  }, {
    key: "close",
    value: function close() {
      if (this.htEditor) {
        this.htEditor.rootElement.style.display = "none";
      }
      this.removeHooksByKey("beforeKeyDown");
      _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "close", this).call(this);
    }
    /**
     * Prepares editor's meta data and configuration of the internal Handsontable's instance.
     *
     * @param {number} row The visual row index.
     * @param {number} col The visual column index.
     * @param {number|string} prop The column property (passed when datasource is an array of objects).
     * @param {HTMLTableCellElement} td The rendered cell element.
     * @param {*} value The rendered value.
     * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
     */
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
      var parent = this;
      var options = {
        startRows: 0,
        startCols: 0,
        minRows: 0,
        minCols: 0,
        className: "listbox",
        copyPaste: false,
        autoColumnSize: false,
        autoRowSize: false,
        readOnly: true,
        fillHandle: false,
        autoWrapCol: false,
        autoWrapRow: false,
        afterOnCellMouseDown: function afterOnCellMouseDown(_, coords) {
          var sourceValue = this.getSourceData(coords.row, coords.col);
          if (sourceValue !== void 0) {
            parent.setValue(sourceValue);
          }
          parent.instance.destroyEditor();
        },
        preventWheel: true,
        layoutDirection: this.hot.isRtl() ? "rtl" : "ltr"
      };
      if (this.cellProperties.handsontable) {
        extend(options, cellProperties.handsontable);
      }
      this.htOptions = options;
    }
    /**
     * Begins editing on a highlighted cell and hides fillHandle corner if was present.
     *
     * @param {*} newInitialValue The editor initial value.
     * @param {*} event The keyboard event object.
     */
  }, {
    key: "beginEditing",
    value: function beginEditing(newInitialValue, event2) {
      var onBeginEditing = this.hot.getSettings().onBeginEditing;
      if (onBeginEditing && onBeginEditing() === false) {
        return;
      }
      _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "beginEditing", this).call(this, newInitialValue, event2);
    }
    /**
     * Creates an editor's elements and adds necessary CSS classnames.
     */
  }, {
    key: "createElements",
    value: function createElements() {
      _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "createElements", this).call(this);
      var DIV = this.hot.rootDocument.createElement("DIV");
      DIV.className = "handsontableEditor";
      this.TEXTAREA_PARENT.appendChild(DIV);
      this.htContainer = DIV;
      this.assignHooks();
    }
    /**
     * Finishes editing and start saving or restoring process for editing cell or last selected range.
     *
     * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
     * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
     * @param {Function} callback The callback function, fired after editor closing.
     */
  }, {
    key: "finishEditing",
    value: function finishEditing(restoreOriginalValue, ctrlDown, callback) {
      if (this.htEditor && this.htEditor.isListening()) {
        this.hot.listen();
      }
      if (this.htEditor && this.htEditor.getSelectedLast()) {
        var value = this.htEditor.getInstance().getValue();
        if (value !== void 0) {
          this.setValue(value);
        }
      }
      _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "finishEditing", this).call(this, restoreOriginalValue, ctrlDown, callback);
    }
    /**
     * Assings afterDestroy callback to prevent memory leaks.
     *
     * @private
     */
  }, {
    key: "assignHooks",
    value: function assignHooks() {
      var _this = this;
      this.hot.addHook("afterDestroy", function() {
        if (_this.htEditor) {
          _this.htEditor.destroy();
        }
      });
    }
    /**
     * Register shortcuts responsible for handling editor.
     *
     * @private
     */
  }, {
    key: "registerShortcuts",
    value: function registerShortcuts() {
      var _this2 = this;
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "registerShortcuts", this).call(this);
      var contextConfig = {
        group: SHORTCUTS_GROUP$5,
        relativeToGroup: SHORTCUTS_GROUP_NAVIGATION,
        position: "before"
      };
      var action = function action2(rowToSelect, event2) {
        var innerHOT = _this2.htEditor.getInstance();
        if (rowToSelect !== void 0) {
          if (rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1) {
            innerHOT.deselectCell();
          } else {
            innerHOT.selectCell(rowToSelect, 0);
          }
          if (innerHOT.getData().length) {
            event2.preventDefault();
            stopImmediatePropagation(event2);
            _this2.hot.listen();
            _this2.TEXTAREA.focus();
            return false;
          }
        }
      };
      editorContext.addShortcuts([{
        keys: [["ArrowUp"]],
        callback: function callback(event2) {
          var innerHOT = _this2.htEditor.getInstance();
          var rowToSelect;
          var selectedRow;
          if (!innerHOT.getSelectedLast() && innerHOT.flipped) {
            rowToSelect = innerHOT.countRows() - 1;
          } else if (innerHOT.getSelectedLast()) {
            if (innerHOT.flipped) {
              selectedRow = innerHOT.getSelectedLast()[0];
              rowToSelect = Math.max(0, selectedRow - 1);
            } else {
              selectedRow = innerHOT.getSelectedLast()[0];
              rowToSelect = selectedRow - 1;
            }
          }
          return action(rowToSelect, event2);
        },
        preventDefault: false
        // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.
      }, {
        keys: [["ArrowDown"]],
        callback: function callback(event2) {
          var innerHOT = _this2.htEditor.getInstance();
          var rowToSelect;
          var selectedRow;
          if (!innerHOT.getSelectedLast() && !innerHOT.flipped) {
            rowToSelect = 0;
          } else if (innerHOT.getSelectedLast()) {
            if (innerHOT.flipped) {
              rowToSelect = innerHOT.getSelectedLast()[0] + 1;
            } else if (!innerHOT.flipped) {
              var lastRow = innerHOT.countRows() - 1;
              selectedRow = innerHOT.getSelectedLast()[0];
              rowToSelect = Math.min(lastRow, selectedRow + 1);
            }
          }
          return action(rowToSelect, event2);
        },
        preventDefault: false
        // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.
      }], contextConfig);
    }
    /**
     * Unregister shortcuts responsible for handling editor.
     *
     * @private
     */
  }, {
    key: "unregisterShortcuts",
    value: function unregisterShortcuts() {
      _get$O(_getPrototypeOf$Y(HandsontableEditor2.prototype), "unregisterShortcuts", this).call(this);
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP$5);
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$8;
    }
  }]);
  return HandsontableEditor2;
}(TextEditor);
function _typeof$Z(obj) {
  "@babel/helpers - typeof";
  return _typeof$Z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$Z(obj);
}
function _classCallCheck$1v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1v(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$N() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$N = Reflect.get.bind();
  } else {
    _get$N = function _get2(target, property, receiver) {
      var base = _superPropBase$N(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$N.apply(this, arguments);
}
function _superPropBase$N(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$X(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$X(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$X(subClass, superClass);
}
function _setPrototypeOf$X(o, p2) {
  _setPrototypeOf$X = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$X(o, p2);
}
function _createSuper$X(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$X();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$X(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$X(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$X(this, result);
  };
}
function _possibleConstructorReturn$X(self2, call2) {
  if (call2 && (_typeof$Z(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$X(self2);
}
function _assertThisInitialized$X(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$X() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$X(o) {
  _getPrototypeOf$X = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$X(o);
}
function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var privatePool$h = /* @__PURE__ */ new WeakMap();
var EDITOR_TYPE$7 = "autocomplete";
var AutocompleteEditor = /* @__PURE__ */ function(_HandsontableEditor) {
  _inherits$X(AutocompleteEditor2, _HandsontableEditor);
  var _super = _createSuper$X(AutocompleteEditor2);
  function AutocompleteEditor2(instance) {
    var _this;
    _classCallCheck$1v(this, AutocompleteEditor2);
    _this = _super.call(this, instance);
    _defineProperty$i(_assertThisInitialized$X(_this), "sortByRelevance", function(value, choices, caseSensitive) {
      var choicesRelevance = [];
      var result = [];
      var valueLength = value.length;
      var choicesCount = choices.length;
      var charsLeft;
      var currentItem;
      var i;
      var valueIndex;
      if (valueLength === 0) {
        for (i = 0; i < choicesCount; i++) {
          result.push(i);
        }
        return result;
      }
      for (i = 0; i < choicesCount; i++) {
        currentItem = stripTags(stringify$1(choices[i]));
        if (caseSensitive) {
          valueIndex = currentItem.indexOf(value);
        } else {
          var locale = this.cellProperties.locale;
          valueIndex = currentItem.toLocaleLowerCase(locale).indexOf(value.toLocaleLowerCase(locale));
        }
        if (valueIndex !== -1) {
          charsLeft = currentItem.length - valueIndex - valueLength;
          choicesRelevance.push({
            baseIndex: i,
            index: valueIndex,
            charsLeft,
            value: currentItem
          });
        }
      }
      choicesRelevance.sort(function(a, b2) {
        if (b2.index === -1) {
          return -1;
        }
        if (a.index === -1) {
          return 1;
        }
        if (a.index < b2.index) {
          return -1;
        } else if (b2.index < a.index) {
          return 1;
        } else if (a.index === b2.index) {
          if (a.charsLeft < b2.charsLeft) {
            return -1;
          } else if (a.charsLeft > b2.charsLeft) {
            return 1;
          }
        }
        return 0;
      });
      for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
        result.push(choicesRelevance[i].baseIndex);
      }
      return result;
    });
    _this.query = null;
    _this.strippedChoices = [];
    _this.rawChoices = [];
    privatePool$h.set(_assertThisInitialized$X(_this), {
      skipOne: false,
      isMacOS: _this.hot.rootWindow.navigator.platform.indexOf("Mac") > -1
    });
    return _this;
  }
  _createClass$1v(AutocompleteEditor2, [{
    key: "getValue",
    value: function getValue() {
      var _this2 = this;
      var selectedValue = this.rawChoices.find(function(value) {
        var strippedValue = _this2.stripValueIfNeeded(value);
        return strippedValue === _this2.TEXTAREA.value;
      });
      if (isDefined(selectedValue)) {
        return selectedValue;
      }
      return this.TEXTAREA.value;
    }
    /**
     * Creates an editor's elements and adds necessary CSS classnames.
     */
  }, {
    key: "createElements",
    value: function createElements() {
      _get$N(_getPrototypeOf$X(AutocompleteEditor2.prototype), "createElements", this).call(this);
      addClass(this.htContainer, "autocompleteEditor");
      addClass(this.htContainer, this.hot.rootWindow.navigator.platform.indexOf("Mac") === -1 ? "" : "htMacScroll");
    }
    /**
     * Opens the editor and adjust its size and internal Handsontable's instance.
     */
  }, {
    key: "open",
    value: function open() {
      var _this3 = this;
      var priv = privatePool$h.get(this);
      _get$N(_getPrototypeOf$X(AutocompleteEditor2.prototype), "open", this).call(this);
      var choicesListHot = this.htEditor.getInstance();
      var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
      this.showEditableElement();
      this.focus();
      var scrollbarWidth = getScrollbarWidth();
      if (scrollbarWidth === 0 && priv.isMacOS) {
        scrollbarWidth += 15;
      }
      this.addHook("beforeKeyDown", function(event2) {
        return _this3.onBeforeKeyDown(event2);
      });
      choicesListHot.updateSettings({
        colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,
        width: trimDropdown ? outerWidth(this.TEXTAREA) + scrollbarWidth : void 0,
        renderer: function renderer(instance, TD, row, col, prop, value, cellProperties) {
          textRenderer(instance, TD, row, col, prop, value, cellProperties);
          var _this3$cellProperties = _this3.cellProperties, filteringCaseSensitive = _this3$cellProperties.filteringCaseSensitive, allowHtml = _this3$cellProperties.allowHtml, locale = _this3$cellProperties.locale;
          var query = _this3.query;
          var cellValue = stringify$1(value);
          var indexOfMatch;
          var match2;
          if (cellValue && !allowHtml) {
            indexOfMatch = filteringCaseSensitive === true ? cellValue.indexOf(query) : cellValue.toLocaleLowerCase(locale).indexOf(query.toLocaleLowerCase(locale));
            if (indexOfMatch !== -1) {
              match2 = cellValue.substr(indexOfMatch, query.length);
              cellValue = cellValue.replace(match2, "<strong>".concat(match2, "</strong>"));
            }
          }
          TD.innerHTML = cellValue;
        },
        autoColumnSize: true
      });
      if (priv.skipOne) {
        priv.skipOne = false;
      }
      this.hot._registerTimeout(function() {
        _this3.queryChoices(_this3.TEXTAREA.value);
      });
    }
    /**
     * Closes the editor.
     */
  }, {
    key: "close",
    value: function close() {
      this.removeHooksByKey("beforeKeyDown");
      _get$N(_getPrototypeOf$X(AutocompleteEditor2.prototype), "close", this).call(this);
    }
    /**
     * Verifies result of validation or closes editor if user's cancelled changes.
     *
     * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,
     *                                   then an editor won't be closed until validation is passed.
     */
  }, {
    key: "discardEditor",
    value: function discardEditor(result) {
      _get$N(_getPrototypeOf$X(AutocompleteEditor2.prototype), "discardEditor", this).call(this, result);
      this.hot.view.render();
    }
    /**
     * Prepares choices list based on applied argument.
     *
     * @private
     * @param {string} query The query.
     */
  }, {
    key: "queryChoices",
    value: function queryChoices(query) {
      var _this4 = this;
      var source = this.cellProperties.source;
      this.query = query;
      if (typeof source === "function") {
        source.call(this.cellProperties, query, function(choices) {
          _this4.rawChoices = choices;
          _this4.updateChoicesList(_this4.stripValuesIfNeeded(choices));
        });
      } else if (Array.isArray(source)) {
        this.rawChoices = source;
        this.updateChoicesList(this.stripValuesIfNeeded(source));
      } else {
        this.updateChoicesList([]);
      }
    }
    /**
     * Updates list of the possible completions to choose.
     *
     * @private
     * @param {Array} choicesList The choices list to process.
     */
  }, {
    key: "updateChoicesList",
    value: function updateChoicesList(choicesList) {
      var pos = getCaretPosition(this.TEXTAREA);
      var endPos = getSelectionEndPosition(this.TEXTAREA);
      var sortByRelevanceSetting = this.cellProperties.sortByRelevance;
      var filterSetting = this.cellProperties.filter;
      var orderByRelevance = null;
      var highlightIndex = null;
      var choices = choicesList;
      if (sortByRelevanceSetting) {
        orderByRelevance = this.sortByRelevance(this.stripValueIfNeeded(this.getValue()), choices, this.cellProperties.filteringCaseSensitive);
      }
      var orderByRelevanceLength = Array.isArray(orderByRelevance) ? orderByRelevance.length : 0;
      if (filterSetting === false) {
        if (orderByRelevanceLength) {
          highlightIndex = orderByRelevance[0];
        }
      } else {
        var sorted = [];
        for (var i = 0, choicesCount = choices.length; i < choicesCount; i++) {
          if (sortByRelevanceSetting && orderByRelevanceLength <= i) {
            break;
          }
          if (orderByRelevanceLength) {
            sorted.push(choices[orderByRelevance[i]]);
          } else {
            sorted.push(choices[i]);
          }
        }
        highlightIndex = 0;
        choices = sorted;
      }
      this.strippedChoices = choices;
      this.htEditor.loadData(pivot([choices]));
      this.updateDropdownHeight();
      this.flipDropdownIfNeeded();
      if (this.cellProperties.strict === true) {
        this.highlightBestMatchingChoice(highlightIndex);
      }
      this.hot.listen();
      setCaretPosition(this.TEXTAREA, pos, pos === endPos ? void 0 : endPos);
    }
    /**
     * Checks where is enough place to open editor.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "flipDropdownIfNeeded",
    value: function flipDropdownIfNeeded() {
      var trimmingContainer = getTrimmingContainer(this.hot.view._wt.wtTable.TABLE);
      var isWindowAsScrollableElement = trimmingContainer === this.hot.rootWindow;
      var preventOverflow = this.cellProperties.preventOverflow;
      if (isWindowAsScrollableElement || !isWindowAsScrollableElement && (preventOverflow || preventOverflow === "horizontal")) {
        return false;
      }
      var textareaOffset = offset(this.TEXTAREA);
      var textareaHeight = outerHeight(this.TEXTAREA);
      var dropdownHeight = this.getDropdownHeight();
      var trimmingContainerScrollTop = trimmingContainer.scrollTop;
      var headersHeight = outerHeight(this.hot.view._wt.wtTable.THEAD);
      var containerOffset = offset(trimmingContainer);
      var spaceAbove = textareaOffset.top - containerOffset.top - headersHeight + trimmingContainerScrollTop;
      var spaceBelow = trimmingContainer.scrollHeight - spaceAbove - headersHeight - textareaHeight;
      var flipNeeded = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
      if (flipNeeded) {
        this.flipDropdown(dropdownHeight);
      } else {
        this.unflipDropdown();
      }
      this.limitDropdownIfNeeded(flipNeeded ? spaceAbove : spaceBelow, dropdownHeight);
      return flipNeeded;
    }
    /**
     * Checks if the internal table should generate scrollbar or could be rendered without it.
     *
     * @private
     * @param {number} spaceAvailable The free space as height defined in px available for dropdown list.
     * @param {number} dropdownHeight The dropdown height.
     */
  }, {
    key: "limitDropdownIfNeeded",
    value: function limitDropdownIfNeeded(spaceAvailable, dropdownHeight) {
      if (dropdownHeight > spaceAvailable) {
        var tempHeight = 0;
        var i = 0;
        var lastRowHeight = 0;
        var height = null;
        do {
          lastRowHeight = this.htEditor.getRowHeight(i) || this.htEditor.view._wt.getSetting("defaultRowHeight");
          tempHeight += lastRowHeight;
          i += 1;
        } while (tempHeight < spaceAvailable);
        height = tempHeight - lastRowHeight;
        if (this.htEditor.flipped) {
          this.htEditor.rootElement.style.top = "".concat(parseInt(this.htEditor.rootElement.style.top, 10) + dropdownHeight - height, "px");
        }
        this.setDropdownHeight(tempHeight - lastRowHeight);
      }
    }
    /**
     * Configures editor to open it at the top.
     *
     * @private
     * @param {number} dropdownHeight The dropdown height.
     */
  }, {
    key: "flipDropdown",
    value: function flipDropdown(dropdownHeight) {
      var dropdownStyle = this.htEditor.rootElement.style;
      dropdownStyle.position = "absolute";
      dropdownStyle.top = "".concat(-dropdownHeight, "px");
      this.htEditor.flipped = true;
    }
    /**
     * Configures editor to open it at the bottom.
     *
     * @private
     */
  }, {
    key: "unflipDropdown",
    value: function unflipDropdown() {
      var dropdownStyle = this.htEditor.rootElement.style;
      dropdownStyle.position = "absolute";
      dropdownStyle.top = "";
      this.htEditor.flipped = void 0;
    }
    /**
     * Updates width and height of the internal Handsontable's instance.
     *
     * @private
     */
  }, {
    key: "updateDropdownHeight",
    value: function updateDropdownHeight() {
      var currentDropdownWidth = this.htEditor.getColWidth(0) + getScrollbarWidth(this.hot.rootDocument) + 2;
      var trimDropdown = this.cellProperties.trimDropdown;
      this.htEditor.updateSettings({
        height: this.getDropdownHeight(),
        width: trimDropdown ? void 0 : currentDropdownWidth
      });
      this.htEditor.view._wt.wtTable.alignOverlaysWithTrimmingContainer();
    }
    /**
     * Sets new height of the internal Handsontable's instance.
     *
     * @private
     * @param {number} height The new dropdown height.
     */
  }, {
    key: "setDropdownHeight",
    value: function setDropdownHeight(height) {
      this.htEditor.updateSettings({
        height
      });
    }
    /**
     * Creates new selection on specified row index, or deselects selected cells.
     *
     * @private
     * @param {number|undefined} index The visual row index.
     */
  }, {
    key: "highlightBestMatchingChoice",
    value: function highlightBestMatchingChoice(index2) {
      if (typeof index2 === "number") {
        this.htEditor.selectCell(index2, 0, void 0, void 0, void 0, false);
      } else {
        this.htEditor.deselectCell();
      }
    }
    /**
     * Calculates and return the internal Handsontable's height.
     *
     * @private
     * @returns {number}
     */
  }, {
    key: "getDropdownHeight",
    value: function getDropdownHeight() {
      var firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;
      var visibleRows = this.cellProperties.visibleRows;
      return this.strippedChoices.length >= visibleRows ? visibleRows * firstRowHeight : this.strippedChoices.length * firstRowHeight + 8;
    }
    /**
     * Sanitizes value from potential dangerous tags.
     *
     * @private
     * @param {string} value The value to sanitize.
     * @returns {string}
     */
  }, {
    key: "stripValueIfNeeded",
    value: function stripValueIfNeeded(value) {
      return this.stripValuesIfNeeded([value])[0];
    }
    /**
     * Sanitizes an array of the values from potential dangerous tags.
     *
     * @private
     * @param {string[]} values The value to sanitize.
     * @returns {string[]}
     */
  }, {
    key: "stripValuesIfNeeded",
    value: function stripValuesIfNeeded(values3) {
      var allowHtml = this.cellProperties.allowHtml;
      var stringifiedValues = arrayMap(values3, function(value) {
        return stringify$1(value);
      });
      var strippedValues = arrayMap(stringifiedValues, function(value) {
        return allowHtml ? value : stripTags(value);
      });
      return strippedValues;
    }
    /**
     * Captures use of arrow down and up to control their behaviour.
     *
     * @private
     * @param {number} keyCode The keyboard keycode.
     * @returns {boolean}
     */
  }, {
    key: "allowKeyEventPropagation",
    value: function allowKeyEventPropagation(keyCode) {
      var selectedRange = this.htEditor.getSelectedRangeLast();
      var selected = {
        row: selectedRange ? selectedRange.from.row : -1
      };
      var allowed = false;
      if (keyCode === KEY_CODES.ARROW_DOWN && selected.row > 0 && selected.row < this.htEditor.countRows() - 1) {
        allowed = true;
      }
      if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {
        allowed = true;
      }
      return allowed;
    }
    /**
     * OnBeforeKeyDown callback.
     *
     * @private
     * @param {KeyboardEvent} event The keyboard event object.
     */
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown(event2) {
      var _this5 = this;
      var priv = privatePool$h.get(this);
      priv.skipOne = false;
      if (isPrintableChar(event2.keyCode) || event2.keyCode === KEY_CODES.BACKSPACE || event2.keyCode === KEY_CODES.DELETE || event2.keyCode === KEY_CODES.INSERT) {
        var timeOffset = 10;
        if (event2.keyCode === KEY_CODES.C && (event2.ctrlKey || event2.metaKey)) {
          return;
        }
        if (!this.isOpened()) {
          timeOffset += 10;
        }
        if (this.htEditor) {
          this.hot._registerTimeout(function() {
            _this5.queryChoices(_this5.TEXTAREA.value);
            priv.skipOne = true;
          }, timeOffset);
        }
      }
    }
    /**
     * Filters and sorts by relevance.
     *
     * @param {*} value The selected value.
     * @param {string[]} choices The list of available choices.
     * @param {boolean} caseSensitive Indicates if it's sorted by case.
     * @returns {number[]} Array of indexes in original choices array.
     */
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$7;
    }
  }]);
  return AutocompleteEditor2;
}(HandsontableEditor);
function _typeof$Y(obj) {
  "@babel/helpers - typeof";
  return _typeof$Y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$Y(obj);
}
function _classCallCheck$1u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1u(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$W(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$W(subClass, superClass);
}
function _setPrototypeOf$W(o, p2) {
  _setPrototypeOf$W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$W(o, p2);
}
function _createSuper$W(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$W();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$W(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$W(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$W(this, result);
  };
}
function _possibleConstructorReturn$W(self2, call2) {
  if (call2 && (_typeof$Y(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$W(self2);
}
function _assertThisInitialized$W(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$W() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$W(o) {
  _getPrototypeOf$W = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$W(o);
}
var EDITOR_TYPE$6 = "checkbox";
var CheckboxEditor = /* @__PURE__ */ function(_BaseEditor) {
  _inherits$W(CheckboxEditor2, _BaseEditor);
  var _super = _createSuper$W(CheckboxEditor2);
  function CheckboxEditor2() {
    _classCallCheck$1u(this, CheckboxEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1u(CheckboxEditor2, [{
    key: "beginEditing",
    value: function beginEditing(initialValue, event2) {
      if (event2 && event2.type === "mouseup") {
        var checkbox = this.TD.querySelector('input[type="checkbox"]');
        if (!hasClass(checkbox, "htBadValue")) {
          checkbox.click();
        }
      }
    }
  }, {
    key: "finishEditing",
    value: function finishEditing() {
    }
  }, {
    key: "init",
    value: function init() {
    }
  }, {
    key: "open",
    value: function open() {
    }
  }, {
    key: "close",
    value: function close() {
    }
  }, {
    key: "getValue",
    value: function getValue() {
    }
  }, {
    key: "setValue",
    value: function setValue() {
    }
  }, {
    key: "focus",
    value: function focus() {
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$6;
    }
  }]);
  return CheckboxEditor2;
}(BaseEditor);
var pikadayExports = {};
var pikaday = {
  get exports() {
    return pikadayExports;
  },
  set exports(v2) {
    pikadayExports = v2;
  }
};
/*!
 * Pikaday
 *
 * Copyright Â© 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
 */
(function(module, exports) {
  (function(root, factory) {
    var moment;
    {
      try {
        moment = require$$0;
      } catch (e2) {
      }
      module.exports = factory(moment);
    }
  })(commonjsGlobal, function(moment) {
    var hasMoment = typeof moment === "function", hasEventListeners = !!window.addEventListener, document2 = window.document, sto = window.setTimeout, addEvent = function(el, e2, callback, capture) {
      if (hasEventListeners) {
        el.addEventListener(e2, callback, !!capture);
      } else {
        el.attachEvent("on" + e2, callback);
      }
    }, removeEvent = function(el, e2, callback, capture) {
      if (hasEventListeners) {
        el.removeEventListener(e2, callback, !!capture);
      } else {
        el.detachEvent("on" + e2, callback);
      }
    }, trim3 = function(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }, hasClass2 = function(el, cn) {
      return (" " + el.className + " ").indexOf(" " + cn + " ") !== -1;
    }, addClass2 = function(el, cn) {
      if (!hasClass2(el, cn)) {
        el.className = el.className === "" ? cn : el.className + " " + cn;
      }
    }, removeClass2 = function(el, cn) {
      el.className = trim3((" " + el.className + " ").replace(" " + cn + " ", " "));
    }, isArray3 = function(obj) {
      return /Array/.test(Object.prototype.toString.call(obj));
    }, isDate = function(obj) {
      return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    }, isWeekend = function(date) {
      var day = date.getDay();
      return day === 0 || day === 6;
    }, isLeapYear = function(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }, getDaysInMonth = function(year, month) {
      return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    }, setToStartOfDay = function(date) {
      if (isDate(date))
        date.setHours(0, 0, 0, 0);
    }, compareDates = function(a, b2) {
      return a.getTime() === b2.getTime();
    }, extend2 = function(to, from3, overwrite) {
      var prop, hasProp;
      for (prop in from3) {
        hasProp = to[prop] !== void 0;
        if (hasProp && typeof from3[prop] === "object" && from3[prop] !== null && from3[prop].nodeName === void 0) {
          if (isDate(from3[prop])) {
            if (overwrite) {
              to[prop] = new Date(from3[prop].getTime());
            }
          } else if (isArray3(from3[prop])) {
            if (overwrite) {
              to[prop] = from3[prop].slice(0);
            }
          } else {
            to[prop] = extend2({}, from3[prop], overwrite);
          }
        } else if (overwrite || !hasProp) {
          to[prop] = from3[prop];
        }
      }
      return to;
    }, fireEvent = function(el, eventName, data2) {
      var ev;
      if (document2.createEvent) {
        ev = document2.createEvent("HTMLEvents");
        ev.initEvent(eventName, true, false);
        ev = extend2(ev, data2);
        el.dispatchEvent(ev);
      } else if (document2.createEventObject) {
        ev = document2.createEventObject();
        ev = extend2(ev, data2);
        el.fireEvent("on" + eventName, ev);
      }
    }, adjustCalendar = function(calendar) {
      if (calendar.month < 0) {
        calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
        calendar.month += 12;
      }
      if (calendar.month > 11) {
        calendar.year += Math.floor(Math.abs(calendar.month) / 12);
        calendar.month -= 12;
      }
      return calendar;
    }, defaults = {
      // bind the picker to a form field
      field: null,
      // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
      bound: void 0,
      // data-attribute on the input field with an aria assistance text (only applied when `bound` is set)
      ariaLabel: "Use the arrow keys to pick a date",
      // position of the datepicker, relative to the field (default to bottom & left)
      // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
      position: "bottom left",
      // automatically fit in the viewport even if it means repositioning from the position option
      reposition: true,
      // the default output format for `.toString()` and `field` value
      format: "YYYY-MM-DD",
      // the toString function which gets passed a current date object and format
      // and returns a string
      toString: null,
      // used to create date object from current input string
      parse: null,
      // the initial date to view when first opened
      defaultDate: null,
      // make the `defaultDate` the initial selected value
      setDefaultDate: false,
      // first day of week (0: Sunday, 1: Monday etc)
      firstDay: 0,
      // minimum number of days in the week that gets week number one
      // default ISO 8601, week 01 is the week with the first Thursday (4)
      firstWeekOfYearMinDays: 4,
      // the default flag for moment's strict date parsing
      formatStrict: false,
      // the minimum/earliest date that can be selected
      minDate: null,
      // the maximum/latest date that can be selected
      maxDate: null,
      // number of years either side, or array of upper/lower range
      yearRange: 10,
      // show week numbers at head of row
      showWeekNumber: false,
      // Week picker mode
      pickWholeWeek: false,
      // used internally (don't config outside)
      minYear: 0,
      maxYear: 9999,
      minMonth: void 0,
      maxMonth: void 0,
      startRange: null,
      endRange: null,
      isRTL: false,
      // Additional text to append to the year in the calendar title
      yearSuffix: "",
      // Render the month after year in the calendar title
      showMonthAfterYear: false,
      // Render days of the calendar grid that fall in the next or previous month
      showDaysInNextAndPreviousMonths: false,
      // Allows user to select days that fall in the next or previous month
      enableSelectionDaysInNextAndPreviousMonths: false,
      // how many months are visible
      numberOfMonths: 1,
      // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
      // only used for the first display or when a selected date is not visible
      mainCalendar: "left",
      // Specify a DOM element to render the calendar in
      container: void 0,
      // Blur field when date is selected
      blurFieldOnSelect: true,
      // internationalization
      i18n: {
        previousMonth: "Previous Month",
        nextMonth: "Next Month",
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
      },
      // Theme Classname
      theme: null,
      // events array
      events: [],
      // callback function
      onSelect: null,
      onOpen: null,
      onClose: null,
      onDraw: null,
      // Enable keyboard input
      keyboardInput: true
    }, renderDayName = function(opts, day, abbr) {
      day += opts.firstDay;
      while (day >= 7) {
        day -= 7;
      }
      return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    }, renderDay = function(opts) {
      var arr = [];
      var ariaSelected = "false";
      if (opts.isEmpty) {
        if (opts.showDaysInNextAndPreviousMonths) {
          arr.push("is-outside-current-month");
          if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
            arr.push("is-selection-disabled");
          }
        } else {
          return '<td class="is-empty"></td>';
        }
      }
      if (opts.isDisabled) {
        arr.push("is-disabled");
      }
      if (opts.isToday) {
        arr.push("is-today");
      }
      if (opts.isSelected) {
        arr.push("is-selected");
        ariaSelected = "true";
      }
      if (opts.hasEvent) {
        arr.push("has-event");
      }
      if (opts.isInRange) {
        arr.push("is-inrange");
      }
      if (opts.isStartRange) {
        arr.push("is-startrange");
      }
      if (opts.isEndRange) {
        arr.push("is-endrange");
      }
      return '<td data-day="' + opts.day + '" class="' + arr.join(" ") + '" aria-selected="' + ariaSelected + '"><button class="pika-button pika-day" type="button" data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + "</button></td>";
    }, isoWeek = function(date, firstWeekOfYearMinDays) {
      date.setHours(0, 0, 0, 0);
      var yearDay = date.getDate(), weekDay = date.getDay(), dayInFirstWeek = firstWeekOfYearMinDays, dayShift = dayInFirstWeek - 1, daysPerWeek = 7, prevWeekDay = function(day) {
        return (day + daysPerWeek - 1) % daysPerWeek;
      };
      date.setDate(yearDay + dayShift - prevWeekDay(weekDay));
      var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek), msPerDay = 24 * 60 * 60 * 1e3, daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay, weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);
      return weekNum;
    }, renderWeek = function(d2, m2, y2, firstWeekOfYearMinDays) {
      var date = new Date(y2, m2, d2), week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);
      return '<td class="pika-week">' + week + "</td>";
    }, renderRow = function(days, isRTL, pickWholeWeek, isRowSelected) {
      return '<tr class="pika-row' + (pickWholeWeek ? " pick-whole-week" : "") + (isRowSelected ? " is-selected" : "") + '">' + (isRTL ? days.reverse() : days).join("") + "</tr>";
    }, renderBody = function(rows) {
      return "<tbody>" + rows.join("") + "</tbody>";
    }, renderHead = function(opts) {
      var i, arr = [];
      if (opts.showWeekNumber) {
        arr.push("<th></th>");
      }
      for (i = 0; i < 7; i++) {
        arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + "</abbr></th>");
      }
      return "<thead><tr>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</tr></thead>";
    }, renderTitle = function(instance, c2, year, month, refYear, randId) {
      var i, j, arr, opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html2 = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">', monthHtml, yearHtml, prev = true, next2 = true;
      for (arr = [], i = 0; i < 12; i++) {
        arr.push('<option value="' + (year === refYear ? i - c2 : 12 + i - c2) + '"' + (i === month ? ' selected="selected"' : "") + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? ' disabled="disabled"' : "") + ">" + opts.i18n.months[i] + "</option>");
      }
      monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join("") + "</select></div>";
      if (isArray3(opts.yearRange)) {
        i = opts.yearRange[0];
        j = opts.yearRange[1] + 1;
      } else {
        i = year - opts.yearRange;
        j = 1 + year + opts.yearRange;
      }
      for (arr = []; i < j && i <= opts.maxYear; i++) {
        if (i >= opts.minYear) {
          arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : "") + ">" + i + "</option>");
        }
      }
      yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join("") + "</select></div>";
      if (opts.showMonthAfterYear) {
        html2 += yearHtml + monthHtml;
      } else {
        html2 += monthHtml + yearHtml;
      }
      if (isMinYear && (month === 0 || opts.minMonth >= month)) {
        prev = false;
      }
      if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
        next2 = false;
      }
      if (c2 === 0) {
        html2 += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>";
      }
      if (c2 === instance._o.numberOfMonths - 1) {
        html2 += '<button class="pika-next' + (next2 ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>";
      }
      return html2 += "</div>";
    }, renderTable = function(opts, data2, randId) {
      return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data2) + "</table>";
    }, Pikaday2 = function(options) {
      var self2 = this, opts = self2.config(options);
      self2._onMouseDown = function(e2) {
        if (!self2._v) {
          return;
        }
        e2 = e2 || window.event;
        var target = e2.target || e2.srcElement;
        if (!target) {
          return;
        }
        if (!hasClass2(target, "is-disabled")) {
          if (hasClass2(target, "pika-button") && !hasClass2(target, "is-empty") && !hasClass2(target.parentNode, "is-disabled")) {
            self2.setDate(new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day")));
            if (opts.bound) {
              sto(function() {
                self2.hide();
                if (opts.blurFieldOnSelect && opts.field) {
                  opts.field.blur();
                }
              }, 100);
            }
          } else if (hasClass2(target, "pika-prev")) {
            self2.prevMonth();
          } else if (hasClass2(target, "pika-next")) {
            self2.nextMonth();
          }
        }
        if (!hasClass2(target, "pika-select")) {
          if (e2.preventDefault) {
            e2.preventDefault();
          } else {
            e2.returnValue = false;
            return false;
          }
        } else {
          self2._c = true;
        }
      };
      self2._onChange = function(e2) {
        e2 = e2 || window.event;
        var target = e2.target || e2.srcElement;
        if (!target) {
          return;
        }
        if (hasClass2(target, "pika-select-month")) {
          self2.gotoMonth(target.value);
        } else if (hasClass2(target, "pika-select-year")) {
          self2.gotoYear(target.value);
        }
      };
      self2._onKeyChange = function(e2) {
        e2 = e2 || window.event;
        if (self2.isVisible()) {
          switch (e2.keyCode) {
            case 13:
            case 27:
              if (opts.field) {
                opts.field.blur();
              }
              break;
            case 37:
              self2.adjustDate("subtract", 1);
              break;
            case 38:
              self2.adjustDate("subtract", 7);
              break;
            case 39:
              self2.adjustDate("add", 1);
              break;
            case 40:
              self2.adjustDate("add", 7);
              break;
            case 8:
            case 46:
              self2.setDate(null);
              break;
          }
        }
      };
      self2._parseFieldValue = function() {
        if (opts.parse) {
          return opts.parse(opts.field.value, opts.format);
        } else if (hasMoment) {
          var date = moment(opts.field.value, opts.format, opts.formatStrict);
          return date && date.isValid() ? date.toDate() : null;
        } else {
          return new Date(Date.parse(opts.field.value));
        }
      };
      self2._onInputChange = function(e2) {
        var date;
        if (e2.firedBy === self2) {
          return;
        }
        date = self2._parseFieldValue();
        if (isDate(date)) {
          self2.setDate(date);
        }
        if (!self2._v) {
          self2.show();
        }
      };
      self2._onInputFocus = function() {
        self2.show();
      };
      self2._onInputClick = function() {
        self2.show();
      };
      self2._onInputBlur = function() {
        var pEl = document2.activeElement;
        do {
          if (hasClass2(pEl, "pika-single")) {
            return;
          }
        } while (pEl = pEl.parentNode);
        if (!self2._c) {
          self2._b = sto(function() {
            self2.hide();
          }, 50);
        }
        self2._c = false;
      };
      self2._onClick = function(e2) {
        e2 = e2 || window.event;
        var target = e2.target || e2.srcElement, pEl = target;
        if (!target) {
          return;
        }
        if (!hasEventListeners && hasClass2(target, "pika-select")) {
          if (!target.onchange) {
            target.setAttribute("onchange", "return;");
            addEvent(target, "change", self2._onChange);
          }
        }
        do {
          if (hasClass2(pEl, "pika-single") || pEl === opts.trigger) {
            return;
          }
        } while (pEl = pEl.parentNode);
        if (self2._v && target !== opts.trigger && pEl !== opts.trigger) {
          self2.hide();
        }
      };
      self2.el = document2.createElement("div");
      self2.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "") + (opts.theme ? " " + opts.theme : "");
      addEvent(self2.el, "mousedown", self2._onMouseDown, true);
      addEvent(self2.el, "touchend", self2._onMouseDown, true);
      addEvent(self2.el, "change", self2._onChange);
      if (opts.keyboardInput) {
        addEvent(document2, "keydown", self2._onKeyChange);
      }
      if (opts.field) {
        if (opts.container) {
          opts.container.appendChild(self2.el);
        } else if (opts.bound) {
          document2.body.appendChild(self2.el);
        } else {
          opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);
        }
        addEvent(opts.field, "change", self2._onInputChange);
        if (!opts.defaultDate) {
          opts.defaultDate = self2._parseFieldValue();
          opts.setDefaultDate = true;
        }
      }
      var defDate = opts.defaultDate;
      if (isDate(defDate)) {
        if (opts.setDefaultDate) {
          self2.setDate(defDate, true);
        } else {
          self2.gotoDate(defDate);
        }
      } else {
        self2.gotoDate(/* @__PURE__ */ new Date());
      }
      if (opts.bound) {
        this.hide();
        self2.el.className += " is-bound";
        addEvent(opts.trigger, "click", self2._onInputClick);
        addEvent(opts.trigger, "focus", self2._onInputFocus);
        addEvent(opts.trigger, "blur", self2._onInputBlur);
      } else {
        this.show();
      }
    };
    Pikaday2.prototype = {
      /**
       * configure functionality
       */
      config: function(options) {
        if (!this._o) {
          this._o = extend2({}, defaults, true);
        }
        var opts = extend2(this._o, options, true);
        opts.isRTL = !!opts.isRTL;
        opts.field = opts.field && opts.field.nodeName ? opts.field : null;
        opts.theme = typeof opts.theme === "string" && opts.theme ? opts.theme : null;
        opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : opts.field);
        opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
        opts.disableWeekends = !!opts.disableWeekends;
        opts.disableDayFn = typeof opts.disableDayFn === "function" ? opts.disableDayFn : null;
        var nom = parseInt(opts.numberOfMonths, 10) || 1;
        opts.numberOfMonths = nom > 4 ? 4 : nom;
        if (!isDate(opts.minDate)) {
          opts.minDate = false;
        }
        if (!isDate(opts.maxDate)) {
          opts.maxDate = false;
        }
        if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
          opts.maxDate = opts.minDate = false;
        }
        if (opts.minDate) {
          this.setMinDate(opts.minDate);
        }
        if (opts.maxDate) {
          this.setMaxDate(opts.maxDate);
        }
        if (isArray3(opts.yearRange)) {
          var fallback = (/* @__PURE__ */ new Date()).getFullYear() - 10;
          opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
          opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
        } else {
          opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
          if (opts.yearRange > 100) {
            opts.yearRange = 100;
          }
        }
        return opts;
      },
      /**
       * return a formatted string of the current selection (using Moment.js if available)
       */
      toString: function(format) {
        format = format || this._o.format;
        if (!isDate(this._d)) {
          return "";
        }
        if (this._o.toString) {
          return this._o.toString(this._d, format);
        }
        if (hasMoment) {
          return moment(this._d).format(format);
        }
        return this._d.toDateString();
      },
      /**
       * return a Moment.js object of the current selection (if available)
       */
      getMoment: function() {
        return hasMoment ? moment(this._d) : null;
      },
      /**
       * set the current selection from a Moment.js object (if available)
       */
      setMoment: function(date, preventOnSelect) {
        if (hasMoment && moment.isMoment(date)) {
          this.setDate(date.toDate(), preventOnSelect);
        }
      },
      /**
       * return a Date object of the current selection
       */
      getDate: function() {
        return isDate(this._d) ? new Date(this._d.getTime()) : null;
      },
      /**
       * set the current selection
       */
      setDate: function(date, preventOnSelect) {
        if (!date) {
          this._d = null;
          if (this._o.field) {
            this._o.field.value = "";
            fireEvent(this._o.field, "change", { firedBy: this });
          }
          return this.draw();
        }
        if (typeof date === "string") {
          date = new Date(Date.parse(date));
        }
        if (!isDate(date)) {
          return;
        }
        var min2 = this._o.minDate, max2 = this._o.maxDate;
        if (isDate(min2) && date < min2) {
          date = min2;
        } else if (isDate(max2) && date > max2) {
          date = max2;
        }
        this._d = new Date(date.getTime());
        setToStartOfDay(this._d);
        this.gotoDate(this._d);
        if (this._o.field) {
          this._o.field.value = this.toString();
          fireEvent(this._o.field, "change", { firedBy: this });
        }
        if (!preventOnSelect && typeof this._o.onSelect === "function") {
          this._o.onSelect.call(this, this.getDate());
        }
      },
      /**
       * clear and reset the date
       */
      clear: function() {
        this.setDate(null);
      },
      /**
       * change view to a specific date
       */
      gotoDate: function(date) {
        var newCalendar = true;
        if (!isDate(date)) {
          return;
        }
        if (this.calendars) {
          var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), visibleDate = date.getTime();
          lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
          lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
          newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
        }
        if (newCalendar) {
          this.calendars = [{
            month: date.getMonth(),
            year: date.getFullYear()
          }];
          if (this._o.mainCalendar === "right") {
            this.calendars[0].month += 1 - this._o.numberOfMonths;
          }
        }
        this.adjustCalendars();
      },
      adjustDate: function(sign, days) {
        var day = this.getDate() || /* @__PURE__ */ new Date();
        var difference = parseInt(days) * 24 * 60 * 60 * 1e3;
        var newDay;
        if (sign === "add") {
          newDay = new Date(day.valueOf() + difference);
        } else if (sign === "subtract") {
          newDay = new Date(day.valueOf() - difference);
        }
        this.setDate(newDay);
      },
      adjustCalendars: function() {
        this.calendars[0] = adjustCalendar(this.calendars[0]);
        for (var c2 = 1; c2 < this._o.numberOfMonths; c2++) {
          this.calendars[c2] = adjustCalendar({
            month: this.calendars[0].month + c2,
            year: this.calendars[0].year
          });
        }
        this.draw();
      },
      gotoToday: function() {
        this.gotoDate(/* @__PURE__ */ new Date());
      },
      /**
       * change view to a specific month (zero-index, e.g. 0: January)
       */
      gotoMonth: function(month) {
        if (!isNaN(month)) {
          this.calendars[0].month = parseInt(month, 10);
          this.adjustCalendars();
        }
      },
      nextMonth: function() {
        this.calendars[0].month++;
        this.adjustCalendars();
      },
      prevMonth: function() {
        this.calendars[0].month--;
        this.adjustCalendars();
      },
      /**
       * change view to a specific full year (e.g. "2012")
       */
      gotoYear: function(year) {
        if (!isNaN(year)) {
          this.calendars[0].year = parseInt(year, 10);
          this.adjustCalendars();
        }
      },
      /**
       * change the minDate
       */
      setMinDate: function(value) {
        if (value instanceof Date) {
          setToStartOfDay(value);
          this._o.minDate = value;
          this._o.minYear = value.getFullYear();
          this._o.minMonth = value.getMonth();
        } else {
          this._o.minDate = defaults.minDate;
          this._o.minYear = defaults.minYear;
          this._o.minMonth = defaults.minMonth;
          this._o.startRange = defaults.startRange;
        }
        this.draw();
      },
      /**
       * change the maxDate
       */
      setMaxDate: function(value) {
        if (value instanceof Date) {
          setToStartOfDay(value);
          this._o.maxDate = value;
          this._o.maxYear = value.getFullYear();
          this._o.maxMonth = value.getMonth();
        } else {
          this._o.maxDate = defaults.maxDate;
          this._o.maxYear = defaults.maxYear;
          this._o.maxMonth = defaults.maxMonth;
          this._o.endRange = defaults.endRange;
        }
        this.draw();
      },
      setStartRange: function(value) {
        this._o.startRange = value;
      },
      setEndRange: function(value) {
        this._o.endRange = value;
      },
      /**
       * refresh the HTML
       */
      draw: function(force) {
        if (!this._v && !force) {
          return;
        }
        var opts = this._o, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html2 = "", randId;
        if (this._y <= minYear) {
          this._y = minYear;
          if (!isNaN(minMonth) && this._m < minMonth) {
            this._m = minMonth;
          }
        }
        if (this._y >= maxYear) {
          this._y = maxYear;
          if (!isNaN(maxMonth) && this._m > maxMonth) {
            this._m = maxMonth;
          }
        }
        for (var c2 = 0; c2 < opts.numberOfMonths; c2++) {
          randId = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2);
          html2 += '<div class="pika-lendar">' + renderTitle(this, c2, this.calendars[c2].year, this.calendars[c2].month, this.calendars[0].year, randId) + this.render(this.calendars[c2].year, this.calendars[c2].month, randId) + "</div>";
        }
        this.el.innerHTML = html2;
        if (opts.bound) {
          if (opts.field.type !== "hidden") {
            sto(function() {
              opts.trigger.focus();
            }, 1);
          }
        }
        if (typeof this._o.onDraw === "function") {
          this._o.onDraw(this);
        }
        if (opts.bound) {
          opts.field.setAttribute("aria-label", opts.ariaLabel);
        }
      },
      adjustPosition: function() {
        var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left2, top2, clientRect, leftAligned, bottomAligned;
        if (this._o.container)
          return;
        this.el.style.position = "absolute";
        field = this._o.trigger;
        pEl = field;
        width = this.el.offsetWidth;
        height = this.el.offsetHeight;
        viewportWidth = window.innerWidth || document2.documentElement.clientWidth;
        viewportHeight = window.innerHeight || document2.documentElement.clientHeight;
        scrollTop = window.pageYOffset || document2.body.scrollTop || document2.documentElement.scrollTop;
        leftAligned = true;
        bottomAligned = true;
        if (typeof field.getBoundingClientRect === "function") {
          clientRect = field.getBoundingClientRect();
          left2 = clientRect.left + window.pageXOffset;
          top2 = clientRect.bottom + window.pageYOffset;
        } else {
          left2 = pEl.offsetLeft;
          top2 = pEl.offsetTop + pEl.offsetHeight;
          while (pEl = pEl.offsetParent) {
            left2 += pEl.offsetLeft;
            top2 += pEl.offsetTop;
          }
        }
        if (this._o.reposition && left2 + width > viewportWidth || this._o.position.indexOf("right") > -1 && left2 - width + field.offsetWidth > 0) {
          left2 = left2 - width + field.offsetWidth;
          leftAligned = false;
        }
        if (this._o.reposition && top2 + height > viewportHeight + scrollTop || this._o.position.indexOf("top") > -1 && top2 - height - field.offsetHeight > 0) {
          top2 = top2 - height - field.offsetHeight;
          bottomAligned = false;
        }
        this.el.style.left = left2 + "px";
        this.el.style.top = top2 + "px";
        addClass2(this.el, leftAligned ? "left-aligned" : "right-aligned");
        addClass2(this.el, bottomAligned ? "bottom-aligned" : "top-aligned");
        removeClass2(this.el, !leftAligned ? "left-aligned" : "right-aligned");
        removeClass2(this.el, !bottomAligned ? "bottom-aligned" : "top-aligned");
      },
      /**
       * render HTML for a particular month
       */
      render: function(year, month, randId) {
        var opts = this._o, now = /* @__PURE__ */ new Date(), days = getDaysInMonth(year, month), before = new Date(year, month, 1).getDay(), data2 = [], row = [];
        setToStartOfDay(now);
        if (opts.firstDay > 0) {
          before -= opts.firstDay;
          if (before < 0) {
            before += 7;
          }
        }
        var previousMonth = month === 0 ? 11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth = month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : year, daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
        var cells = days + before, after = cells;
        while (after > 7) {
          after -= 7;
        }
        cells += 7 - after;
        var isWeekSelected = false;
        for (var i = 0, r2 = 0; i < cells; i++) {
          var day = new Date(year, month, 1 + (i - before)), isSelected = isDate(this._d) ? compareDates(day, this._d) : false, isToday = compareDates(day, now), hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false, isEmpty2 = i < before || i >= days + before, dayNumber = 1 + (i - before), monthNumber = month, yearNumber = year, isStartRange = opts.startRange && compareDates(opts.startRange, day), isEndRange = opts.endRange && compareDates(opts.endRange, day), isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled2 = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
          if (isEmpty2) {
            if (i < before) {
              dayNumber = daysInPreviousMonth + dayNumber;
              monthNumber = previousMonth;
              yearNumber = yearOfPreviousMonth;
            } else {
              dayNumber = dayNumber - days;
              monthNumber = nextMonth;
              yearNumber = yearOfNextMonth;
            }
          }
          var dayConfig = {
            day: dayNumber,
            month: monthNumber,
            year: yearNumber,
            hasEvent,
            isSelected,
            isToday,
            isDisabled: isDisabled2,
            isEmpty: isEmpty2,
            isStartRange,
            isEndRange,
            isInRange,
            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
            enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
          };
          if (opts.pickWholeWeek && isSelected) {
            isWeekSelected = true;
          }
          row.push(renderDay(dayConfig));
          if (++r2 === 7) {
            if (opts.showWeekNumber) {
              row.unshift(renderWeek(i - before, month, year, opts.firstWeekOfYearMinDays));
            }
            data2.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
            row = [];
            r2 = 0;
            isWeekSelected = false;
          }
        }
        return renderTable(opts, data2, randId);
      },
      isVisible: function() {
        return this._v;
      },
      show: function() {
        if (!this.isVisible()) {
          this._v = true;
          this.draw();
          removeClass2(this.el, "is-hidden");
          if (this._o.bound) {
            addEvent(document2, "click", this._onClick);
            this.adjustPosition();
          }
          if (typeof this._o.onOpen === "function") {
            this._o.onOpen.call(this);
          }
        }
      },
      hide: function() {
        var v2 = this._v;
        if (v2 !== false) {
          if (this._o.bound) {
            removeEvent(document2, "click", this._onClick);
          }
          if (!this._o.container) {
            this.el.style.position = "static";
            this.el.style.left = "auto";
            this.el.style.top = "auto";
          }
          addClass2(this.el, "is-hidden");
          this._v = false;
          if (v2 !== void 0 && typeof this._o.onClose === "function") {
            this._o.onClose.call(this);
          }
        }
      },
      /**
       * GAME OVER
       */
      destroy: function() {
        var opts = this._o;
        this.hide();
        removeEvent(this.el, "mousedown", this._onMouseDown, true);
        removeEvent(this.el, "touchend", this._onMouseDown, true);
        removeEvent(this.el, "change", this._onChange);
        if (opts.keyboardInput) {
          removeEvent(document2, "keydown", this._onKeyChange);
        }
        if (opts.field) {
          removeEvent(opts.field, "change", this._onInputChange);
          if (opts.bound) {
            removeEvent(opts.trigger, "click", this._onInputClick);
            removeEvent(opts.trigger, "focus", this._onInputFocus);
            removeEvent(opts.trigger, "blur", this._onInputBlur);
          }
        }
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
      }
    };
    return Pikaday2;
  });
})(pikaday);
const Pikaday = pikadayExports;
function _typeof$X(obj) {
  "@babel/helpers - typeof";
  return _typeof$X = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$X(obj);
}
function _classCallCheck$1t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1t(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$M() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$M = Reflect.get.bind();
  } else {
    _get$M = function _get2(target, property, receiver) {
      var base = _superPropBase$M(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$M.apply(this, arguments);
}
function _superPropBase$M(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$V(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$V(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$V(subClass, superClass);
}
function _setPrototypeOf$V(o, p2) {
  _setPrototypeOf$V = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$V(o, p2);
}
function _createSuper$V(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$V();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$V(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$V(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$V(this, result);
  };
}
function _possibleConstructorReturn$V(self2, call2) {
  if (call2 && (_typeof$X(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$V(self2);
}
function _assertThisInitialized$V(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$V() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$V(o) {
  _getPrototypeOf$V = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$V(o);
}
var EDITOR_TYPE$5 = "date";
var SHORTCUTS_GROUP_EDITOR = "dateEditor";
var DateEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$V(DateEditor2, _TextEditor);
  var _super = _createSuper$V(DateEditor2);
  function DateEditor2(hotInstance) {
    var _this;
    _classCallCheck$1t(this, DateEditor2);
    _this = _super.call(this, hotInstance);
    _this.defaultDateFormat = "DD/MM/YYYY";
    _this.isCellEdited = false;
    _this.parentDestroyed = false;
    _this.$datePicker = null;
    return _this;
  }
  _createClass$1t(DateEditor2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      if (typeof hooks !== "function") {
        throw new Error("You need to include moment.js to your project.");
      }
      if (typeof Pikaday !== "function") {
        throw new Error("You need to include Pikaday to your project.");
      }
      _get$M(_getPrototypeOf$V(DateEditor2.prototype), "init", this).call(this);
      this.instance.addHook("afterDestroy", function() {
        _this2.parentDestroyed = true;
        _this2.destroyElements();
      });
    }
    /**
     * Create data picker instance.
     */
  }, {
    key: "createElements",
    value: function createElements() {
      _get$M(_getPrototypeOf$V(DateEditor2.prototype), "createElements", this).call(this);
      this.datePicker = this.hot.rootDocument.createElement("DIV");
      this.datePickerStyle = this.datePicker.style;
      this.datePickerStyle.position = "absolute";
      this.datePickerStyle.top = 0;
      this.datePickerStyle.left = 0;
      this.datePickerStyle.zIndex = 9999;
      this.datePicker.setAttribute("dir", this.hot.isRtl() ? "rtl" : "ltr");
      addClass(this.datePicker, "htDatepickerHolder");
      this.hot.rootDocument.body.appendChild(this.datePicker);
      var eventManager = new EventManager$1(this);
      eventManager.addEventListener(this.datePicker, "mousedown", function(event2) {
        return event2.stopPropagation();
      });
    }
    /**
     * Destroy data picker instance.
     */
  }, {
    key: "destroyElements",
    value: function destroyElements() {
      var datePickerParentElement = this.datePicker.parentNode;
      if (this.$datePicker) {
        this.$datePicker.destroy();
      }
      if (datePickerParentElement) {
        datePickerParentElement.removeChild(this.datePicker);
      }
    }
    /**
     * Prepare editor to appear.
     *
     * @param {number} row The visual row index.
     * @param {number} col The visual column index.
     * @param {number|string} prop The column property (passed when datasource is an array of objects).
     * @param {HTMLTableCellElement} td The rendered cell element.
     * @param {*} value The rendered value.
     * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
     */
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      _get$M(_getPrototypeOf$V(DateEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
    }
    /**
     * Open editor.
     *
     * @param {Event} [event=null] The event object.
     */
  }, {
    key: "open",
    value: function open() {
      var event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      _get$M(_getPrototypeOf$V(DateEditor2.prototype), "open", this).call(this);
      this.showDatepicker(event2);
      editorContext.addShortcut({
        keys: [["Enter"]],
        callback: function callback(keyboardEvent) {
          keyboardEvent.stopPropagation();
        },
        group: SHORTCUTS_GROUP_EDITOR
      });
    }
    /**
     * Close editor.
     */
  }, {
    key: "close",
    value: function close() {
      var _this$$datePicker, _this3 = this;
      this._opened = false;
      if ((_this$$datePicker = this.$datePicker) !== null && _this$$datePicker !== void 0 && _this$$datePicker.destroy) {
        this.$datePicker.destroy();
      }
      this.instance._registerTimeout(function() {
        _this3.instance._refreshBorders();
      });
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);
      _get$M(_getPrototypeOf$V(DateEditor2.prototype), "close", this).call(this);
    }
    /**
     * Finishes editing and start saving or restoring process for editing cell or last selected range.
     *
     * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
     * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
     */
  }, {
    key: "finishEditing",
    value: function finishEditing() {
      var restoreOriginalValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var ctrlDown = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (restoreOriginalValue) {
        var value = this.originalValue;
        if (value !== void 0) {
          this.setValue(value);
        }
      }
      _get$M(_getPrototypeOf$V(DateEditor2.prototype), "finishEditing", this).call(this, restoreOriginalValue, ctrlDown);
    }
    /**
     * Show data picker.
     *
     * @param {Event} event The event object.
     */
  }, {
    key: "showDatepicker",
    value: function showDatepicker(event2) {
      var offset2 = this.TD.getBoundingClientRect();
      var dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
      var isMouseDown = this.instance.view.isMouseDown();
      var isMeta = event2 ? isFunctionKey(event2.keyCode) : false;
      var dateStr;
      this.datePicker.style.display = "block";
      this.$datePicker = new Pikaday(this.getDatePickerConfig());
      this.$datePicker._onInputFocus = function() {
      };
      this.datePickerStyle.top = "".concat(this.hot.rootWindow.pageYOffset + offset2.top + outerHeight(this.TD), "px");
      var pickerLeftPosition = this.hot.rootWindow.pageXOffset;
      if (this.hot.isRtl()) {
        pickerLeftPosition = offset2.right - outerWidth(this.datePicker);
      } else {
        pickerLeftPosition = offset2.left;
      }
      this.datePickerStyle.left = "".concat(pickerLeftPosition, "px");
      if (this.originalValue) {
        dateStr = this.originalValue;
        if (hooks(dateStr, dateFormat, true).isValid()) {
          this.$datePicker.setMoment(hooks(dateStr, dateFormat), true);
        }
        if (this.getValue() !== this.originalValue) {
          this.setValue(this.originalValue);
        }
        if (!isMeta && !isMouseDown) {
          this.setValue("");
        }
      } else if (this.cellProperties.defaultDate) {
        dateStr = this.cellProperties.defaultDate;
        if (hooks(dateStr, dateFormat, true).isValid()) {
          this.$datePicker.setMoment(hooks(dateStr, dateFormat), true);
        }
        if (!isMeta && !isMouseDown) {
          this.setValue("");
        }
      } else {
        this.$datePicker.gotoToday();
      }
    }
    /**
     * Hide data picker.
     */
  }, {
    key: "hideDatepicker",
    value: function hideDatepicker() {
      this.datePickerStyle.display = "none";
      this.$datePicker.hide();
    }
    /**
     * Get date picker options.
     *
     * @returns {object}
     */
  }, {
    key: "getDatePickerConfig",
    value: function getDatePickerConfig() {
      var _this4 = this;
      var htInput = this.TEXTAREA;
      var options = {};
      if (this.cellProperties && this.cellProperties.datePickerConfig) {
        deepExtend(options, this.cellProperties.datePickerConfig);
      }
      var origOnSelect = options.onSelect;
      var origOnClose = options.onClose;
      options.field = htInput;
      options.trigger = htInput;
      options.container = this.datePicker;
      options.bound = false;
      options.format = options.format || this.defaultDateFormat;
      options.reposition = options.reposition || false;
      options.isRTL = false;
      options.onSelect = function(value) {
        var dateStr = value;
        if (!isNaN(dateStr.getTime())) {
          dateStr = hooks(dateStr).format(_this4.cellProperties.dateFormat || _this4.defaultDateFormat);
        }
        _this4.setValue(dateStr);
        _this4.hideDatepicker();
        if (origOnSelect) {
          origOnSelect();
        }
      };
      options.onClose = function() {
        if (!_this4.parentDestroyed) {
          _this4.finishEditing(false);
        }
        if (origOnClose) {
          origOnClose();
        }
      };
      return options;
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$5;
    }
  }]);
  return DateEditor2;
}(TextEditor);
function _typeof$W(obj) {
  "@babel/helpers - typeof";
  return _typeof$W = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$W(obj);
}
function _classCallCheck$1s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1s(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$L() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$L = Reflect.get.bind();
  } else {
    _get$L = function _get2(target, property, receiver) {
      var base = _superPropBase$L(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$L.apply(this, arguments);
}
function _superPropBase$L(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$U(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$U(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$U(subClass, superClass);
}
function _setPrototypeOf$U(o, p2) {
  _setPrototypeOf$U = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$U(o, p2);
}
function _createSuper$U(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$U();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$U(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$U(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$U(this, result);
  };
}
function _possibleConstructorReturn$U(self2, call2) {
  if (call2 && (_typeof$W(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$U(self2);
}
function _assertThisInitialized$U(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$U() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$U(o) {
  _getPrototypeOf$U = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$U(o);
}
var EDITOR_TYPE$4 = "dropdown";
var DropdownEditor = /* @__PURE__ */ function(_AutocompleteEditor) {
  _inherits$U(DropdownEditor2, _AutocompleteEditor);
  var _super = _createSuper$U(DropdownEditor2);
  function DropdownEditor2() {
    _classCallCheck$1s(this, DropdownEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1s(DropdownEditor2, [{
    key: "prepare",
    value: (
      /**
       * @param {number} row The visual row index.
       * @param {number} col The visual column index.
       * @param {number|string} prop The column property (passed when datasource is an array of objects).
       * @param {HTMLTableCellElement} td The rendered cell element.
       * @param {*} value The rendered value.
       * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
       */
      function prepare(row, col, prop, td, value, cellProperties) {
        _get$L(_getPrototypeOf$U(DropdownEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
        this.cellProperties.filter = false;
        this.cellProperties.strict = true;
      }
    )
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$4;
    }
  }]);
  return DropdownEditor2;
}(AutocompleteEditor);
Hooks$1.getSingleton().add("beforeValidate", function(value, row, col) {
  var cellMeta = this.getCellMeta(row, this.propToCol(col));
  if (cellMeta.editor === DropdownEditor) {
    if (cellMeta.strict === void 0) {
      cellMeta.filter = false;
      cellMeta.strict = true;
    }
  }
});
function _typeof$V(obj) {
  "@babel/helpers - typeof";
  return _typeof$V = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$V(obj);
}
function _classCallCheck$1r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1r(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$T(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$T(subClass, superClass);
}
function _setPrototypeOf$T(o, p2) {
  _setPrototypeOf$T = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$T(o, p2);
}
function _createSuper$T(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$T();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$T(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$T(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$T(this, result);
  };
}
function _possibleConstructorReturn$T(self2, call2) {
  if (call2 && (_typeof$V(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$T(self2);
}
function _assertThisInitialized$T(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$T() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$T(o) {
  _getPrototypeOf$T = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$T(o);
}
var EDITOR_TYPE$3 = "numeric";
var NumericEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$T(NumericEditor2, _TextEditor);
  var _super = _createSuper$T(NumericEditor2);
  function NumericEditor2() {
    _classCallCheck$1r(this, NumericEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1r(NumericEditor2, null, [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$3;
    }
  }]);
  return NumericEditor2;
}(TextEditor);
function _typeof$U(obj) {
  "@babel/helpers - typeof";
  return _typeof$U = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$U(obj);
}
function _classCallCheck$1q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1q(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$K() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$K = Reflect.get.bind();
  } else {
    _get$K = function _get2(target, property, receiver) {
      var base = _superPropBase$K(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$K.apply(this, arguments);
}
function _superPropBase$K(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$S(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$S(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$S(subClass, superClass);
}
function _setPrototypeOf$S(o, p2) {
  _setPrototypeOf$S = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$S(o, p2);
}
function _createSuper$S(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$S();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$S(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$S(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$S(this, result);
  };
}
function _possibleConstructorReturn$S(self2, call2) {
  if (call2 && (_typeof$U(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$S(self2);
}
function _assertThisInitialized$S(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$S() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$S(o) {
  _getPrototypeOf$S = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$S(o);
}
var EDITOR_TYPE$2 = "password";
var PasswordEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$S(PasswordEditor2, _TextEditor);
  var _super = _createSuper$S(PasswordEditor2);
  function PasswordEditor2() {
    _classCallCheck$1q(this, PasswordEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1q(PasswordEditor2, [{
    key: "createElements",
    value: function createElements() {
      _get$K(_getPrototypeOf$S(PasswordEditor2.prototype), "createElements", this).call(this);
      this.TEXTAREA = this.hot.rootDocument.createElement("input");
      this.TEXTAREA.setAttribute("type", "password");
      this.TEXTAREA.setAttribute("data-hot-input", "");
      this.TEXTAREA.className = "handsontableInput";
      this.textareaStyle = this.TEXTAREA.style;
      this.textareaStyle.width = 0;
      this.textareaStyle.height = 0;
      empty(this.TEXTAREA_PARENT);
      this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$2;
    }
  }]);
  return PasswordEditor2;
}(TextEditor);
function _typeof$T(obj) {
  "@babel/helpers - typeof";
  return _typeof$T = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$T(obj);
}
function _classCallCheck$1p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1p(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$J() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$J = Reflect.get.bind();
  } else {
    _get$J = function _get2(target, property, receiver) {
      var base = _superPropBase$J(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$J.apply(this, arguments);
}
function _superPropBase$J(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$R(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$R(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$R(subClass, superClass);
}
function _setPrototypeOf$R(o, p2) {
  _setPrototypeOf$R = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$R(o, p2);
}
function _createSuper$R(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$R();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$R(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$R(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$R(this, result);
  };
}
function _possibleConstructorReturn$R(self2, call2) {
  if (call2 && (_typeof$T(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$R(self2);
}
function _assertThisInitialized$R(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$R() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$R(o) {
  _getPrototypeOf$R = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$R(o);
}
var EDITOR_VISIBLE_CLASS_NAME = "ht_editor_visible";
var SHORTCUTS_GROUP$4 = "selectEditor";
var EDITOR_TYPE$1 = "select";
var SelectEditor = /* @__PURE__ */ function(_BaseEditor) {
  _inherits$R(SelectEditor2, _BaseEditor);
  var _super = _createSuper$R(SelectEditor2);
  function SelectEditor2() {
    _classCallCheck$1p(this, SelectEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1p(SelectEditor2, [{
    key: "init",
    value: (
      /**
       * Initializes editor instance, DOM Element and mount hooks.
       */
      function init() {
        this.select = this.hot.rootDocument.createElement("SELECT");
        addClass(this.select, "htSelectEditor");
        this.select.style.display = "none";
        this.hot.rootElement.appendChild(this.select);
        this.registerHooks();
      }
    )
    /**
     * Returns select's value.
     *
     * @returns {*}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.select.value;
    }
    /**
     * Sets value in the select element.
     *
     * @param {*} value A new select's value.
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.select.value = value;
    }
    /**
     * Opens the editor and adjust its size.
     */
  }, {
    key: "open",
    value: function open() {
      this._opened = true;
      this.refreshDimensions();
      this.select.style.display = "";
      var shortcutManager = this.hot.getShortcutManager();
      shortcutManager.setActiveContextName("editor");
      this.registerShortcuts();
    }
    /**
     * Closes the editor.
     */
  }, {
    key: "close",
    value: function close() {
      this._opened = false;
      this.select.style.display = "none";
      if (hasClass(this.select, EDITOR_VISIBLE_CLASS_NAME)) {
        removeClass(this.select, EDITOR_VISIBLE_CLASS_NAME);
      }
      this.unregisterShortcuts();
      this.clearHooks();
    }
    /**
     * Sets focus state on the select element.
     */
  }, {
    key: "focus",
    value: function focus() {
      this.select.focus();
    }
    /**
     * Binds hooks to refresh editor's size after scrolling of the viewport or resizing of columns/rows.
     *
     * @private
     */
  }, {
    key: "registerHooks",
    value: function registerHooks() {
      var _this = this;
      this.addHook("afterScrollHorizontally", function() {
        return _this.refreshDimensions();
      });
      this.addHook("afterScrollVertically", function() {
        return _this.refreshDimensions();
      });
      this.addHook("afterColumnResize", function() {
        return _this.refreshDimensions();
      });
      this.addHook("afterRowResize", function() {
        return _this.refreshDimensions();
      });
    }
    /**
     * Prepares editor's meta data and a list of available options.
     *
     * @param {number} row The visual row index.
     * @param {number} col The visual column index.
     * @param {number|string} prop The column property (passed when datasource is an array of objects).
     * @param {HTMLTableCellElement} td The rendered cell element.
     * @param {*} value The rendered value.
     * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
     */
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      var _this2 = this;
      _get$J(_getPrototypeOf$R(SelectEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
      var selectOptions = this.cellProperties.selectOptions;
      var options;
      if (typeof selectOptions === "function") {
        options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
      } else {
        options = this.prepareOptions(selectOptions);
      }
      empty(this.select);
      objectEach(options, function(optionValue, key) {
        var optionElement = _this2.hot.rootDocument.createElement("OPTION");
        optionElement.value = key;
        fastInnerHTML(optionElement, optionValue);
        _this2.select.appendChild(optionElement);
      });
    }
    /**
     * Creates consistent list of available options.
     *
     * @private
     * @param {Array|object} optionsToPrepare The list of the values to render in the select eleemnt.
     * @returns {object}
     */
  }, {
    key: "prepareOptions",
    value: function prepareOptions(optionsToPrepare) {
      var preparedOptions = {};
      if (Array.isArray(optionsToPrepare)) {
        for (var i = 0, len = optionsToPrepare.length; i < len; i++) {
          preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
        }
      } else if (_typeof$T(optionsToPrepare) === "object") {
        preparedOptions = optionsToPrepare;
      }
      return preparedOptions;
    }
    /**
     * Refreshes editor's value using source data.
     *
     * @private
     */
  }, {
    key: "refreshValue",
    value: function refreshValue() {
      var sourceData = this.hot.getSourceDataAtCell(this.row, this.prop);
      this.originalValue = sourceData;
      this.setValue(sourceData);
      this.refreshDimensions();
    }
    /**
     * Refreshes editor's size and position.
     *
     * @private
     */
  }, {
    key: "refreshDimensions",
    value: function refreshDimensions() {
      if (this.state !== EDITOR_STATE.EDITING) {
        return;
      }
      this.TD = this.getEditedCell();
      if (!this.TD) {
        this.close();
        return;
      }
      var _this$getEditedCellRe = this.getEditedCellRect(), top2 = _this$getEditedCellRe.top, start = _this$getEditedCellRe.start, width = _this$getEditedCellRe.width, height = _this$getEditedCellRe.height;
      var selectStyle = this.select.style;
      selectStyle.height = "".concat(height, "px");
      selectStyle.width = "".concat(width, "px");
      selectStyle.top = "".concat(top2, "px");
      selectStyle[this.hot.isRtl() ? "right" : "left"] = "".concat(start, "px");
      selectStyle.margin = "0px";
      addClass(this.select, EDITOR_VISIBLE_CLASS_NAME);
    }
    /**
     * Register shortcuts responsible for handling editor.
     *
     * @private
     */
  }, {
    key: "registerShortcuts",
    value: function registerShortcuts() {
      var _this3 = this;
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      var contextConfig = {
        group: SHORTCUTS_GROUP$4
      };
      if (this.isInFullEditMode() === false) {
        return;
      }
      editorContext.addShortcuts([{
        keys: [["ArrowUp"]],
        callback: function callback() {
          var previousOptionIndex = _this3.select.selectedIndex - 1;
          if (previousOptionIndex >= 0) {
            _this3.select[previousOptionIndex].selected = true;
          }
        }
      }, {
        keys: [["ArrowDown"]],
        callback: function callback() {
          var nextOptionIndex = _this3.select.selectedIndex + 1;
          if (nextOptionIndex <= _this3.select.length - 1) {
            _this3.select[nextOptionIndex].selected = true;
          }
        }
      }], contextConfig);
    }
    /**
     * Unregister shortcuts responsible for handling editor.
     *
     * @private
     */
  }, {
    key: "unregisterShortcuts",
    value: function unregisterShortcuts() {
      var shortcutManager = this.hot.getShortcutManager();
      var editorContext = shortcutManager.getContext("editor");
      editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP$4);
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE$1;
    }
  }]);
  return SelectEditor2;
}(BaseEditor);
function _typeof$S(obj) {
  "@babel/helpers - typeof";
  return _typeof$S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$S(obj);
}
function _classCallCheck$1o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1o(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$I() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$I = Reflect.get.bind();
  } else {
    _get$I = function _get2(target, property, receiver) {
      var base = _superPropBase$I(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$I.apply(this, arguments);
}
function _superPropBase$I(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$Q(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$Q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$Q(subClass, superClass);
}
function _setPrototypeOf$Q(o, p2) {
  _setPrototypeOf$Q = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$Q(o, p2);
}
function _createSuper$Q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$Q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$Q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$Q(this, result);
  };
}
function _possibleConstructorReturn$Q(self2, call2) {
  if (call2 && (_typeof$S(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$Q(self2);
}
function _assertThisInitialized$Q(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$Q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$Q(o) {
  _getPrototypeOf$Q = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$Q(o);
}
var EDITOR_TYPE = "time";
var TimeEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$Q(TimeEditor2, _TextEditor);
  var _super = _createSuper$Q(TimeEditor2);
  function TimeEditor2() {
    _classCallCheck$1o(this, TimeEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1o(TimeEditor2, [{
    key: "prepare",
    value: (
      /**
       * Prepares editor's meta data.
       *
       * @param {number} row The visual row index.
       * @param {number} col The visual column index.
       * @param {number|string} prop The column property (passed when datasource is an array of objects).
       * @param {HTMLTableCellElement} td The rendered cell element.
       * @param {*} value The rendered value.
       * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
       */
      function prepare(row, col, prop, td, value, cellProperties) {
        _get$I(_getPrototypeOf$Q(TimeEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
        this.TEXTAREA.dir = "ltr";
      }
    )
  }], [{
    key: "EDITOR_TYPE",
    get: function get2() {
      return EDITOR_TYPE;
    }
  }]);
  return TimeEditor2;
}(TextEditor);
function registerAllEditors() {
  _register$3(BaseEditor);
  _register$3(AutocompleteEditor);
  _register$3(CheckboxEditor);
  _register$3(DateEditor);
  _register$3(DropdownEditor);
  _register$3(HandsontableEditor);
  _register$3(NumericEditor);
  _register$3(PasswordEditor);
  _register$3(SelectEditor);
  _register$3(TextEditor);
  _register$3(TimeEditor);
}
var VALIDATOR_TYPE$3 = "autocomplete";
function autocompleteValidator(value, callback) {
  var valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
    return;
  }
  if (this.strict && this.source) {
    if (typeof this.source === "function") {
      this.source(valueToValidate, process(valueToValidate, callback));
    } else {
      process(valueToValidate, callback)(this.source);
    }
  } else {
    callback(true);
  }
}
autocompleteValidator.VALIDATOR_TYPE = VALIDATOR_TYPE$3;
function process(value, callback) {
  var originalVal = value;
  return function(source) {
    var found = false;
    for (var s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true;
        break;
      }
    }
    callback(found);
  };
}
var sameValue$1 = Object.is || function is(x2, y2) {
  return x2 === y2 ? x2 !== 0 || 1 / x2 === 1 / y2 : x2 != x2 && y2 != y2;
};
var call = functionCall;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var anObject = anObject$l;
var isNullOrUndefined = isNullOrUndefined$b;
var requireObjectCoercible$2 = requireObjectCoercible$e;
var sameValue = sameValue$1;
var toString$2 = toString$j;
var getMethod = getMethod$7;
var regExpExec = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible$2(this);
      var searcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, SEARCH);
      return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString$2(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function(string) {
      var rx = anObject(this);
      var S = toString$2(string);
      var res = maybeCallNative(nativeSearch, rx, S);
      if (res.done)
        return res.value;
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0))
        rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex))
        rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});
function getNormalizedDate(dateString) {
  var nativeDate = new Date(dateString);
  if (!isNaN(new Date("".concat(dateString, "T00:00")).getDate())) {
    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 6e4);
  }
  return nativeDate;
}
var VALIDATOR_TYPE$2 = "date";
function dateValidator(value, callback) {
  var dateEditor = _getEditorInstance(EDITOR_TYPE$5, this.instance);
  var valueToValidate = value;
  var valid = true;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  var isValidFormat = hooks(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
  var isValidDate = hooks(new Date(valueToValidate)).isValid() || isValidFormat;
  if (this.allowEmpty && valueToValidate === "") {
    isValidDate = true;
    isValidFormat = true;
  }
  if (!isValidDate) {
    valid = false;
  }
  if (!isValidDate && isValidFormat) {
    valid = true;
  }
  if (isValidDate && !isValidFormat) {
    if (this.correctFormat === true) {
      var correctedValue = correctFormat(valueToValidate, this.dateFormat);
      var row = this.instance.toVisualRow(this.row);
      var column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "dateValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
dateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE$2;
function correctFormat(value, dateFormat) {
  var dateFromDate = hooks(getNormalizedDate(value));
  var dateFromMoment = hooks(value, dateFormat);
  var isAlphanumeric = value.search(/[A-z]/g) > -1;
  var date;
  if (dateFromDate.isValid() && dateFromDate.format("x") === dateFromMoment.format("x") || !dateFromMoment.isValid() || isAlphanumeric) {
    date = dateFromDate;
  } else {
    date = dateFromMoment;
  }
  return date.format(dateFormat);
}
var VALIDATOR_TYPE$1 = "numeric";
function numericValidator(value, callback) {
  var valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
  } else if (valueToValidate === "") {
    callback(false);
  } else {
    callback(isNumeric(value));
  }
}
numericValidator.VALIDATOR_TYPE = VALIDATOR_TYPE$1;
var STRICT_FORMATS = [
  "YYYY-MM-DDTHH:mm:ss.SSSZ",
  "X",
  // Unix timestamp
  "x"
  // Unix ms timestamp
];
var VALIDATOR_TYPE = "time";
function timeValidator(value, callback) {
  var timeFormat = this.timeFormat || "h:mm:ss a";
  var valid = true;
  var valueToValidate = value;
  if (valueToValidate === null) {
    valueToValidate = "";
  }
  valueToValidate = /^\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;
  var twoDigitValue = /^\d{1,2}$/.test(valueToValidate);
  if (twoDigitValue) {
    valueToValidate += ":00";
  }
  var date = hooks(valueToValidate, STRICT_FORMATS, true).isValid() ? hooks(valueToValidate) : hooks(valueToValidate, timeFormat);
  var isValidTime = date.isValid();
  var isValidFormat = hooks(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;
  if (this.allowEmpty && valueToValidate === "") {
    isValidTime = true;
    isValidFormat = true;
  }
  if (!isValidTime) {
    valid = false;
  }
  if (!isValidTime && isValidFormat) {
    valid = true;
  }
  if (isValidTime && !isValidFormat) {
    if (this.correctFormat === true) {
      var correctedValue = date.format(timeFormat);
      var row = this.instance.toVisualRow(this.row);
      var column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "timeValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
timeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;
function registerAllValidators() {
  _register$1(autocompleteValidator);
  _register$1(dateValidator);
  _register$1(numericValidator);
  _register$1(timeValidator);
}
var CELL_TYPE$7 = "autocomplete";
var AutocompleteCellType = {
  CELL_TYPE: CELL_TYPE$7,
  editor: AutocompleteEditor,
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};
var CELL_TYPE$6 = "checkbox";
var CheckboxCellType = {
  CELL_TYPE: CELL_TYPE$6,
  editor: CheckboxEditor,
  renderer: checkboxRenderer
};
var CELL_TYPE$5 = "date";
var DateCellType = {
  CELL_TYPE: CELL_TYPE$5,
  editor: DateEditor,
  // displays small gray arrow on right side of the cell
  renderer: autocompleteRenderer,
  validator: dateValidator
};
var CELL_TYPE$4 = "dropdown";
var DropdownCellType = {
  CELL_TYPE: CELL_TYPE$4,
  editor: DropdownEditor,
  // displays small gray arrow on right side of the cell
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};
var CELL_TYPE$3 = "handsontable";
var HandsontableCellType = {
  CELL_TYPE: CELL_TYPE$3,
  editor: HandsontableEditor,
  // displays small gray arrow on right side of the cell
  renderer: autocompleteRenderer
};
var CELL_TYPE$2 = "numeric";
var NumericCellType = {
  CELL_TYPE: CELL_TYPE$2,
  editor: NumericEditor,
  renderer: numericRenderer,
  validator: numericValidator,
  dataType: "number"
};
var CELL_TYPE$1 = "password";
var PasswordCellType = {
  CELL_TYPE: CELL_TYPE$1,
  editor: PasswordEditor,
  renderer: passwordRenderer,
  copyable: false
};
var CELL_TYPE = "time";
var TimeCellType = {
  CELL_TYPE,
  editor: TimeEditor,
  renderer: timeRenderer,
  validator: timeValidator
};
function registerAllCellTypes() {
  _register(AutocompleteCellType);
  _register(CheckboxCellType);
  _register(DateCellType);
  _register(DropdownCellType);
  _register(HandsontableCellType);
  _register(NumericCellType);
  _register(PasswordCellType);
  _register(TextCellType);
  _register(TimeCellType);
}
var collection = collection$5;
var collectionWeak = collectionWeak$2;
collection("WeakSet", function(init) {
  return function WeakSet2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionWeak);
function _slicedToArray$y(arr, i) {
  return _arrayWithHoles$A(arr) || _iterableToArrayLimit$y(arr, i) || _unsupportedIterableToArray$O(arr, i) || _nonIterableRest$A();
}
function _nonIterableRest$A() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$O(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$O(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$O(o, minLen);
}
function _arrayLikeToArray$O(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$y(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$A(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1n(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration$8(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration$8(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var DEPS_TYPE_CHECKERS = /* @__PURE__ */ new Map([["plugin", hasPlugin], ["cell-type", hasItem], ["editor", hasItem$3], ["renderer", hasItem$2], ["validator", hasItem$1]]);
var PLUGIN_KEY$x = "base";
var privatePool$g = /* @__PURE__ */ new WeakMap();
var missingDependeciesMsgs = [];
var initializedPlugins = null;
var _isRelevantToSettings = /* @__PURE__ */ new WeakSet();
var BasePlugin = /* @__PURE__ */ function() {
  function BasePlugin2(hotInstance) {
    var _this = this;
    _classCallCheck$1n(this, BasePlugin2);
    _classPrivateMethodInitSpec(this, _isRelevantToSettings);
    defineGetter(this, "hot", hotInstance, {
      writable: false
    });
    privatePool$g.set(this, {
      hooks: {}
    });
    initializedPlugins = null;
    this.pluginName = null;
    this.pluginsInitializedCallbacks = [];
    this.isPluginsReady = false;
    this.enabled = false;
    this.initialized = false;
    this.hot.addHook("afterPluginsInitialized", function() {
      return _this.onAfterPluginsInitialized();
    });
    this.hot.addHook("afterUpdateSettings", function(newSettings) {
      return _this.onUpdateSettings(newSettings);
    });
    this.hot.addHook("beforeInit", function() {
      return _this.init();
    });
  }
  _createClass$1n(BasePlugin2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      this.pluginName = this.hot.getPluginName(this);
      var pluginDeps = this.constructor.PLUGIN_DEPS;
      var dependecies = Array.isArray(pluginDeps) ? pluginDeps : [];
      if (dependecies.length > 0) {
        var missingDependencies = [];
        dependecies.forEach(function(dependency) {
          var _dependency$split = dependency.split(":"), _dependency$split2 = _slicedToArray$y(_dependency$split, 2), type = _dependency$split2[0], moduleName = _dependency$split2[1];
          if (!DEPS_TYPE_CHECKERS.has(type)) {
            throw new Error('Unknown plugin dependency type "'.concat(type, '" was found.'));
          }
          if (!DEPS_TYPE_CHECKERS.get(type)(moduleName)) {
            missingDependencies.push(" - ".concat(moduleName, " (").concat(type, ")"));
          }
        });
        if (missingDependencies.length > 0) {
          var errorMsg = ["The ".concat(this.pluginName, " plugin requires the following modules:\n"), "".concat(missingDependencies.join("\n"), "\n")].join("");
          missingDependeciesMsgs.push(errorMsg);
        }
      }
      if (!initializedPlugins) {
        initializedPlugins = getPluginsNames();
      }
      if (initializedPlugins.indexOf("UndoRedo") >= 0) {
        initializedPlugins.splice(initializedPlugins.indexOf("UndoRedo"), 1);
      }
      if (initializedPlugins.indexOf(this.pluginName) >= 0) {
        initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
      }
      this.hot.addHookOnce("afterPluginsInitialized", function() {
        if (_this2.isEnabled && _this2.isEnabled()) {
          _this2.enablePlugin();
        }
      });
      var isAllPluginsAreInitialized = initializedPlugins.length === 0;
      if (isAllPluginsAreInitialized) {
        if (missingDependeciesMsgs.length > 0) {
          var _errorMsg = ["".concat(missingDependeciesMsgs.join("\n"), "\n"), "You have to import and register them manually."].join("");
          throw new Error(_errorMsg);
        }
        this.hot.runHooks("afterPluginsInitialized");
      }
      this.initialized = true;
    }
    /**
     * Enable plugin for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      this.enabled = true;
    }
    /**
     * Disable plugin for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      if (this.eventManager) {
        this.eventManager.clear();
      }
      this.clearHooks();
      this.enabled = false;
    }
    /**
     * Add listener to plugin hooks system.
     *
     * @param {string} name The hook name.
     * @param {Function} callback The listener function to add.
     */
  }, {
    key: "addHook",
    value: function addHook2(name, callback) {
      privatePool$g.get(this).hooks[name] = privatePool$g.get(this).hooks[name] || [];
      var hooks2 = privatePool$g.get(this).hooks[name];
      this.hot.addHook(name, callback);
      hooks2.push(callback);
      privatePool$g.get(this).hooks[name] = hooks2;
    }
    /**
     * Remove all hooks listeners by hook name.
     *
     * @param {string} name The hook name.
     */
  }, {
    key: "removeHooks",
    value: function removeHooks(name) {
      var _this3 = this;
      arrayEach(privatePool$g.get(this).hooks[name] || [], function(callback) {
        _this3.hot.removeHook(name, callback);
      });
    }
    /**
     * Clear all hooks.
     */
  }, {
    key: "clearHooks",
    value: function clearHooks2() {
      var _this4 = this;
      var hooks2 = privatePool$g.get(this).hooks;
      objectEach(hooks2, function(callbacks, name) {
        return _this4.removeHooks(name);
      });
      hooks2.length = 0;
    }
    /**
     * Register function which will be immediately called after all plugins initialized.
     *
     * @param {Function} callback The listener function to call.
     */
  }, {
    key: "callOnPluginsReady",
    value: function callOnPluginsReady(callback) {
      if (this.isPluginsReady) {
        callback();
      } else {
        this.pluginsInitializedCallbacks.push(callback);
      }
    }
    /**
     * Check if any of the keys defined in `SETTING_KEYS` configuration of the plugin is present in the provided
     * config object, or if the `SETTING_KEYS` configuration states that the plugin is relevant to the config object
     * regardless of its contents.
     *
     * @private
     * @param {Handsontable.DefaultSettings} settings The config object passed to `updateSettings`.
     * @returns {boolean}
     */
  }, {
    key: "onAfterPluginsInitialized",
    value: (
      /**
       * On after plugins initialized listener.
       *
       * @private
       */
      function onAfterPluginsInitialized() {
        arrayEach(this.pluginsInitializedCallbacks, function(callback) {
          return callback();
        });
        this.pluginsInitializedCallbacks.length = 0;
        this.isPluginsReady = true;
      }
    )
    /**
     * On update settings listener.
     *
     * @private
     * @param {object} newSettings New set of settings passed to the `updateSettings` method.
     */
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings(newSettings) {
      var relevantToSettings = _classPrivateMethodGet(this, _isRelevantToSettings, _isRelevantToSettings2).call(this, newSettings);
      if (this.isEnabled) {
        if (this.enabled && !this.isEnabled()) {
          this.disablePlugin();
        }
        if (!this.enabled && this.isEnabled()) {
          this.enablePlugin();
        }
        if (this.enabled && this.isEnabled() && relevantToSettings) {
          this.updatePlugin(newSettings);
        }
      }
    }
    /**
     * Updates the plugin to use the latest options you have specified.
     *
     * @private
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
    }
    /**
     * Destroy plugin.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this5 = this;
      if (this.eventManager) {
        this.eventManager.destroy();
      }
      this.clearHooks();
      objectEach(this, function(value, property) {
        if (property !== "hot") {
          _this5[property] = null;
        }
      });
      delete this.t;
      delete this.hot;
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$x;
    }
    /**
     * The `SETTING_KEYS` getter defines the keys that, when present in the config object, trigger the plugin update
     * after the `updateSettings` calls.
     * - When it returns `true`, the plugin updates after all `updateSettings` calls, regardless of the contents of the
     * config object.
     * - When it returns `false`, the plugin never updates on `updateSettings` calls.
     *
     * @returns {string[] | boolean}
     */
  }, {
    key: "SETTING_KEYS",
    get: function get2() {
      return [this.PLUGIN_KEY];
    }
  }]);
  return BasePlugin2;
}();
function _isRelevantToSettings2(settings) {
  if (!settings) {
    return false;
  }
  var settingKeys = this.constructor.SETTING_KEYS;
  if (typeof settingKeys === "boolean") {
    return settingKeys;
  }
  for (var i = 0; i < settingKeys.length; i++) {
    if (settings[settingKeys[i]] !== void 0) {
      return true;
    }
  }
  return false;
}
function _slicedToArray$x(arr, i) {
  return _arrayWithHoles$z(arr) || _iterableToArrayLimit$x(arr, i) || _unsupportedIterableToArray$N(arr, i) || _nonIterableRest$z();
}
function _nonIterableRest$z() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$N(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$N(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$N(o, minLen);
}
function _arrayLikeToArray$N(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$x(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$z(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1m(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var GhostTable$2 = /* @__PURE__ */ function() {
  function GhostTable2(hotInstance) {
    _classCallCheck$1m(this, GhostTable2);
    this.hot = hotInstance;
    this.container = null;
    this.injected = false;
    this.rows = [];
    this.columns = [];
    this.samples = null;
    this.settings = {
      useHeaders: true
    };
  }
  _createClass$1m(GhostTable2, [{
    key: "addRow",
    value: function addRow(row, samples) {
      if (this.columns.length) {
        throw new Error("Doesn't support multi-dimensional table");
      }
      if (!this.rows.length) {
        this.container = this.createContainer(this.hot.rootElement.className);
      }
      var rowObject = {
        row
      };
      this.rows.push(rowObject);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      this.table.colGroup.appendChild(this.createColGroupsCol());
      this.table.tr.appendChild(this.createRow(row));
      this.container.container.appendChild(this.table.fragment);
      rowObject.table = this.table.table;
    }
    /**
     * Add a row consisting of the column headers.
     *
     * @param {Map} samples A map with sampled table values.
     */
  }, {
    key: "addColumnHeadersRow",
    value: function addColumnHeadersRow(samples) {
      var colHeader = this.hot.getColHeader(0);
      if (colHeader !== null && colHeader !== void 0) {
        var rowObject = {
          row: -1
        };
        this.rows.push(rowObject);
        this.container = this.createContainer(this.hot.rootElement.className);
        this.samples = samples;
        this.table = this.createTable(this.hot.table.className);
        this.table.colGroup.appendChild(this.createColGroupsCol());
        this.appendColumnHeadersRow();
        this.container.container.appendChild(this.table.fragment);
        rowObject.table = this.table.table;
      }
    }
    /**
     * Add column.
     *
     * @param {number} column Column index.
     * @param {Map} samples A map with sampled table values.
     */
  }, {
    key: "addColumn",
    value: function addColumn(column, samples) {
      if (this.rows.length) {
        throw new Error("Doesn't support multi-dimensional table");
      }
      if (!this.columns.length) {
        this.container = this.createContainer(this.hot.rootElement.className);
      }
      var columnObject = {
        col: column
      };
      this.columns.push(columnObject);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      if (this.getSetting("useHeaders") && this.hot.getColHeader(column) !== null) {
        this.hot.view.appendColHeader(column, this.table.th);
      }
      this.table.tBody.appendChild(this.createCol(column));
      this.container.container.appendChild(this.table.fragment);
      columnObject.table = this.table.table;
    }
    /**
     * Get calculated heights.
     *
     * @param {Function} callback Callback which will be fired for each calculated row.
     */
  }, {
    key: "getHeights",
    value: function getHeights(callback) {
      if (!this.injected) {
        this.injectTable();
      }
      arrayEach(this.rows, function(row) {
        callback(row.row, outerHeight(row.table) - 1);
      });
    }
    /**
     * Get calculated widths.
     *
     * @param {Function} callback Callback which will be fired for each calculated column.
     */
  }, {
    key: "getWidths",
    value: function getWidths(callback) {
      if (!this.injected) {
        this.injectTable();
      }
      arrayEach(this.columns, function(column) {
        var _column$table$getBoun = column.table.getBoundingClientRect(), width = _column$table$getBoun.width;
        callback(column.col, Math.ceil(width));
      });
    }
    /**
     * Set the Ghost Table settings to the provided object.
     *
     * @param {object} settings New Ghost Table Settings.
     */
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      this.settings = settings;
    }
    /**
     * Set a single setting of the Ghost Table.
     *
     * @param {string} name Setting name.
     * @param {*} value Setting value.
     */
  }, {
    key: "setSetting",
    value: function setSetting(name, value) {
      if (!this.settings) {
        this.settings = {};
      }
      this.settings[name] = value;
    }
    /**
     * Get the Ghost Table settings.
     *
     * @returns {object|null}
     */
  }, {
    key: "getSettings",
    value: function getSettings() {
      return this.settings;
    }
    /**
     * Get a single Ghost Table setting.
     *
     * @param {string} name The setting name to get.
     * @returns {boolean|null}
     */
  }, {
    key: "getSetting",
    value: function getSetting(name) {
      if (this.settings) {
        return this.settings[name];
      }
      return null;
    }
    /**
     * Create colgroup col elements.
     *
     * @returns {DocumentFragment}
     */
  }, {
    key: "createColGroupsCol",
    value: function createColGroupsCol() {
      var _this = this;
      var fragment = this.hot.rootDocument.createDocumentFragment();
      if (this.hot.hasRowHeaders()) {
        fragment.appendChild(this.createColElement(-1));
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          fragment.appendChild(_this.createColElement(string.col));
        });
      });
      return fragment;
    }
    /**
     * Create table row element.
     *
     * @param {number} row Row index.
     * @returns {DocumentFragment} Returns created table row elements.
     */
  }, {
    key: "createRow",
    value: function createRow(row) {
      var _this2 = this;
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      var th = rootDocument.createElement("th");
      if (this.hot.hasRowHeaders()) {
        this.hot.view.appendRowHeader(row, th);
        fragment.appendChild(th);
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var column = string.col;
          var cellProperties = _this2.hot.getCellMeta(row, column);
          cellProperties.col = column;
          cellProperties.row = row;
          var renderer = _this2.hot.getCellRenderer(cellProperties);
          var td = rootDocument.createElement("td");
          td.setAttribute("ghost-table", 1);
          renderer(_this2.hot, td, row, column, _this2.hot.colToProp(column), string.value, cellProperties);
          fragment.appendChild(td);
        });
      });
      return fragment;
    }
    /**
     * Creates DOM elements for headers and appends them to the THEAD element of the table.
     */
  }, {
    key: "appendColumnHeadersRow",
    value: function appendColumnHeadersRow() {
      var _this3 = this;
      var rootDocument = this.hot.rootDocument;
      var domFragment = rootDocument.createDocumentFragment();
      var columnHeaders = [];
      if (this.hot.hasRowHeaders()) {
        var th = rootDocument.createElement("th");
        columnHeaders.push([-1, th]);
        domFragment.appendChild(th);
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var column = string.col;
          var th2 = rootDocument.createElement("th");
          columnHeaders.push([column, th2]);
          domFragment.appendChild(th2);
        });
      });
      this.table.tHead.appendChild(domFragment);
      arrayEach(columnHeaders, function(columnHeader) {
        var _columnHeader = _slicedToArray$x(columnHeader, 2), column = _columnHeader[0], th2 = _columnHeader[1];
        _this3.hot.view.appendColHeader(column, th2);
      });
    }
    /**
     * Create table column elements.
     *
     * @param {number} column Column index.
     * @returns {DocumentFragment} Returns created column table column elements.
     */
  }, {
    key: "createCol",
    value: function createCol(column) {
      var _this4 = this;
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var row = string.row;
          var cellProperties = _this4.hot.getCellMeta(row, column);
          cellProperties.col = column;
          cellProperties.row = row;
          var renderer = _this4.hot.getCellRenderer(cellProperties);
          var td = rootDocument.createElement("td");
          var tr = rootDocument.createElement("tr");
          td.setAttribute("ghost-table", 1);
          renderer(_this4.hot, td, row, column, _this4.hot.colToProp(column), string.value, cellProperties);
          tr.appendChild(td);
          fragment.appendChild(tr);
        });
      });
      return fragment;
    }
    /**
     * Remove table from document and reset internal state.
     */
  }, {
    key: "clean",
    value: function clean() {
      this.rows.length = 0;
      this.rows[-1] = void 0;
      this.columns.length = 0;
      if (this.samples) {
        this.samples.clear();
      }
      this.samples = null;
      this.removeTable();
    }
    /**
     * Inject generated table into document.
     *
     * @param {HTMLElement} [parent=null] The element to which the ghost table is injected.
     */
  }, {
    key: "injectTable",
    value: function injectTable() {
      var parent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (!this.injected) {
        (parent || this.hot.rootElement).appendChild(this.container.fragment);
        this.injected = true;
      }
    }
    /**
     * Remove table from document.
     */
  }, {
    key: "removeTable",
    value: function removeTable() {
      if (this.injected && this.container.container.parentNode) {
        this.container.container.parentNode.removeChild(this.container.container);
        this.container = null;
        this.injected = false;
      }
    }
    /**
     * Create col element.
     *
     * @param {number} column Column index.
     * @returns {HTMLElement}
     */
  }, {
    key: "createColElement",
    value: function createColElement(column) {
      var col = this.hot.rootDocument.createElement("col");
      col.style.width = "".concat(this.hot.view._wt.wtTable.getStretchedColumnWidth(column), "px");
      return col;
    }
    /**
     * Create table element.
     *
     * @param {string} className The CSS classes to add.
     * @returns {object}
     */
  }, {
    key: "createTable",
    value: function createTable() {
      var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      var table = rootDocument.createElement("table");
      var tHead = rootDocument.createElement("thead");
      var tBody = rootDocument.createElement("tbody");
      var colGroup = rootDocument.createElement("colgroup");
      var tr = rootDocument.createElement("tr");
      var th = rootDocument.createElement("th");
      if (this.isVertical()) {
        table.appendChild(colGroup);
      }
      if (this.isHorizontal()) {
        tr.appendChild(th);
        tHead.appendChild(tr);
        table.style.tableLayout = "auto";
        table.style.width = "auto";
      }
      table.appendChild(tHead);
      if (this.isVertical()) {
        tBody.appendChild(tr);
      }
      table.appendChild(tBody);
      addClass(table, className);
      fragment.appendChild(table);
      return {
        fragment,
        table,
        tHead,
        tBody,
        colGroup,
        tr,
        th
      };
    }
    /**
     * Create container for tables.
     *
     * @param {string} className The CSS classes to add.
     * @returns {object}
     */
  }, {
    key: "createContainer",
    value: function createContainer() {
      var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      var container = rootDocument.createElement("div");
      var containerClassName = "htGhostTable htAutoSize ".concat(className.trim());
      addClass(container, containerClassName);
      fragment.appendChild(container);
      return {
        fragment,
        container
      };
    }
    /**
     * Checks if table is raised vertically (checking rows).
     *
     * @returns {boolean}
     */
  }, {
    key: "isVertical",
    value: function isVertical() {
      return !!(this.rows.length && !this.columns.length);
    }
    /**
     * Checks if table is raised horizontally (checking columns).
     *
     * @returns {boolean}
     */
  }, {
    key: "isHorizontal",
    value: function isHorizontal() {
      return !!(this.columns.length && !this.rows.length);
    }
  }]);
  return GhostTable2;
}();
const GhostTable$3 = GhostTable$2;
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$1l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1l(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var SamplesGenerator = /* @__PURE__ */ function() {
  function SamplesGenerator2(dataFactory) {
    _classCallCheck$1l(this, SamplesGenerator2);
    this.samples = null;
    this.dataFactory = dataFactory;
    this.customSampleCount = null;
    this.allowDuplicates = false;
  }
  _createClass$1l(SamplesGenerator2, [{
    key: "getSampleCount",
    value: function getSampleCount() {
      if (this.customSampleCount) {
        return this.customSampleCount;
      }
      return SamplesGenerator2.SAMPLE_COUNT;
    }
    /**
     * Set the sample count.
     *
     * @param {number} sampleCount Number of samples to be collected.
     */
  }, {
    key: "setSampleCount",
    value: function setSampleCount(sampleCount) {
      this.customSampleCount = sampleCount;
    }
    /**
     * Set if the generator should accept duplicate values.
     *
     * @param {boolean} allowDuplicates `true` to allow duplicate values.
     */
  }, {
    key: "setAllowDuplicates",
    value: function setAllowDuplicates(allowDuplicates) {
      this.allowDuplicates = allowDuplicates;
    }
    /**
     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.
     *
     * @param {object|number} rowRange The rows range to generate the samples.
     * @param {object} colRange The column range to generate the samples.
     * @returns {object}
     */
  }, {
    key: "generateRowSamples",
    value: function generateRowSamples(rowRange, colRange) {
      return this.generateSamples("row", colRange, rowRange);
    }
    /**
     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.
     *
     * @param {object} colRange Column index.
     * @param {object} rowRange Column index.
     * @returns {object}
     */
  }, {
    key: "generateColumnSamples",
    value: function generateColumnSamples(colRange, rowRange) {
      return this.generateSamples("col", rowRange, colRange);
    }
    /**
     * Generate collection of samples.
     *
     * @param {string} type Type to generate. Can be `col` or `row`.
     * @param {object} range The range to generate the samples.
     * @param {object|number} specifierRange The range to generate the samples.
     * @returns {Map}
     */
  }, {
    key: "generateSamples",
    value: function generateSamples(type, range, specifierRange) {
      var _this = this;
      var samples = /* @__PURE__ */ new Map();
      var _ref2 = typeof specifierRange === "number" ? {
        from: specifierRange,
        to: specifierRange
      } : specifierRange, from3 = _ref2.from, to = _ref2.to;
      rangeEach(from3, to, function(index2) {
        var sample = _this.generateSample(type, range, index2);
        samples.set(index2, sample);
      });
      return samples;
    }
    /**
     * Generate sample for specified type (`row` or `col`).
     *
     * @param {string} type Samples type `row` or `col`.
     * @param {object} range The range to generate the samples.
     * @param {number} specifierValue The range to generate the samples.
     * @returns {Map}
     */
  }, {
    key: "generateSample",
    value: function generateSample(type, range, specifierValue) {
      var _this2 = this;
      if (type !== "row" && type !== "col") {
        throw new Error("Unsupported sample type");
      }
      var samples = /* @__PURE__ */ new Map();
      var computedKey = type === "row" ? "col" : "row";
      var sampledValues = [];
      rangeEach(range.from, range.to, function(index2) {
        var _ref2 = type === "row" ? _this2.dataFactory(specifierValue, index2) : _this2.dataFactory(index2, specifierValue), value = _ref2.value, bundleSeed = _ref2.bundleSeed;
        var hasCustomBundleSeed = typeof bundleSeed === "string" && bundleSeed.length > 0;
        var seed;
        if (hasCustomBundleSeed) {
          seed = bundleSeed;
        } else if (isObject$7(value)) {
          seed = "".concat(Object.keys(value).length);
        } else if (Array.isArray(value)) {
          seed = "".concat(value.length);
        } else {
          seed = "".concat(stringify$1(value).length);
        }
        if (!samples.has(seed)) {
          samples.set(seed, {
            needed: _this2.getSampleCount(),
            strings: []
          });
        }
        var sample = samples.get(seed);
        if (sample.needed) {
          var duplicate = sampledValues.indexOf(value) > -1;
          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {
            sample.strings.push(_defineProperty$h({
              value
            }, computedKey, index2));
            sampledValues.push(value);
            sample.needed -= 1;
          }
        }
      });
      return samples;
    }
  }], [{
    key: "SAMPLE_COUNT",
    get: (
      /**
       * Number of samples to take of each value length.
       *
       * @type {number}
       */
      function get2() {
        return 3;
      }
    )
  }]);
  return SamplesGenerator2;
}();
const SamplesGenerator$1 = SamplesGenerator;
function _typeof$R(obj) {
  "@babel/helpers - typeof";
  return _typeof$R = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$R(obj);
}
function _slicedToArray$w(arr, i) {
  return _arrayWithHoles$y(arr) || _iterableToArrayLimit$w(arr, i) || _unsupportedIterableToArray$M(arr, i) || _nonIterableRest$y();
}
function _nonIterableRest$y() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$M(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$M(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$M(o, minLen);
}
function _arrayLikeToArray$M(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$w(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$y(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1k(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$H() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$H = Reflect.get.bind();
  } else {
    _get$H = function _get2(target, property, receiver) {
      var base = _superPropBase$H(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$H.apply(this, arguments);
}
function _superPropBase$H(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$P(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$P(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$P(subClass, superClass);
}
function _setPrototypeOf$P(o, p2) {
  _setPrototypeOf$P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$P(o, p2);
}
function _createSuper$P(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$P();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$P(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$P(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$P(this, result);
  };
}
function _possibleConstructorReturn$P(self2, call2) {
  if (call2 && (_typeof$R(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$P(self2);
}
function _assertThisInitialized$P(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$P() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$P(o) {
  _getPrototypeOf$P = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$P(o);
}
Hooks$1.getSingleton().register("modifyAutoColumnSizeSeed");
var PLUGIN_KEY$w = "autoColumnSize";
var PLUGIN_PRIORITY$v = 10;
var privatePool$f = /* @__PURE__ */ new WeakMap();
var COLUMN_SIZE_MAP_NAME = "autoColumnSize";
var AutoColumnSize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$P(AutoColumnSize2, _BasePlugin);
  var _super = _createSuper$P(AutoColumnSize2);
  function AutoColumnSize2(hotInstance) {
    var _this;
    _classCallCheck$1k(this, AutoColumnSize2);
    _this = _super.call(this, hotInstance);
    privatePool$f.set(_assertThisInitialized$P(_this), {
      /**
       * Cached column header names. It is used to diff current column headers with previous state and detect which
       * columns width should be updated.
       *
       * @private
       * @type {Array}
       */
      cachedColumnHeaders: []
    });
    _this.ghostTable = new GhostTable$3(_this.hot);
    _this.samplesGenerator = new SamplesGenerator$1(function(row, column) {
      var cellMeta = _this.hot.getCellMeta(row, column);
      var cellValue = "";
      if (!cellMeta.spanned) {
        cellValue = _this.hot.getDataAtCell(row, column);
      }
      var bundleSeed = "";
      if (_this.hot.hasHook("modifyAutoColumnSizeSeed")) {
        bundleSeed = _this.hot.runHooks("modifyAutoColumnSizeSeed", bundleSeed, cellMeta, cellValue);
      }
      return {
        value: cellValue,
        bundleSeed
      };
    });
    _this.firstCalculation = true;
    _this.inProgress = false;
    _this.measuredColumns = 0;
    _this.columnWidthsMap = new PhysicalIndexToValueMap();
    _this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, _this.columnWidthsMap);
    _this.addHook("beforeColumnResize", function(size, column, isDblClick) {
      return _this.onBeforeColumnResize(size, column, isDblClick);
    });
    return _this;
  }
  _createClass$1k(AutoColumnSize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$w] !== false && !this.hot.getSettings().colWidths;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var setting = this.hot.getSettings()[PLUGIN_KEY$w];
      if (setting && setting.useHeaders !== null && setting.useHeaders !== void 0) {
        this.ghostTable.setSetting("useHeaders", setting.useHeaders);
      }
      this.setSamplingOptions();
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.addHook("beforeChangeRender", function(changes) {
        return _this2.onBeforeChange(changes);
      });
      this.addHook("afterFormulasValuesUpdate", function(changes) {
        return _this2.onAfterFormulasValuesUpdate(changes);
      });
      this.addHook("beforeViewRender", function(force) {
        return _this2.onBeforeViewRender(force);
      });
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.getColumnWidth(col, width);
      });
      this.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      _get$H(_getPrototypeOf$P(AutoColumnSize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var changedColumns = this.findColumnsWhereHeaderWasChanged();
      if (changedColumns.length) {
        this.clearCache(changedColumns);
        this.calculateVisibleColumnsWidth();
      }
      _get$H(_getPrototypeOf$P(AutoColumnSize2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      _get$H(_getPrototypeOf$P(AutoColumnSize2.prototype), "disablePlugin", this).call(this);
      this.addHook("beforeColumnResize", function(size, column, isDblClick) {
        return _this3.onBeforeColumnResize(size, column, isDblClick);
      });
    }
    /**
     * Calculates visible columns width.
     */
  }, {
    key: "calculateVisibleColumnsWidth",
    value: function calculateVisibleColumnsWidth() {
      var rowsCount = this.hot.countRows();
      if (!rowsCount) {
        return;
      }
      var force = this.hot.renderCall;
      var firstVisibleColumn = this.getFirstVisibleColumn();
      var lastVisibleColumn = this.getLastVisibleColumn();
      if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {
        return;
      }
      this.calculateColumnsWidth({
        from: firstVisibleColumn,
        to: lastVisibleColumn
      }, void 0, force);
    }
    /**
     * Calculates a columns width.
     *
     * @param {number|object} colRange Visual column index or an object with `from` and `to` visual indexes as a range.
     * @param {number|object} rowRange Visual row index or an object with `from` and `to` visual indexes as a range.
     * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
     */
  }, {
    key: "calculateColumnsWidth",
    value: function calculateColumnsWidth() {
      var _this4 = this;
      var colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var rowRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var columnsRange = typeof colRange === "number" ? {
        from: colRange,
        to: colRange
      } : colRange;
      var rowsRange = typeof rowRange === "number" ? {
        from: rowRange,
        to: rowRange
      } : rowRange;
      rangeEach(columnsRange.from, columnsRange.to, function(visualColumn) {
        var physicalColumn = _this4.hot.toPhysicalColumn(visualColumn);
        if (physicalColumn === null) {
          physicalColumn = visualColumn;
        }
        if (force || _this4.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !_this4.hot._getColWidthFromSettings(physicalColumn)) {
          var samples = _this4.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);
          arrayEach(samples, function(_ref2) {
            var _ref22 = _slicedToArray$w(_ref2, 2), column = _ref22[0], sample = _ref22[1];
            return _this4.ghostTable.addColumn(column, sample);
          });
        }
      });
      if (this.ghostTable.columns.length) {
        this.hot.batchExecution(function() {
          _this4.ghostTable.getWidths(function(visualColumn, width) {
            var physicalColumn = _this4.hot.toPhysicalColumn(visualColumn);
            _this4.columnWidthsMap.setValueAtIndex(physicalColumn, width);
          });
        }, true);
        this.measuredColumns = columnsRange.to + 1;
        this.ghostTable.clean();
      }
    }
    /**
     * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.
     * To retrieve width for specified column use {@link AutoColumnSize#getColumnWidth} method.
     *
     * @param {object|number} rowRange Row index or an object with `from` and `to` properties which define row range.
     */
  }, {
    key: "calculateAllColumnsWidth",
    value: function calculateAllColumnsWidth() {
      var _this5 = this;
      var rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var current = 0;
      var length = this.hot.countCols() - 1;
      var timer = null;
      this.inProgress = true;
      var loop = function loop2() {
        if (!_this5.hot) {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          return;
        }
        _this5.calculateColumnsWidth({
          from: current,
          to: Math.min(current + AutoColumnSize2.CALCULATION_STEP, length)
        }, rowRange);
        current = current + AutoColumnSize2.CALCULATION_STEP + 1;
        if (current < length) {
          timer = requestAnimationFrame(loop2);
        } else {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          _this5.hot.view.adjustElementsSize();
        }
      };
      var syncLimit = this.getSyncCalculationLimit();
      if (this.firstCalculation && syncLimit >= 0) {
        this.calculateColumnsWidth({
          from: 0,
          to: syncLimit
        }, rowRange);
        this.firstCalculation = false;
        current = syncLimit + 1;
      }
      if (current < length) {
        loop();
      } else {
        this.inProgress = false;
      }
    }
    /**
     * Sets the sampling options.
     *
     * @private
     */
  }, {
    key: "setSamplingOptions",
    value: function setSamplingOptions() {
      var setting = this.hot.getSettings()[PLUGIN_KEY$w];
      var samplingRatio = setting && hasOwnProperty$2(setting, "samplingRatio") ? setting.samplingRatio : void 0;
      var allowSampleDuplicates = setting && hasOwnProperty$2(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
      if (samplingRatio && !isNaN(samplingRatio)) {
        this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
      }
      if (allowSampleDuplicates) {
        this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
      }
    }
    /**
     * Recalculates all columns width (overwrite cache values).
     */
  }, {
    key: "recalculateAllColumnsWidth",
    value: function recalculateAllColumnsWidth() {
      if (this.hot.view && this.hot.view._wt.wtTable.isVisible()) {
        this.clearCache();
        this.calculateAllColumnsWidth();
      }
    }
    /**
     * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated
     * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).
     *
     * @returns {number}
     */
  }, {
    key: "getSyncCalculationLimit",
    value: function getSyncCalculationLimit() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$w];
      var limit = AutoColumnSize2.SYNC_CALCULATION_LIMIT;
      var colsLimit = this.hot.countCols() - 1;
      if (isObject$7(settings)) {
        limit = settings.syncLimit;
        if (isPercentValue(limit)) {
          limit = valueAccordingPercent(colsLimit, limit);
        } else {
          limit >>= 0;
        }
      }
      return Math.min(limit, colsLimit);
    }
    /**
     * Gets the calculated column width.
     *
     * @param {number} column Visual column index.
     * @param {number} [defaultWidth] Default column width. It will be picked up if no calculated width found.
     * @param {boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).
     * @returns {number}
     */
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(column) {
      var defaultWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      var keepMinimum = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var width = defaultWidth;
      if (width === void 0) {
        width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));
        if (keepMinimum && typeof width === "number") {
          width = Math.max(width, ViewportColumnsCalculator$1.DEFAULT_WIDTH);
        }
      }
      return width;
    }
    /**
     * Gets the first visible column.
     *
     * @returns {number} Returns visual column index, -1 if table is not rendered or if there are no columns to base the the calculations on.
     */
  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn3() {
      var wot = this.hot.view._wt;
      if (wot.wtViewport.columnsVisibleCalculator) {
        var firstFullyVisibleColumn = wot.wtTable.getFirstVisibleColumn();
        if (firstFullyVisibleColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstFullyVisibleColumn);
        }
      }
      if (wot.wtViewport.columnsRenderCalculator) {
        var firstRenderedColumn = wot.wtTable.getFirstRenderedColumn();
        if (firstRenderedColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstRenderedColumn);
        }
      }
      return -1;
    }
    /**
     * Gets the last visible column.
     *
     * @returns {number} Returns visual column index or -1 if table is not rendered.
     */
  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn3() {
      var wot = this.hot.view._wt;
      if (wot.wtViewport.columnsVisibleCalculator) {
        var lastFullyVisibleColumn = wot.wtTable.getLastVisibleColumn();
        if (lastFullyVisibleColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastFullyVisibleColumn);
        }
      }
      if (wot.wtViewport.columnsRenderCalculator) {
        var lastRenderedColumn = wot.wtTable.getLastRenderedColumn();
        if (lastRenderedColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastRenderedColumn);
        }
      }
      return -1;
    }
    /**
     * Collects all columns which titles has been changed in comparison to the previous state.
     *
     * @private
     * @returns {Array} It returns an array of physical column indexes.
     */
  }, {
    key: "findColumnsWhereHeaderWasChanged",
    value: function findColumnsWhereHeaderWasChanged() {
      var columnHeaders = this.hot.getColHeader();
      var _privatePool$get = privatePool$f.get(this), cachedColumnHeaders = _privatePool$get.cachedColumnHeaders;
      var changedColumns = arrayReduce$1(columnHeaders, function(acc, columnTitle, physicalColumn) {
        var cachedColumnsLength = cachedColumnHeaders.length;
        if (cachedColumnsLength - 1 < physicalColumn || cachedColumnHeaders[physicalColumn] !== columnTitle) {
          acc.push(physicalColumn);
        }
        if (cachedColumnsLength - 1 < physicalColumn) {
          cachedColumnHeaders.push(columnTitle);
        } else {
          cachedColumnHeaders[physicalColumn] = columnTitle;
        }
        return acc;
      }, []);
      return changedColumns;
    }
    /**
     * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.
     * Otherwise whole cache will be cleared.
     *
     * @param {number[]} [columns] List of physical column indexes to clear.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      var _this6 = this;
      var columns = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (columns.length) {
        this.hot.batchExecution(function() {
          arrayEach(columns, function(physicalIndex) {
            _this6.columnWidthsMap.setValueAtIndex(physicalIndex, null);
          });
        }, true);
      } else {
        this.columnWidthsMap.clear();
      }
    }
    /**
     * Checks if all widths were calculated. If not then return `true` (need recalculate).
     *
     * @returns {boolean}
     */
  }, {
    key: "isNeedRecalculate",
    value: function isNeedRecalculate() {
      return !!arrayFilter(this.columnWidthsMap.getValues().slice(0, this.measuredColumns), function(item) {
        return item === null;
      }).length;
    }
    /**
     * On before view render listener.
     *
     * @private
     */
  }, {
    key: "onBeforeViewRender",
    value: function onBeforeViewRender() {
      this.calculateVisibleColumnsWidth();
      if (this.isNeedRecalculate() && !this.inProgress) {
        this.calculateAllColumnsWidth();
      }
    }
    /**
     * On after load data listener.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      var _this7 = this;
      if (this.hot.view) {
        this.recalculateAllColumnsWidth();
      } else {
        setTimeout(function() {
          if (_this7.hot) {
            _this7.recalculateAllColumnsWidth();
          }
        }, 0);
      }
    }
    /**
     * On before change listener.
     *
     * @private
     * @param {Array} changes An array of modified data.
     */
  }, {
    key: "onBeforeChange",
    value: function onBeforeChange(changes) {
      var _this8 = this;
      var changedColumns = arrayMap(changes, function(_ref3) {
        var _ref4 = _slicedToArray$w(_ref3, 2), columnProperty = _ref4[1];
        return _this8.hot.toPhysicalColumn(_this8.hot.propToCol(columnProperty));
      });
      this.clearCache(Array.from(new Set(changedColumns)));
    }
    /**
     * On before column resize listener.
     *
     * @private
     * @param {number} size Calculated new column width.
     * @param {number} column Visual index of the resized column.
     * @param {boolean} isDblClick  Flag that determines whether there was a double-click.
     * @returns {number}
     */
  }, {
    key: "onBeforeColumnResize",
    value: function onBeforeColumnResize(size, column, isDblClick) {
      var newSize = size;
      if (isDblClick) {
        this.calculateColumnsWidth(column, void 0, true);
        newSize = this.getColumnWidth(column, void 0, false);
      }
      return newSize;
    }
    /**
     * On after Handsontable init fill plugin with all necessary values.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      privatePool$f.get(this).cachedColumnHeaders = this.hot.getColHeader();
    }
    /**
     * After formulas values updated listener.
     *
     * @private
     * @param {Array} changes An array of modified data.
     */
  }, {
    key: "onAfterFormulasValuesUpdate",
    value: function onAfterFormulasValuesUpdate(changes) {
      var filteredChanges = arrayFilter(changes, function(change) {
        var _change$address;
        return isDefined((_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col);
      });
      var changedColumns = arrayMap(filteredChanges, function(change) {
        return change.address.col;
      });
      this.clearCache(Array.from(new Set(changedColumns)));
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.ghostTable.clean();
      _get$H(_getPrototypeOf$P(AutoColumnSize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$w;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$v;
    }
  }, {
    key: "SETTING_KEYS",
    get: function get2() {
      return true;
    }
  }, {
    key: "CALCULATION_STEP",
    get: function get2() {
      return 50;
    }
  }, {
    key: "SYNC_CALCULATION_LIMIT",
    get: function get2() {
      return 50;
    }
  }]);
  return AutoColumnSize2;
}(BasePlugin);
var DIRECTIONS = {
  horizontal: "horizontal",
  vertical: "vertical"
};
function getDeltas(start, end, data2, direction) {
  var rowsLength = data2.length;
  var columnsLength = data2 ? data2[0].length : 0;
  var deltas = [];
  var diffRow = end.row - start.row;
  var diffCol = end.col - start.col;
  if (["down", "up"].indexOf(direction) !== -1) {
    var arr = [];
    for (var col = 0; col < diffCol; col++) {
      var startValue = parseInt(data2[0][col], 10);
      var endValue = parseInt(data2[rowsLength - 1][col], 10);
      var delta = (direction === "down" ? endValue - startValue : startValue - endValue) / (rowsLength - 1) || 0;
      arr.push(delta);
    }
    deltas.push(arr);
  }
  if (["right", "left"].indexOf(direction) !== -1) {
    for (var row = 0; row < diffRow; row++) {
      var _startValue = parseInt(data2[row][0], 10);
      var _endValue = parseInt(data2[row][columnsLength - 1], 10);
      var _delta = (direction === "right" ? _endValue - _startValue : _startValue - _endValue) / (columnsLength - 1) || 0;
      deltas.push([_delta]);
    }
  }
  return deltas;
}
function getDragDirectionAndRange(startSelection, endSelection, cellCoordsFactory) {
  var startOfDragCoords;
  var endOfDragCoords;
  var directionOfDrag;
  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {
    directionOfDrag = "left";
    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);
    endOfDragCoords = cellCoordsFactory(endSelection[2], startSelection[1] - 1);
  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {
    directionOfDrag = "right";
    startOfDragCoords = cellCoordsFactory(endSelection[0], startSelection[3] + 1);
    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);
  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "up";
    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);
    endOfDragCoords = cellCoordsFactory(startSelection[0] - 1, endSelection[3]);
  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "down";
    startOfDragCoords = cellCoordsFactory(startSelection[2] + 1, endSelection[1]);
    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);
  }
  if (startOfDragCoords) {
    startOfDragCoords.normalize();
  }
  if (endOfDragCoords) {
    endOfDragCoords.normalize();
  }
  return {
    directionOfDrag,
    startOfDragCoords,
    endOfDragCoords
  };
}
function getMappedFillHandleSetting(fillHandle) {
  var mappedSettings = {};
  if (fillHandle === true) {
    mappedSettings.directions = Object.keys(DIRECTIONS);
    mappedSettings.autoInsertRow = true;
  } else if (isObject$7(fillHandle)) {
    if (isDefined(fillHandle.autoInsertRow)) {
      if (fillHandle.direction === DIRECTIONS.horizontal) {
        mappedSettings.autoInsertRow = false;
      } else {
        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;
      }
    } else {
      mappedSettings.autoInsertRow = false;
    }
    if (isDefined(fillHandle.direction)) {
      mappedSettings.directions = [fillHandle.direction];
    } else {
      mappedSettings.directions = Object.keys(DIRECTIONS);
    }
  } else if (typeof fillHandle === "string") {
    mappedSettings.directions = [fillHandle];
    mappedSettings.autoInsertRow = true;
  } else {
    mappedSettings.directions = [];
    mappedSettings.autoInsertRow = false;
  }
  return mappedSettings;
}
function _typeof$Q(obj) {
  "@babel/helpers - typeof";
  return _typeof$Q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$Q(obj);
}
function _toConsumableArray$h(arr) {
  return _arrayWithoutHoles$h(arr) || _iterableToArray$j(arr) || _unsupportedIterableToArray$L(arr) || _nonIterableSpread$h();
}
function _nonIterableSpread$h() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$j(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$h(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$L(arr);
}
function _slicedToArray$v(arr, i) {
  return _arrayWithHoles$x(arr) || _iterableToArrayLimit$v(arr, i) || _unsupportedIterableToArray$L(arr, i) || _nonIterableRest$x();
}
function _nonIterableRest$x() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$L(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$L(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$L(o, minLen);
}
function _arrayLikeToArray$L(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$v(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$x(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1j(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$G() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$G = Reflect.get.bind();
  } else {
    _get$G = function _get2(target, property, receiver) {
      var base = _superPropBase$G(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$G.apply(this, arguments);
}
function _superPropBase$G(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$O(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$O(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$O(subClass, superClass);
}
function _setPrototypeOf$O(o, p2) {
  _setPrototypeOf$O = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$O(o, p2);
}
function _createSuper$O(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$O();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$O(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$O(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$O(this, result);
  };
}
function _possibleConstructorReturn$O(self2, call2) {
  if (call2 && (_typeof$Q(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$O(self2);
}
function _assertThisInitialized$O(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$O() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$O(o) {
  _getPrototypeOf$O = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$O(o);
}
Hooks$1.getSingleton().register("modifyAutofillRange");
Hooks$1.getSingleton().register("beforeAutofill");
Hooks$1.getSingleton().register("afterAutofill");
var PLUGIN_KEY$v = "autofill";
var PLUGIN_PRIORITY$u = 20;
var SETTING_KEYS$2 = ["fillHandle"];
var INSERT_ROW_ALTER_ACTION_NAME = "insert_row";
var INTERVAL_FOR_ADDING_ROW = 200;
var Autofill = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$O(Autofill2, _BasePlugin);
  var _super = _createSuper$O(Autofill2);
  function Autofill2(hotInstance) {
    var _this;
    _classCallCheck$1j(this, Autofill2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager$1(_assertThisInitialized$O(_this));
    _this.addingStarted = false;
    _this.mouseDownOnCellCorner = false;
    _this.mouseDragOutside = false;
    _this.handleDraggedCells = 0;
    _this.directions = [];
    _this.autoInsertRow = false;
    return _this;
  }
  _createClass$1j(Autofill2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().fillHandle;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.mapSettings();
      this.registerEvents();
      this.addHook("afterOnCellCornerMouseDown", function(event2) {
        return _this2.onAfterCellCornerMouseDown(event2);
      });
      this.addHook("afterOnCellCornerDblClick", function(event2) {
        return _this2.onCellCornerDblClick(event2);
      });
      this.addHook("beforeOnCellMouseOver", function(_, coords) {
        return _this2.onBeforeCellMouseOver(coords);
      });
      _get$G(_getPrototypeOf$O(Autofill2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - `autofill`
     *  - [`fillHandle`](@/api/options.md#fillhandle)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$G(_getPrototypeOf$O(Autofill2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearMappedSettings();
      _get$G(_getPrototypeOf$O(Autofill2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Gets selection data.
     *
     * @private
     * @returns {object[]} Ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.
     */
  }, {
    key: "getSelectionData",
    value: function getSelectionData() {
      var _this3 = this;
      var selection = this.hot.getSelectedRangeLast();
      var _selection$getTopStar = selection.getTopStartCorner(), startRow = _selection$getTopStar.row, startCol = _selection$getTopStar.col;
      var _selection$getBottomE = selection.getBottomEndCorner(), endRow = _selection$getBottomE.row, endCol = _selection$getBottomE.col;
      var copyableRanges = this.hot.runHooks("modifyCopyableRange", [{
        startRow,
        startCol,
        endRow,
        endCol
      }]);
      var copyableRows = [];
      var copyableColumns = [];
      var data2 = [];
      arrayEach(copyableRanges, function(range) {
        for (var visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {
          if (copyableRows.indexOf(visualRow) === -1) {
            copyableRows.push(visualRow);
          }
        }
        for (var visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {
          if (copyableColumns.indexOf(visualColumn) === -1) {
            copyableColumns.push(visualColumn);
          }
        }
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this3.hot.getCopyableData(row, column));
        });
        data2.push(rowSet);
      });
      return data2;
    }
    /**
     * Try to apply fill values to the area in fill border, omitting the selection border.
     *
     * @private
     * @returns {boolean} Reports if fill was applied.
     *
     * @fires Hooks#modifyAutofillRange
     * @fires Hooks#beforeAutofill
     * @fires Hooks#afterAutofill
     */
  }, {
    key: "fillIn",
    value: function fillIn() {
      var _this4 = this;
      if (this.hot.selection.highlight.getFill().isEmpty()) {
        return false;
      }
      var _this$hot$selection$h = this.hot.selection.highlight.getFill().getVisualCorners(), _this$hot$selection$h2 = _slicedToArray$v(_this$hot$selection$h, 4), fillStartRow = _this$hot$selection$h2[0], fillStartColumn = _this$hot$selection$h2[1], fillEndRow = _this$hot$selection$h2[2], fillEndColumn = _this$hot$selection$h2[3];
      var selectionRangeLast = this.hot.getSelectedRangeLast();
      var topStartCorner = selectionRangeLast.getTopStartCorner();
      var bottomEndCorner = selectionRangeLast.getBottomEndCorner();
      this.resetSelectionOfDraggedArea();
      var cornersOfSelectedCells = [topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col];
      var cornersOfSelectionAndDragAreas = this.hot.runHooks("modifyAutofillRange", [Math.min(topStartCorner.row, fillStartRow), Math.min(topStartCorner.col, fillStartColumn), Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, fillEndColumn)], cornersOfSelectedCells);
      var _getDragDirectionAndR = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas, function(row, column) {
        return _this4.hot._createCellCoords(row, column);
      }), directionOfDrag = _getDragDirectionAndR.directionOfDrag, startOfDragCoords = _getDragDirectionAndR.startOfDragCoords, endOfDragCoords = _getDragDirectionAndR.endOfDragCoords;
      if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {
        var selectionData = this.getSelectionData();
        var sourceRange = selectionRangeLast.clone();
        var targetRange = this.hot._createCellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);
        var beforeAutofillHookResult = this.hot.runHooks("beforeAutofill", selectionData, sourceRange, targetRange, directionOfDrag);
        if (beforeAutofillHookResult === false) {
          this.hot.selection.highlight.getFill().clear();
          this.hot.render();
          return false;
        }
        var deltas = getDeltas(startOfDragCoords, endOfDragCoords, selectionData, directionOfDrag);
        var fillData = beforeAutofillHookResult;
        var res = beforeAutofillHookResult;
        if (["up", "left"].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {
          fillData = [];
          if (directionOfDrag === "up") {
            var dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;
            var fillOffset = dragLength % res.length;
            for (var i = 0; i < dragLength; i++) {
              fillData.push(res[(i + (res.length - fillOffset)) % res.length]);
            }
          } else {
            var _dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;
            var _fillOffset = _dragLength % res[0].length;
            for (var _i2 = 0; _i2 < res.length; _i2++) {
              fillData.push([]);
              for (var j = 0; j < _dragLength; j++) {
                fillData[_i2].push(res[_i2][(j + (res[_i2].length - _fillOffset)) % res[_i2].length]);
              }
            }
          }
        }
        this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, "".concat(this.pluginName, ".fill"), null, directionOfDrag, deltas);
        this.setSelection(cornersOfSelectionAndDragAreas);
        this.hot.runHooks("afterAutofill", fillData, sourceRange, targetRange, directionOfDrag);
        this.hot.render();
      } else {
        this.hot._refreshBorders();
      }
      return true;
    }
    /**
     * Reduces the selection area if the handle was dragged outside of the table or on headers.
     *
     * @private
     * @param {CellCoords} coords Indexes of selection corners.
     * @returns {CellCoords}
     */
  }, {
    key: "reduceSelectionAreaIfNeeded",
    value: function reduceSelectionAreaIfNeeded(coords) {
      if (coords.row < 0) {
        coords.row = 0;
      }
      if (coords.col < 0) {
        coords.col = 0;
      }
      return coords;
    }
    /**
     * Gets the coordinates of the drag & drop borders.
     *
     * @private
     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
     * @returns {CellCoords}
     */
  }, {
    key: "getCoordsOfDragAndDropBorders",
    value: function getCoordsOfDragAndDropBorders(coordsOfSelection) {
      var currentSelection = this.hot.getSelectedRangeLast();
      var bottomRightCorner = currentSelection.getBottomEndCorner();
      var coords = coordsOfSelection;
      if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {
        var topStartCorner = currentSelection.getTopStartCorner();
        if (bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= coordsOfSelection.col) {
          coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);
        }
        if (bottomRightCorner.row < coordsOfSelection.row || topStartCorner.row > coordsOfSelection.row) {
          coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);
        }
      } else if (this.directions.includes(DIRECTIONS.vertical)) {
        coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);
      } else if (this.directions.includes(DIRECTIONS.horizontal)) {
        coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);
      } else {
        return;
      }
      return this.reduceSelectionAreaIfNeeded(coords);
    }
    /**
     * Show the fill border.
     *
     * @private
     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
     */
  }, {
    key: "showBorder",
    value: function showBorder(coordsOfSelection) {
      var coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);
      if (coordsOfDragAndDropBorders) {
        this.redrawBorders(coordsOfDragAndDropBorders);
      }
    }
    /**
     * Add new row.
     *
     * @private
     */
  }, {
    key: "addRow",
    value: function addRow() {
      var _this5 = this;
      this.hot._registerTimeout(function() {
        _this5.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, "".concat(_this5.pluginName, ".fill"));
        _this5.addingStarted = false;
      }, INTERVAL_FOR_ADDING_ROW);
    }
    /**
     * Add new rows if they are needed to continue auto-filling values.
     *
     * @private
     */
  }, {
    key: "addNewRowIfNeeded",
    value: function addNewRowIfNeeded() {
      if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {
        var cornersOfSelectedCells = this.hot.getSelectedLast();
        var cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();
        var nrOfTableRows = this.hot.countRows();
        if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {
          this.addingStarted = true;
          this.addRow();
        }
      }
    }
    /**
     * Get index of last adjacent filled in row.
     *
     * @private
     * @param {Array} cornersOfSelectedCells Indexes of selection corners.
     * @returns {number} Gives number greater than or equal to zero when selection adjacent can be applied.
     *                   Or -1 when selection adjacent can't be applied.
     */
  }, {
    key: "getIndexOfLastAdjacentFilledInRow",
    value: function getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {
      var data2 = this.hot.getData();
      var nrOfTableRows = this.hot.countRows();
      var lastFilledInRowIndex;
      for (var rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {
        for (var columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {
          var dataInCell = data2[rowIndex][columnIndex];
          if (dataInCell) {
            return -1;
          }
        }
        var dataInNextLeftCell = data2[rowIndex][cornersOfSelectedCells[1] - 1];
        var dataInNextRightCell = data2[rowIndex][cornersOfSelectedCells[3] + 1];
        if (!!dataInNextLeftCell || !!dataInNextRightCell) {
          lastFilledInRowIndex = rowIndex;
        }
      }
      return lastFilledInRowIndex;
    }
    /**
     * Adds a selection from the start area to the specific row index.
     *
     * @private
     * @param {Array} selectStartArea Selection area from which we start to create more comprehensive selection.
     * @param {number} rowIndex The row index into the selection will be added.
     */
  }, {
    key: "addSelectionFromStartAreaToSpecificRowIndex",
    value: function addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {
      this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords(selectStartArea[0], selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, selectStartArea[3])).commit();
    }
    /**
     * Sets selection based on passed corners.
     *
     * @private
     * @param {Array} cornersOfArea An array witch defines selection.
     */
  }, {
    key: "setSelection",
    value: function setSelection(cornersOfArea) {
      var _this$hot;
      (_this$hot = this.hot).selectCell.apply(_this$hot, _toConsumableArray$h(arrayMap(cornersOfArea, function(index2) {
        return Math.max(index2, 0);
      })).concat([false, false]));
    }
    /**
     * Try to select cells down to the last row in the left column and then returns if selection was applied.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "selectAdjacent",
    value: function selectAdjacent() {
      var cornersOfSelectedCells = this.hot.getSelectedLast();
      var lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);
      if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {
        return false;
      }
      this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);
      return true;
    }
    /**
     * Resets selection of dragged area.
     *
     * @private
     */
  }, {
    key: "resetSelectionOfDraggedArea",
    value: function resetSelectionOfDraggedArea() {
      this.handleDraggedCells = 0;
      this.hot.selection.highlight.getFill().clear();
    }
    /**
     * Redraws borders.
     *
     * @private
     * @param {CellCoords} coords `CellCoords` coord object.
     */
  }, {
    key: "redrawBorders",
    value: function redrawBorders(coords) {
      this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();
      this.hot.view.render();
    }
    /**
     * Get if mouse was dragged outside.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     * @returns {boolean}
     */
  }, {
    key: "getIfMouseWasDraggedOutside",
    value: function getIfMouseWasDraggedOutside(event2) {
      var documentElement = this.hot.rootDocument.documentElement;
      var tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);
      var tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);
      return event2.clientY > tableBottom && event2.clientX <= tableRight;
    }
    /**
     * Bind the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this6 = this;
      var documentElement = this.hot.rootDocument.documentElement;
      this.eventManager.addEventListener(documentElement, "mouseup", function() {
        return _this6.onMouseUp();
      });
      this.eventManager.addEventListener(documentElement, "mousemove", function(event2) {
        return _this6.onMouseMove(event2);
      });
    }
    /**
     * On cell corner double click callback.
     *
     * @private
     */
  }, {
    key: "onCellCornerDblClick",
    value: function onCellCornerDblClick() {
      var selectionApplied = this.selectAdjacent();
      if (selectionApplied) {
        this.fillIn();
      }
    }
    /**
     * On after cell corner mouse down listener.
     *
     * @private
     */
  }, {
    key: "onAfterCellCornerMouseDown",
    value: function onAfterCellCornerMouseDown() {
      this.handleDraggedCells = 1;
      this.mouseDownOnCellCorner = true;
    }
    /**
     * On before cell mouse over listener.
     *
     * @private
     * @param {CellCoords} coords `CellCoords` coord object.
     */
  }, {
    key: "onBeforeCellMouseOver",
    value: function onBeforeCellMouseOver(coords) {
      if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {
        this.handleDraggedCells += 1;
        this.showBorder(coords);
        this.addNewRowIfNeeded();
      }
    }
    /**
     * On mouse up listener.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      if (this.handleDraggedCells) {
        if (this.handleDraggedCells > 1) {
          this.fillIn();
        }
        this.handleDraggedCells = 0;
        this.mouseDownOnCellCorner = false;
      }
    }
    /**
     * On mouse move listener.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event2);
      if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {
        this.mouseDragOutside = true;
        this.addingStarted = true;
      } else {
        this.mouseDragOutside = false;
      }
      if (this.mouseDragOutside && this.autoInsertRow) {
        this.addRow();
      }
    }
    /**
     * Clears mapped settings.
     *
     * @private
     */
  }, {
    key: "clearMappedSettings",
    value: function clearMappedSettings() {
      this.directions.length = 0;
      this.autoInsertRow = false;
    }
    /**
     * Map settings.
     *
     * @private
     */
  }, {
    key: "mapSettings",
    value: function mapSettings() {
      var mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);
      this.directions = mappedSettings.directions;
      this.autoInsertRow = mappedSettings.autoInsertRow;
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$G(_getPrototypeOf$O(Autofill2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$v;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$u;
    }
  }, {
    key: "SETTING_KEYS",
    get: function get2() {
      return [PLUGIN_KEY$v].concat(SETTING_KEYS$2);
    }
  }]);
  return Autofill2;
}(BasePlugin);
function _typeof$P(obj) {
  "@babel/helpers - typeof";
  return _typeof$P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$P(obj);
}
function _slicedToArray$u(arr, i) {
  return _arrayWithHoles$w(arr) || _iterableToArrayLimit$u(arr, i) || _unsupportedIterableToArray$K(arr, i) || _nonIterableRest$w();
}
function _nonIterableRest$w() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$K(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$K(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$K(o, minLen);
}
function _arrayLikeToArray$K(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$u(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$w(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1i(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$F() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$F = Reflect.get.bind();
  } else {
    _get$F = function _get2(target, property, receiver) {
      var base = _superPropBase$F(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$F.apply(this, arguments);
}
function _superPropBase$F(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$N(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$N(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$N(subClass, superClass);
}
function _setPrototypeOf$N(o, p2) {
  _setPrototypeOf$N = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$N(o, p2);
}
function _createSuper$N(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$N();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$N(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$N(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$N(this, result);
  };
}
function _possibleConstructorReturn$N(self2, call2) {
  if (call2 && (_typeof$P(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$N(self2);
}
function _assertThisInitialized$N(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$N() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$N(o) {
  _getPrototypeOf$N = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$N(o);
}
var PLUGIN_KEY$u = "autoRowSize";
var PLUGIN_PRIORITY$t = 40;
var ROW_WIDTHS_MAP_NAME = "autoRowSize";
var AutoRowSize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$N(AutoRowSize2, _BasePlugin);
  var _super = _createSuper$N(AutoRowSize2);
  function AutoRowSize2(hotInstance) {
    var _this;
    _classCallCheck$1i(this, AutoRowSize2);
    _this = _super.call(this, hotInstance);
    _this.rowHeightsMap = void 0;
    _this.headerHeight = null;
    _this.ghostTable = new GhostTable$3(_this.hot);
    _this.samplesGenerator = new SamplesGenerator$1(function(row, col) {
      var cellValue;
      if (row >= 0) {
        cellValue = _this.hot.getDataAtCell(row, col);
      } else if (row === -1) {
        cellValue = _this.hot.getColHeader(col);
      }
      return {
        value: cellValue
      };
    });
    _this.firstCalculation = true;
    _this.inProgress = false;
    _this.measuredRows = 0;
    _this.rowHeightsMap = new PhysicalIndexToValueMap();
    _this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, _this.rowHeightsMap);
    _this.addHook("beforeRowResize", function(size, row, isDblClick) {
      return _this.onBeforeRowResize(size, row, isDblClick);
    });
    return _this;
  }
  _createClass$1i(AutoRowSize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$u];
      return settings === true || isObject$7(settings);
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.setSamplingOptions();
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.addHook("beforeChangeRender", function(changes) {
        return _this2.onBeforeChange(changes);
      });
      this.addHook("beforeColumnResize", function() {
        return _this2.recalculateAllRowsHeight();
      });
      this.addHook("beforeViewRender", function(force) {
        return _this2.onBeforeViewRender(force);
      });
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.getRowHeight(row, height);
      });
      this.addHook("modifyColumnHeaderHeight", function() {
        return _this2.getColumnHeaderHeight();
      });
      _get$F(_getPrototypeOf$N(AutoRowSize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      this.headerHeight = null;
      _get$F(_getPrototypeOf$N(AutoRowSize2.prototype), "disablePlugin", this).call(this);
      this.addHook("beforeRowResize", function(size, row, isDblClick) {
        return _this3.onBeforeRowResize(size, row, isDblClick);
      });
    }
    /**
     * Calculate a given rows height.
     *
     * @param {number|object} rowRange Row index or an object with `from` and `to` indexes as a range.
     * @param {number|object} colRange Column index or an object with `from` and `to` indexes as a range.
     * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
     */
  }, {
    key: "calculateRowsHeight",
    value: function calculateRowsHeight() {
      var _this4 = this;
      var rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var colRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var rowsRange = typeof rowRange === "number" ? {
        from: rowRange,
        to: rowRange
      } : rowRange;
      var columnsRange = typeof colRange === "number" ? {
        from: colRange,
        to: colRange
      } : colRange;
      if (this.hot.getColHeader(0) !== null) {
        var samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);
        this.ghostTable.addColumnHeadersRow(samples.get(-1));
      }
      rangeEach(rowsRange.from, rowsRange.to, function(row) {
        if (force || _this4.rowHeightsMap.getValueAtIndex(row) === null) {
          var _samples = _this4.samplesGenerator.generateRowSamples(row, columnsRange);
          arrayEach(_samples, function(_ref2) {
            var _ref22 = _slicedToArray$u(_ref2, 2), rowIndex = _ref22[0], sample = _ref22[1];
            return _this4.ghostTable.addRow(rowIndex, sample);
          });
        }
      });
      if (this.ghostTable.rows.length) {
        this.hot.batchExecution(function() {
          _this4.ghostTable.getHeights(function(row, height) {
            if (row < 0) {
              _this4.headerHeight = height;
            } else {
              _this4.rowHeightsMap.setValueAtIndex(_this4.hot.toPhysicalRow(row), height);
            }
          });
        }, true);
        this.measuredRows = rowsRange.to + 1;
        this.ghostTable.clean();
      }
    }
    /**
     * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.
     * To retrieve height for specified row use {@link AutoRowSize#getRowHeight} method.
     *
     * @param {object|number} colRange Row index or an object with `from` and `to` properties which define row range.
     */
  }, {
    key: "calculateAllRowsHeight",
    value: function calculateAllRowsHeight() {
      var _this5 = this;
      var colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var current = 0;
      var length = this.hot.countRows() - 1;
      var timer = null;
      this.inProgress = true;
      var loop = function loop2() {
        if (!_this5.hot) {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          return;
        }
        _this5.calculateRowsHeight({
          from: current,
          to: Math.min(current + AutoRowSize2.CALCULATION_STEP, length)
        }, colRange);
        current = current + AutoRowSize2.CALCULATION_STEP + 1;
        if (current < length) {
          timer = requestAnimationFrame(loop2);
        } else {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          _this5.hot.view.adjustElementsSize(true);
          if (_this5.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {
            _this5.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();
          }
        }
      };
      var syncLimit = this.getSyncCalculationLimit();
      if (this.firstCalculation && syncLimit >= 0) {
        this.calculateRowsHeight({
          from: 0,
          to: syncLimit
        }, colRange);
        this.firstCalculation = false;
        current = syncLimit + 1;
      }
      if (current < length) {
        loop();
      } else {
        this.inProgress = false;
        this.hot.view.adjustElementsSize(false);
      }
    }
    /**
     * Sets the sampling options.
     *
     * @private
     */
  }, {
    key: "setSamplingOptions",
    value: function setSamplingOptions() {
      var setting = this.hot.getSettings()[PLUGIN_KEY$u];
      var samplingRatio = setting && hasOwnProperty$2(setting, "samplingRatio") ? setting.samplingRatio : void 0;
      var allowSampleDuplicates = setting && hasOwnProperty$2(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
      if (samplingRatio && !isNaN(samplingRatio)) {
        this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
      }
      if (allowSampleDuplicates) {
        this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
      }
    }
    /**
     * Recalculates all rows height (overwrite cache values).
     */
  }, {
    key: "recalculateAllRowsHeight",
    value: function recalculateAllRowsHeight() {
      if (isVisible(this.hot.view._wt.wtTable.TABLE)) {
        this.clearCache();
        this.calculateAllRowsHeight();
      }
    }
    /**
     * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated
     * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).
     *
     * @returns {number}
     */
  }, {
    key: "getSyncCalculationLimit",
    value: function getSyncCalculationLimit() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$u];
      var limit = AutoRowSize2.SYNC_CALCULATION_LIMIT;
      var rowsLimit = this.hot.countRows() - 1;
      if (isObject$7(settings)) {
        limit = settings.syncLimit;
        if (isPercentValue(limit)) {
          limit = valueAccordingPercent(rowsLimit, limit);
        } else {
          limit >>= 0;
        }
      }
      return Math.min(limit, rowsLimit);
    }
    /**
     * Gets the calculated row height.
     *
     * Mind that this method is different from the [Core](@/api/core.md)'s [`getRowHeight()`](@/api/core.md#getrowheight) method.
     *
     * @param {number} row Visual row index.
     * @param {number} [defaultHeight] Default row height. It will be picked up if no calculated height found.
     * @returns {number}
     */
  }, {
    key: "getRowHeight",
    value: function getRowHeight(row) {
      var defaultHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      var cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));
      var height = defaultHeight;
      if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {
        height = cachedHeight;
      }
      return height;
    }
    /**
     * Get the calculated column header height.
     *
     * @returns {number|undefined}
     */
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight() {
      return this.headerHeight;
    }
    /**
     * Get the first visible row.
     *
     * @returns {number} Returns row index, -1 if table is not rendered or if there are no rows to base the the calculations on.
     */
  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow4() {
      var wot = this.hot.view._wt;
      if (wot.wtViewport.rowsVisibleCalculator) {
        return wot.wtTable.getFirstVisibleRow();
      }
      if (wot.wtViewport.rowsRenderCalculator) {
        return wot.wtTable.getFirstRenderedRow();
      }
      return -1;
    }
    /**
     * Gets the last visible row.
     *
     * @returns {number} Returns row index or -1 if table is not rendered.
     */
  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow4() {
      var wot = this.hot.view._wt;
      if (wot.wtViewport.rowsVisibleCalculator) {
        return wot.wtTable.getLastVisibleRow();
      }
      if (wot.wtViewport.rowsRenderCalculator) {
        return wot.wtTable.getLastRenderedRow();
      }
      return -1;
    }
    /**
     * Clears cached heights.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.headerHeight = null;
      this.rowHeightsMap.init();
    }
    /**
     * Clears cache by range.
     *
     * @param {object|number} range Row index or an object with `from` and `to` properties which define row range.
     */
  }, {
    key: "clearCacheByRange",
    value: function clearCacheByRange(range) {
      var _this6 = this;
      var _ref3 = typeof range === "number" ? {
        from: range,
        to: range
      } : range, from3 = _ref3.from, to = _ref3.to;
      this.hot.batchExecution(function() {
        rangeEach(Math.min(from3, to), Math.max(from3, to), function(row) {
          _this6.rowHeightsMap.setValueAtIndex(row, null);
        });
      }, true);
    }
    /**
     * Checks if all heights were calculated. If not then return `true` (need recalculate).
     *
     * @returns {boolean}
     */
  }, {
    key: "isNeedRecalculate",
    value: function isNeedRecalculate() {
      return !!arrayFilter(this.rowHeightsMap.getValues().slice(0, this.measuredRows), function(item) {
        return item === null;
      }).length;
    }
    /**
     * On before view render listener.
     *
     * @private
     */
  }, {
    key: "onBeforeViewRender",
    value: function onBeforeViewRender() {
      var force = this.hot.renderCall;
      var fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;
      var firstVisibleRow = this.getFirstVisibleRow();
      var lastVisibleRow = this.getLastVisibleRow();
      if (firstVisibleRow === -1 || lastVisibleRow === -1) {
        return;
      }
      this.calculateRowsHeight({
        from: firstVisibleRow,
        to: lastVisibleRow
      }, void 0, force);
      if (fixedRowsBottom) {
        var totalRows = this.hot.countRows() - 1;
        this.calculateRowsHeight({
          from: totalRows - fixedRowsBottom,
          to: totalRows
        });
      }
      if (this.isNeedRecalculate() && !this.inProgress) {
        this.calculateAllRowsHeight();
      }
    }
    /**
     * On before row move listener.
     *
     * @private
     * @param {number} from Row index where was grabbed.
     * @param {number} to Destination row index.
     */
  }, {
    key: "onBeforeRowMove",
    value: function onBeforeRowMove(from3, to) {
      this.clearCacheByRange({
        from: from3,
        to
      });
      this.calculateAllRowsHeight();
    }
    /**
     * On before row resize listener.
     *
     * @private
     * @param {number} size The size of the current row index.
     * @param {number} row Current row index.
     * @param {boolean} isDblClick Indicates if the resize was triggered by doubleclick.
     * @returns {number}
     */
  }, {
    key: "onBeforeRowResize",
    value: function onBeforeRowResize(size, row, isDblClick) {
      var newSize = size;
      if (isDblClick) {
        this.calculateRowsHeight(row, void 0, true);
        newSize = this.getRowHeight(row);
      }
      return newSize;
    }
    /**
     * On after load data listener.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      var _this7 = this;
      if (this.hot.view) {
        this.recalculateAllRowsHeight();
      } else {
        setTimeout(function() {
          if (_this7.hot) {
            _this7.recalculateAllRowsHeight();
          }
        }, 0);
      }
    }
    /**
     * On before change listener.
     *
     * @private
     * @param {Array} changes 2D array containing information about each of the edited cells.
     */
  }, {
    key: "onBeforeChange",
    value: function onBeforeChange(changes) {
      var range = null;
      if (changes.length === 1) {
        range = changes[0][0];
      } else if (changes.length > 1) {
        range = {
          from: changes[0][0],
          to: changes[changes.length - 1][0]
        };
      }
      if (range !== null) {
        this.clearCacheByRange(range);
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.ghostTable.clean();
      _get$F(_getPrototypeOf$N(AutoRowSize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$u;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$t;
    }
  }, {
    key: "SETTING_KEYS",
    get: function get2() {
      return true;
    }
  }, {
    key: "CALCULATION_STEP",
    get: function get2() {
      return 50;
    }
  }, {
    key: "SYNC_CALCULATION_LIMIT",
    get: function get2() {
      return 500;
    }
  }]);
  return AutoRowSize2;
}(BasePlugin);
function _typeof$O(obj) {
  "@babel/helpers - typeof";
  return _typeof$O = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$O(obj);
}
function _classCallCheck$1h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1h(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$E() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$E = Reflect.get.bind();
  } else {
    _get$E = function _get2(target, property, receiver) {
      var base = _superPropBase$E(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$E.apply(this, arguments);
}
function _superPropBase$E(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$M(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$M(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$M(subClass, superClass);
}
function _setPrototypeOf$M(o, p2) {
  _setPrototypeOf$M = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$M(o, p2);
}
function _createSuper$M(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$M();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$M(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$M(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$M(this, result);
  };
}
function _possibleConstructorReturn$M(self2, call2) {
  if (call2 && (_typeof$O(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$M(self2);
}
function _assertThisInitialized$M(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$M() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$M(o) {
  _getPrototypeOf$M = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$M(o);
}
var _alterUtilsFactory$1 = alterUtilsFactory("physicallyIndexed"), getListWithInsertedItems$1 = _alterUtilsFactory$1.getListWithInsertedItems, getListWithRemovedItems$1 = _alterUtilsFactory$1.getListWithRemovedItems;
var LooseBindsMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$M(LooseBindsMap2, _IndexMap);
  var _super = _createSuper$M(LooseBindsMap2);
  function LooseBindsMap2() {
    _classCallCheck$1h(this, LooseBindsMap2);
    return _super.call(this, function(index2) {
      return index2;
    });
  }
  _createClass$1h(LooseBindsMap2, [{
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      var listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);
      this.indexedValues = getListWithInsertedItems$1(listAfterUpdate, insertionIndex, insertedIndexes, this.initValueOrFn);
      _get$E(_getPrototypeOf$M(LooseBindsMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
    /**
     * Remove values from the list and reorganize.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      var listAfterUpdate = getListWithRemovedItems$1(this.indexedValues, removedIndexes);
      this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);
      _get$E(_getPrototypeOf$M(LooseBindsMap2.prototype), "remove", this).call(this, removedIndexes);
    }
  }]);
  return LooseBindsMap2;
}(IndexMap);
const LooseBindsMap$1 = LooseBindsMap;
function _typeof$N(obj) {
  "@babel/helpers - typeof";
  return _typeof$N = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$N(obj);
}
function _toConsumableArray$g(arr) {
  return _arrayWithoutHoles$g(arr) || _iterableToArray$i(arr) || _unsupportedIterableToArray$J(arr) || _nonIterableSpread$g();
}
function _nonIterableSpread$g() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$J(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$J(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$J(o, minLen);
}
function _iterableToArray$i(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$g(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$J(arr);
}
function _arrayLikeToArray$J(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1g(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$D() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$D = Reflect.get.bind();
  } else {
    _get$D = function _get2(target, property, receiver) {
      var base = _superPropBase$D(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$D.apply(this, arguments);
}
function _superPropBase$D(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$L(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$L(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$L(subClass, superClass);
}
function _setPrototypeOf$L(o, p2) {
  _setPrototypeOf$L = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$L(o, p2);
}
function _createSuper$L(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$L();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$L(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$L(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$L(this, result);
  };
}
function _possibleConstructorReturn$L(self2, call2) {
  if (call2 && (_typeof$N(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$L(self2);
}
function _assertThisInitialized$L(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$L() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$L(o) {
  _getPrototypeOf$L = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$L(o);
}
var _alterUtilsFactory = alterUtilsFactory("physicallyIndexed"), getListWithInsertedItems = _alterUtilsFactory.getListWithInsertedItems, getListWithRemovedItems = _alterUtilsFactory.getListWithRemovedItems;
var StrictBindsMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$L(StrictBindsMap2, _IndexMap);
  var _super = _createSuper$L(StrictBindsMap2);
  function StrictBindsMap2() {
    _classCallCheck$1g(this, StrictBindsMap2);
    return _super.call(this, function(index2) {
      return index2;
    });
  }
  _createClass$1g(StrictBindsMap2, [{
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      var _this = this;
      this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, function(_, ordinalNumber) {
        return _this.getNextValue(ordinalNumber);
      });
      _get$D(_getPrototypeOf$L(StrictBindsMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
    /**
     * Remove values from the list and reorganize.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);
      _get$D(_getPrototypeOf$L(StrictBindsMap2.prototype), "remove", this).call(this, removedIndexes);
    }
    /**
     * Get next values, which should be greater than actual maximum value in the list.
     *
     * @param {number} ordinalNumber Position in the list.
     * @returns {number}
     */
  }, {
    key: "getNextValue",
    value: function getNextValue(ordinalNumber) {
      return Math.max.apply(Math, _toConsumableArray$g(this.getValues())) + 1 + ordinalNumber;
    }
  }]);
  return StrictBindsMap2;
}(IndexMap);
const StrictBindsMap$1 = StrictBindsMap;
function _typeof$M(obj) {
  "@babel/helpers - typeof";
  return _typeof$M = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$M(obj);
}
function _classCallCheck$1f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1f(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$C() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$C = Reflect.get.bind();
  } else {
    _get$C = function _get2(target, property, receiver) {
      var base = _superPropBase$C(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$C.apply(this, arguments);
}
function _superPropBase$C(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$K(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$K(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$K(subClass, superClass);
}
function _setPrototypeOf$K(o, p2) {
  _setPrototypeOf$K = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$K(o, p2);
}
function _createSuper$K(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$K();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$K(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$K(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$K(this, result);
  };
}
function _possibleConstructorReturn$K(self2, call2) {
  if (call2 && (_typeof$M(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$K(self2);
}
function _assertThisInitialized$K(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$K() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$K(o) {
  _getPrototypeOf$K = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$K(o);
}
var PLUGIN_KEY$t = "bindRowsWithHeaders";
var PLUGIN_PRIORITY$s = 210;
var DEFAULT_BIND = "loose";
var bindTypeToMapStrategy = /* @__PURE__ */ new Map([["loose", LooseBindsMap$1], ["strict", StrictBindsMap$1]]);
var BindRowsWithHeaders = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$K(BindRowsWithHeaders2, _BasePlugin);
  var _super = _createSuper$K(BindRowsWithHeaders2);
  function BindRowsWithHeaders2(hotInstance) {
    var _this;
    _classCallCheck$1f(this, BindRowsWithHeaders2);
    _this = _super.call(this, hotInstance);
    _this.headerIndexes = null;
    return _this;
  }
  _createClass$1f(BindRowsWithHeaders2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$t];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var bindType = this.hot.getSettings()[PLUGIN_KEY$t];
      if (typeof bindType !== "string") {
        bindType = DEFAULT_BIND;
      }
      var MapStrategy = bindTypeToMapStrategy.get(bindType);
      this.headerIndexes = this.hot.rowIndexMapper.registerMap("bindRowsWithHeaders", new MapStrategy());
      this.addHook("modifyRowHeader", function(row) {
        return _this2.onModifyRowHeader(row);
      });
      _get$C(_getPrototypeOf$K(BindRowsWithHeaders2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap("bindRowsWithHeaders");
      _get$C(_getPrototypeOf$K(BindRowsWithHeaders2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * On modify row header listener.
     *
     * @private
     * @param {number} row Row index.
     * @returns {number}
     */
  }, {
    key: "onModifyRowHeader",
    value: function onModifyRowHeader(row) {
      return this.headerIndexes.getValueAtIndex(this.hot.toPhysicalRow(row));
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$C(_getPrototypeOf$K(BindRowsWithHeaders2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$t;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$s;
    }
  }]);
  return BindRowsWithHeaders2;
}(BasePlugin);
function _typeof$L(obj) {
  "@babel/helpers - typeof";
  return _typeof$L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$L(obj);
}
function _toConsumableArray$f(arr) {
  return _arrayWithoutHoles$f(arr) || _iterableToArray$h(arr) || _unsupportedIterableToArray$I(arr) || _nonIterableSpread$f();
}
function _nonIterableSpread$f() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$I(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$I(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$I(o, minLen);
}
function _iterableToArray$h(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$f(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$I(arr);
}
function _arrayLikeToArray$I(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1e(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$B() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$B = Reflect.get.bind();
  } else {
    _get$B = function _get2(target, property, receiver) {
      var base = _superPropBase$B(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$B.apply(this, arguments);
}
function _superPropBase$B(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$J(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$J(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$J(subClass, superClass);
}
function _setPrototypeOf$J(o, p2) {
  _setPrototypeOf$J = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$J(o, p2);
}
function _createSuper$J(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$J();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$J(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$J(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$J(this, result);
  };
}
function _possibleConstructorReturn$J(self2, call2) {
  if (call2 && (_typeof$L(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$J(self2);
}
function _assertThisInitialized$J(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$J() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$J(o) {
  _getPrototypeOf$J = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$J(o);
}
function _classPrivateFieldInitSpec$7(obj, privateMap, value) {
  _checkPrivateRedeclaration$7(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$7(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldGet$7(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$7(receiver, privateMap, "get");
  return _classApplyDescriptorGet$7(receiver, descriptor);
}
function _classApplyDescriptorGet$7(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$7(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$7(receiver, privateMap, "set");
  _classApplyDescriptorSet$7(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$7(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$7(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var PLUGIN_KEY$s = "collapsibleColumns";
var PLUGIN_PRIORITY$r = 290;
var SETTING_KEYS$1 = ["nestedHeaders"];
var actionDictionary = /* @__PURE__ */ new Map([["collapse", {
  hideColumn: true,
  beforeHook: "beforeColumnCollapse",
  afterHook: "afterColumnCollapse"
}], ["expand", {
  hideColumn: false,
  beforeHook: "beforeColumnExpand",
  afterHook: "afterColumnExpand"
}]]);
var _collapsedColumnsMap = /* @__PURE__ */ new WeakMap();
var CollapsibleColumns = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$J(CollapsibleColumns2, _BasePlugin);
  var _super = _createSuper$J(CollapsibleColumns2);
  function CollapsibleColumns2() {
    var _this;
    _classCallCheck$1e(this, CollapsibleColumns2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$g(_assertThisInitialized$J(_this), "nestedHeadersPlugin", null);
    _defineProperty$g(_assertThisInitialized$J(_this), "eventManager", new EventManager$1(_assertThisInitialized$J(_this)));
    _defineProperty$g(_assertThisInitialized$J(_this), "headerStateManager", null);
    _classPrivateFieldInitSpec$7(_assertThisInitialized$J(_this), _collapsedColumnsMap, {
      writable: true,
      value: null
    });
    return _this;
  }
  _createClass$1e(CollapsibleColumns2, [{
    key: "isEnabled",
    value: (
      /**
       * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
       * hook and if it returns `true` than the {@link CollapsibleColumns#enablePlugin} method is called.
       *
       * @returns {boolean}
       */
      function isEnabled() {
        return !!this.hot.getSettings()[PLUGIN_KEY$s];
      }
    )
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var _this$hot$getSettings = this.hot.getSettings(), nestedHeaders = _this$hot$getSettings.nestedHeaders;
      if (!nestedHeaders) {
        warn$1("You need to configure the Nested Headers plugin in order to use collapsible headers.");
      }
      _classPrivateFieldSet$7(this, _collapsedColumnsMap, this.hot.columnIndexMapper.createAndRegisterIndexMap(this.pluginName, "hiding"));
      this.nestedHeadersPlugin = this.hot.getPlugin("nestedHeaders");
      this.headerStateManager = this.nestedHeadersPlugin.getStateManager();
      this.addHook("init", function() {
        return _this2.onInit();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.addHook("afterGetColHeader", function(col, TH) {
        return _this2.onAfterGetColHeader(col, TH);
      });
      this.addHook("beforeOnCellMouseDown", function(event2, coords, TD) {
        return _this2.onBeforeOnCellMouseDown(event2, coords, TD);
      });
      _get$B(_getPrototypeOf$J(CollapsibleColumns2.prototype), "enablePlugin", this).call(this);
      this.updatePlugin();
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *   - [`collapsibleColumns`](@/api/options.md#collapsiblecolumns)
     *   - [`nestedHeaders`](@/api/options.md#nestedheaders)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      if (!this.hot.view) {
        return;
      }
      if (!this.nestedHeadersPlugin.detectedOverlappedHeaders) {
        var _this$hot$getSettings2 = this.hot.getSettings(), collapsibleColumns = _this$hot$getSettings2.collapsibleColumns;
        if (typeof collapsibleColumns === "boolean") {
          this.headerStateManager.mapState(function(headerSettings) {
            return {
              collapsible: headerSettings.origColspan > 1
            };
          });
        } else if (Array.isArray(collapsibleColumns)) {
          this.headerStateManager.mapState(function() {
            return {
              collapsible: false
            };
          });
          this.headerStateManager.mergeStateWith(collapsibleColumns);
        }
      }
      _get$B(_getPrototypeOf$J(CollapsibleColumns2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.columnIndexMapper.unregisterMap(this.pluginName);
      _classPrivateFieldSet$7(this, _collapsedColumnsMap, null);
      this.nestedHeadersPlugin = null;
      this.clearButtons();
      _get$B(_getPrototypeOf$J(CollapsibleColumns2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Clears the expand/collapse buttons.
     *
     * @private
     */
  }, {
    key: "clearButtons",
    value: function clearButtons() {
      if (!this.hot.view) {
        return;
      }
      var headerLevels = this.hot.view._wt.getSetting("columnHeaders").length;
      var mainHeaders = this.hot.view._wt.wtTable.THEAD;
      var topHeaders = this.hot.view._wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
      var topLeftCornerHeaders = this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay ? this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;
      var removeButton = function removeButton2(button) {
        if (button) {
          button.parentNode.removeChild(button);
        }
      };
      rangeEach(0, headerLevels - 1, function(i) {
        var masterLevel = mainHeaders.childNodes[i];
        var topLevel = topHeaders.childNodes[i];
        var topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
        rangeEach(0, masterLevel.childNodes.length - 1, function(j) {
          var button = masterLevel.childNodes[j].querySelector(".collapsibleIndicator");
          removeButton(button);
          if (topLevel && topLevel.childNodes[j]) {
            button = topLevel.childNodes[j].querySelector(".collapsibleIndicator");
            removeButton(button);
          }
          if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
            button = topLeftCornerLevel.childNodes[j].querySelector(".collapsibleIndicator");
            removeButton(button);
          }
        });
      });
    }
    /**
     * Expands section at the provided coords.
     *
     * @param {object} coords Contains coordinates information. (`coords.row`, `coords.col`).
     */
  }, {
    key: "expandSection",
    value: function expandSection(coords) {
      this.toggleCollapsibleSection([coords], "expand");
    }
    /**
     * Collapses section at the provided coords.
     *
     * @param {object} coords Contains coordinates information. (`coords.row`, `coords.col`).
     */
  }, {
    key: "collapseSection",
    value: function collapseSection(coords) {
      this.toggleCollapsibleSection([coords], "collapse");
    }
    /**
     * Collapses or expand all collapsible sections, depending on the action parameter.
     *
     * @param {string} action 'collapse' or 'expand'.
     */
  }, {
    key: "toggleAllCollapsibleSections",
    value: function toggleAllCollapsibleSections(action) {
      var _this3 = this;
      var coords = this.headerStateManager.mapNodes(function(headerSettings) {
        var collapsible = headerSettings.collapsible, origColspan = headerSettings.origColspan, headerLevel = headerSettings.headerLevel, columnIndex = headerSettings.columnIndex, isCollapsed = headerSettings.isCollapsed;
        if (collapsible === true && origColspan > 1 && (isCollapsed && action === "expand" || !isCollapsed && action === "collapse")) {
          return {
            row: _this3.headerStateManager.levelToRowCoords(headerLevel),
            col: columnIndex
          };
        }
      });
      this.toggleCollapsibleSection(coords, action);
    }
    /**
     * Collapses all collapsible sections.
     */
  }, {
    key: "collapseAll",
    value: function collapseAll() {
      this.toggleAllCollapsibleSections("collapse");
    }
    /**
     * Expands all collapsible sections.
     */
  }, {
    key: "expandAll",
    value: function expandAll() {
      this.toggleAllCollapsibleSections("expand");
    }
    /**
     * Collapses/Expands a section.
     *
     * @param {Array} coords Array of coords - section coordinates.
     * @param {string} [action] Action definition ('collapse' or 'expand').
     * @fires Hooks#beforeColumnCollapse
     * @fires Hooks#beforeColumnExpand
     * @fires Hooks#afterColumnCollapse
     * @fires Hooks#afterColumnExpand
     */
  }, {
    key: "toggleCollapsibleSection",
    value: function toggleCollapsibleSection(coords, action) {
      var _this4 = this;
      if (!actionDictionary.has(action)) {
        throw new Error("Unsupported action is passed (".concat(action, ")."));
      }
      if (!Array.isArray(coords)) {
        return;
      }
      var filteredCoords = arrayFilter(coords, function(_ref2) {
        var row = _ref2.row;
        return row < 0;
      });
      var isActionPossible = filteredCoords.length > 0;
      arrayEach(filteredCoords, function(_ref2) {
        var _this4$headerStateMan;
        var row = _ref2.row, column = _ref2.col;
        var _ref3 = (_this4$headerStateMan = _this4.headerStateManager.getHeaderSettings(row, column)) !== null && _this4$headerStateMan !== void 0 ? _this4$headerStateMan : {}, collapsible = _ref3.collapsible, isCollapsed = _ref3.isCollapsed;
        if (!collapsible || isCollapsed && action === "collapse" || !isCollapsed && action === "expand") {
          isActionPossible = false;
          return false;
        }
      });
      var nodeModRollbacks = [];
      var affectedColumnsIndexes = [];
      if (isActionPossible) {
        arrayEach(filteredCoords, function(_ref4) {
          var row = _ref4.row, column = _ref4.col;
          var _this4$headerStateMan2 = _this4.headerStateManager.triggerNodeModification(action, row, column), colspanCompensation = _this4$headerStateMan2.colspanCompensation, affectedColumns = _this4$headerStateMan2.affectedColumns, rollbackModification = _this4$headerStateMan2.rollbackModification;
          if (colspanCompensation > 0) {
            affectedColumnsIndexes.push.apply(affectedColumnsIndexes, _toConsumableArray$f(affectedColumns));
            nodeModRollbacks.push(rollbackModification);
          }
        });
      }
      var currentCollapsedColumns = this.getCollapsedColumns();
      var destinationCollapsedColumns = [];
      if (action === "collapse") {
        destinationCollapsedColumns = arrayUnique([].concat(_toConsumableArray$f(currentCollapsedColumns), affectedColumnsIndexes));
      } else if (action === "expand") {
        destinationCollapsedColumns = arrayFilter(currentCollapsedColumns, function(index2) {
          return !affectedColumnsIndexes.includes(index2);
        });
      }
      var actionTranslator = actionDictionary.get(action);
      var isActionAllowed = this.hot.runHooks(actionTranslator.beforeHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible);
      if (isActionAllowed === false) {
        arrayEach(nodeModRollbacks, function(nodeModRollback) {
          nodeModRollback();
        });
        return;
      }
      this.hot.batchExecution(function() {
        arrayEach(affectedColumnsIndexes, function(visualColumn) {
          _classPrivateFieldGet$7(_this4, _collapsedColumnsMap).setValueAtIndex(_this4.hot.toPhysicalColumn(visualColumn), actionTranslator.hideColumn);
        });
      }, true);
      var isActionPerformed = this.getCollapsedColumns().length !== currentCollapsedColumns.length;
      this.hot.runHooks(actionTranslator.afterHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible, isActionPerformed);
      this.hot.render();
      this.hot.view.adjustElementsSize(true);
    }
    /**
     * Gets an array of physical indexes of collapsed columns.
     *
     * @private
     * @returns {number[]}
     */
  }, {
    key: "getCollapsedColumns",
    value: function getCollapsedColumns() {
      return _classPrivateFieldGet$7(this, _collapsedColumnsMap).getHiddenIndexes();
    }
    /**
     * Generates the indicator element.
     *
     * @private
     * @param {number} row Row index.
     * @param {number} column Column index.
     * @returns {HTMLElement}
     */
  }, {
    key: "generateIndicator",
    value: function generateIndicator(row, column) {
      var divEl = this.hot.rootDocument.createElement("div");
      var columnSettings = this.headerStateManager.getHeaderSettings(row, column);
      addClass(divEl, "collapsibleIndicator");
      if (columnSettings.isCollapsed) {
        addClass(divEl, "collapsed");
        fastInnerText(divEl, "+");
      } else {
        addClass(divEl, "expanded");
        fastInnerText(divEl, "-");
      }
      return divEl;
    }
    /**
     * Adds the indicator to the headers.
     *
     * @private
     * @param {number} column Column index.
     * @param {HTMLElement} TH TH element.
     */
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(column, TH) {
      var _this$headerStateMana;
      var TR = TH.parentNode;
      var THEAD = TR.parentNode;
      var row = -1 * THEAD.childNodes.length + Array.prototype.indexOf.call(THEAD.childNodes, TR);
      var _ref5 = (_this$headerStateMana = this.headerStateManager.getHeaderSettings(row, column)) !== null && _this$headerStateMana !== void 0 ? _this$headerStateMana : {}, collapsible = _ref5.collapsible, origColspan = _ref5.origColspan;
      if (collapsible && origColspan > 1 && column >= this.hot.getSettings().fixedColumnsStart) {
        var button = this.generateIndicator(row, column);
        TH.querySelector("div:first-child").appendChild(button);
      }
    }
    /**
     * Indicator mouse event callback.
     *
     * @private
     * @param {object} event Mouse event.
     * @param {object} coords Event coordinates.
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords) {
      if (hasClass(event2.target, "collapsibleIndicator")) {
        if (hasClass(event2.target, "expanded")) {
          this.eventManager.fireEvent(event2.target, "mouseup");
          this.toggleCollapsibleSection([coords], "collapse");
        } else if (hasClass(event2.target, "collapsed")) {
          this.eventManager.fireEvent(event2.target, "mouseup");
          this.toggleCollapsibleSection([coords], "expand");
        }
        stopImmediatePropagation(event2);
      }
    }
    /**
     * Updates the plugin state after HoT initialization.
     *
     * @private
     */
  }, {
    key: "onInit",
    value: function onInit() {
      this.updatePlugin();
    }
    /**
     * Updates the plugin state after new dataset load.
     *
     * @private
     * @param {Array[]} sourceData Array of arrays or array of objects containing data.
     * @param {boolean} initialLoad Flag that determines whether the data has been loaded
     *                              during the initialization.
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(sourceData, initialLoad) {
      if (!initialLoad) {
        this.updatePlugin();
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet$7(this, _collapsedColumnsMap, null);
      _get$B(_getPrototypeOf$J(CollapsibleColumns2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$s;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$r;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get2() {
      return ["plugin:NestedHeaders"];
    }
  }, {
    key: "SETTING_KEYS",
    get: function get2() {
      return [PLUGIN_KEY$s].concat(SETTING_KEYS$1);
    }
    /**
     * Cached reference to the NestedHeaders plugin.
     *
     * @private
     * @type {NestedHeaders}
     */
  }]);
  return CollapsibleColumns2;
}(BasePlugin);
function ownKeys$8(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
      _defineProperty$f(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$t(arr, i) {
  return _arrayWithHoles$v(arr) || _iterableToArrayLimit$t(arr, i) || _unsupportedIterableToArray$H(arr, i) || _nonIterableRest$v();
}
function _nonIterableRest$v() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$H(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$H(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$H(o, minLen);
}
function _arrayLikeToArray$H(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$t(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$v(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1d(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var inheritedColumnProperties = ["sortEmptyCells", "indicator", "headerAction", "compareFunctionFactory"];
var SORT_EMPTY_CELLS_DEFAULT = false;
var SHOW_SORT_INDICATOR_DEFAULT = true;
var HEADER_ACTION_DEFAULT = true;
var ColumnStatesManager = /* @__PURE__ */ function() {
  function ColumnStatesManager2(hot, mapName) {
    _classCallCheck$1d(this, ColumnStatesManager2);
    this.hot = hot;
    this.sortingStates = new LinkedPhysicalIndexToValueMap();
    this.sortEmptyCells = SORT_EMPTY_CELLS_DEFAULT;
    this.indicator = SHOW_SORT_INDICATOR_DEFAULT;
    this.headerAction = HEADER_ACTION_DEFAULT;
    this.compareFunctionFactory = void 0;
    this.mapName = mapName;
    this.hot.columnIndexMapper.registerMap(mapName, this.sortingStates);
  }
  _createClass$1d(ColumnStatesManager2, [{
    key: "updateAllColumnsProperties",
    value: function updateAllColumnsProperties(allSortSettings) {
      var _this = this;
      if (!isObject$7(allSortSettings)) {
        return;
      }
      objectEach(allSortSettings, function(newValue, propertyName) {
        if (inheritedColumnProperties.includes(propertyName)) {
          _this[propertyName] = newValue;
        }
      });
    }
    /**
     * Get all column properties which affect the sorting result.
     *
     * @returns {object}
     */
  }, {
    key: "getAllColumnsProperties",
    value: function getAllColumnsProperties() {
      var columnProperties = {
        sortEmptyCells: this.sortEmptyCells,
        indicator: this.indicator,
        headerAction: this.headerAction
      };
      if (typeof this.compareFunctionFactory === "function") {
        columnProperties.compareFunctionFactory = this.compareFunctionFactory;
      }
      return columnProperties;
    }
    /**
     * Get sort order of column.
     *
     * @param {number} searchedColumn Visual column index.
     * @returns {string|undefined} Sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).
     */
  }, {
    key: "getSortOrderOfColumn",
    value: function getSortOrderOfColumn(searchedColumn) {
      var _this$sortingStates$g;
      return (_this$sortingStates$g = this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(searchedColumn))) === null || _this$sortingStates$g === void 0 ? void 0 : _this$sortingStates$g.sortOrder;
    }
    /**
     * Get order of particular column in the states queue.
     *
     * @param {number} column Visual column index.
     * @returns {number}
     */
  }, {
    key: "getIndexOfColumnInSortQueue",
    value: function getIndexOfColumnInSortQueue(column) {
      column = this.hot.toPhysicalColumn(column);
      return this.sortingStates.getEntries().findIndex(function(_ref2) {
        var _ref22 = _slicedToArray$t(_ref2, 1), physicalColumn = _ref22[0];
        return physicalColumn === column;
      });
    }
    /**
     * Get number of sorted columns.
     *
     * @returns {number}
     */
  }, {
    key: "getNumberOfSortedColumns",
    value: function getNumberOfSortedColumns() {
      return this.sortingStates.getLength();
    }
    /**
     * Get if list of sorted columns is empty.
     *
     * @returns {boolean}
     */
  }, {
    key: "isListOfSortedColumnsEmpty",
    value: function isListOfSortedColumnsEmpty() {
      return this.getNumberOfSortedColumns() === 0;
    }
    /**
     * Get if particular column is sorted.
     *
     * @param {number} column Visual column index.
     * @returns {boolean}
     */
  }, {
    key: "isColumnSorted",
    value: function isColumnSorted(column) {
      return isObject$7(this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(column)));
    }
    /**
     * Queue of sort states containing sorted columns and their orders (Array of objects containing `column` and `sortOrder` properties).
     *
     * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
     *
     * @returns {Array<object>}
     */
  }, {
    key: "getSortStates",
    value: function getSortStates() {
      var _this2 = this;
      if (this.sortingStates === null) {
        return [];
      }
      var sortingStatesQueue = this.sortingStates.getEntries();
      return sortingStatesQueue.map(function(_ref3) {
        var _ref4 = _slicedToArray$t(_ref3, 2), physicalColumn = _ref4[0], value = _ref4[1];
        return _objectSpread$8({
          column: _this2.hot.toVisualColumn(physicalColumn)
        }, value);
      });
    }
    /**
     * Get sort state for particular column. Object contains `column` and `sortOrder` properties.
     *
     * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
     *
     * @param {number} column Visual column index.
     * @returns {object|undefined}
     */
  }, {
    key: "getColumnSortState",
    value: function getColumnSortState(column) {
      var sortOrder = this.getSortOrderOfColumn(column);
      if (isDefined(sortOrder)) {
        return {
          column,
          sortOrder
        };
      }
    }
    /**
     * Set all column states.
     *
     * @param {Array} sortStates Sort states.
     */
  }, {
    key: "setSortStates",
    value: function setSortStates(sortStates) {
      this.sortingStates.clear();
      for (var i = 0; i < sortStates.length; i += 1) {
        this.sortingStates.setValueAtIndex(this.hot.toPhysicalColumn(sortStates[i].column), {
          sortOrder: sortStates[i].sortOrder
        });
      }
    }
    /**
     * Destroy the state manager.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.hot.columnIndexMapper.unregisterMap(this.mapName);
      this.sortingStates = null;
    }
  }]);
  return ColumnStatesManager2;
}();
var ASC_SORT_STATE = "asc";
var DESC_SORT_STATE = "desc";
var HEADER_SPAN_CLASS = "colHeader";
function isValidColumnState(columnState) {
  if (isObject$7(columnState) === false) {
    return false;
  }
  var column = columnState.column, sortOrder = columnState.sortOrder;
  return Number.isInteger(column) && [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);
}
function areValidSortStates(sortStates) {
  if (sortStates.some(function(columnState) {
    return isValidColumnState(columnState) === false;
  })) {
    return false;
  }
  var sortedColumns = sortStates.map(function(_ref2) {
    var column = _ref2.column;
    return column;
  });
  return new Set(sortedColumns).size === sortedColumns.length;
}
function getNextSortOrder(sortOrder) {
  if (sortOrder === DESC_SORT_STATE) {
    return;
  } else if (sortOrder === ASC_SORT_STATE) {
    return DESC_SORT_STATE;
  }
  return ASC_SORT_STATE;
}
function getHeaderSpanElement(TH) {
  var headerSpanElement = TH.querySelector(".".concat(HEADER_SPAN_CLASS));
  return headerSpanElement;
}
function isFirstLevelColumnHeader(column, TH) {
  if (column < 0 || !TH.parentNode) {
    return false;
  }
  var TRs = TH.parentNode.parentNode.childNodes;
  var headerLevel = Array.from(TRs).indexOf(TH.parentNode) - TRs.length;
  if (headerLevel !== -1) {
    return false;
  }
  return true;
}
function wasHeaderClickedProperly(row, column, clickEvent) {
  return row === -1 && column >= 0 && isRightClick(clickEvent) === false;
}
var HEADER_CLASS_ASC_SORT = "ascending";
var HEADER_CLASS_DESC_SORT = "descending";
var HEADER_CLASS_INDICATOR_DISABLED = "indicatorDisabled";
var HEADER_SORT_CLASS = "columnSorting";
var HEADER_ACTION_CLASS = "sortAction";
var orderToCssClass = /* @__PURE__ */ new Map([[ASC_SORT_STATE, HEADER_CLASS_ASC_SORT], [DESC_SORT_STATE, HEADER_CLASS_DESC_SORT]]);
function getClassesToAdd$1(columnStatesManager, column, showSortIndicator, headerAction) {
  var cssClasses = [HEADER_SORT_CLASS];
  if (headerAction) {
    cssClasses.push(HEADER_ACTION_CLASS);
  }
  if (showSortIndicator === false) {
    cssClasses.push(HEADER_CLASS_INDICATOR_DISABLED);
    return cssClasses;
  }
  var columnOrder = columnStatesManager.getSortOrderOfColumn(column);
  if (isDefined(columnOrder)) {
    cssClasses.push(orderToCssClass.get(columnOrder));
  }
  return cssClasses;
}
function getClassesToRemove$1() {
  return Array.from(orderToCssClass.values()).concat(HEADER_ACTION_CLASS, HEADER_CLASS_INDICATOR_DISABLED, HEADER_SORT_CLASS);
}
function compareFunctionFactory$3(sortOrder, columnMeta, columnPluginSettings) {
  var locale = columnMeta.locale;
  return function(value, nextValue) {
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (typeof value === "string") {
      value = value.toLocaleLowerCase(locale);
    }
    if (typeof nextValue === "string") {
      nextValue = nextValue.toLocaleLowerCase(locale);
    }
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    if (isNaN(value) && !isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    } else if (!isNaN(value) && isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (!(isNaN(value) || isNaN(nextValue))) {
      value = parseFloat(value);
      nextValue = parseFloat(nextValue);
    }
    if (value < nextValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (value > nextValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE$3 = "default";
function compareFunctionFactory$2(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var parsedFirstValue = parseFloat(value);
    var parsedSecondValue = parseFloat(nextValue);
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (parsedFirstValue === parsedSecondValue || isNaN(parsedFirstValue) && isNaN(parsedSecondValue)) {
      return DO_NOT_SWAP;
    }
    if (sortEmptyCells) {
      if (isEmpty(value)) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      if (isEmpty(nextValue)) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
    }
    if (isNaN(parsedFirstValue)) {
      return FIRST_AFTER_SECOND;
    }
    if (isNaN(parsedSecondValue)) {
      return FIRST_BEFORE_SECOND;
    }
    if (parsedFirstValue < parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (parsedFirstValue > parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE$2 = "numeric";
function compareFunctionFactory$1(sortOrder, columnMeta, columnPluginSettings) {
  var checkedTemplate = columnMeta.checkedTemplate;
  var uncheckedTemplate = columnMeta.uncheckedTemplate;
  var sortEmptyCells = columnPluginSettings.sortEmptyCells;
  return function(value, nextValue) {
    var isEmptyValue = isEmpty(value);
    var isEmptyNextValue = isEmpty(nextValue);
    var unifiedValue = isEmptyValue ? uncheckedTemplate : value;
    var unifiedNextValue = isEmptyNextValue ? uncheckedTemplate : nextValue;
    var isValueFromTemplate = unifiedValue === uncheckedTemplate || unifiedValue === checkedTemplate;
    var isNextValueFromTemplate = unifiedNextValue === uncheckedTemplate || unifiedNextValue === checkedTemplate;
    if (sortEmptyCells === false) {
      if (isEmptyValue && isEmptyNextValue === false) {
        return FIRST_AFTER_SECOND;
      }
      if (isEmptyValue === false && isEmptyNextValue) {
        return FIRST_BEFORE_SECOND;
      }
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (isValueFromTemplate && isNextValueFromTemplate === false) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate === false) {
      return compareFunctionFactory$3(sortOrder, columnMeta, columnPluginSettings)(value, nextValue);
    }
    if (unifiedValue === uncheckedTemplate && unifiedNextValue === checkedTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (unifiedValue === checkedTemplate && unifiedNextValue === uncheckedTemplate) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE$1 = "checkbox";
function compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    var dateFormat = columnMeta.dateFormat;
    var firstDate = hooks(value, dateFormat);
    var nextDate = hooks(nextValue, dateFormat);
    if (!firstDate.isValid()) {
      return FIRST_AFTER_SECOND;
    }
    if (!nextDate.isValid()) {
      return FIRST_BEFORE_SECOND;
    }
    if (nextDate.isAfter(firstDate)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (nextDate.isBefore(firstDate)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE = "date";
var _staticRegister = staticRegister("sorting.compareFunctionFactory"), registerCompareFunctionFactory = _staticRegister.register, getGloballyCompareFunctionFactory = _staticRegister.getItem, hasGloballyCompareFunctionFactory = _staticRegister.hasItem;
var _staticRegister2 = staticRegister("sorting.mainSortComparator"), registerRootComparator = _staticRegister2.register, getRootComparator = _staticRegister2.getItem;
function getCompareFunctionFactory(type) {
  if (hasGloballyCompareFunctionFactory(type)) {
    return getGloballyCompareFunctionFactory(type);
  }
  return getGloballyCompareFunctionFactory(COLUMN_DATA_TYPE$3);
}
registerCompareFunctionFactory(COLUMN_DATA_TYPE$2, compareFunctionFactory$2);
registerCompareFunctionFactory(COLUMN_DATA_TYPE$1, compareFunctionFactory$1);
registerCompareFunctionFactory(COLUMN_DATA_TYPE, compareFunctionFactory);
registerCompareFunctionFactory(COLUMN_DATA_TYPE$3, compareFunctionFactory$3);
var DO_NOT_SWAP = 0;
var FIRST_BEFORE_SECOND = -1;
var FIRST_AFTER_SECOND = 1;
function sort2(indexesWithData, rootComparatorId) {
  var rootComparator2 = getRootComparator(rootComparatorId);
  for (var _len = arguments.length, argsForRootComparator = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    argsForRootComparator[_key - 2] = arguments[_key];
  }
  indexesWithData.sort(rootComparator2.apply(void 0, argsForRootComparator));
}
function _toArray$1(arr) {
  return _arrayWithHoles$u(arr) || _iterableToArray$g(arr) || _unsupportedIterableToArray$G(arr) || _nonIterableRest$u();
}
function _nonIterableRest$u() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$G(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$G(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$G(o, minLen);
}
function _arrayLikeToArray$G(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArray$g(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithHoles$u(arr) {
  if (Array.isArray(arr))
    return arr;
}
function rootComparator$1(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    var _rowIndexWithValues = _toArray$1(rowIndexWithValues), values3 = _rowIndexWithValues.slice(1);
    var _nextRowIndexWithValu = _toArray$1(nextRowIndexWithValues), nextValues = _nextRowIndexWithValu.slice(1);
    return function getCompareResult(column) {
      var sortingOrder = sortingOrders[column];
      var columnMeta = columnMetas[column];
      var value = values3[column];
      var nextValue = nextValues[column];
      var pluginSettings = columnMeta.columnSorting;
      var compareFunctionFactory2 = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      var compareResult = compareFunctionFactory2(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      return compareResult;
    }(0);
  };
}
function _typeof$K(obj) {
  "@babel/helpers - typeof";
  return _typeof$K = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$K(obj);
}
var _excluded$3 = ["column"], _excluded2 = ["column"];
function _toConsumableArray$e(arr) {
  return _arrayWithoutHoles$e(arr) || _iterableToArray$f(arr) || _unsupportedIterableToArray$F(arr) || _nonIterableSpread$e();
}
function _nonIterableSpread$e() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$F(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$F(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$F(o, minLen);
}
function _iterableToArray$f(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$e(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$F(arr);
}
function _arrayLikeToArray$F(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys$7(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty$e(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$1c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1c(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$A() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$A = Reflect.get.bind();
  } else {
    _get$A = function _get2(target, property, receiver) {
      var base = _superPropBase$A(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$A.apply(this, arguments);
}
function _superPropBase$A(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$I(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$I(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$I(subClass, superClass);
}
function _setPrototypeOf$I(o, p2) {
  _setPrototypeOf$I = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$I(o, p2);
}
function _createSuper$I(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$I();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$I(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$I(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$I(this, result);
  };
}
function _possibleConstructorReturn$I(self2, call2) {
  if (call2 && (_typeof$K(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$I(self2);
}
function _assertThisInitialized$I(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$I() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$I(o) {
  _getPrototypeOf$I = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$I(o);
}
var PLUGIN_KEY$r = "columnSorting";
var PLUGIN_PRIORITY$q = 50;
var APPEND_COLUMN_CONFIG_STRATEGY$1 = "append";
var REPLACE_COLUMN_CONFIG_STRATEGY = "replace";
registerRootComparator(PLUGIN_KEY$r, rootComparator$1);
Hooks$1.getSingleton().register("beforeColumnSort");
Hooks$1.getSingleton().register("afterColumnSort");
var ColumnSorting = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$I(ColumnSorting2, _BasePlugin);
  var _super = _createSuper$I(ColumnSorting2);
  function ColumnSorting2(hotInstance) {
    var _this;
    _classCallCheck$1c(this, ColumnSorting2);
    _this = _super.call(this, hotInstance);
    _this.columnStatesManager = null;
    _this.columnMetaCache = null;
    _this.pluginKey = PLUGIN_KEY$r;
    _this.indexesSequenceCache = null;
    return _this;
  }
  _createClass$1c(ColumnSorting2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[this.pluginKey];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.columnStatesManager = new ColumnStatesManager(this.hot, "".concat(this.pluginKey, ".sortingStates"));
      this.columnMetaCache = new PhysicalIndexToValueMap(function(physicalIndex) {
        var visualIndex = _this2.hot.toVisualColumn(physicalIndex);
        if (visualIndex === null) {
          visualIndex = physicalIndex;
        }
        return _this2.getMergedPluginSettings(visualIndex);
      });
      this.hot.columnIndexMapper.registerMap("".concat(this.pluginKey, ".columnMeta"), this.columnMetaCache);
      this.addHook("afterGetColHeader", function(column, TH) {
        return _this2.onAfterGetColHeader(column, TH);
      });
      this.addHook("beforeOnCellMouseDown", function() {
        return _this2.onBeforeOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("afterOnCellMouseDown", function(event2, target) {
        return _this2.onAfterOnCellMouseDown(event2, target);
      });
      this.addHook("afterInit", function() {
        return _this2.loadOrSortBySettings();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      if (this.hot.view) {
        this.loadOrSortBySettings();
      }
      _get$A(_getPrototypeOf$I(ColumnSorting2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      var clearColHeader = function clearColHeader2(column, TH) {
        var headerSpanElement = getHeaderSpanElement(TH);
        if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
          return;
        }
        _this3.updateHeaderClasses(headerSpanElement);
      };
      this.hot.addHook("afterGetColHeader", clearColHeader);
      this.hot.addHookOnce("afterViewRender", function() {
        _this3.hot.removeHook("afterGetColHeader", clearColHeader);
      });
      this.hot.batchExecution(function() {
        if (_this3.indexesSequenceCache !== null) {
          _this3.hot.rowIndexMapper.setIndexesSequence(_this3.indexesSequenceCache.getValues());
          _this3.hot.rowIndexMapper.unregisterMap(_this3.pluginKey);
        }
      }, true);
      this.hot.columnIndexMapper.unregisterMap("".concat(this.pluginKey, ".columnMeta"));
      this.columnStatesManager.destroy();
      this.columnMetaCache = null;
      this.columnStatesManager = null;
      _get$A(_getPrototypeOf$I(ColumnSorting2.prototype), "disablePlugin", this).call(this);
    }
    // DIFF - MultiColumnSorting & ColumnSorting: changed function documentation.
    /**
     * Sorts the table by chosen columns and orders.
     *
     * @param {undefined|object} sortConfig Single column sort configuration. The configuration object contains `column` and `sortOrder` properties.
     * First of them contains visual column index, the second one contains sort order (`asc` for ascending, `desc` for descending).
     *
     * **Note**: Please keep in mind that every call of `sort` function set an entirely new sort order. Previous sort configs aren't preserved.
     *
     * @example
     * ```js
     * // sort ascending first visual column
     * hot.getPlugin('columnSorting').sort({ column: 0, sortOrder: 'asc' });
     * ```
     *
     * @fires Hooks#beforeColumnSort
     * @fires Hooks#afterColumnSort
     */
  }, {
    key: "sort",
    value: function sort3(sortConfig) {
      var currentSortConfig = this.getSortConfig();
      var destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
      var sortPossible = this.areValidSortConfigs(destinationSortConfigs);
      var allowSort = this.hot.runHooks("beforeColumnSort", currentSortConfig, destinationSortConfigs, sortPossible);
      if (allowSort === false) {
        return;
      }
      if (currentSortConfig.length === 0 && this.indexesSequenceCache === null) {
        this.indexesSequenceCache = this.hot.rowIndexMapper.registerMap(this.pluginKey, new IndexesSequence());
        this.indexesSequenceCache.setValues(this.hot.rowIndexMapper.getIndexesSequence());
      }
      if (sortPossible) {
        this.columnStatesManager.setSortStates(destinationSortConfigs);
        this.sortByPresetSortStates(destinationSortConfigs);
        this.saveAllSortSettings(destinationSortConfigs);
      }
      this.hot.runHooks("afterColumnSort", currentSortConfig, sortPossible ? destinationSortConfigs : currentSortConfig, sortPossible);
      if (sortPossible) {
        this.hot.render();
        this.hot.forceFullRender = false;
        this.hot.view.render();
      }
    }
    /**
     * Clear the sort performed on the table.
     */
  }, {
    key: "clearSort",
    value: function clearSort() {
      this.sort([]);
    }
    /**
     * Checks if the table is sorted (any column have to be sorted).
     *
     * @returns {boolean}
     */
  }, {
    key: "isSorted",
    value: function isSorted() {
      return this.enabled && !this.columnStatesManager.isListOfSortedColumnsEmpty();
    }
    /**
     * Get sort configuration for particular column or for all sorted columns. Objects contain `column` and `sortOrder` properties.
     *
     * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key. They are handled by the `sort` function.
     *
     * @param {number} [column] Visual column index.
     * @returns {undefined|object|Array}
     */
  }, {
    key: "getSortConfig",
    value: function getSortConfig(column) {
      if (isDefined(column)) {
        return this.columnStatesManager.getColumnSortState(column);
      }
      return this.columnStatesManager.getSortStates();
    }
    /**
     * @description
     * Warn: Useful mainly for providing server side sort implementation (see in the example below). It doesn't sort the data set. It just sets sort configuration for all sorted columns.
     * Note: Please keep in mind that this method doesn't re-render the table.
     *
     * @example
     * ```js
     * beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {
     *   const columnSortPlugin = this.getPlugin('columnSorting');
     *
     *   columnSortPlugin.setSortConfig(destinationSortConfigs);
     *
     *   // const newData = ... // Calculated data set, ie. from an AJAX call.
     *
     *   this.loadData(newData); // Load new data set and re-render the table.
     *
     *   return false; // The blockade for the default sort action.
     * }
     * ```
     *
     * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
     * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
     * sort order (`asc` for ascending, `desc` for descending).
     */
  }, {
    key: "setSortConfig",
    value: function setSortConfig(sortConfig) {
      var destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
      if (this.areValidSortConfigs(destinationSortConfigs)) {
        this.columnStatesManager.setSortStates(destinationSortConfigs);
      }
    }
    /**
     * Get normalized sort configs.
     *
     * @private
     * @param {object|Array} [sortConfig=[]] Single column sort configuration or full sort configuration (for all sorted columns).
     * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
     * sort order (`asc` for ascending, `desc` for descending).
     * @returns {Array}
     */
  }, {
    key: "getNormalizedSortConfigs",
    value: function getNormalizedSortConfigs() {
      var sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (Array.isArray(sortConfig)) {
        return sortConfig.slice(0, 1);
      }
      return [sortConfig];
    }
    /**
     * Get if sort configs are valid.
     *
     * @private
     * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
     * @returns {boolean}
     */
  }, {
    key: "areValidSortConfigs",
    value: function areValidSortConfigs(sortConfigs) {
      var numberOfColumns = this.hot.countCols();
      return areValidSortStates(sortConfigs) && sortConfigs.every(function(_ref2) {
        var column = _ref2.column;
        return column <= numberOfColumns && column >= 0;
      });
    }
    /**
     * Saves all sorting settings. Saving works only when {@link Options#persistentState} option is enabled.
     *
     * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
     *
     * @private
     * @fires Hooks#persistentStateSave
     */
  }, {
    key: "saveAllSortSettings",
    value: function saveAllSortSettings(sortConfigs) {
      var _this4 = this;
      var allSortSettings = this.columnStatesManager.getAllColumnsProperties();
      var translateColumnToPhysical = function translateColumnToPhysical2(_ref2) {
        var visualColumn = _ref2.column, restOfProperties = _objectWithoutProperties$3(_ref2, _excluded$3);
        return _objectSpread$7({
          column: _this4.hot.toPhysicalColumn(visualColumn)
        }, restOfProperties);
      };
      allSortSettings.initialConfig = arrayMap(sortConfigs, translateColumnToPhysical);
      this.hot.runHooks("persistentStateSave", "columnSorting", allSortSettings);
    }
    /**
     * Get all saved sorting settings. Loading works only when {@link Options#persistentState} option is enabled.
     *
     * @private
     * @returns {object} Previously saved sort settings.
     *
     * @fires Hooks#persistentStateLoad
     */
  }, {
    key: "getAllSavedSortSettings",
    value: function getAllSavedSortSettings() {
      var _this5 = this;
      var storedAllSortSettings = {};
      this.hot.runHooks("persistentStateLoad", "columnSorting", storedAllSortSettings);
      var allSortSettings = storedAllSortSettings.value;
      var translateColumnToVisual = function translateColumnToVisual2(_ref3) {
        var physicalColumn = _ref3.column, restOfProperties = _objectWithoutProperties$3(_ref3, _excluded2);
        return _objectSpread$7({
          column: _this5.hot.toVisualColumn(physicalColumn)
        }, restOfProperties);
      };
      if (isDefined(allSortSettings) && Array.isArray(allSortSettings.initialConfig)) {
        allSortSettings.initialConfig = arrayMap(allSortSettings.initialConfig, translateColumnToVisual);
      }
      return allSortSettings;
    }
    /**
     * Get next sort configuration for particular column. Object contain `column` and `sortOrder` properties.
     *
     * **Note**: Please keep in mind that returned object expose **visual** column index under the `column` key.
     *
     * @private
     * @param {number} column Visual column index.
     * @returns {undefined|object}
     */
  }, {
    key: "getColumnNextConfig",
    value: function getColumnNextConfig(column) {
      var sortOrder = this.columnStatesManager.getSortOrderOfColumn(column);
      if (isDefined(sortOrder)) {
        var nextSortOrder = getNextSortOrder(sortOrder);
        if (isDefined(nextSortOrder)) {
          return {
            column,
            sortOrder: nextSortOrder
          };
        }
        return;
      }
      var nrOfColumns = this.hot.countCols();
      if (Number.isInteger(column) && column >= 0 && column < nrOfColumns) {
        return {
          column,
          sortOrder: getNextSortOrder()
        };
      }
    }
    /**
     * Get sort configuration with "next order" for particular column.
     *
     * @private
     * @param {number} columnToChange Visual column index of column which order will be changed.
     * @param {string} strategyId ID of strategy. Possible values: 'append' and 'replace'. The first one
     * change order of particular column and change it's position in the sort queue to the last one. The second one
     * just change order of particular column.
     *
     * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
     *
     * @returns {Array}
     */
  }, {
    key: "getNextSortConfig",
    value: function getNextSortConfig(columnToChange) {
      var strategyId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : APPEND_COLUMN_CONFIG_STRATEGY$1;
      var indexOfColumnToChange = this.columnStatesManager.getIndexOfColumnInSortQueue(columnToChange);
      var isColumnSorted = indexOfColumnToChange !== -1;
      var currentSortConfig = this.getSortConfig();
      var nextColumnConfig = this.getColumnNextConfig(columnToChange);
      if (isColumnSorted) {
        if (isUndefined(nextColumnConfig)) {
          return [].concat(_toConsumableArray$e(currentSortConfig.slice(0, indexOfColumnToChange)), _toConsumableArray$e(currentSortConfig.slice(indexOfColumnToChange + 1)));
        }
        if (strategyId === APPEND_COLUMN_CONFIG_STRATEGY$1) {
          return [].concat(_toConsumableArray$e(currentSortConfig.slice(0, indexOfColumnToChange)), _toConsumableArray$e(currentSortConfig.slice(indexOfColumnToChange + 1)), [nextColumnConfig]);
        } else if (strategyId === REPLACE_COLUMN_CONFIG_STRATEGY) {
          return [].concat(_toConsumableArray$e(currentSortConfig.slice(0, indexOfColumnToChange)), [nextColumnConfig], _toConsumableArray$e(currentSortConfig.slice(indexOfColumnToChange + 1)));
        }
      }
      if (isDefined(nextColumnConfig)) {
        return currentSortConfig.concat(nextColumnConfig);
      }
      return currentSortConfig;
    }
    /**
     * Get plugin's column config for the specified column index.
     *
     * @private
     * @param {object} columnConfig Configuration inside `columns` property for the specified column index.
     * @returns {object}
     */
  }, {
    key: "getPluginColumnConfig",
    value: function getPluginColumnConfig(columnConfig) {
      if (isObject$7(columnConfig)) {
        var pluginColumnConfig = columnConfig[this.pluginKey];
        if (isObject$7(pluginColumnConfig)) {
          return pluginColumnConfig;
        }
      }
      return {};
    }
    /**
     * Get plugin settings related properties, properly merged from cascade settings.
     *
     * @private
     * @param {number} column Visual column index.
     * @returns {object}
     */
  }, {
    key: "getMergedPluginSettings",
    value: function getMergedPluginSettings(column) {
      var pluginMainSettings = this.hot.getSettings()[this.pluginKey];
      var storedColumnProperties = this.columnStatesManager.getAllColumnsProperties();
      var cellMeta = this.hot.getCellMeta(0, column);
      var columnMeta = Object.getPrototypeOf(cellMeta);
      if (Array.isArray(columnMeta.columns)) {
        return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns[column]));
      } else if (isFunction(columnMeta.columns)) {
        return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns(column)));
      }
      return Object.assign(storedColumnProperties, pluginMainSettings);
    }
    /**
     * Get copy of settings for first cell in the column.
     *
     * @private
     * @param {number} column Visual column index.
     * @returns {object}
     */
    // TODO: Workaround. Inheriting of non-primitive cell meta values doesn't work. Instead of getting properties from column meta we call this function.
    // TODO: Remove test named: "should not break the dataset when inserted new row" (#5431).
  }, {
    key: "getFirstCellSettings",
    value: function getFirstCellSettings(column) {
      var cellMeta = this.hot.getCellMeta(0, column);
      var cellMetaCopy = Object.create(cellMeta);
      cellMetaCopy[this.pluginKey] = this.columnMetaCache.getValueAtIndex(this.hot.toPhysicalColumn(column));
      return cellMetaCopy;
    }
    /**
     * Get number of rows which should be sorted.
     *
     * @private
     * @param {number} numberOfRows Total number of displayed rows.
     * @returns {number}
     */
  }, {
    key: "getNumberOfRowsToSort",
    value: function getNumberOfRowsToSort(numberOfRows) {
      var settings = this.hot.getSettings();
      if (settings.maxRows <= numberOfRows) {
        return settings.maxRows;
      }
      return numberOfRows - settings.minSpareRows;
    }
    /**
     * Performs the sorting using a stable sort function basing on internal state of sorting.
     *
     * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
     * @private
     */
  }, {
    key: "sortByPresetSortStates",
    value: function sortByPresetSortStates(sortConfigs) {
      var _this6 = this;
      if (sortConfigs.length === 0) {
        this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValues());
        return;
      }
      var indexesWithData = [];
      var numberOfRows = this.hot.countRows();
      var getDataForSortedColumns = function getDataForSortedColumns2(visualRowIndex2) {
        return arrayMap(sortConfigs, function(sortConfig) {
          return _this6.hot.getDataAtCell(visualRowIndex2, sortConfig.column);
        });
      };
      for (var visualRowIndex = 0; visualRowIndex < this.getNumberOfRowsToSort(numberOfRows); visualRowIndex += 1) {
        indexesWithData.push([this.hot.toPhysicalRow(visualRowIndex)].concat(getDataForSortedColumns(visualRowIndex)));
      }
      var indexesBefore = arrayMap(indexesWithData, function(indexWithData) {
        return indexWithData[0];
      });
      sort2(indexesWithData, this.pluginKey, arrayMap(sortConfigs, function(sortConfig) {
        return sortConfig.sortOrder;
      }), arrayMap(sortConfigs, function(sortConfig) {
        return _this6.getFirstCellSettings(sortConfig.column);
      }));
      for (var _visualRowIndex = indexesWithData.length; _visualRowIndex < numberOfRows; _visualRowIndex += 1) {
        indexesWithData.push([_visualRowIndex].concat(getDataForSortedColumns(_visualRowIndex)));
      }
      var indexesAfter = arrayMap(indexesWithData, function(indexWithData) {
        return indexWithData[0];
      });
      var indexMapping = new Map(arrayMap(indexesBefore, function(indexBefore, indexInsideArray) {
        return [indexBefore, indexesAfter[indexInsideArray]];
      }));
      var newIndexesSequence = arrayMap(this.hot.rowIndexMapper.getIndexesSequence(), function(physicalIndex) {
        if (indexMapping.has(physicalIndex)) {
          return indexMapping.get(physicalIndex);
        }
        return physicalIndex;
      });
      this.hot.rowIndexMapper.setIndexesSequence(newIndexesSequence);
    }
    /**
     * Load saved settings or sort by predefined plugin configuration.
     *
     * @private
     */
  }, {
    key: "loadOrSortBySettings",
    value: function loadOrSortBySettings() {
      var storedAllSortSettings = this.getAllSavedSortSettings();
      if (isObject$7(storedAllSortSettings)) {
        this.sortBySettings(storedAllSortSettings);
      } else {
        var allSortSettings = this.hot.getSettings()[this.pluginKey];
        this.sortBySettings(allSortSettings);
      }
    }
    /**
     * Sort the table by provided configuration.
     *
     * @private
     * @param {object} allSortSettings All sort config settings. Object may contain `initialConfig`, `indicator`,
     * `sortEmptyCells`, `headerAction` and `compareFunctionFactory` properties.
     */
  }, {
    key: "sortBySettings",
    value: function sortBySettings(allSortSettings) {
      if (isObject$7(allSortSettings)) {
        this.columnStatesManager.updateAllColumnsProperties(allSortSettings);
        var initialConfig = allSortSettings.initialConfig;
        if (Array.isArray(initialConfig) || isObject$7(initialConfig)) {
          this.sort(initialConfig);
        }
      } else {
        this.hot.render();
      }
    }
    /**
     * Callback for the `onAfterGetColHeader` hook. Adds column sorting CSS classes.
     *
     * @private
     * @param {number} column Visual column index.
     * @param {Element} TH TH HTML element.
     */
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(column, TH) {
      var headerSpanElement = getHeaderSpanElement(TH);
      if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
        return;
      }
      var pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
      var showSortIndicator = pluginSettingsForColumn.indicator;
      var headerActionEnabled = pluginSettingsForColumn.headerAction;
      this.updateHeaderClasses(headerSpanElement, this.columnStatesManager, column, showSortIndicator, headerActionEnabled);
    }
    /**
     * Update header classes.
     *
     * @private
     * @param {HTMLElement} headerSpanElement Header span element.
     * @param {...*} args Extra arguments for helpers.
     */
  }, {
    key: "updateHeaderClasses",
    value: function updateHeaderClasses(headerSpanElement) {
      removeClass(headerSpanElement, getClassesToRemove$1());
      if (this.enabled !== false) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        addClass(headerSpanElement, getClassesToAdd$1.apply(void 0, args));
      }
    }
    /**
     * Overwriting base plugin's `onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` isn't called
     * for `updateSettings` in specific situations.
     *
     * @private
     * @param {object} newSettings New settings object.
     */
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings(newSettings) {
      _get$A(_getPrototypeOf$I(ColumnSorting2.prototype), "onUpdateSettings", this).call(this);
      if (this.columnMetaCache !== null) {
        this.columnMetaCache.init(this.hot.columnIndexMapper.getNumberOfIndexes());
      }
      if (isDefined(newSettings[this.pluginKey])) {
        this.sortBySettings(newSettings[this.pluginKey]);
      }
    }
    /**
     * Callback for the `afterLoadData` hook.
     *
     * @private
     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(initialLoad) {
      if (initialLoad === true) {
        if (this.hot.view) {
          this.loadOrSortBySettings();
        }
      }
    }
    /**
     * Indicates if clickable header was clicked.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     * @param {number} column Visual column index.
     * @returns {boolean}
     */
  }, {
    key: "wasClickableHeaderClicked",
    value: function wasClickableHeaderClicked(event2, column) {
      var pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
      var headerActionEnabled = pluginSettingsForColumn.headerAction;
      return headerActionEnabled && event2.target.nodeName === "SPAN";
    }
    /**
     * Changes the behavior of selection / dragging.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     * @param {CellCoords} coords Visual coordinates.
     * @param {HTMLElement} TD The cell element.
     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
     *                            a boolean value that allows or disallows changing the selection for that particular area.
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD, controller) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event2, coords.col) && this.hot.getShortcutManager().isCtrlPressed()) {
        controller.column = true;
      }
    }
    /**
     * Callback for the `onAfterOnCellMouseDown` hook.
     *
     * @private
     * @param {Event} event Event which are provided by hook.
     * @param {CellCoords} coords Visual coords of the selected cell.
     */
  }, {
    key: "onAfterOnCellMouseDown",
    value: function onAfterOnCellMouseDown(event2, coords) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event2, coords.col)) {
        if (this.hot.getShortcutManager().isCtrlPressed()) {
          this.hot.deselectCell();
          this.hot.selectColumns(coords.col);
        }
        this.sort(this.getColumnNextConfig(coords.col));
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$columnStatesMan;
      (_this$columnStatesMan = this.columnStatesManager) === null || _this$columnStatesMan === void 0 ? void 0 : _this$columnStatesMan.destroy();
      _get$A(_getPrototypeOf$I(ColumnSorting2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$r;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$q;
    }
  }]);
  return ColumnSorting2;
}(BasePlugin);
var $$2 = _export;
var uncurryThis$2 = functionUncurryThis;
var toIntegerOrInfinity = toIntegerOrInfinity$8;
var thisNumberValue = thisNumberValue$2;
var $repeat = stringRepeat;
var fails$1 = fails$G;
var $RangeError = RangeError;
var $String = String;
var floor = Math.floor;
var repeat2 = uncurryThis$2($repeat);
var stringSlice = uncurryThis$2("".slice);
var nativeToFixed = uncurryThis$2(1 .toFixed);
var pow = function(x2, n2, acc) {
  return n2 === 0 ? acc : n2 % 2 === 1 ? pow(x2, n2 - 1, acc * x2) : pow(x2 * x2, n2 / 2, acc);
};
var log = function(x2) {
  var n2 = 0;
  var x22 = x2;
  while (x22 >= 4096) {
    n2 += 12;
    x22 /= 4096;
  }
  while (x22 >= 2) {
    n2 += 1;
    x22 /= 2;
  }
  return n2;
};
var multiply = function(data2, n2, c2) {
  var index2 = -1;
  var c22 = c2;
  while (++index2 < 6) {
    c22 += n2 * data2[index2];
    data2[index2] = c22 % 1e7;
    c22 = floor(c22 / 1e7);
  }
};
var divide = function(data2, n2) {
  var index2 = 6;
  var c2 = 0;
  while (--index2 >= 0) {
    c2 += data2[index2];
    data2[index2] = floor(c2 / n2);
    c2 = c2 % n2 * 1e7;
  }
};
var dataToString = function(data2) {
  var index2 = 6;
  var s = "";
  while (--index2 >= 0) {
    if (s !== "" || index2 === 0 || data2[index2] !== 0) {
      var t2 = $String(data2[index2]);
      s = s === "" ? t2 : s + repeat2("0", 7 - t2.length) + t2;
    }
  }
  return s;
};
var FORCED = fails$1(function() {
  return nativeToFixed(8e-5, 3) !== "0.000" || nativeToFixed(0.9, 0) !== "1" || nativeToFixed(1.255, 2) !== "1.25" || nativeToFixed(1000000000000000100, 0) !== "1000000000000000128";
}) || !fails$1(function() {
  nativeToFixed({});
});
$$2({ target: "Number", proto: true, forced: FORCED }, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toIntegerOrInfinity(fractionDigits);
    var data2 = [0, 0, 0, 0, 0, 0];
    var sign = "";
    var result = "0";
    var e2, z2, j, k2;
    if (fractDigits < 0 || fractDigits > 20)
      throw $RangeError("Incorrect fraction digits");
    if (number != number)
      return "NaN";
    if (number <= -1e21 || number >= 1e21)
      return $String(number);
    if (number < 0) {
      sign = "-";
      number = -number;
    }
    if (number > 1e-21) {
      e2 = log(number * pow(2, 69, 1)) - 69;
      z2 = e2 < 0 ? number * pow(2, -e2, 1) : number / pow(2, e2, 1);
      z2 *= 4503599627370496;
      e2 = 52 - e2;
      if (e2 > 0) {
        multiply(data2, 0, z2);
        j = fractDigits;
        while (j >= 7) {
          multiply(data2, 1e7, 0);
          j -= 7;
        }
        multiply(data2, pow(10, j, 1), 0);
        j = e2 - 1;
        while (j >= 23) {
          divide(data2, 1 << 23);
          j -= 23;
        }
        divide(data2, 1 << j);
        multiply(data2, 1, 1);
        divide(data2, 2);
        result = dataToString(data2);
      } else {
        multiply(data2, 0, z2);
        multiply(data2, 1 << -e2, 0);
        result = dataToString(data2) + repeat2("0", fractDigits);
      }
    }
    if (fractDigits > 0) {
      k2 = result.length;
      result = sign + (k2 <= fractDigits ? "0." + repeat2("0", fractDigits - k2) + result : stringSlice(result, 0, k2 - fractDigits) + "." + stringSlice(result, k2 - fractDigits));
    } else {
      result = sign + result;
    }
    return result;
  }
});
function _classCallCheck$1b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1b(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Endpoints = /* @__PURE__ */ function() {
  function Endpoints2(plugin, settings) {
    _classCallCheck$1b(this, Endpoints2);
    this.plugin = plugin;
    this.hot = this.plugin.hot;
    this.endpoints = [];
    this.settings = settings;
    this.settingsType = "array";
    this.currentEndpoint = null;
    this.cellsToSetCache = [];
  }
  _createClass$1b(Endpoints2, [{
    key: "getEndpoint",
    value: function getEndpoint(index2) {
      if (this.settingsType === "function") {
        return this.fillMissingEndpointData(this.settings)[index2];
      }
      return this.endpoints[index2];
    }
    /**
     * Get an array with all the endpoints.
     *
     * @returns {Array}
     */
  }, {
    key: "getAllEndpoints",
    value: function getAllEndpoints() {
      if (this.settingsType === "function") {
        return this.fillMissingEndpointData(this.settings);
      }
      return this.endpoints;
    }
    /**
     * Used to fill the blanks in the endpoint data provided by a settings function.
     *
     * @private
     * @param {Function} func Function provided in the HOT settings.
     * @returns {Array} An array of endpoints.
     */
  }, {
    key: "fillMissingEndpointData",
    value: function fillMissingEndpointData(func) {
      return this.parseSettings(func.call(this));
    }
    /**
     * Parse plugin's settings.
     *
     * @param {Array} settings The settings array.
     * @returns {object[]}
     */
  }, {
    key: "parseSettings",
    value: function parseSettings(settings) {
      var _this = this;
      var endpointsArray = [];
      var settingsArray = settings;
      if (!settingsArray && typeof this.settings === "function") {
        this.settingsType = "function";
        return;
      }
      if (!settingsArray) {
        settingsArray = this.settings;
      }
      arrayEach(settingsArray, function(val) {
        var newEndpoint = {};
        _this.assignSetting(val, newEndpoint, "ranges", [[0, _this.hot.countRows() - 1]]);
        _this.assignSetting(val, newEndpoint, "reversedRowCoords", false);
        _this.assignSetting(val, newEndpoint, "destinationRow", new Error("\n        You must provide a destination row for the Column Summary plugin in order to work properly!\n      "));
        _this.assignSetting(val, newEndpoint, "destinationColumn", new Error("\n        You must provide a destination column for the Column Summary plugin in order to work properly!\n      "));
        _this.assignSetting(val, newEndpoint, "sourceColumn", val.destinationColumn);
        _this.assignSetting(val, newEndpoint, "type", "sum");
        _this.assignSetting(val, newEndpoint, "forceNumeric", false);
        _this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
        _this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
        _this.assignSetting(val, newEndpoint, "customFunction", null);
        _this.assignSetting(val, newEndpoint, "readOnly", true);
        _this.assignSetting(val, newEndpoint, "roundFloat", false);
        endpointsArray.push(newEndpoint);
      });
      return endpointsArray;
    }
    /**
     * Setter for the internal setting objects.
     *
     * @param {object} settings Object with the settings.
     * @param {object} endpoint Contains information about the endpoint for the the calculation.
     * @param {string} name Settings name.
     * @param {object} defaultValue Default value for the settings.
     */
  }, {
    key: "assignSetting",
    value: function assignSetting(settings, endpoint, name, defaultValue) {
      if (name === "ranges" && settings[name] === void 0) {
        endpoint[name] = defaultValue;
        return;
      } else if (name === "ranges" && settings[name].length === 0) {
        return;
      }
      if (settings[name] === void 0) {
        if (defaultValue instanceof Error) {
          throw defaultValue;
        }
        endpoint[name] = defaultValue;
      } else {
        if (name === "destinationRow" && endpoint.reversedRowCoords) {
          endpoint[name] = this.hot.countRows() - settings[name] - 1;
        } else {
          endpoint[name] = settings[name];
        }
      }
    }
    /**
     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.
     *
     * @private
     * @param {string} action Type of the action performed.
     * @param {number} index Row/column index.
     * @param {number} number Number of rows/columns added/removed.
     */
  }, {
    key: "resetSetupBeforeStructureAlteration",
    value: function resetSetupBeforeStructureAlteration(action, index2, number) {
      if (this.settingsType !== "function") {
        return;
      }
      var type = action.indexOf("row") > -1 ? "row" : "col";
      var endpoints = this.getAllEndpoints();
      arrayEach(endpoints, function(val) {
        if (type === "row" && val.destinationRow >= index2) {
          if (action === "insert_row") {
            val.alterRowOffset = number;
          } else if (action === "remove_row") {
            val.alterRowOffset = -1 * number;
          }
        }
        if (type === "col" && val.destinationColumn >= index2) {
          if (action === "insert_col") {
            val.alterColumnOffset = number;
          } else if (action === "remove_col") {
            val.alterColumnOffset = -1 * number;
          }
        }
      });
      this.resetAllEndpoints(endpoints, false);
    }
    /**
     * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality
     * after changing the table structure.
     *
     * @private
     * @param {string} action Type of the action performed.
     * @param {number} index Row/column index.
     * @param {number} number Number of rows/columns added/removed.
     * @param {Array} [logicRows] Array of the logical indexes.
     * @param {string} [source] Source of change.
     * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.
     */
  }, {
    key: "resetSetupAfterStructureAlteration",
    value: function resetSetupAfterStructureAlteration(action, index2, number, logicRows, source) {
      var _this2 = this;
      var forceRefresh = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (this.settingsType === "function") {
        var beforeViewRenderCallback = function beforeViewRenderCallback2() {
          _this2.hot.removeHook("beforeViewRender", beforeViewRenderCallback2);
          return _this2.refreshAllEndpoints();
        };
        this.hot.addHookOnce("beforeViewRender", beforeViewRenderCallback);
        return;
      }
      var type = action.indexOf("row") > -1 ? "row" : "col";
      var multiplier = action.indexOf("remove") > -1 ? -1 : 1;
      var endpoints = this.getAllEndpoints();
      var rowMoving = action.indexOf("move_row") === 0;
      var placeOfAlteration = index2;
      arrayEach(endpoints, function(val) {
        if (type === "row" && val.destinationRow >= placeOfAlteration) {
          val.alterRowOffset = multiplier * number;
        }
        if (type === "col" && val.destinationColumn >= placeOfAlteration) {
          val.alterColumnOffset = multiplier * number;
        }
      });
      this.resetAllEndpoints(endpoints, !rowMoving);
      if (rowMoving) {
        arrayEach(endpoints, function(endpoint) {
          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);
          _this2.recreatePhysicalRanges(endpoint);
          _this2.clearOffsetInformation(endpoint);
        });
      } else {
        arrayEach(endpoints, function(endpoint) {
          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);
        });
      }
      if (forceRefresh) {
        this.refreshAllEndpoints();
      }
    }
    /**
     * Clear the offset information from the endpoint object.
     *
     * @private
     * @param {object} endpoint And endpoint object.
     */
  }, {
    key: "clearOffsetInformation",
    value: function clearOffsetInformation(endpoint) {
      endpoint.alterRowOffset = void 0;
      endpoint.alterColumnOffset = void 0;
    }
    /**
     * Extend the row ranges for the provided endpoint.
     *
     * @private
     * @param {object} endpoint The endpoint object.
     * @param {number} placeOfAlteration Index of the row where the alteration takes place.
     * @param {number} previousPosition Previous endpoint result position.
     * @param {number} offset Offset generated by the alteration.
     */
  }, {
    key: "extendEndpointRanges",
    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset2) {
      arrayEach(endpoint.ranges, function(range) {
        if (range[1]) {
          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {
            if (previousPosition > range[1]) {
              range[1] += offset2;
            } else if (previousPosition < range[0]) {
              range[0] -= offset2;
            }
          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {
            range[1] -= offset2;
            if (placeOfAlteration <= range[0]) {
              range[0] += 1;
              range[1] += 1;
            }
          }
        }
      });
    }
    /**
     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.
     *
     * @private
     * @param {object} endpoint An endpoint object.
     */
  }, {
    key: "recreatePhysicalRanges",
    value: function recreatePhysicalRanges(endpoint) {
      var _this3 = this;
      var ranges = endpoint.ranges;
      var newRanges = [];
      var allIndexes = [];
      arrayEach(ranges, function(range) {
        var newRange = [];
        if (range[1]) {
          for (var i = range[0]; i <= range[1]; i++) {
            newRange.push(_this3.hot.toPhysicalRow(i));
          }
        } else {
          newRange.push(_this3.hot.toPhysicalRow(range[0]));
        }
        allIndexes.push(newRange);
      });
      arrayEach(allIndexes, function(range) {
        var newRange = [];
        arrayEach(range, function(coord, index2) {
          if (index2 === 0) {
            newRange.push(coord);
          } else if (range[index2] !== range[index2 - 1] + 1) {
            newRange.push(range[index2 - 1]);
            newRanges.push(newRange);
            newRange = [];
            newRange.push(coord);
          }
          if (index2 === range.length - 1) {
            newRange.push(coord);
            newRanges.push(newRange);
          }
        });
      });
      endpoint.ranges = newRanges;
    }
    /**
     * Shifts the endpoint coordinates by the defined offset.
     *
     * @private
     * @param {object} endpoint Endpoint object.
     * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.
     */
  }, {
    key: "shiftEndpointCoordinates",
    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {
      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {
        endpoint.destinationRow += endpoint.alterRowOffset || 0;
        arrayEach(endpoint.ranges, function(element) {
          arrayEach(element, function(subElement, j) {
            if (subElement >= offsetStartIndex) {
              element[j] += endpoint.alterRowOffset || 0;
            }
          });
        });
      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {
        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;
        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;
      }
    }
    /**
     * Resets (removes) the endpoints from the table.
     *
     * @param {Array} [endpoints] Array containing the endpoints.
     * @param {boolean} [useOffset=true] Use the cell offset value.
     */
  }, {
    key: "resetAllEndpoints",
    value: function resetAllEndpoints() {
      var _this4 = this;
      var endpoints = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getAllEndpoints();
      var useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var anyEndpointOutOfRange = endpoints.some(function(endpoint) {
        var alterRowOffset = endpoint.alterRowOffset || 0;
        var alterColOffset = endpoint.alterColumnOffset || 0;
        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {
          return true;
        }
        return false;
      });
      if (anyEndpointOutOfRange) {
        return;
      }
      this.cellsToSetCache = [];
      arrayEach(endpoints, function(endpoint) {
        _this4.resetEndpointValue(endpoint, useOffset);
      });
      this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
      this.cellsToSetCache = [];
    }
    /**
     * Calculate and refresh all defined endpoints.
     */
  }, {
    key: "refreshAllEndpoints",
    value: function refreshAllEndpoints() {
      var _this5 = this;
      this.cellsToSetCache = [];
      arrayEach(this.getAllEndpoints(), function(value) {
        _this5.currentEndpoint = value;
        _this5.plugin.calculate(value);
        _this5.setEndpointValue(value, "init");
      });
      this.currentEndpoint = null;
      this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
      this.cellsToSetCache = [];
    }
    /**
     * Calculate and refresh endpoints only in the changed columns.
     *
     * @param {Array} changes Array of changes from the `afterChange` hook.
     */
  }, {
    key: "refreshChangedEndpoints",
    value: function refreshChangedEndpoints(changes) {
      var _this6 = this;
      var needToRefresh = [];
      this.cellsToSetCache = [];
      arrayEach(changes, function(value, key, changesObj) {
        if ("".concat(value[2] || "") === "".concat(value[3])) {
          return;
        }
        arrayEach(_this6.getAllEndpoints(), function(endpoint, j) {
          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {
            needToRefresh.push(j);
          }
        });
      });
      arrayEach(needToRefresh, function(value) {
        _this6.refreshEndpoint(_this6.getEndpoint(value));
      });
      this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
      this.cellsToSetCache = [];
    }
    /**
     * Calculate and refresh a single endpoint.
     *
     * @param {object} endpoint Contains the endpoint information.
     */
  }, {
    key: "refreshEndpoint",
    value: function refreshEndpoint(endpoint) {
      this.currentEndpoint = endpoint;
      this.plugin.calculate(endpoint);
      this.setEndpointValue(endpoint);
      this.currentEndpoint = null;
    }
    /**
     * Reset the endpoint value.
     *
     * @param {object} endpoint Contains the endpoint information.
     * @param {boolean} [useOffset=true] Use the cell offset value.
     */
  }, {
    key: "resetEndpointValue",
    value: function resetEndpointValue(endpoint) {
      var useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var alterRowOffset = endpoint.alterRowOffset || 0;
      var alterColOffset = endpoint.alterColumnOffset || 0;
      var _ref2 = [this.hot.toVisualRow(endpoint.destinationRow), this.hot.toVisualColumn(endpoint.destinationColumn)], visualRowIndex = _ref2[0], visualColumnIndex = _ref2[1];
      if (visualColumnIndex !== null && visualRowIndex !== null) {
        var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);
        cellMeta.readOnly = false;
        cellMeta.className = "";
      }
      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), ""]);
    }
    /**
     * Set the endpoint value.
     *
     * @param {object} endpoint Contains the endpoint information.
     * @param {string} [source] Source of the call information.
     * @param {boolean} [render=false] `true` if it needs to render the table afterwards.
     */
  }, {
    key: "setEndpointValue",
    value: function setEndpointValue(endpoint, source) {
      var render = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;
      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;
      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);
      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {
        this.throwOutOfBoundsWarning();
        return;
      }
      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow + reverseRowOffset);
      if (destinationVisualRow !== null) {
        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn + reverseColOffset);
        if (source === "init" || cellMeta.readOnly !== endpoint.readOnly) {
          cellMeta.readOnly = endpoint.readOnly;
          cellMeta.className = "columnSummaryResult";
        }
      }
      if (endpoint.roundFloat && !isNaN(endpoint.result)) {
        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);
      }
      if (render) {
        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, "ColumnSummary.set");
      } else {
        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);
      }
      endpoint.alterRowOffset = void 0;
      endpoint.alterColumnOffset = void 0;
    }
    /**
     * Throw an error for the calculation range being out of boundaries.
     *
     * @private
     */
  }, {
    key: "throwOutOfBoundsWarning",
    value: function throwOutOfBoundsWarning() {
      warn$1("One of the Column Summary plugins' destination points you provided is beyond the table boundaries!");
    }
  }]);
  return Endpoints2;
}();
const Endpoints$1 = Endpoints;
function isNullishOrNaN(value) {
  return value === null || value === void 0 || isNaN(value);
}
function _typeof$J(obj) {
  "@babel/helpers - typeof";
  return _typeof$J = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$J(obj);
}
var _templateObject$a;
function _taggedTemplateLiteral$a(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$1a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1a(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$z() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$z = Reflect.get.bind();
  } else {
    _get$z = function _get2(target, property, receiver) {
      var base = _superPropBase$z(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$z.apply(this, arguments);
}
function _superPropBase$z(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$H(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$H(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$H(subClass, superClass);
}
function _setPrototypeOf$H(o, p2) {
  _setPrototypeOf$H = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$H(o, p2);
}
function _createSuper$H(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$H();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$H(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$H(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$H(this, result);
  };
}
function _possibleConstructorReturn$H(self2, call2) {
  if (call2 && (_typeof$J(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$H(self2);
}
function _assertThisInitialized$H(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$H() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$H(o) {
  _getPrototypeOf$H = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$H(o);
}
var PLUGIN_KEY$q = "columnSummary";
var PLUGIN_PRIORITY$p = 220;
var ColumnSummary = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$H(ColumnSummary2, _BasePlugin);
  var _super = _createSuper$H(ColumnSummary2);
  function ColumnSummary2(hotInstance) {
    var _this;
    _classCallCheck$1a(this, ColumnSummary2);
    _this = _super.call(this, hotInstance);
    _this.endpoints = null;
    return _this;
  }
  _createClass$1a(ColumnSummary2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$q];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.settings = this.hot.getSettings()[PLUGIN_KEY$q];
      this.endpoints = new Endpoints$1(this, this.settings);
      this.addHook("afterInit", function() {
        return _this2.onAfterInit.apply(_this2, arguments);
      });
      this.addHook("afterChange", function() {
        return _this2.onAfterChange.apply(_this2, arguments);
      });
      this.addHook("beforeCreateRow", function(index2, amount, source) {
        return _this2.endpoints.resetSetupBeforeStructureAlteration("insert_row", index2, amount, null, source);
      });
      this.addHook("beforeCreateCol", function(index2, amount, source) {
        return _this2.endpoints.resetSetupBeforeStructureAlteration("insert_col", index2, amount, null, source);
      });
      this.addHook("beforeRemoveRow", function() {
        var _this2$endpoints;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_this2$endpoints = _this2.endpoints).resetSetupBeforeStructureAlteration.apply(_this2$endpoints, ["remove_row"].concat(args));
      });
      this.addHook("beforeRemoveCol", function() {
        var _this2$endpoints2;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return (_this2$endpoints2 = _this2.endpoints).resetSetupBeforeStructureAlteration.apply(_this2$endpoints2, ["remove_col"].concat(args));
      });
      this.addHook("afterCreateRow", function(index2, amount, source) {
        return _this2.endpoints.resetSetupAfterStructureAlteration("insert_row", index2, amount, null, source);
      });
      this.addHook("afterCreateCol", function(index2, amount, source) {
        return _this2.endpoints.resetSetupAfterStructureAlteration("insert_col", index2, amount, null, source);
      });
      this.addHook("afterRemoveRow", function() {
        var _this2$endpoints3;
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return (_this2$endpoints3 = _this2.endpoints).resetSetupAfterStructureAlteration.apply(_this2$endpoints3, ["remove_row"].concat(args));
      });
      this.addHook("afterRemoveCol", function() {
        var _this2$endpoints4;
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return (_this2$endpoints4 = _this2.endpoints).resetSetupAfterStructureAlteration.apply(_this2$endpoints4, ["remove_col"].concat(args));
      });
      this.addHook("afterRowMove", function() {
        return _this2.onAfterRowMove.apply(_this2, arguments);
      });
      _get$z(_getPrototypeOf$H(ColumnSummary2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.endpoints = null;
      this.settings = null;
      this.currentEndpoint = null;
    }
    /**
     * Calculates math for a single endpoint.
     *
     * @private
     * @param {object} endpoint Contains information about the endpoint.
     */
  }, {
    key: "calculate",
    value: function calculate(endpoint) {
      switch (endpoint.type.toLowerCase()) {
        case "sum":
          endpoint.result = this.calculateSum(endpoint);
          break;
        case "min":
          endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
          break;
        case "max":
          endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
          break;
        case "count":
          endpoint.result = this.countEntries(endpoint);
          break;
        case "average":
          endpoint.result = this.calculateAverage(endpoint);
          break;
        case "custom":
          endpoint.result = endpoint.customFunction.call(this, endpoint);
          break;
      }
    }
    /**
     * Calculates sum of the values contained in ranges provided in the plugin config.
     *
     * @private
     * @param {object} endpoint Contains the endpoint information.
     * @returns {number} Sum for the selected range.
     */
  }, {
    key: "calculateSum",
    value: function calculateSum(endpoint) {
      var _this3 = this;
      var sum = 0;
      objectEach(endpoint.ranges, function(range) {
        sum += _this3.getPartialSum(range, endpoint.sourceColumn);
      });
      return sum;
    }
    /**
     * Returns partial sum of values from a single row range.
     *
     * @private
     * @param {Array} rowRange Range for the sum.
     * @param {number} col Column index.
     * @returns {number} The partial sum.
     */
  }, {
    key: "getPartialSum",
    value: function getPartialSum(rowRange, col) {
      var sum = 0;
      var i = rowRange[1] || rowRange[0];
      var cellValue = null;
      var biggestDecimalPlacesCount = 0;
      do {
        cellValue = this.getCellValue(i, col);
        cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
        if (cellValue !== null) {
          var decimalPlaces = ("".concat(cellValue).split(".")[1] || []).length || 1;
          if (decimalPlaces > biggestDecimalPlacesCount) {
            biggestDecimalPlacesCount = decimalPlaces;
          }
        }
        sum += cellValue || 0;
        i -= 1;
      } while (i >= rowRange[0]);
      return Math.round(sum * Math.pow(10, biggestDecimalPlacesCount)) / Math.pow(10, biggestDecimalPlacesCount);
    }
    /**
     * Calculates the minimal value for the selected ranges.
     *
     * @private
     * @param {object} endpoint Contains the endpoint information.
     * @param {string} type `'min'` or `'max'`.
     * @returns {number} Min or Max value.
     */
  }, {
    key: "calculateMinMax",
    value: function calculateMinMax(endpoint, type) {
      var _this4 = this;
      var result = null;
      objectEach(endpoint.ranges, function(range) {
        var partialResult = _this4.getPartialMinMax(range, endpoint.sourceColumn, type);
        if (result === null && partialResult !== null) {
          result = partialResult;
        }
        if (partialResult !== null) {
          switch (type) {
            case "min":
              result = Math.min(result, partialResult);
              break;
            case "max":
              result = Math.max(result, partialResult);
              break;
          }
        }
      });
      return result === null ? "Not enough data" : result;
    }
    /**
     * Returns a local minimum of the provided sub-range.
     *
     * @private
     * @param {Array} rowRange Range for the calculation.
     * @param {number} col Column index.
     * @param {string} type `'min'` or `'max'`.
     * @returns {number|null} Min or max value.
     */
  }, {
    key: "getPartialMinMax",
    value: function getPartialMinMax(rowRange, col, type) {
      var result = null;
      var i = rowRange[1] || rowRange[0];
      var cellValue;
      do {
        cellValue = this.getCellValue(i, col);
        cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
        if (result === null) {
          result = cellValue;
        } else if (cellValue !== null) {
          switch (type) {
            case "min":
              result = Math.min(result, cellValue);
              break;
            case "max":
              result = Math.max(result, cellValue);
              break;
          }
        }
        i -= 1;
      } while (i >= rowRange[0]);
      return result;
    }
    /**
     * Counts empty cells in the provided row range.
     *
     * @private
     * @param {Array} rowRange Row range for the calculation.
     * @param {number} col Column index.
     * @returns {number} Empty cells count.
     */
  }, {
    key: "countEmpty",
    value: function countEmpty(rowRange, col) {
      var cellValue;
      var counter2 = 0;
      var i = rowRange[1] || rowRange[0];
      do {
        cellValue = this.getCellValue(i, col);
        cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
        if (cellValue === null) {
          counter2 += 1;
        }
        i -= 1;
      } while (i >= rowRange[0]);
      return counter2;
    }
    /**
     * Counts non-empty cells in the provided row range.
     *
     * @private
     * @param {object} endpoint Contains the endpoint information.
     * @returns {number} Entry count.
     */
  }, {
    key: "countEntries",
    value: function countEntries(endpoint) {
      var _this5 = this;
      var result = 0;
      var ranges = endpoint.ranges;
      objectEach(ranges, function(range) {
        var partial2 = range[1] === void 0 ? 1 : range[1] - range[0] + 1;
        var emptyCount = _this5.countEmpty(range, endpoint.sourceColumn);
        result += partial2;
        result -= emptyCount;
      });
      return result;
    }
    /**
     * Calculates the average value from the cells in the range.
     *
     * @private
     * @param {object} endpoint Contains the endpoint information.
     * @returns {number} Avarage value.
     */
  }, {
    key: "calculateAverage",
    value: function calculateAverage(endpoint) {
      var sum = this.calculateSum(endpoint);
      var entriesCount = this.countEntries(endpoint);
      return sum / entriesCount;
    }
    /**
     * Returns a cell value, taking into consideration a basic validation.
     *
     * @private
     * @param {number} row Row index.
     * @param {number} col Column index.
     * @returns {string} The cell value.
     */
  }, {
    key: "getCellValue",
    value: function getCellValue(row, col) {
      var visualRowIndex = this.hot.toVisualRow(row);
      var visualColumnIndex = this.hot.toVisualColumn(col);
      var cellValue = this.hot.getSourceDataAtCell(row, col);
      var cellClassName = "";
      if (visualRowIndex !== null && visualColumnIndex !== null) {
        cellClassName = this.hot.getCellMeta(visualRowIndex, visualColumnIndex).className || "";
      }
      if (cellClassName.indexOf("columnSummaryResult") > -1) {
        return null;
      }
      if (this.endpoints.currentEndpoint.forceNumeric) {
        if (typeof cellValue === "string") {
          cellValue = cellValue.replace(/,/, ".");
        }
        cellValue = parseFloat(cellValue);
      }
      if (isNaN(cellValue)) {
        if (!this.endpoints.currentEndpoint.suppressDataTypeErrors) {
          throw new Error(toSingleLine(_templateObject$a || (_templateObject$a = _taggedTemplateLiteral$a(["ColumnSummary plugin: cell at (", ", ", ") is not in a \n          numeric format. Cannot do the calculation."], ["ColumnSummary plugin: cell at (", ", ", ") is not in a\\x20\n          numeric format. Cannot do the calculation."])), row, col));
        }
      }
      return cellValue;
    }
    /**
     * `afterInit` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.endpoints.endpoints = this.endpoints.parseSettings();
      this.endpoints.refreshAllEndpoints(true);
    }
    /**
     * `afterChange` hook callback.
     *
     * @private
     * @param {Array} changes 2D array containing information about each of the edited cells.
     * @param {string} source The string that identifies source of changes.
     */
  }, {
    key: "onAfterChange",
    value: function onAfterChange2(changes, source) {
      if (changes && source !== "ColumnSummary.reset" && source !== "ColumnSummary.set" && source !== "loadData") {
        this.endpoints.refreshChangedEndpoints(changes);
      }
    }
    /**
     * `beforeRowMove` hook callback.
     *
     * @private
     * @param {Array} rows Array of visual row indexes to be moved.
     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md).
     */
  }, {
    key: "onAfterRowMove",
    value: function onAfterRowMove(rows, finalIndex) {
      this.endpoints.resetSetupBeforeStructureAlteration("move_row", rows[0], rows.length, rows, this.pluginName);
      this.endpoints.resetSetupAfterStructureAlteration("move_row", finalIndex, rows.length, rows, this.pluginName);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$q;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$p;
    }
  }]);
  return ColumnSummary2;
}(BasePlugin);
function _classCallCheck$19(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$19(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$19(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$19(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$19(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var CommentEditor = /* @__PURE__ */ function() {
  function CommentEditor2(rootDocument, isRtl) {
    _classCallCheck$19(this, CommentEditor2);
    this.rootDocument = rootDocument;
    this.isRtl = isRtl;
    this.container = null;
    this.editor = this.createEditor();
    this.editorStyle = this.editor.style;
    this.hidden = true;
    this.hide();
  }
  _createClass$19(CommentEditor2, [{
    key: "setPosition",
    value: function setPosition(x2, y2) {
      this.editorStyle.left = "".concat(x2, "px");
      this.editorStyle.top = "".concat(y2, "px");
    }
    /**
     * Set the editor size according to the provided arguments.
     *
     * @param {number} width Width in pixels.
     * @param {number} height Height in pixels.
     */
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (width && height) {
        var input = this.getInputElement();
        input.style.width = "".concat(width, "px");
        input.style.height = "".concat(height, "px");
      }
    }
    /**
     * Returns the size of the comments editor.
     *
     * @returns {{ width: number, height: number }}
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: outerWidth(this.getInputElement()),
        height: outerHeight(this.getInputElement())
      };
    }
    /**
     * Reset the editor size to its initial state.
     */
  }, {
    key: "resetSize",
    value: function resetSize() {
      var input = this.getInputElement();
      input.style.width = "";
      input.style.height = "";
    }
    /**
     * Set the read-only state for the comments editor.
     *
     * @param {boolean} state The new read only state.
     */
  }, {
    key: "setReadOnlyState",
    value: function setReadOnlyState(state) {
      var input = this.getInputElement();
      input.readOnly = state;
    }
    /**
     * Show the comments editor.
     */
  }, {
    key: "show",
    value: function show() {
      this.editorStyle.display = "block";
      this.hidden = false;
    }
    /**
     * Hide the comments editor.
     */
  }, {
    key: "hide",
    value: function hide() {
      if (!this.hidden) {
        this.editorStyle.display = "none";
      }
      this.hidden = true;
    }
    /**
     * Checks if the editor is visible.
     *
     * @returns {boolean}
     */
  }, {
    key: "isVisible",
    value: function isVisible2() {
      return this.editorStyle.display === "block";
    }
    /**
     * Set the comment value.
     *
     * @param {string} [value] The value to use.
     */
  }, {
    key: "setValue",
    value: function setValue() {
      var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var comment = value || "";
      this.getInputElement().value = comment;
    }
    /**
     * Get the comment value.
     *
     * @returns {string}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.getInputElement().value;
    }
    /**
     * Checks if the comment input element is focused.
     *
     * @returns {boolean}
     */
  }, {
    key: "isFocused",
    value: function isFocused() {
      return this.rootDocument.activeElement === this.getInputElement();
    }
    /**
     * Focus the comments input element.
     */
  }, {
    key: "focus",
    value: function focus() {
      this.getInputElement().focus();
    }
    /**
     * Create the `textarea` to be used as a comments editor.
     *
     * @returns {HTMLElement}
     */
  }, {
    key: "createEditor",
    value: function createEditor() {
      var editor = this.rootDocument.createElement("div");
      var textArea = this.rootDocument.createElement("textarea");
      editor.style.display = "none";
      this.container = this.rootDocument.createElement("div");
      this.container.setAttribute("dir", this.isRtl ? "rtl" : "ltr");
      addClass(this.container, CommentEditor2.CLASS_EDITOR_CONTAINER);
      this.rootDocument.body.appendChild(this.container);
      addClass(editor, CommentEditor2.CLASS_EDITOR);
      addClass(textArea, CommentEditor2.CLASS_INPUT);
      editor.appendChild(textArea);
      this.container.appendChild(editor);
      return editor;
    }
    /**
     * Get the input element.
     *
     * @returns {HTMLElement}
     */
  }, {
    key: "getInputElement",
    value: function getInputElement() {
      return this.editor.querySelector(".".concat(CommentEditor2.CLASS_INPUT));
    }
    /**
     * Destroy the comments editor.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var containerParentElement = this.container ? this.container.parentNode : null;
      this.editor.parentNode.removeChild(this.editor);
      this.editor = null;
      this.editorStyle = null;
      if (containerParentElement) {
        containerParentElement.removeChild(this.container);
      }
    }
  }], [{
    key: "CLASS_EDITOR_CONTAINER",
    get: function get2() {
      return "htCommentsContainer";
    }
  }, {
    key: "CLASS_EDITOR",
    get: function get2() {
      return "htComments";
    }
  }, {
    key: "CLASS_INPUT",
    get: function get2() {
      return "htCommentTextArea";
    }
  }, {
    key: "CLASS_CELL",
    get: function get2() {
      return "htCommentCell";
    }
  }]);
  return CommentEditor2;
}();
const CommentEditor$1 = CommentEditor;
var KEY$c = "---------";
function separatorItem() {
  return {
    name: KEY$c
  };
}
function normalizeSelection(selRanges) {
  return arrayMap(selRanges, function(range) {
    return {
      start: range.getTopStartCorner(),
      end: range.getBottomEndCorner()
    };
  });
}
function isSeparator(cell) {
  return hasClass(cell, "htSeparator");
}
function hasSubMenu(cell) {
  return hasClass(cell, "htSubmenu");
}
function isDisabled(cell) {
  return hasClass(cell, "htDisabled");
}
function isSelectionDisabled(cell) {
  return hasClass(cell, "htSelectionDisabled");
}
function getValidSelection(hot) {
  var selected = hot.getSelected();
  if (!selected) {
    return null;
  }
  if (selected[0] < 0) {
    return null;
  }
  return selected;
}
function prepareVerticalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  var replacedClassName = className.replace("htTop", "").replace("htMiddle", "").replace("htBottom", "").replace("  ", "");
  return "".concat(replacedClassName, " ").concat(alignment);
}
function prepareHorizontalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  var replacedClassName = className.replace("htLeft", "").replace("htCenter", "").replace("htRight", "").replace("htJustify", "").replace("  ", "");
  return "".concat(replacedClassName, " ").concat(alignment);
}
function getAlignmentClasses(ranges, callback) {
  var classes = {};
  arrayEach(ranges, function(range) {
    range.forAll(function(row, col) {
      if (row >= 0 && col >= 0) {
        if (!classes[row]) {
          classes[row] = [];
        }
        classes[row][col] = callback(row, col);
      }
    });
  });
  return classes;
}
function align(ranges, type, alignment, cellDescriptor, propertySetter) {
  arrayEach(ranges, function(range) {
    range.forAll(function(row, col) {
      if (row >= 0 && col >= 0) {
        applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);
      }
    });
  });
}
function applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {
  var cellMeta = cellDescriptor(row, col);
  var className = alignment;
  if (cellMeta.className) {
    if (type === "vertical") {
      className = prepareVerticalAlignClass(cellMeta.className, alignment);
    } else {
      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
    }
  }
  propertySetter(row, col, "className", className);
}
function checkSelectionConsistency(ranges, comparator) {
  var result = false;
  if (Array.isArray(ranges)) {
    arrayEach(ranges, function(range) {
      range.forAll(function(row, col) {
        if (row >= 0 && col >= 0 && comparator(row, col)) {
          result = true;
          return false;
        }
      });
      return result;
    });
  }
  return result;
}
function markLabelAsSelected(label) {
  return '<span class="selected">'.concat(String.fromCharCode(10003), "</span>").concat(label);
}
function isItemHidden(item, instance) {
  return !item.hidden || !(typeof item.hidden === "function" && item.hidden.call(instance));
}
function shiftSeparators(items, separator) {
  var result = items.slice(0);
  for (var i = 0; i < result.length; ) {
    if (result[i].name === separator) {
      result.shift();
    } else {
      break;
    }
  }
  return result;
}
function popSeparators(items, separator) {
  var result = items.slice(0);
  result.reverse();
  result = shiftSeparators(result, separator);
  result.reverse();
  return result;
}
function removeDuplicatedSeparators(items) {
  var result = [];
  arrayEach(items, function(value, index2) {
    if (index2 > 0) {
      if (result[result.length - 1].name !== value.name) {
        result.push(value);
      }
    } else {
      result.push(value);
    }
  });
  return result;
}
function filterSeparators(items) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : KEY$c;
  var result = items.slice(0);
  result = shiftSeparators(result, separator);
  result = popSeparators(result, separator);
  result = removeDuplicatedSeparators(result);
  return result;
}
function _classCallCheck$18(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$18(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$18(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$18(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$18(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DEFAULT_DISPLAY_DELAY = 250;
var DEFAULT_HIDE_DELAY = 250;
var DisplaySwitch = /* @__PURE__ */ function() {
  function DisplaySwitch2(displayDelay) {
    _classCallCheck$18(this, DisplaySwitch2);
    this.wasLastActionShow = true;
    this.showDebounced = null;
    this.hidingTimer = null;
    this.updateDelay(displayDelay);
  }
  _createClass$18(DisplaySwitch2, [{
    key: "hide",
    value: function hide() {
      var _this = this;
      this.wasLastActionShow = false;
      this.hidingTimer = setTimeout(function() {
        if (_this.wasLastActionShow === false) {
          _this.runLocalHooks("hide");
        }
      }, DEFAULT_HIDE_DELAY);
    }
    /**
     * Responsible for showing comment after proper delay.
     *
     * @param {object} range Coordinates of selected cell.
     */
  }, {
    key: "show",
    value: function show(range) {
      this.wasLastActionShow = true;
      this.showDebounced(range);
    }
    /**
     * Cancel hiding comment.
     */
  }, {
    key: "cancelHiding",
    value: function cancelHiding() {
      this.wasLastActionShow = true;
      clearTimeout(this.hidingTimer);
      this.hidingTimer = null;
    }
    /**
     * Update the switch settings.
     *
     * @param {number} displayDelay Delay of showing the comments (in milliseconds).
     */
  }, {
    key: "updateDelay",
    value: function updateDelay() {
      var _this2 = this;
      var displayDelay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_DISPLAY_DELAY;
      this.showDebounced = debounce(function(range) {
        if (_this2.wasLastActionShow) {
          _this2.runLocalHooks("show", range.from.row, range.from.col);
        }
      }, displayDelay);
    }
    /**
     * Destroy the switcher.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearLocalHooks();
    }
  }]);
  return DisplaySwitch2;
}();
mixin(DisplaySwitch, localHooks$1);
const DisplaySwitch$1 = DisplaySwitch;
function _typeof$I(obj) {
  "@babel/helpers - typeof";
  return _typeof$I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$I(obj);
}
function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$17(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$17(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$17(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$17(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$17(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$y() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$y = Reflect.get.bind();
  } else {
    _get$y = function _get2(target, property, receiver) {
      var base = _superPropBase$y(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$y.apply(this, arguments);
}
function _superPropBase$y(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$G(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$G(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$G(subClass, superClass);
}
function _setPrototypeOf$G(o, p2) {
  _setPrototypeOf$G = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$G(o, p2);
}
function _createSuper$G(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$G();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$G(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$G(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$G(this, result);
  };
}
function _possibleConstructorReturn$G(self2, call2) {
  if (call2 && (_typeof$I(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$G(self2);
}
function _assertThisInitialized$G(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$G() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$G(o) {
  _getPrototypeOf$G = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$G(o);
}
var PLUGIN_KEY$p = "comments";
var PLUGIN_PRIORITY$o = 60;
var privatePool$e = /* @__PURE__ */ new WeakMap();
var META_COMMENT = "comment";
var META_COMMENT_VALUE = "value";
var META_STYLE = "style";
var META_READONLY = "readOnly";
var Comments = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$G(Comments2, _BasePlugin);
  var _super = _createSuper$G(Comments2);
  function Comments2(hotInstance) {
    var _this;
    _classCallCheck$17(this, Comments2);
    _this = _super.call(this, hotInstance);
    _this.editor = null;
    _this.displaySwitch = null;
    _this.eventManager = null;
    _this.range = {};
    _this.preventEditorAutoSwitch = false;
    privatePool$e.set(_assertThisInitialized$G(_this), {
      tempEditorDimensions: {},
      cellBelowCursor: null
    });
    return _this;
  }
  _createClass$17(Comments2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$p];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      if (!this.editor) {
        this.editor = new CommentEditor$1(this.hot.rootDocument, this.hot.isRtl());
      }
      if (!this.eventManager) {
        this.eventManager = new EventManager$1(this);
      }
      if (!this.displaySwitch) {
        this.displaySwitch = new DisplaySwitch$1(this.getDisplayDelaySetting());
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.addToContextMenu(options);
      });
      this.addHook("afterRenderer", function(TD, row, col, prop, value, cellProperties) {
        return _this2.onAfterRenderer(TD, cellProperties);
      });
      this.addHook("afterScrollHorizontally", function() {
        return _this2.hide();
      });
      this.addHook("afterScrollVertically", function() {
        return _this2.hide();
      });
      this.addHook("afterBeginEditing", function() {
        return _this2.hide();
      });
      this.displaySwitch.addLocalHook("hide", function() {
        return _this2.hide();
      });
      this.displaySwitch.addLocalHook("show", function(row, col) {
        return _this2.showAtCell(row, col);
      });
      this.registerListeners();
      _get$y(_getPrototypeOf$G(Comments2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *   - [`comments`](@/api/options.md#comments)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$y(_getPrototypeOf$G(Comments2.prototype), "updatePlugin", this).call(this);
      this.displaySwitch.updateDelay(this.getDisplayDelaySetting());
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get$y(_getPrototypeOf$G(Comments2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Registers all necessary DOM listeners.
     *
     * @private
     */
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this3 = this;
      var rootDocument = this.hot.rootDocument;
      this.eventManager.addEventListener(rootDocument, "mouseover", function(event2) {
        return _this3.onMouseOver(event2);
      });
      this.eventManager.addEventListener(rootDocument, "mousedown", function(event2) {
        return _this3.onMouseDown(event2);
      });
      this.eventManager.addEventListener(rootDocument, "mouseup", function() {
        return _this3.onMouseUp();
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "blur", function() {
        return _this3.onEditorBlur();
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "mousedown", function(event2) {
        return _this3.onEditorMouseDown(event2);
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "mouseup", function(event2) {
        return _this3.onEditorMouseUp(event2);
      });
    }
    /**
     * Sets the current cell range to be able to use general methods like {@link Comments#setComment}, {@link Comments#removeComment}, {@link Comments#show}.
     *
     * @param {object} range Object with `from` property, each with `row` and `col` properties.
     */
  }, {
    key: "setRange",
    value: function setRange(range) {
      this.range = range;
    }
    /**
     * Clears the currently selected cell.
     */
  }, {
    key: "clearRange",
    value: function clearRange() {
      this.range = {};
    }
    /**
     * Checks if the event target is a cell containing a comment.
     *
     * @private
     * @param {Event} event DOM event.
     * @returns {boolean}
     */
  }, {
    key: "targetIsCellWithComment",
    value: function targetIsCellWithComment(event2) {
      var closestCell = closest(event2.target, "TD", "TBODY");
      return !!(closestCell && hasClass(closestCell, "htCommentCell") && closest(closestCell, [this.hot.rootElement]));
    }
    /**
     * Checks if the event target is a comment textarea.
     *
     * @private
     * @param {Event} event DOM event.
     * @returns {boolean}
     */
  }, {
    key: "targetIsCommentTextArea",
    value: function targetIsCommentTextArea(event2) {
      return this.editor.getInputElement() === event2.target;
    }
    /**
     * Sets a comment for a cell according to the previously set range (see {@link Comments#setRange}).
     *
     * @param {string} value Comment contents.
     */
  }, {
    key: "setComment",
    value: function setComment(value) {
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      var editorValue = this.editor.getValue();
      var comment = "";
      if (value !== null && value !== void 0) {
        comment = value;
      } else if (editorValue !== null && editorValue !== void 0) {
        comment = editorValue;
      }
      var row = this.range.from.row;
      var col = this.range.from.col;
      this.updateCommentMeta(row, col, _defineProperty$d({}, META_COMMENT_VALUE, comment));
      this.hot.render();
    }
    /**
     * Sets a comment for a specified cell.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {string} value Comment contents.
     */
  }, {
    key: "setCommentAtCell",
    value: function setCommentAtCell(row, column, value) {
      this.setRange({
        from: this.hot._createCellCoords(row, column)
      });
      this.setComment(value);
    }
    /**
     * Removes a comment from a cell according to previously set range (see {@link Comments#setRange}).
     *
     * @param {boolean} [forceRender=true] If set to `true`, the table will be re-rendered at the end of the operation.
     */
  }, {
    key: "removeComment",
    value: function removeComment() {
      var forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      this.hot.setCellMeta(this.range.from.row, this.range.from.col, META_COMMENT);
      if (forceRender) {
        this.hot.render();
      }
      this.hide();
    }
    /**
     * Removes a comment from a specified cell.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {boolean} [forceRender=true] If `true`, the table will be re-rendered at the end of the operation.
     */
  }, {
    key: "removeCommentAtCell",
    value: function removeCommentAtCell(row, column) {
      var forceRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      this.setRange({
        from: this.hot._createCellCoords(row, column)
      });
      this.removeComment(forceRender);
    }
    /**
     * Gets comment from a cell according to previously set range (see {@link Comments#setRange}).
     *
     * @returns {string|undefined} Returns a content of the comment.
     */
  }, {
    key: "getComment",
    value: function getComment() {
      var row = this.range.from.row;
      var column = this.range.from.col;
      return this.getCommentMeta(row, column, META_COMMENT_VALUE);
    }
    /**
     * Gets comment from a cell at the provided coordinates.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @returns {string|undefined} Returns a content of the comment.
     */
  }, {
    key: "getCommentAtCell",
    value: function getCommentAtCell(row, column) {
      return this.getCommentMeta(row, column, META_COMMENT_VALUE);
    }
    /**
     * Shows the comment editor accordingly to the previously set range (see {@link Comments#setRange}).
     *
     * @returns {boolean} Returns `true` if comment editor was shown.
     */
  }, {
    key: "show",
    value: function show() {
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      var _this$range$from = this.range.from, row = _this$range$from.row, col = _this$range$from.col;
      if (row < 0 || row > this.hot.countSourceRows() - 1 || col < 0 || col > this.hot.countSourceCols() - 1) {
        return false;
      }
      var meta2 = this.hot.getCellMeta(this.range.from.row, this.range.from.col);
      this.editor.setValue(meta2[META_COMMENT] ? meta2[META_COMMENT][META_COMMENT_VALUE] : "");
      this.editor.show();
      this.refreshEditor(true);
      return true;
    }
    /**
     * Shows comment editor according to cell coordinates.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @returns {boolean} Returns `true` if comment editor was shown.
     */
  }, {
    key: "showAtCell",
    value: function showAtCell(row, column) {
      this.setRange({
        from: this.hot._createCellCoords(row, column)
      });
      return this.show();
    }
    /**
     * Hides the comment editor.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.editor.hide();
    }
    /**
     * Refreshes comment editor position and styling.
     *
     * @param {boolean} [force=false] If `true` then recalculation will be forced.
     */
  }, {
    key: "refreshEditor",
    value: function refreshEditor() {
      var _renderableRow, _renderableColumn;
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!force && (!this.range.from || !this.editor.isVisible())) {
        return;
      }
      var _this$hot = this.hot, rowIndexMapper = _this$hot.rowIndexMapper, columnIndexMapper = _this$hot.columnIndexMapper;
      var _this$range$from2 = this.range.from, visualRow = _this$range$from2.row, visualColumn = _this$range$from2.col;
      var renderableRow = rowIndexMapper.getRenderableFromVisualIndex(visualRow);
      var renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(visualColumn);
      var targetingPreviousRow = renderableRow === null;
      if (renderableRow === null) {
        renderableRow = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(visualRow, -1));
      }
      if (renderableColumn === null) {
        renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(visualColumn, -1));
      }
      var isBeforeRenderedRows = renderableRow === null;
      var isBeforeRenderedColumns = renderableColumn === null;
      renderableRow = (_renderableRow = renderableRow) !== null && _renderableRow !== void 0 ? _renderableRow : 0;
      renderableColumn = (_renderableColumn = renderableColumn) !== null && _renderableColumn !== void 0 ? _renderableColumn : 0;
      var _this$hot2 = this.hot, rootWindow = _this$hot2.rootWindow, wt = _this$hot2.view._wt;
      var wtTable = wt.wtTable;
      var TD = wtTable.getCell({
        row: renderableRow,
        col: renderableColumn
      });
      var commentStyle = this.getCommentMeta(visualRow, visualColumn, META_STYLE);
      if (commentStyle) {
        this.editor.setSize(commentStyle.width, commentStyle.height);
      } else {
        this.editor.resetSize();
      }
      var lastColWidth = isBeforeRenderedColumns ? 0 : wtTable.getStretchedColumnWidth(renderableColumn);
      var lastRowHeight = targetingPreviousRow && !isBeforeRenderedRows ? outerHeight(TD) : 0;
      var _TD$getBoundingClient = TD.getBoundingClientRect(), left2 = _TD$getBoundingClient.left, top2 = _TD$getBoundingClient.top, cellWidth = _TD$getBoundingClient.width, cellHeight = _TD$getBoundingClient.height;
      var _this$editor$getSize = this.editor.getSize(), editorWidth = _this$editor$getSize.width, editorHeight = _this$editor$getSize.height;
      var _this$hot$rootWindow = this.hot.rootWindow, innerWidth2 = _this$hot$rootWindow.innerWidth, innerHeight2 = _this$hot$rootWindow.innerHeight;
      var documentElement = this.hot.rootDocument.documentElement;
      var x2 = left2 + rootWindow.scrollX + lastColWidth;
      var y2 = top2 + rootWindow.scrollY + lastRowHeight;
      if (this.hot.isRtl()) {
        x2 -= editorWidth + lastColWidth;
      }
      if (this.hot.isLtr() && left2 + cellWidth + editorWidth > innerWidth2) {
        x2 = left2 + rootWindow.scrollX - editorWidth - 1;
      } else if (this.hot.isRtl() && x2 < -(documentElement.scrollWidth - documentElement.clientWidth)) {
        x2 = left2 + rootWindow.scrollX + lastColWidth + 1;
      }
      if (top2 + editorHeight > innerHeight2) {
        y2 -= editorHeight - cellHeight + 1;
      }
      this.editor.setPosition(x2, y2);
      this.editor.setReadOnlyState(this.getCommentMeta(visualRow, visualColumn, META_READONLY));
    }
    /**
     * Checks if there is a comment for selected range.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "checkSelectionCommentsConsistency",
    value: function checkSelectionCommentsConsistency() {
      var selected = this.hot.getSelectedRangeLast();
      if (!selected) {
        return false;
      }
      var hasComment = false;
      var cell = selected.getTopStartCorner();
      if (this.getCommentMeta(cell.row, cell.col, META_COMMENT_VALUE)) {
        hasComment = true;
      }
      return hasComment;
    }
    /**
     * Sets or update the comment-related cell meta.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {object} metaObject Object defining all the comment-related meta information.
     */
  }, {
    key: "updateCommentMeta",
    value: function updateCommentMeta(row, column, metaObject) {
      var oldComment = this.hot.getCellMeta(row, column)[META_COMMENT];
      var newComment;
      if (oldComment) {
        newComment = deepClone(oldComment);
        deepExtend(newComment, metaObject);
      } else {
        newComment = metaObject;
      }
      this.hot.setCellMeta(row, column, META_COMMENT, newComment);
    }
    /**
     * Gets the comment related meta information.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {string} property Cell meta property.
     * @returns {Mixed}
     */
  }, {
    key: "getCommentMeta",
    value: function getCommentMeta(row, column, property) {
      var cellMeta = this.hot.getCellMeta(row, column);
      if (!cellMeta[META_COMMENT]) {
        return void 0;
      }
      return cellMeta[META_COMMENT][property];
    }
    /**
     * `mousedown` event callback.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      if (!this.hot.view || !this.hot.view._wt) {
        return;
      }
      if (!this.preventEditorAutoSwitch && !this.targetIsCommentTextArea(event2)) {
        var eventCell = closest(event2.target, "TD", "TBODY");
        var coordinates = null;
        if (eventCell) {
          coordinates = this.hot.getCoords(eventCell);
        }
        if (!eventCell || this.range.from && coordinates && (this.range.from.row !== coordinates.row || this.range.from.col !== coordinates.col)) {
          this.hide();
        }
      }
    }
    /**
     * `mouseover` event callback.
     *
     * @private
     * @param {MouseEvent} event The `mouseover` event.
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      var priv = privatePool$e.get(this);
      var rootDocument = this.hot.rootDocument;
      if (this.preventEditorAutoSwitch || this.editor.isFocused() || hasClass(event2.target, "wtBorder") || priv.cellBelowCursor === event2.target || !this.editor) {
        return;
      }
      priv.cellBelowCursor = rootDocument.elementFromPoint(event2.clientX, event2.clientY);
      if (this.targetIsCellWithComment(event2)) {
        var range = this.hot._createCellRange(this.hot.getCoords(event2.target));
        this.displaySwitch.show(range);
      } else if (isChildOf(event2.target, rootDocument) && !this.targetIsCommentTextArea(event2)) {
        this.displaySwitch.hide();
      }
    }
    /**
     * `mouseup` event callback.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      this.preventEditorAutoSwitch = false;
    }
    /**
     * The `afterRenderer` hook callback.
     *
     * @private
     * @param {HTMLTableCellElement} TD The rendered `TD` element.
     * @param {object} cellProperties The rendered cell's property object.
     */
  }, {
    key: "onAfterRenderer",
    value: function onAfterRenderer(TD, cellProperties) {
      if (cellProperties[META_COMMENT] && cellProperties[META_COMMENT][META_COMMENT_VALUE]) {
        addClass(TD, cellProperties.commentedCellClassName);
      }
    }
    /**
     * `blur` event callback for the comment editor.
     *
     * @private
     */
  }, {
    key: "onEditorBlur",
    value: function onEditorBlur() {
      this.setComment();
    }
    /**
     * `mousedown` hook. Along with `onEditorMouseUp` used to simulate the textarea resizing event.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     */
  }, {
    key: "onEditorMouseDown",
    value: function onEditorMouseDown(event2) {
      var priv = privatePool$e.get(this);
      priv.tempEditorDimensions = {
        width: outerWidth(event2.target),
        height: outerHeight(event2.target)
      };
    }
    /**
     * `mouseup` hook. Along with `onEditorMouseDown` used to simulate the textarea resizing event.
     *
     * @private
     * @param {MouseEvent} event The `mouseup` event.
     */
  }, {
    key: "onEditorMouseUp",
    value: function onEditorMouseUp(event2) {
      var priv = privatePool$e.get(this);
      var currentWidth = outerWidth(event2.target);
      var currentHeight = outerHeight(event2.target);
      if (currentWidth !== priv.tempEditorDimensions.width + 1 || currentHeight !== priv.tempEditorDimensions.height + 2) {
        this.updateCommentMeta(this.range.from.row, this.range.from.col, _defineProperty$d({}, META_STYLE, {
          width: currentWidth,
          height: currentHeight
        }));
      }
    }
    /**
     * Context Menu's "Add comment" callback. Results in showing the comment editor.
     *
     * @private
     */
  }, {
    key: "onContextMenuAddComment",
    value: function onContextMenuAddComment() {
      var coords = this.hot.getSelectedRangeLast();
      this.preventEditorAutoSwitch = true;
      this.displaySwitch.cancelHiding();
      this.setRange({
        from: coords.highlight
      });
      this.show();
      this.hot.deselectCell();
      this.editor.focus();
    }
    /**
     * Context Menu's "remove comment" callback.
     *
     * @private
     */
  }, {
    key: "onContextMenuRemoveComment",
    value: function onContextMenuRemoveComment() {
      var _this4 = this;
      var coords = this.hot.getSelectedRangeLast();
      this.preventEditorAutoSwitch = true;
      coords.forAll(function(row, column) {
        if (row >= 0 && column >= 0) {
          _this4.removeCommentAtCell(row, column, false);
        }
      });
      this.hot.render();
    }
    /**
     * Context Menu's "make comment read-only" callback.
     *
     * @private
     */
  }, {
    key: "onContextMenuMakeReadOnly",
    value: function onContextMenuMakeReadOnly() {
      var _this5 = this;
      var coords = this.hot.getSelectedRangeLast();
      this.preventEditorAutoSwitch = true;
      coords.forAll(function(row, column) {
        if (row >= 0 && column >= 0) {
          var currentState = !!_this5.getCommentMeta(row, column, META_READONLY);
          _this5.updateCommentMeta(row, column, _defineProperty$d({}, META_READONLY, !currentState));
        }
      });
    }
    /**
     * Add Comments plugin options to the Context Menu.
     *
     * @private
     * @param {object} defaultOptions The menu options.
     */
  }, {
    key: "addToContextMenu",
    value: function addToContextMenu(defaultOptions) {
      var _this6 = this;
      var isThereAnyCellRendered = function isThereAnyCellRendered2() {
        return _this6.hot.rowIndexMapper.getRenderableIndexesLength() > 0 && _this6.hot.columnIndexMapper.getRenderableIndexesLength() > 0;
      };
      defaultOptions.items.push({
        name: "---------"
      }, {
        key: "commentsAddEdit",
        name: function name() {
          if (_this6.checkSelectionCommentsConsistency()) {
            return _this6.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_EDIT_COMMENT);
          }
          return _this6.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_ADD_COMMENT);
        },
        callback: function callback() {
          return _this6.onContextMenuAddComment();
        },
        disabled: function disabled() {
          if (!isThereAnyCellRendered()) {
            return true;
          }
          return !(_this6.hot.getSelectedLast() && !_this6.hot.selection.isSelectedByCorner());
        }
      }, {
        key: "commentsRemove",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COMMENT);
        },
        callback: function callback() {
          return _this6.onContextMenuRemoveComment();
        },
        disabled: function disabled() {
          if (!isThereAnyCellRendered()) {
            return true;
          }
          return !(_this6.hot.getSelectedLast() && !_this6.hot.selection.isSelectedByCorner());
        }
      }, {
        key: "commentsReadOnly",
        name: function name() {
          var _this7 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY_COMMENT);
          var hasProperty = checkSelectionConsistency(this.getSelectedRangeLast(), function(row, col) {
            var readOnlyProperty = _this7.getCellMeta(row, col)[META_COMMENT];
            if (readOnlyProperty) {
              readOnlyProperty = readOnlyProperty[META_READONLY];
            }
            if (readOnlyProperty) {
              return true;
            }
          });
          if (hasProperty) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          return _this6.onContextMenuMakeReadOnly();
        },
        disabled: function disabled() {
          if (!isThereAnyCellRendered()) {
            return true;
          }
          return !(_this6.hot.getSelectedLast() && !_this6.hot.selection.isSelectedByCorner()) || !_this6.checkSelectionCommentsConsistency();
        }
      });
    }
    /**
     * Get `displayDelay` setting of comment plugin.
     *
     * @private
     * @returns {number|undefined}
     */
  }, {
    key: "getDisplayDelaySetting",
    value: function getDisplayDelaySetting() {
      var commentSetting = this.hot.getSettings()[PLUGIN_KEY$p];
      if (isObject$7(commentSetting)) {
        return commentSetting.displayDelay;
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.editor) {
        this.editor.destroy();
      }
      if (this.displaySwitch) {
        this.displaySwitch.destroy();
      }
      _get$y(_getPrototypeOf$G(Comments2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$p;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$o;
    }
  }]);
  return Comments2;
}(BasePlugin);
function _classCallCheck$16(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$16(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$16(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$16(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$16(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var CommandExecutor = /* @__PURE__ */ function() {
  function CommandExecutor2(hotInstance) {
    _classCallCheck$16(this, CommandExecutor2);
    this.hot = hotInstance;
    this.commands = {};
    this.commonCallback = null;
  }
  _createClass$16(CommandExecutor2, [{
    key: "registerCommand",
    value: function registerCommand(name, commandDescriptor) {
      this.commands[name] = commandDescriptor;
    }
    /**
     * Set common callback which will be trigger on every executed command.
     *
     * @param {Function} callback Function which will be fired on every command execute.
     */
  }, {
    key: "setCommonCallback",
    value: function setCommonCallback(callback) {
      this.commonCallback = callback;
    }
    /**
     * Execute command by its name.
     *
     * @param {string} commandName Command id.
     * @param {*} params Arguments passed to command task.
     */
  }, {
    key: "execute",
    value: function execute(commandName) {
      var _this = this;
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      var commandSplit = commandName.split(":");
      var commandNamePrimary = commandSplit[0];
      var subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
      var command = this.commands[commandNamePrimary];
      if (!command) {
        throw new Error("Menu command '".concat(commandNamePrimary, "' not exists."));
      }
      if (subCommandName && command.submenu) {
        command = findSubCommand(subCommandName, command.submenu.items);
      }
      if (command.disabled === true) {
        return;
      }
      if (typeof command.disabled === "function" && command.disabled.call(this.hot) === true) {
        return;
      }
      if (hasOwnProperty$2(command, "submenu")) {
        return;
      }
      var callbacks = [];
      if (typeof command.callback === "function") {
        callbacks.push(command.callback);
      }
      if (typeof this.commonCallback === "function") {
        callbacks.push(this.commonCallback);
      }
      params.unshift(commandSplit.join(":"));
      arrayEach(callbacks, function(callback) {
        return callback.apply(_this.hot, params);
      });
    }
  }]);
  return CommandExecutor2;
}();
function findSubCommand(subCommandName, subCommands) {
  var command;
  arrayEach(subCommands, function(cmd) {
    var cmds = cmd.key ? cmd.key.split(":") : null;
    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
      command = cmd;
      return false;
    }
  });
  return command;
}
const CommandExecutor$1 = CommandExecutor;
var KEY$b = "alignment";
function alignmentItem() {
  return {
    key: KEY$b,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT);
    },
    disabled: function disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());
    },
    submenu: {
      items: [{
        key: "".concat(KEY$b, ":left"),
        name: function name() {
          var _this = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this.getCellMeta(row, col).className;
            if (className && className.indexOf("htLeft") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this2 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this2.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htLeft";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this2.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this2.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$b, ":center"),
        name: function name() {
          var _this3 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this3.getCellMeta(row, col).className;
            if (className && className.indexOf("htCenter") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this4 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this4.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htCenter";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this4.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this4.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$b, ":right"),
        name: function name() {
          var _this5 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this5.getCellMeta(row, col).className;
            if (className && className.indexOf("htRight") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this6 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this6.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htRight";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this6.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this6.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$b, ":justify"),
        name: function name() {
          var _this7 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this7.getCellMeta(row, col).className;
            if (className && className.indexOf("htJustify") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this8 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this8.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htJustify";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this8.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this8.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        name: KEY$c
      }, {
        key: "".concat(KEY$b, ":top"),
        name: function name() {
          var _this9 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_TOP);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this9.getCellMeta(row, col).className;
            if (className && className.indexOf("htTop") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this10 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this10.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htTop";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this10.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this10.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$b, ":middle"),
        name: function name() {
          var _this11 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this11.getCellMeta(row, col).className;
            if (className && className.indexOf("htMiddle") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this12 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this12.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htMiddle";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this12.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this12.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$b, ":bottom"),
        name: function name() {
          var _this13 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this13.getCellMeta(row, col).className;
            if (className && className.indexOf("htBottom") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this14 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this14.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htBottom";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this14.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this14.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }]
    }
  };
}
var KEY$a = "clear_column";
function clearColumnItem() {
  return {
    key: KEY$a,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CLEAR_COLUMN);
    },
    callback: function callback(key, selection) {
      var startColumn = selection[0].start.col;
      var endColumn = selection[0].end.col;
      if (this.countRows()) {
        this.populateFromArray(0, startColumn, [[null]], Math.max(selection[0].start.row, selection[0].end.row), endColumn, "ContextMenu.clearColumn");
      }
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      return !this.selection.isSelectedByColumnHeader();
    }
  };
}
var KEY$9 = "col_left";
function columnLeftItem() {
  return {
    key: KEY$9,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_LEFT);
    },
    callback: function callback() {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var columnLeft = this.isRtl() ? this.countCols() : 0;
      if (!isSelectedByCorner) {
        var selectedRange = this.getSelectedRangeLast();
        if (isDefined(selectedRange)) {
          var _selectedRange$getTop = selectedRange.getTopLeftCorner(), col = _selectedRange$getTop.col;
          columnLeft = this.isRtl() ? col + 1 : col;
        }
      }
      this.alter("insert_col", columnLeft, 1, "ContextMenu.columnLeft");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        var totalColumns = this.countCols();
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}
var KEY$8 = "col_right";
function columnRightItem() {
  return {
    key: KEY$8,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_RIGHT);
    },
    callback: function callback() {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var columnRight = this.isRtl() ? 0 : this.countCols();
      if (!isSelectedByCorner) {
        var selectedRange = this.getSelectedRangeLast();
        if (isDefined(selectedRange)) {
          var _selectedRange$getTop = selectedRange.getTopRightCorner(), col = _selectedRange$getTop.col;
          columnRight = this.isRtl() ? col : col + 1;
        }
      }
      this.alter("insert_col", columnRight, 1, "ContextMenu.columnRight");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}
var KEY$7 = "make_read_only";
function readOnlyItem() {
  return {
    key: KEY$7,
    name: function name() {
      var _this = this;
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY);
      var atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
        return _this.getCellMeta(row, col).readOnly;
      });
      if (atLeastOneReadOnly) {
        label = markLabelAsSelected(label);
      }
      return label;
    },
    callback: function callback() {
      var _this2 = this;
      var ranges = this.getSelectedRange();
      var atLeastOneReadOnly = checkSelectionConsistency(ranges, function(row, col) {
        return _this2.getCellMeta(row, col).readOnly;
      });
      arrayEach(ranges, function(range) {
        range.forAll(function(row, col) {
          if (row >= 0 && col >= 0) {
            _this2.setCellMeta(row, col, "readOnly", !atLeastOneReadOnly);
          }
        });
      });
      this.render();
    },
    disabled: function disabled() {
      if (this.selection.isSelectedByCorner()) {
        return true;
      }
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      if (!this.getSelectedRange() || this.getSelectedRange().length === 0) {
        return true;
      }
      return false;
    }
  };
}
var KEY$6 = "redo";
function redoItem() {
  return {
    key: KEY$6,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REDO);
    },
    callback: function callback() {
      this.redo();
    },
    hidden: function hidden() {
      var undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled: function disabled() {
      return !this.getPlugin("undoRedo").isRedoAvailable();
    }
  };
}
function _slicedToArray$s(arr, i) {
  return _arrayWithHoles$t(arr) || _iterableToArrayLimit$s(arr, i) || _unsupportedIterableToArray$E(arr, i) || _nonIterableRest$t();
}
function _nonIterableRest$t() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$E(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$E(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$E(o, minLen);
}
function _arrayLikeToArray$E(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$s(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$t(arr) {
  if (Array.isArray(arr))
    return arr;
}
var KEY$5 = "remove_col";
function removeColumnItem() {
  return {
    key: KEY$5,
    name: function name() {
      var selection = this.getSelected();
      var pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          var _selection$ = _slicedToArray$s(selection[0], 4), fromColumn = _selection$[1], toColumn = _selection$[3];
          if (fromColumn - toColumn !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COLUMN, pluralForm);
    },
    callback: function callback() {
      this.alter("remove_col", transformSelectionToColumnDistance(this.getSelected()), null, "ContextMenu.removeColumn");
    },
    disabled: function disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      var totalColumns = this.countCols();
      if (this.selection.isSelectedByCorner()) {
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || totalColumns === 0;
    },
    hidden: function hidden() {
      return !this.getSettings().allowRemoveColumn;
    }
  };
}
function _slicedToArray$r(arr, i) {
  return _arrayWithHoles$s(arr) || _iterableToArrayLimit$r(arr, i) || _unsupportedIterableToArray$D(arr, i) || _nonIterableRest$s();
}
function _nonIterableRest$s() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$D(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$D(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$D(o, minLen);
}
function _arrayLikeToArray$D(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$r(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$s(arr) {
  if (Array.isArray(arr))
    return arr;
}
var KEY$4 = "remove_row";
function removeRowItem() {
  return {
    key: KEY$4,
    name: function name() {
      var selection = this.getSelected();
      var pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          var _selection$ = _slicedToArray$r(selection[0], 3), fromRow = _selection$[0], toRow = _selection$[2];
          if (fromRow - toRow !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_ROW, pluralForm);
    },
    callback: function callback() {
      this.alter("remove_row", transformSelectionToRowDistance(this.getSelected()), 1, "ContextMenu.removeRow");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      var totalRows = this.countRows();
      if (this.selection.isSelectedByCorner()) {
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || totalRows === 0;
    },
    hidden: function hidden() {
      return !this.getSettings().allowRemoveRow;
    }
  };
}
var KEY$3 = "row_above";
function rowAboveItem() {
  return {
    key: KEY$3,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_ABOVE);
    },
    callback: function callback(key, normalizedSelection) {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var rowAbove = 0;
      if (!isSelectedByCorner) {
        var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
        rowAbove = latestSelection.start.row;
      }
      this.alter("insert_row", rowAbove, 1, "ContextMenu.rowAbove");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        var totalRows = this.countRows();
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}
var KEY$2 = "row_below";
function rowBelowItem() {
  return {
    key: KEY$2,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_BELOW);
    },
    callback: function callback(key, normalizedSelection) {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var rowBelow = 0;
      if (isSelectedByCorner) {
        rowBelow = this.countRows();
      } else {
        var _latestSelection$end;
        var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
        var selectedRow = latestSelection === null || latestSelection === void 0 ? void 0 : (_latestSelection$end = latestSelection.end) === null || _latestSelection$end === void 0 ? void 0 : _latestSelection$end.row;
        rowBelow = isDefined(selectedRow) ? selectedRow + 1 : 0;
      }
      this.alter("insert_row", rowBelow, 1, "ContextMenu.rowBelow");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}
var KEY$1 = "no_items";
function noItemsItem() {
  return {
    key: KEY$1,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NO_ITEMS);
    },
    disabled: true,
    isCommand: false
  };
}
var KEY = "undo";
function undoItem() {
  return {
    key: KEY,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNDO);
    },
    callback: function callback() {
      this.undo();
    },
    hidden: function hidden() {
      var undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled: function disabled() {
      return !this.getPlugin("undoRedo").isUndoAvailable();
    }
  };
}
var _predefinedItems2;
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ITEMS = [KEY$3, KEY$2, KEY$9, KEY$8, KEY$a, KEY$4, KEY$5, KEY, KEY$6, KEY$7, KEY$b, KEY$c, KEY$1];
var _predefinedItems = (_predefinedItems2 = {}, _defineProperty$c(_predefinedItems2, KEY$c, separatorItem), _defineProperty$c(_predefinedItems2, KEY$1, noItemsItem), _defineProperty$c(_predefinedItems2, KEY$3, rowAboveItem), _defineProperty$c(_predefinedItems2, KEY$2, rowBelowItem), _defineProperty$c(_predefinedItems2, KEY$9, columnLeftItem), _defineProperty$c(_predefinedItems2, KEY$8, columnRightItem), _defineProperty$c(_predefinedItems2, KEY$a, clearColumnItem), _defineProperty$c(_predefinedItems2, KEY$4, removeRowItem), _defineProperty$c(_predefinedItems2, KEY$5, removeColumnItem), _defineProperty$c(_predefinedItems2, KEY, undoItem), _defineProperty$c(_predefinedItems2, KEY$6, redoItem), _defineProperty$c(_predefinedItems2, KEY$7, readOnlyItem), _defineProperty$c(_predefinedItems2, KEY$b, alignmentItem), _predefinedItems2);
function predefinedItems() {
  var items = {};
  objectEach(_predefinedItems, function(itemFactory, key) {
    items[key] = itemFactory();
  });
  return items;
}
function _classCallCheck$15(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$15(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$15(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$15(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$15(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ItemsFactory = /* @__PURE__ */ function() {
  function ItemsFactory2(hotInstance) {
    var orderPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    _classCallCheck$15(this, ItemsFactory2);
    this.hot = hotInstance;
    this.predefinedItems = predefinedItems();
    this.defaultOrderPattern = orderPattern;
  }
  _createClass$15(ItemsFactory2, [{
    key: "setPredefinedItems",
    value: function setPredefinedItems(predefinedItemsCollection) {
      var _this = this;
      var items = {};
      this.defaultOrderPattern.length = 0;
      objectEach(predefinedItemsCollection, function(value, key) {
        var menuItemKey = "";
        if (value.name === KEY$c) {
          items[KEY$c] = value;
          menuItemKey = KEY$c;
        } else if (isNaN(parseInt(key, 10))) {
          value.key = value.key === void 0 ? key : value.key;
          items[key] = value;
          menuItemKey = value.key;
        } else {
          items[value.key] = value;
          menuItemKey = value.key;
        }
        _this.defaultOrderPattern.push(menuItemKey);
      });
      this.predefinedItems = items;
    }
    /**
     * Get all menu items based on pattern.
     *
     * @param {Array|object|boolean} pattern Pattern which you can define by displaying menu items order. If `true` default
     *                                       pattern will be used.
     * @returns {Array}
     */
  }, {
    key: "getItems",
    value: function getItems() {
      var pattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return _getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
    }
  }]);
  return ItemsFactory2;
}();
function _getItems() {
  var itemsPattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  var defaultPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var items = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var result = [];
  var pattern = itemsPattern;
  if (pattern && pattern.items) {
    pattern = pattern.items;
  } else if (!Array.isArray(pattern)) {
    pattern = defaultPattern;
  }
  if (isObject$7(pattern)) {
    objectEach(pattern, function(value, key) {
      var item = items[typeof value === "string" ? value : key];
      if (!item) {
        item = value;
      }
      if (isObject$7(value)) {
        extend(item, value);
      } else if (typeof item === "string") {
        item = {
          name: item
        };
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  } else {
    arrayEach(pattern, function(name, key) {
      var item = items[name];
      if (!item && ITEMS.indexOf(name) >= 0) {
        return;
      }
      if (!item) {
        item = {
          name,
          key: "".concat(key)
        };
      }
      if (isObject$7(name)) {
        extend(item, name);
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  }
  return result;
}
const ItemsFactory$1 = ItemsFactory;
function _classCallCheck$14(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$14(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$14(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$14(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$14(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Cursor = /* @__PURE__ */ function() {
  function Cursor2(object, rootWindow) {
    _classCallCheck$14(this, Cursor2);
    var windowScrollTop = getWindowScrollTop(rootWindow);
    var windowScrollLeft = getWindowScrollLeft(rootWindow);
    var top2;
    var topRelative;
    var left2;
    var leftRelative;
    var cellHeight;
    var cellWidth;
    this.rootWindow = rootWindow;
    this.type = this.getSourceType(object);
    if (this.type === "literal") {
      top2 = parseInt(object.top, 10);
      left2 = parseInt(object.left, 10);
      cellHeight = object.height || 0;
      cellWidth = object.width || 0;
      topRelative = top2;
      leftRelative = left2;
      top2 += windowScrollTop;
      left2 += windowScrollLeft;
    } else if (this.type === "event") {
      top2 = parseInt(object.pageY, 10);
      left2 = parseInt(object.pageX, 10);
      cellHeight = object.target.clientHeight;
      cellWidth = object.target.clientWidth;
      topRelative = top2 - windowScrollTop;
      leftRelative = left2 - windowScrollLeft;
    }
    this.top = top2;
    this.topRelative = topRelative;
    this.left = left2;
    this.leftRelative = leftRelative;
    this.scrollTop = windowScrollTop;
    this.scrollLeft = windowScrollLeft;
    this.cellHeight = cellHeight;
    this.cellWidth = cellWidth;
  }
  _createClass$14(Cursor2, [{
    key: "getSourceType",
    value: function getSourceType(object) {
      var type = "literal";
      if (object instanceof Event) {
        type = "event";
      }
      return type;
    }
    /**
     * Checks if element can be placed above the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit above the cursor.
     * @returns {boolean}
     */
  }, {
    key: "fitsAbove",
    value: function fitsAbove(element) {
      return this.topRelative >= element.offsetHeight;
    }
    /**
     * Checks if element can be placed below the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit below the cursor.
     * @param {number} [viewportHeight] The viewport height.
     * @returns {boolean}
     */
  }, {
    key: "fitsBelow",
    value: function fitsBelow(element) {
      var viewportHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerHeight;
      return this.topRelative + element.offsetHeight <= viewportHeight;
    }
    /**
     * Checks if element can be placed on the right of the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit on the right of the cursor.
     * @param {number} [viewportWidth] The viewport width.
     * @returns {boolean}
     */
  }, {
    key: "fitsOnRight",
    value: function fitsOnRight(element) {
      var viewportWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerWidth;
      return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
    }
    /**
     * Checks if element can be placed on the left on the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit on the left of the cursor.
     * @returns {boolean}
     */
  }, {
    key: "fitsOnLeft",
    value: function fitsOnLeft(element) {
      return this.leftRelative >= element.offsetWidth;
    }
  }]);
  return Cursor2;
}();
const Cursor$1 = Cursor;
function ownKeys$6(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$13(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$13(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$13(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$13(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$13(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var MIN_WIDTH = 215;
var SHORTCUTS_CONTEXT = "menu";
var SHORTCUTS_GROUP$3 = SHORTCUTS_CONTEXT;
var Menu = /* @__PURE__ */ function() {
  function Menu2(hotInstance, options) {
    _classCallCheck$13(this, Menu2);
    this.hot = hotInstance;
    this.options = options || {
      parent: null,
      name: null,
      className: "",
      keepInViewport: true,
      standalone: false,
      minWidth: MIN_WIDTH,
      container: this.hot.rootDocument.documentElement
    };
    this.eventManager = new EventManager$1(this);
    this.container = this.createContainer(this.options.name);
    this.hotMenu = null;
    this.hotSubMenus = {};
    this.parentMenu = this.options.parent || null;
    this.menuItems = null;
    this.origOutsideClickDeselects = null;
    this.keyEvent = false;
    this.offset = {
      above: 0,
      below: 0,
      left: 0,
      right: 0
    };
    this._afterScrollCallback = null;
    this.registerEvents();
  }
  _createClass$13(Menu2, [{
    key: "registerEvents",
    value: function registerEvents2() {
      var _this = this;
      var frame = this.hot.rootWindow;
      while (frame) {
        this.eventManager.addEventListener(frame.document, "mousedown", function(event2) {
          return _this.onDocumentMouseDown(event2);
        });
        this.eventManager.addEventListener(frame.document, "contextmenu", function(event2) {
          return _this.onDocumentContextMenu(event2);
        });
        frame = getParentWindow(frame);
      }
    }
    /**
     * Set array of objects which defines menu items.
     *
     * @param {Array} menuItems Menu items to display.
     */
  }, {
    key: "setMenuItems",
    value: function setMenuItems(menuItems) {
      this.menuItems = menuItems;
    }
    /**
     * Returns currently selected menu item. Returns `null` if no item was selected.
     *
     * @returns {object|null}
     */
  }, {
    key: "getSelectedItem",
    value: function getSelectedItem() {
      return this.hasSelectedItem() ? this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]) : null;
    }
    /**
     * Checks if the menu has selected (highlighted) any item from the menu list.
     *
     * @returns {boolean}
     */
  }, {
    key: "hasSelectedItem",
    value: function hasSelectedItem() {
      return Array.isArray(this.hotMenu.getSelectedLast());
    }
    /**
     * Set offset menu position for specified area (`above`, `below`, `left` or `right`).
     *
     * @param {string} area Specified area name (`above`, `below`, `left` or `right`).
     * @param {number} offset Offset value.
     */
  }, {
    key: "setOffset",
    value: function setOffset(area) {
      var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      this.offset[area] = offset2;
    }
    /**
     * Check if menu is using as sub-menu.
     *
     * @returns {boolean}
     */
  }, {
    key: "isSubMenu",
    value: function isSubMenu() {
      return this.parentMenu !== null;
    }
    /**
     * Open menu.
     *
     * @fires Hooks#beforeContextMenuShow
     * @fires Hooks#afterContextMenuShow
     */
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;
      this.runLocalHooks("beforeOpen");
      this.container.removeAttribute("style");
      this.container.style.display = "block";
      var delayedOpenSubMenu = debounce(function(row) {
        return _this2.openSubMenu(row);
      }, 300);
      var minWidthOfMenu = this.options.minWidth || MIN_WIDTH;
      var noItemsDefined = false;
      var filteredItems = arrayFilter(this.menuItems, function(item) {
        if (item.key === KEY$1) {
          noItemsDefined = true;
        }
        return isItemHidden(item, _this2.hot);
      });
      if (filteredItems.length < 1 && !noItemsDefined) {
        filteredItems.push(predefinedItems()[KEY$1]);
      } else if (filteredItems.length === 0) {
        return;
      }
      filteredItems = filterSeparators(filteredItems, KEY$c);
      var shouldAutoCloseMenu = false;
      var settings = {
        data: filteredItems,
        colHeaders: false,
        autoColumnSize: true,
        autoWrapRow: false,
        modifyColWidth: function modifyColWidth(width) {
          if (isDefined(width) && width < minWidthOfMenu) {
            return minWidthOfMenu;
          }
          return width;
        },
        autoRowSize: false,
        readOnly: true,
        editor: false,
        copyPaste: false,
        maxCols: 1,
        columns: [{
          data: "name",
          renderer: function renderer(hot, TD, row, col, prop, value) {
            return _this2.menuItemRenderer(hot, TD, row, col, prop, value);
          }
        }],
        renderAllRows: true,
        fragmentSelection: false,
        outsideClickDeselects: false,
        disableVisualSelection: "area",
        layoutDirection: this.hot.isRtl() ? "rtl" : "ltr",
        afterOnCellMouseOver: function afterOnCellMouseOver(event2, coords) {
          if (_this2.isAllSubMenusClosed()) {
            delayedOpenSubMenu(coords.row);
          } else {
            _this2.openSubMenu(coords.row);
          }
        },
        rowHeights: function rowHeights(row) {
          return filteredItems[row].name === KEY$c ? 1 : 23;
        },
        afterOnCellContextMenu: function afterOnCellContextMenu(event2) {
          event2.preventDefault();
          if (isWindowsOS() && shouldAutoCloseMenu && _this2.hasSelectedItem()) {
            _this2.close(true);
          }
        },
        beforeOnCellMouseUp: function beforeOnCellMouseUp(event2) {
          if (_this2.hasSelectedItem()) {
            shouldAutoCloseMenu = !_this2.isCommandPassive(_this2.getSelectedItem());
            _this2.executeCommand(event2);
          }
        },
        afterOnCellMouseUp: function afterOnCellMouseUp(event2) {
          if ((!isWindowsOS() || !isRightClick(event2)) && shouldAutoCloseMenu && _this2.hasSelectedItem()) {
            if (isMobileBrowser() || isIpadOS()) {
              setTimeout(function() {
                return _this2.close(true);
              }, 325);
            } else {
              _this2.close(true);
            }
          }
        },
        afterUnlisten: function afterUnlisten() {
          if (!_this2.hasSelectedItem() && _this2.isOpened()) {
            _this2.hotMenu.listen();
          }
        }
      };
      this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
      this.hot.getSettings().outsideClickDeselects = false;
      this.hotMenu = new Core(this.container, settings);
      this.hotMenu.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      this.hotMenu.addHook("afterSelection", function() {
        return _this2.onAfterSelection.apply(_this2, arguments);
      });
      this.hotMenu.init();
      this.hotMenu.listen();
      var shortcutManager = this.hotMenu.getShortcutManager();
      var menuContext = shortcutManager.addContext(SHORTCUTS_GROUP$3);
      var config = {
        group: SHORTCUTS_CONTEXT
      };
      var menuContextConfig = _objectSpread$6(_objectSpread$6({}, config), {}, {
        runOnlyIf: function runOnlyIf(event2) {
          return isInput(event2.target) === false || _this2.container.contains(event2.target) === false;
        }
      });
      shortcutManager.setActiveContextName("menu");
      menuContext.addShortcuts([{
        keys: [["Escape"]],
        callback: function callback() {
          _this2.keyEvent = true;
          _this2.close();
          _this2.keyEvent = false;
        }
      }, {
        keys: [["ArrowDown"]],
        callback: function callback() {
          var selection = _this2.hotMenu.getSelectedLast();
          _this2.keyEvent = true;
          if (selection) {
            _this2.selectNextCell(selection[0], selection[1]);
          } else {
            _this2.selectFirstCell();
          }
          _this2.keyEvent = false;
        }
      }, {
        keys: [["ArrowUp"]],
        callback: function callback() {
          var selection = _this2.hotMenu.getSelectedLast();
          _this2.keyEvent = true;
          if (selection) {
            _this2.selectPrevCell(selection[0], selection[1]);
          } else {
            _this2.selectLastCell();
          }
          _this2.keyEvent = false;
        }
      }, {
        keys: [["ArrowRight"]],
        callback: function callback() {
          var selection = _this2.hotMenu.getSelectedLast();
          _this2.keyEvent = true;
          if (selection) {
            var menu = _this2.openSubMenu(selection[0]);
            if (menu) {
              menu.selectFirstCell();
            }
          }
          _this2.keyEvent = false;
        }
      }, {
        keys: [["ArrowLeft"]],
        callback: function callback() {
          var selection = _this2.hotMenu.getSelectedLast();
          _this2.keyEvent = true;
          if (selection && _this2.isSubMenu()) {
            _this2.close();
            if (_this2.parentMenu) {
              _this2.parentMenu.hotMenu.listen();
            }
          }
          _this2.keyEvent = false;
        }
      }, {
        keys: [["Enter"]],
        callback: function callback(event2) {
          var selection = _this2.hotMenu.getSelectedLast();
          _this2.keyEvent = true;
          if (!_this2.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
            _this2.executeCommand(event2);
            _this2.close(true);
          }
          _this2.keyEvent = false;
        }
      }, {
        keys: [["PageUp"]],
        callback: function callback() {
          var selection = _this2.hotMenu.getSelectedLast();
          _this2.keyEvent = true;
          if (selection) {
            _this2.hotMenu.selection.transformStart(-_this2.hotMenu.countVisibleRows(), 0);
          } else {
            _this2.selectFirstCell();
          }
          _this2.keyEvent = false;
        }
      }, {
        keys: [["PageDown"]],
        callback: function callback() {
          var selection = _this2.hotMenu.getSelectedLast();
          _this2.keyEvent = true;
          if (selection) {
            _this2.hotMenu.selection.transformStart(_this2.hotMenu.countVisibleRows(), 0);
          } else {
            _this2.selectLastCell();
          }
          _this2.keyEvent = false;
        }
      }], menuContextConfig);
      this.blockMainTableCallbacks();
      this.runLocalHooks("afterOpen");
    }
    /**
     * Close menu.
     *
     * @param {boolean} [closeParent=false] If `true` try to close parent menu if exists.
     */
  }, {
    key: "close",
    value: function close() {
      var closeParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!this.isOpened()) {
        return;
      }
      if (closeParent && this.parentMenu) {
        this.parentMenu.close();
      } else {
        this.closeAllSubMenus();
        this.container.style.display = "none";
        this.releaseMainTableCallbacks();
        this.hotMenu.destroy();
        this.hotMenu = null;
        this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
        this.runLocalHooks("afterClose");
        if (this.parentMenu) {
          this.parentMenu.hotMenu.listen();
        }
      }
    }
    /**
     * Open sub menu at the provided row index.
     *
     * @param {number} row Row index.
     * @returns {Menu|boolean} Returns created menu or `false` if no one menu was created.
     */
  }, {
    key: "openSubMenu",
    value: function openSubMenu(row) {
      if (!this.hotMenu) {
        return false;
      }
      var cell = this.hotMenu.getCell(row, 0);
      this.closeAllSubMenus();
      if (!cell || !hasSubMenu(cell)) {
        return false;
      }
      var dataItem = this.hotMenu.getSourceDataAtRow(row);
      var subMenu = new Menu2(this.hot, {
        parent: this,
        name: dataItem.name,
        className: this.options.className,
        keepInViewport: true,
        container: this.options.container
      });
      subMenu.setMenuItems(dataItem.submenu.items);
      subMenu.open();
      subMenu.setPosition(cell.getBoundingClientRect());
      this.hotSubMenus[dataItem.key] = subMenu;
      return subMenu;
    }
    /**
     * Close sub menu at row index.
     *
     * @param {number} row Row index.
     */
  }, {
    key: "closeSubMenu",
    value: function closeSubMenu(row) {
      var dataItem = this.hotMenu.getSourceDataAtRow(row);
      var menus = this.hotSubMenus[dataItem.key];
      if (menus) {
        menus.destroy();
        delete this.hotSubMenus[dataItem.key];
      }
    }
    /**
     * Close all opened sub menus.
     */
  }, {
    key: "closeAllSubMenus",
    value: function closeAllSubMenus() {
      var _this3 = this;
      arrayEach(this.hotMenu.getData(), function(value, row) {
        return _this3.closeSubMenu(row);
      });
    }
    /**
     * Checks if all created and opened sub menus are closed.
     *
     * @returns {boolean}
     */
  }, {
    key: "isAllSubMenusClosed",
    value: function isAllSubMenusClosed() {
      return Object.keys(this.hotSubMenus).length === 0;
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var menuContainerParentElement = this.container.parentNode;
      this.clearLocalHooks();
      this.close();
      this.parentMenu = null;
      this.eventManager.destroy();
      if (menuContainerParentElement) {
        menuContainerParentElement.removeChild(this.container);
      }
    }
    /**
     * Checks if menu was opened.
     *
     * @returns {boolean} Returns `true` if menu was opened.
     */
  }, {
    key: "isOpened",
    value: function isOpened() {
      return this.hotMenu !== null;
    }
    /**
     * Execute menu command.
     *
     * The `executeCommand()` method works only for selected cells.
     *
     * When no cells are selected, `executeCommand()` doesn't do anything.
     *
     * @param {Event} [event] The mouse event object.
     */
  }, {
    key: "executeCommand",
    value: function executeCommand(event2) {
      if (!this.isOpened() || !this.hasSelectedItem()) {
        return;
      }
      var selectedItem = this.getSelectedItem();
      this.runLocalHooks("select", selectedItem, event2);
      if (this.isCommandPassive(selectedItem)) {
        return;
      }
      var selRanges = this.hot.getSelectedRange();
      var normalizedSelection = selRanges ? normalizeSelection(selRanges) : [];
      this.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event2);
      if (this.isSubMenu()) {
        this.parentMenu.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event2);
      }
    }
    /**
     * Checks if the passed command is passive or not. The command is passive when it's marked as
     * disabled, the descriptor object contains `isCommand` property set to `false`, command
     * is a separator, or the item is recognized as submenu. For passive items the menu is not
     * closed automatically after the user trigger the command through the UI.
     *
     * @param {object} commandDescriptor Selected menu item from the menu data source.
     * @returns {boolean}
     */
  }, {
    key: "isCommandPassive",
    value: function isCommandPassive(commandDescriptor) {
      var isCommand = commandDescriptor.isCommand, commandName = commandDescriptor.name, disabled = commandDescriptor.disabled, submenu = commandDescriptor.submenu;
      var isItemDisabled = disabled === true || typeof disabled === "function" && disabled.call(this.hot) === true;
      return isCommand === false || commandName === KEY$c || isItemDisabled === true || submenu;
    }
    /**
     * Set menu position based on dom event or based on literal object.
     *
     * @param {Event|object} coords Event or literal Object with coordinates.
     */
  }, {
    key: "setPosition",
    value: function setPosition(coords) {
      var cursor = new Cursor$1(coords, this.container.ownerDocument.defaultView);
      if (this.options.keepInViewport) {
        if (cursor.fitsBelow(this.container)) {
          this.setPositionBelowCursor(cursor);
        } else if (cursor.fitsAbove(this.container)) {
          this.setPositionAboveCursor(cursor);
        } else {
          this.setPositionBelowCursor(cursor);
        }
        if (this.hot.isLtr()) {
          this.setHorizontalPositionForLtr(cursor);
        } else {
          this.setHorizontalPositionForRtl(cursor);
        }
      } else {
        this.setPositionBelowCursor(cursor);
        this.setPositionOnRightOfCursor(cursor);
      }
    }
    /**
     * Set menu horizontal position for RTL mode.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setHorizontalPositionForRtl",
    value: function setHorizontalPositionForRtl(cursor) {
      if (cursor.fitsOnLeft(this.container)) {
        this.setPositionOnLeftOfCursor(cursor);
      } else {
        this.setPositionOnRightOfCursor(cursor);
      }
    }
    /**
     * Set menu horizontal position for LTR mode.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setHorizontalPositionForLtr",
    value: function setHorizontalPositionForLtr(cursor) {
      if (cursor.fitsOnRight(this.container)) {
        this.setPositionOnRightOfCursor(cursor);
      } else {
        this.setPositionOnLeftOfCursor(cursor);
      }
    }
    /**
     * Set menu position above cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionAboveCursor",
    value: function setPositionAboveCursor(cursor) {
      var top2 = this.offset.above + cursor.top - this.container.offsetHeight;
      if (this.isSubMenu()) {
        top2 = cursor.top + cursor.cellHeight - this.container.offsetHeight + 3;
      }
      this.container.style.top = "".concat(top2, "px");
    }
    /**
     * Set menu position below cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionBelowCursor",
    value: function setPositionBelowCursor(cursor) {
      var top2 = this.offset.below + cursor.top + 1;
      if (this.isSubMenu()) {
        top2 = cursor.top - 1;
      }
      this.container.style.top = "".concat(top2, "px");
    }
    /**
     * Set menu position on the right of cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionOnRightOfCursor",
    value: function setPositionOnRightOfCursor(cursor) {
      var left2 = cursor.left;
      if (this.isSubMenu()) {
        var _this$parentMenu$cont = this.parentMenu.container.getBoundingClientRect(), parentMenuRight = _this$parentMenu$cont.right;
        left2 += cursor.cellWidth + parentMenuRight - (cursor.left + cursor.cellWidth);
      } else {
        left2 += this.offset.right;
      }
      this.container.style.left = "".concat(left2, "px");
    }
    /**
     * Set menu position on the left of cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionOnLeftOfCursor",
    value: function setPositionOnLeftOfCursor(cursor) {
      var left2 = this.offset.left + cursor.left - this.container.offsetWidth;
      if (this.isSubMenu()) {
        var _this$parentMenu$cont2 = this.parentMenu.container.getBoundingClientRect(), parentMenuLeft = _this$parentMenu$cont2.left;
        left2 -= cursor.left - parentMenuLeft;
      }
      this.container.style.left = "".concat(left2, "px");
    }
    /**
     * Select first cell in opened menu.
     */
  }, {
    key: "selectFirstCell",
    value: function selectFirstCell() {
      var cell = this.hotMenu.getCell(0, 0);
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectNextCell(0, 0);
      } else {
        this.hotMenu.selectCell(0, 0);
      }
    }
    /**
     * Select last cell in opened menu.
     */
  }, {
    key: "selectLastCell",
    value: function selectLastCell() {
      var lastRow = this.hotMenu.countRows() - 1;
      var cell = this.hotMenu.getCell(lastRow, 0);
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectPrevCell(lastRow, 0);
      } else {
        this.hotMenu.selectCell(lastRow, 0, void 0, void 0, false);
        this.hotMenu.scrollViewportTo(lastRow, 0, true, false);
      }
    }
    /**
     * Select next cell in opened menu.
     *
     * @param {number} row Row index.
     * @param {number} col Column index.
     */
  }, {
    key: "selectNextCell",
    value: function selectNextCell(row, col) {
      var nextRow = row + 1;
      var cell = nextRow < this.hotMenu.countRows() ? this.hotMenu.getCell(nextRow, col) : null;
      if (!cell) {
        return;
      }
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectNextCell(nextRow, col);
      } else {
        this.hotMenu.selectCell(nextRow, col);
      }
    }
    /**
     * Select previous cell in opened menu.
     *
     * @param {number} row Row index.
     * @param {number} col Column index.
     */
  }, {
    key: "selectPrevCell",
    value: function selectPrevCell(row, col) {
      var prevRow = row - 1;
      var cell = prevRow >= 0 ? this.hotMenu.getCell(prevRow, col) : null;
      if (!cell) {
        return;
      }
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectPrevCell(prevRow, col);
      } else {
        this.hotMenu.selectCell(prevRow, col);
      }
    }
    /**
     * Menu item renderer.
     *
     * @private
     * @param {Core} hot The Handsontable instance.
     * @param {HTMLCellElement} TD The rendered cell element.
     * @param {number} row The visual index.
     * @param {number} col The visual index.
     * @param {string} prop The column property if used.
     * @param {string} value The cell value.
     */
  }, {
    key: "menuItemRenderer",
    value: function menuItemRenderer(hot, TD, row, col, prop, value) {
      var _this4 = this;
      var item = hot.getSourceDataAtRow(row);
      var wrapper2 = this.hot.rootDocument.createElement("div");
      var isSubMenu = function isSubMenu2(itemToTest) {
        return hasOwnProperty$2(itemToTest, "submenu");
      };
      var itemIsSeparator = function itemIsSeparator2(itemToTest) {
        return new RegExp(KEY$c, "i").test(itemToTest.name);
      };
      var itemIsDisabled = function itemIsDisabled2(itemToTest) {
        return itemToTest.disabled === true || typeof itemToTest.disabled === "function" && itemToTest.disabled.call(_this4.hot) === true;
      };
      var itemIsSelectionDisabled = function itemIsSelectionDisabled2(itemToTest) {
        return itemToTest.disableSelection;
      };
      var itemValue = value;
      if (typeof itemValue === "function") {
        itemValue = itemValue.call(this.hot);
      }
      empty(TD);
      addClass(wrapper2, "htItemWrapper");
      TD.appendChild(wrapper2);
      if (itemIsSeparator(item)) {
        addClass(TD, "htSeparator");
      } else if (typeof item.renderer === "function") {
        addClass(TD, "htCustomMenuRenderer");
        TD.appendChild(item.renderer(hot, wrapper2, row, col, prop, itemValue));
      } else {
        fastInnerHTML(wrapper2, itemValue);
      }
      if (itemIsDisabled(item)) {
        addClass(TD, "htDisabled");
        this.eventManager.addEventListener(TD, "mouseenter", function() {
          return hot.deselectCell();
        });
      } else if (itemIsSelectionDisabled(item)) {
        addClass(TD, "htSelectionDisabled");
        this.eventManager.addEventListener(TD, "mouseenter", function() {
          return hot.deselectCell();
        });
      } else if (isSubMenu(item)) {
        addClass(TD, "htSubmenu");
        if (itemIsSelectionDisabled(item)) {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.deselectCell();
          });
        } else {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.selectCell(row, col, void 0, void 0, false, false);
          });
        }
      } else {
        removeClass(TD, ["htSubmenu", "htDisabled"]);
        if (itemIsSelectionDisabled(item)) {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.deselectCell();
          });
        } else {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.selectCell(row, col, void 0, void 0, false, false);
          });
        }
      }
    }
    /**
     * Create container/wrapper for handsontable.
     *
     * @private
     * @param {string} [name] Class name.
     * @returns {HTMLElement}
     */
  }, {
    key: "createContainer",
    value: function createContainer() {
      var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var doc = this.options.container.ownerDocument;
      var className = name;
      var container;
      if (className) {
        if (isFunction(className)) {
          className = className.call(this.hot);
          if (className === null || isUndefined(className)) {
            className = "";
          } else {
            className = className.toString();
          }
        }
        className = className.replace(/[^A-z0-9]/g, "_");
        className = "".concat(this.options.className, "Sub_").concat(className);
        container = doc.querySelector(".".concat(this.options.className, ".").concat(className));
      }
      if (!container) {
        container = doc.createElement("div");
        addClass(container, "htMenu ".concat(this.options.className));
        if (className) {
          addClass(container, className);
        }
        this.options.container.appendChild(container);
      }
      return container;
    }
    /**
     * @private
     */
  }, {
    key: "blockMainTableCallbacks",
    value: function blockMainTableCallbacks() {
      this._afterScrollCallback = function() {
      };
      this.hot.addHook("afterScrollVertically", this._afterScrollCallback);
      this.hot.addHook("afterScrollHorizontally", this._afterScrollCallback);
    }
    /**
     * @private
     */
  }, {
    key: "releaseMainTableCallbacks",
    value: function releaseMainTableCallbacks() {
      if (this._afterScrollCallback) {
        this.hot.removeHook("afterScrollVertically", this._afterScrollCallback);
        this.hot.removeHook("afterScrollHorizontally", this._afterScrollCallback);
        this._afterScrollCallback = null;
      }
    }
    /**
     * On after init listener.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      var wtTable = this.hotMenu.view._wt.wtTable;
      var data2 = this.hotMenu.getSettings().data;
      var hiderStyle = wtTable.hider.style;
      var holderStyle = wtTable.holder.style;
      var currentHiderWidth = parseInt(hiderStyle.width, 10);
      var realHeight = arrayReduce$1(data2, function(accumulator, value) {
        return accumulator + (value.name === KEY$c ? 1 : 26);
      }, 0);
      holderStyle.width = "".concat(currentHiderWidth + 3, "px");
      holderStyle.height = "".concat(realHeight + 3, "px");
      hiderStyle.height = holderStyle.height;
    }
    /**
     * On after selection listener.
     *
     * @param {number} r Selection start row index.
     * @param {number} c Selection start column index.
     * @param {number} r2 Selection end row index.
     * @param {number} c2 Selection end column index.
     * @param {object} preventScrolling Object with `value` property where its value change will be observed.
     */
  }, {
    key: "onAfterSelection",
    value: function onAfterSelection(r2, c2, r22, c22, preventScrolling) {
      if (this.keyEvent === false) {
        preventScrolling.value = true;
      }
    }
    /**
     * Document mouse down listener.
     *
     * @private
     * @param {Event} event The mouse event object.
     */
  }, {
    key: "onDocumentMouseDown",
    value: function onDocumentMouseDown(event2) {
      if (!this.isOpened()) {
        return;
      }
      if (this.options.standalone && this.hotMenu && !isChildOf(event2.target, this.hotMenu.rootElement)) {
        this.close(true);
      } else if ((this.isAllSubMenusClosed() || this.isSubMenu()) && !isChildOf(event2.target, ".htMenu")) {
        this.close(true);
      }
    }
    /**
     * Document's contextmenu listener.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "onDocumentContextMenu",
    value: function onDocumentContextMenu(event2) {
      if (!this.isOpened()) {
        return;
      }
      if (hasClass(event2.target, "htCore") && isChildOf(event2.target, this.hotMenu.rootElement)) {
        event2.preventDefault();
      }
    }
  }]);
  return Menu2;
}();
mixin(Menu, localHooks$1);
const Menu$1 = Menu;
function _typeof$H(obj) {
  "@babel/helpers - typeof";
  return _typeof$H = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$H(obj);
}
function _classCallCheck$12(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$12(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$12(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$12(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$12(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$x() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$x = Reflect.get.bind();
  } else {
    _get$x = function _get2(target, property, receiver) {
      var base = _superPropBase$x(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$x.apply(this, arguments);
}
function _superPropBase$x(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$F(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$F(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$F(subClass, superClass);
}
function _setPrototypeOf$F(o, p2) {
  _setPrototypeOf$F = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$F(o, p2);
}
function _createSuper$F(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$F();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$F(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$F(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$F(this, result);
  };
}
function _possibleConstructorReturn$F(self2, call2) {
  if (call2 && (_typeof$H(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$F(self2);
}
function _assertThisInitialized$F(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$F() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$F(o) {
  _getPrototypeOf$F = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$F(o);
}
var PLUGIN_KEY$o = "contextMenu";
var PLUGIN_PRIORITY$n = 70;
Hooks$1.getSingleton().register("afterContextMenuDefaultOptions");
Hooks$1.getSingleton().register("beforeContextMenuShow");
Hooks$1.getSingleton().register("afterContextMenuShow");
Hooks$1.getSingleton().register("afterContextMenuHide");
Hooks$1.getSingleton().register("afterContextMenuExecute");
var ContextMenu = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$F(ContextMenu2, _BasePlugin);
  var _super = _createSuper$F(ContextMenu2);
  function ContextMenu2(hotInstance) {
    var _this;
    _classCallCheck$12(this, ContextMenu2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager$1(_assertThisInitialized$F(_this));
    _this.commandExecutor = new CommandExecutor$1(_this.hot);
    _this.itemsFactory = null;
    _this.menu = null;
    return _this;
  }
  _createClass$12(ContextMenu2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$o];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var settings = this.hot.getSettings()[PLUGIN_KEY$o];
      if (typeof settings.callback === "function") {
        this.commandExecutor.setCommonCallback(settings.callback);
      }
      this.menu = new Menu$1(this.hot, {
        className: "htContextMenu",
        keepInViewport: true,
        container: settings.uiContainer || this.hot.rootDocument.body
      });
      this.menu.addLocalHook("beforeOpen", function() {
        return _this2.onMenuBeforeOpen();
      });
      this.menu.addLocalHook("afterOpen", function() {
        return _this2.onMenuAfterOpen();
      });
      this.menu.addLocalHook("afterClose", function() {
        return _this2.onMenuAfterClose();
      });
      this.menu.addLocalHook("executeCommand", function() {
        var _this2$executeCommand;
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }
        return (_this2$executeCommand = _this2.executeCommand).call.apply(_this2$executeCommand, [_this2].concat(params));
      });
      this.addHook("afterOnCellContextMenu", function(event2) {
        return _this2.onAfterOnCellContextMenu(event2);
      });
      _get$x(_getPrototypeOf$F(ContextMenu2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`contextMenu`](@/api/options.md#contextmenu)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$x(_getPrototypeOf$F(ContextMenu2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
        this.menu = null;
      }
      _get$x(_getPrototypeOf$F(ContextMenu2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Opens menu and re-position it based on the passed coordinates.
     *
     * @param {Event} event The mouse event object.
     */
  }, {
    key: "open",
    value: function open(event2) {
      if (!this.menu) {
        return;
      }
      this.prepareMenuItems();
      this.menu.open();
      if (!this.menu.isOpened()) {
        return;
      }
      var offsetTop = 0;
      var offsetLeft = 0;
      if (this.hot.rootDocument !== this.menu.container.ownerDocument) {
        var frameElement = this.hot.rootWindow.frameElement;
        var _frameElement$getBoun = frameElement.getBoundingClientRect(), top2 = _frameElement$getBoun.top, left2 = _frameElement$getBoun.left;
        offsetTop = top2 - getWindowScrollTop(event2.view);
        offsetLeft = left2 - getWindowScrollLeft(event2.view);
      } else {
        offsetTop = -1 * getWindowScrollTop(this.menu.hotMenu.rootWindow);
        offsetLeft = -1 * getWindowScrollLeft(this.menu.hotMenu.rootWindow);
      }
      this.menu.setPosition({
        top: parseInt(event2.pageY, 10) + offsetTop,
        left: parseInt(event2.pageX, 10) + offsetLeft
      });
    }
    /**
     * Closes the menu.
     */
  }, {
    key: "close",
    value: function close() {
      if (!this.menu) {
        return;
      }
      this.menu.close();
      this.itemsFactory = null;
    }
    /**
     * Execute context menu command.
     *
     * The `executeCommand()` method works only for selected cells.
     *
     * When no cells are selected, `executeCommand()` doesn't do anything.
     *
     * You can execute all predefined commands:
     *  * `'row_above'` - Insert row above
     *  * `'row_below'` - Insert row below
     *  * `'col_left'` - Insert column left
     *  * `'col_right'` - Insert column right
     *  * `'clear_column'` - Clear selected column
     *  * `'remove_row'` - Remove row
     *  * `'remove_col'` - Remove column
     *  * `'undo'` - Undo last action
     *  * `'redo'` - Redo last action
     *  * `'make_read_only'` - Make cell read only
     *  * `'alignment:left'` - Alignment to the left
     *  * `'alignment:top'` - Alignment to the top
     *  * `'alignment:right'` - Alignment to the right
     *  * `'alignment:bottom'` - Alignment to the bottom
     *  * `'alignment:middle'` - Alignment to the middle
     *  * `'alignment:center'` - Alignment to the center (justify).
     *
     * Or you can execute command registered in settings where `key` is your command name.
     *
     * @param {string} commandName The command name to be executed.
     * @param {*} params Additional parameters passed to command executor module.
     */
  }, {
    key: "executeCommand",
    value: function executeCommand(commandName) {
      var _this$commandExecutor;
      if (this.itemsFactory === null) {
        this.prepareMenuItems();
      }
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      (_this$commandExecutor = this.commandExecutor).execute.apply(_this$commandExecutor, [commandName].concat(params));
    }
    /**
     * Prepares available contextMenu's items list and registers them in commandExecutor.
     *
     * @private
     * @fires Hooks#afterContextMenuDefaultOptions
     * @fires Hooks#beforeContextMenuSetItems
     */
  }, {
    key: "prepareMenuItems",
    value: function prepareMenuItems() {
      var _this3 = this;
      this.itemsFactory = new ItemsFactory$1(this.hot, ContextMenu2.DEFAULT_ITEMS);
      var settings = this.hot.getSettings()[PLUGIN_KEY$o];
      var predefinedItems2 = {
        items: this.itemsFactory.getItems(settings)
      };
      this.hot.runHooks("afterContextMenuDefaultOptions", predefinedItems2);
      this.itemsFactory.setPredefinedItems(predefinedItems2.items);
      var menuItems = this.itemsFactory.getItems(settings);
      this.hot.runHooks("beforeContextMenuSetItems", menuItems);
      this.menu.setMenuItems(menuItems);
      arrayEach(menuItems, function(command) {
        return _this3.commandExecutor.registerCommand(command.key, command);
      });
    }
    /**
     * On contextmenu listener.
     *
     * @private
     * @param {Event} event The mouse event object.
     */
  }, {
    key: "onAfterOnCellContextMenu",
    value: function onAfterOnCellContextMenu(event2) {
      var settings = this.hot.getSettings();
      var showRowHeaders = settings.rowHeaders;
      var showColHeaders = settings.colHeaders;
      function isValidElement(element2) {
        return element2.nodeName === "TD" || element2.parentNode.nodeName === "TD";
      }
      var element = event2.target;
      this.close();
      if (hasClass(element, "handsontableInput")) {
        return;
      }
      event2.preventDefault();
      event2.stopPropagation();
      if (!(showRowHeaders || showColHeaders)) {
        if (!isValidElement(element) && !(hasClass(element, "current") && hasClass(element, "wtBorder"))) {
          return;
        }
      }
      this.open(event2);
    }
    /**
     * On menu before open listener.
     *
     * @private
     */
  }, {
    key: "onMenuBeforeOpen",
    value: function onMenuBeforeOpen() {
      this.hot.runHooks("beforeContextMenuShow", this);
    }
    /**
     * On menu after open listener.
     *
     * @private
     */
  }, {
    key: "onMenuAfterOpen",
    value: function onMenuAfterOpen() {
      this.hot.runHooks("afterContextMenuShow", this);
    }
    /**
     * On menu after close listener.
     *
     * @private
     */
  }, {
    key: "onMenuAfterClose",
    value: function onMenuAfterClose() {
      this.hot.listen();
      this.hot.runHooks("afterContextMenuHide", this);
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
      }
      _get$x(_getPrototypeOf$F(ContextMenu2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$o;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$n;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get2() {
      return ["plugin:AutoColumnSize"];
    }
    /**
     * Context menu default items order when `contextMenu` options is set as `true`.
     *
     * @returns {string[]}
     */
  }, {
    key: "DEFAULT_ITEMS",
    get: function get2() {
      return [KEY$3, KEY$2, KEY$c, KEY$9, KEY$8, KEY$c, KEY$4, KEY$5, KEY$c, KEY, KEY$6, KEY$c, KEY$7, KEY$c, KEY$b];
    }
  }]);
  return ContextMenu2;
}(BasePlugin);
ContextMenu.SEPARATOR = {
  name: KEY$c
};
function copyItem(copyPastePlugin) {
  return {
    key: "copy",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY);
    },
    callback: function callback() {
      copyPastePlugin.copy();
    },
    disabled: function disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      var selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}
function cutItem(copyPastePlugin) {
  return {
    key: "cut",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CUT);
    },
    callback: function callback() {
      copyPastePlugin.cut();
    },
    disabled: function disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      var selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}
function _classCallCheck$11(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$11(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$11(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$11(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$11(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ClipboardData = /* @__PURE__ */ function() {
  function ClipboardData2() {
    _classCallCheck$11(this, ClipboardData2);
    this.data = {};
  }
  _createClass$11(ClipboardData2, [{
    key: "setData",
    value: function setData(type, value) {
      this.data[type] = value;
    }
  }, {
    key: "getData",
    value: function getData(type) {
      return this.data[type] || void 0;
    }
  }]);
  return ClipboardData2;
}();
function _defineProperties$10(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$10(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$10(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$10(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$10(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var PasteEvent = /* @__PURE__ */ _createClass$10(function PasteEvent2() {
  _classCallCheck$10(this, PasteEvent2);
  this.clipboardData = new ClipboardData();
});
function _classCallCheck$$(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$$(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$$(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$$(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$$(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var FocusableWrapper = /* @__PURE__ */ function() {
  function FocusableWrapper2(container) {
    _classCallCheck$$(this, FocusableWrapper2);
    this.rootDocument = container.defaultView ? container : container.ownerDocument;
    this.mainElement = null;
    this.eventManager = new EventManager$1(this);
    this.listenersCount = /* @__PURE__ */ new WeakSet();
    this.container = container;
  }
  _createClass$$(FocusableWrapper2, [{
    key: "useSecondaryElement",
    value: function useSecondaryElement() {
      var el = createOrGetSecondaryElement(this.container);
      if (!this.listenersCount.has(el)) {
        this.listenersCount.add(el);
        forwardEventsToLocalHooks(this.eventManager, el, this);
      }
      this.mainElement = el;
    }
    /**
     * Switch to the main focusable element.
     *
     * @param {HTMLElement} element The DOM element.
     */
  }, {
    key: "setFocusableElement",
    value: function setFocusableElement(element) {
      if (!this.listenersCount.has(element)) {
        this.listenersCount.add(element);
        forwardEventsToLocalHooks(this.eventManager, element, this);
      }
      this.mainElement = element;
    }
    /**
     * Get currently set focusable element.
     *
     * @returns {HTMLElement}
     */
  }, {
    key: "getFocusableElement",
    value: function getFocusableElement() {
      return this.mainElement;
    }
    /**
     * Set focus to the focusable element.
     */
  }, {
    key: "focus",
    value: function focus() {
      this.mainElement.value = " ";
      if (!isMobileBrowser()) {
        selectElementIfAllowed(this.mainElement);
      }
    }
  }]);
  return FocusableWrapper2;
}();
mixin(FocusableWrapper, localHooks$1);
var refCounter = /* @__PURE__ */ new WeakMap();
function createElement(container) {
  var focusableWrapper = new FocusableWrapper(container);
  var counter2 = refCounter.get(container);
  counter2 = isNaN(counter2) ? 0 : counter2;
  refCounter.set(container, counter2 + 1);
  return focusableWrapper;
}
function deactivateElement(wrapper2) {
  wrapper2.eventManager.clear();
}
var runLocalHooks2 = function runLocalHooks3(eventName, subject) {
  return function(event2) {
    return subject.runLocalHooks(eventName, event2);
  };
};
function forwardEventsToLocalHooks(eventManager, element, subject) {
  eventManager.addEventListener(element, "copy", runLocalHooks2("copy", subject));
  eventManager.addEventListener(element, "cut", runLocalHooks2("cut", subject));
  eventManager.addEventListener(element, "paste", runLocalHooks2("paste", subject));
}
var secondaryElements = /* @__PURE__ */ new WeakMap();
function createOrGetSecondaryElement(container) {
  var secondaryElement = secondaryElements.get(container);
  if (secondaryElement) {
    if (!secondaryElement.parentElement) {
      container.appendChild(secondaryElement);
    }
    return secondaryElement;
  }
  var doc = container.defaultView ? container : container.ownerDocument;
  var element = doc.createElement("textarea");
  secondaryElements.set(container, element);
  element.setAttribute("data-hot-input", "");
  element.className = "HandsontableCopyPaste";
  element.tabIndex = -1;
  element.autocomplete = "off";
  element.wrap = "hard";
  element.value = " ";
  container.appendChild(element);
  return element;
}
function destroyElement(wrapper2) {
  if (!(wrapper2 instanceof FocusableWrapper)) {
    return;
  }
  var counter2 = refCounter.get(wrapper2.container);
  counter2 = isNaN(counter2) ? 0 : counter2;
  if (counter2 > 0) {
    counter2 -= 1;
  }
  deactivateElement(wrapper2);
  if (counter2 <= 0) {
    counter2 = 0;
    var secondaryElement = secondaryElements.get(wrapper2.container);
    if (secondaryElement && secondaryElement.parentNode) {
      secondaryElement.parentNode.removeChild(secondaryElement);
      secondaryElements.delete(wrapper2.container);
    }
    wrapper2.mainElement = null;
  }
  refCounter.set(wrapper2.container, counter2);
}
function _slicedToArray$q(arr, i) {
  return _arrayWithHoles$r(arr) || _iterableToArrayLimit$q(arr, i) || _unsupportedIterableToArray$C(arr, i) || _nonIterableRest$r();
}
function _nonIterableRest$r() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$C(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$C(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$C(o, minLen);
}
function _arrayLikeToArray$C(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$q(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$r(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$G(obj) {
  "@babel/helpers - typeof";
  return _typeof$G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$G(obj);
}
function _classCallCheck$_(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$_(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$_(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$_(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$_(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$w() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$w = Reflect.get.bind();
  } else {
    _get$w = function _get2(target, property, receiver) {
      var base = _superPropBase$w(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$w.apply(this, arguments);
}
function _superPropBase$w(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$E(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$E(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$E(subClass, superClass);
}
function _setPrototypeOf$E(o, p2) {
  _setPrototypeOf$E = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$E(o, p2);
}
function _createSuper$E(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$E();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$E(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$E(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$E(this, result);
  };
}
function _possibleConstructorReturn$E(self2, call2) {
  if (call2 && (_typeof$G(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$E(self2);
}
function _assertThisInitialized$E(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$E() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$E(o) {
  _getPrototypeOf$E = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$E(o);
}
Hooks$1.getSingleton().register("afterCopyLimit");
Hooks$1.getSingleton().register("modifyCopyableRange");
Hooks$1.getSingleton().register("beforeCut");
Hooks$1.getSingleton().register("afterCut");
Hooks$1.getSingleton().register("beforePaste");
Hooks$1.getSingleton().register("afterPaste");
Hooks$1.getSingleton().register("beforeCopy");
Hooks$1.getSingleton().register("afterCopy");
var PLUGIN_KEY$n = "copyPaste";
var PLUGIN_PRIORITY$m = 80;
var SETTING_KEYS = ["fragmentSelection"];
var ROWS_LIMIT = Infinity;
var COLUMNS_LIMIT = Infinity;
var privatePool$d = /* @__PURE__ */ new WeakMap();
var META_HEAD = ['<meta name="generator" content="Handsontable"/>', '<style type="text/css">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join("");
var CopyPaste = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$E(CopyPaste2, _BasePlugin);
  var _super = _createSuper$E(CopyPaste2);
  function CopyPaste2(hotInstance) {
    var _this;
    _classCallCheck$_(this, CopyPaste2);
    _this = _super.call(this, hotInstance);
    _this.columnsLimit = COLUMNS_LIMIT;
    _this.copyableRanges = [];
    _this.focusableElement = void 0;
    _this.pasteMode = "overwrite";
    _this.rowsLimit = ROWS_LIMIT;
    _this.uiContainer = _this.hot.rootDocument.body;
    privatePool$d.set(_assertThisInitialized$E(_this), {
      isTriggeredByCopy: false,
      isTriggeredByCut: false,
      isBeginEditing: false,
      isFragmentSelectionEnabled: false
    });
    return _this;
  }
  _createClass$_(CopyPaste2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$n];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var _this$hot$getSettings = this.hot.getSettings(), settings = _this$hot$getSettings[PLUGIN_KEY$n], fragmentSelection = _this$hot$getSettings.fragmentSelection;
      var priv = privatePool$d.get(this);
      priv.isFragmentSelectionEnabled = !!fragmentSelection;
      if (_typeof$G(settings) === "object") {
        this.pasteMode = settings.pasteMode || this.pasteMode;
        this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;
        this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;
        this.uiContainer = settings.uiContainer || this.uiContainer;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.onAfterContextMenuDefaultOptions(options);
      });
      this.addHook("afterOnCellMouseUp", function() {
        return _this2.onAfterOnCellMouseUp();
      });
      this.addHook("afterSelectionEnd", function() {
        return _this2.onAfterSelectionEnd();
      });
      this.addHook("beforeKeyDown", function() {
        return _this2.onBeforeKeyDown();
      });
      this.focusableElement = createElement(this.uiContainer);
      this.focusableElement.addLocalHook("copy", function(event2) {
        return _this2.onCopy(event2);
      }).addLocalHook("cut", function(event2) {
        return _this2.onCut(event2);
      }).addLocalHook("paste", function(event2) {
        return _this2.onPaste(event2);
      });
      _get$w(_getPrototypeOf$E(CopyPaste2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`copyPaste`](@/api/options.md#copypaste)
     *  - [`fragmentSelection`](@/api/options.md#fragmentselection)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.getOrCreateFocusableElement();
      _get$w(_getPrototypeOf$E(CopyPaste2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      if (this.focusableElement) {
        destroyElement(this.focusableElement);
      }
      _get$w(_getPrototypeOf$E(CopyPaste2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Copies the selected cell into the clipboard.
     */
  }, {
    key: "copy",
    value: function copy() {
      var priv = privatePool$d.get(this);
      priv.isTriggeredByCopy = true;
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
      this.hot.rootDocument.execCommand("copy");
    }
    /**
     * Cuts the selected cell into the clipboard.
     */
  }, {
    key: "cut",
    value: function cut() {
      var priv = privatePool$d.get(this);
      priv.isTriggeredByCut = true;
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
      this.hot.rootDocument.execCommand("cut");
    }
    /**
     * Creates copyable text releated to range objects.
     *
     * @param {object[]} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.
     * @returns {string} Returns string which will be copied into clipboard.
     */
  }, {
    key: "getRangedCopyableData",
    value: function getRangedCopyableData(ranges) {
      var _this3 = this;
      var dataSet = [];
      var copyableRows = [];
      var copyableColumns = [];
      arrayEach(ranges, function(range) {
        rangeEach(range.startRow, range.endRow, function(row) {
          if (copyableRows.indexOf(row) === -1) {
            copyableRows.push(row);
          }
        });
        rangeEach(range.startCol, range.endCol, function(column) {
          if (copyableColumns.indexOf(column) === -1) {
            copyableColumns.push(column);
          }
        });
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this3.hot.getCopyableData(row, column));
        });
        dataSet.push(rowSet);
      });
      return stringify(dataSet);
    }
    /**
     * Creates copyable text releated to range objects.
     *
     * @param {object[]} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.
     * @returns {Array[]} Returns array of arrays which will be copied into clipboard.
     */
  }, {
    key: "getRangedData",
    value: function getRangedData(ranges) {
      var _this4 = this;
      var dataSet = [];
      var copyableRows = [];
      var copyableColumns = [];
      arrayEach(ranges, function(range) {
        rangeEach(range.startRow, range.endRow, function(row) {
          if (copyableRows.indexOf(row) === -1) {
            copyableRows.push(row);
          }
        });
        rangeEach(range.startCol, range.endCol, function(column) {
          if (copyableColumns.indexOf(column) === -1) {
            copyableColumns.push(column);
          }
        });
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this4.hot.getCopyableData(row, column));
        });
        dataSet.push(rowSet);
      });
      return dataSet;
    }
    /**
     * Simulates the paste action.
     *
     * Due to security reasons, modern browsers disallow reading from the system clipboard.
     *
     * @param {string} pastableText Value as raw string to paste.
     * @param {string} [pastableHtml=''] Value as HTML to paste.
     */
  }, {
    key: "paste",
    value: function paste() {
      var pastableText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var pastableHtml = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pastableText;
      if (!pastableText && !pastableHtml) {
        return;
      }
      var pasteData = new PasteEvent();
      if (pastableText) {
        pasteData.clipboardData.setData("text/plain", pastableText);
      }
      if (pastableHtml) {
        pasteData.clipboardData.setData("text/html", pastableHtml);
      }
      this.getOrCreateFocusableElement();
      this.onPaste(pasteData);
    }
    /**
     * Prepares copyable text from the cells selection in the invisible textarea.
     */
  }, {
    key: "setCopyableText",
    value: function setCopyableText() {
      var selRange = this.hot.getSelectedRangeLast();
      if (!selRange) {
        return;
      }
      var topStart = selRange.getTopStartCorner();
      var bottomEnd = selRange.getBottomEndCorner();
      var startRow = topStart.row;
      var startCol = topStart.col;
      var endRow = bottomEnd.row;
      var endCol = bottomEnd.col;
      var finalEndRow = Math.min(endRow, startRow + this.rowsLimit - 1);
      var finalEndCol = Math.min(endCol, startCol + this.columnsLimit - 1);
      this.copyableRanges.length = 0;
      this.copyableRanges.push({
        startRow,
        startCol,
        endRow: finalEndRow,
        endCol: finalEndCol
      });
      this.copyableRanges = this.hot.runHooks("modifyCopyableRange", this.copyableRanges);
      if (endRow !== finalEndRow || endCol !== finalEndCol) {
        this.hot.runHooks("afterCopyLimit", endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);
      }
    }
    /**
     * Force focus on editable element.
     *
     * @private
     */
  }, {
    key: "getOrCreateFocusableElement",
    value: function getOrCreateFocusableElement() {
      var editor = this.hot.getActiveEditor();
      var editableElement = editor ? editor.TEXTAREA : void 0;
      if (editableElement) {
        this.focusableElement.setFocusableElement(editableElement);
      } else {
        this.focusableElement.useSecondaryElement();
      }
    }
    /**
     * Verifies if editor exists and is open.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "isEditorOpened",
    value: function isEditorOpened() {
      var editor = this.hot.getActiveEditor();
      return editor && editor.isOpened();
    }
    /**
     * Prepares new values to populate them into datasource.
     *
     * @private
     * @param {Array} inputArray An array of the data to populate.
     * @param {Array} [selection] The selection which indicates from what position the data will be populated.
     * @returns {Array} Range coordinates after populate data.
     */
  }, {
    key: "populateValues",
    value: function populateValues(inputArray) {
      var selection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.hot.getSelectedRangeLast();
      if (!inputArray.length) {
        return;
      }
      var populatedRowsLength = inputArray.length;
      var populatedColumnsLength = inputArray[0].length;
      var newRows = [];
      var _selection$getTopStar = selection.getTopStartCorner(), startRow = _selection$getTopStar.row, startColumn = _selection$getTopStar.col;
      var _selection$getBottomE = selection.getBottomEndCorner(), endRowFromSelection = _selection$getBottomE.row, endColumnFromSelection = _selection$getBottomE.col;
      var visualRowForPopulatedData = startRow;
      var visualColumnForPopulatedData = startColumn;
      var lastVisualRow = startRow;
      var lastVisualColumn = startColumn;
      while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {
        var _this$hot$getCellMeta = this.hot.getCellMeta(visualRowForPopulatedData, startColumn), skipRowOnPaste = _this$hot$getCellMeta.skipRowOnPaste, visualRow = _this$hot$getCellMeta.visualRow;
        visualRowForPopulatedData = visualRow + 1;
        if (skipRowOnPaste === true) {
          continue;
        }
        lastVisualRow = visualRow;
        visualColumnForPopulatedData = startColumn;
        var newRow = [];
        var insertedRow = newRows.length % populatedRowsLength;
        while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {
          var _this$hot$getCellMeta2 = this.hot.getCellMeta(startRow, visualColumnForPopulatedData), skipColumnOnPaste = _this$hot$getCellMeta2.skipColumnOnPaste, visualCol = _this$hot$getCellMeta2.visualCol;
          visualColumnForPopulatedData = visualCol + 1;
          if (skipColumnOnPaste === true) {
            continue;
          }
          lastVisualColumn = visualCol;
          var insertedColumn = newRow.length % populatedColumnsLength;
          newRow.push(inputArray[insertedRow][insertedColumn]);
        }
        newRows.push(newRow);
      }
      this.hot.populateFromArray(startRow, startColumn, newRows, void 0, void 0, "CopyPaste.paste", this.pasteMode);
      return [startRow, startColumn, lastVisualRow, lastVisualColumn];
    }
    /**
     * `copy` event callback on textarea element.
     *
     * @param {Event} event ClipboardEvent.
     * @private
     */
  }, {
    key: "onCopy",
    value: function onCopy(event2) {
      var priv = privatePool$d.get(this);
      if (!this.hot.isListening() && !priv.isTriggeredByCopy || this.isEditorOpened()) {
        return;
      }
      this.setCopyableText();
      priv.isTriggeredByCopy = false;
      var rangedData = this.getRangedData(this.copyableRanges);
      var allowCopying = !!this.hot.runHooks("beforeCopy", rangedData, this.copyableRanges);
      if (allowCopying) {
        var textPlain = stringify(rangedData);
        if (event2 && event2.clipboardData) {
          var textHTML = _dataToHTML(rangedData, this.hot.rootDocument);
          event2.clipboardData.setData("text/plain", textPlain);
          event2.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
        } else if (typeof ClipboardEvent === "undefined") {
          this.hot.rootWindow.clipboardData.setData("Text", textPlain);
        }
        this.hot.runHooks("afterCopy", rangedData, this.copyableRanges);
      }
      event2.preventDefault();
    }
    /**
     * `cut` event callback on textarea element.
     *
     * @param {Event} event ClipboardEvent.
     * @private
     */
  }, {
    key: "onCut",
    value: function onCut(event2) {
      var priv = privatePool$d.get(this);
      if (!this.hot.isListening() && !priv.isTriggeredByCut || this.isEditorOpened()) {
        return;
      }
      this.setCopyableText();
      priv.isTriggeredByCut = false;
      var rangedData = this.getRangedData(this.copyableRanges);
      var allowCuttingOut = !!this.hot.runHooks("beforeCut", rangedData, this.copyableRanges);
      if (allowCuttingOut) {
        var textPlain = stringify(rangedData);
        if (event2 && event2.clipboardData) {
          var textHTML = _dataToHTML(rangedData, this.hot.rootDocument);
          event2.clipboardData.setData("text/plain", textPlain);
          event2.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
        } else if (typeof ClipboardEvent === "undefined") {
          this.hot.rootWindow.clipboardData.setData("Text", textPlain);
        }
        this.hot.emptySelectedCells("CopyPaste.cut");
        this.hot.runHooks("afterCut", rangedData, this.copyableRanges);
      }
      event2.preventDefault();
    }
    /**
     * `paste` event callback on textarea element.
     *
     * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.
     * @private
     */
  }, {
    key: "onPaste",
    value: function onPaste(event2) {
      if (!this.hot.isListening() || this.isEditorOpened()) {
        return;
      }
      if (event2 && event2.preventDefault) {
        event2.preventDefault();
      }
      var pastedData;
      if (event2 && typeof event2.clipboardData !== "undefined") {
        var textHTML = sanitize(event2.clipboardData.getData("text/html"), {
          ADD_TAGS: ["meta"],
          ADD_ATTR: ["content"],
          FORCE_BODY: true
        });
        if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {
          var parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);
          pastedData = parsedConfig.data;
        } else {
          pastedData = event2.clipboardData.getData("text/plain");
        }
      } else if (typeof ClipboardEvent === "undefined" && typeof this.hot.rootWindow.clipboardData !== "undefined") {
        pastedData = this.hot.rootWindow.clipboardData.getData("Text");
      }
      if (typeof pastedData === "string") {
        pastedData = parse(pastedData);
      }
      if (pastedData && pastedData.length === 0) {
        return;
      }
      if (this.hot.runHooks("beforePaste", pastedData, this.copyableRanges) === false) {
        return;
      }
      var _this$populateValues = this.populateValues(pastedData), _this$populateValues2 = _slicedToArray$q(_this$populateValues, 4), startRow = _this$populateValues2[0], startColumn = _this$populateValues2[1], endRow = _this$populateValues2[2], endColumn = _this$populateValues2[3];
      this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));
      this.hot.runHooks("afterPaste", pastedData, this.copyableRanges);
    }
    /**
     * Add copy and cut options to the Context Menu.
     *
     * @private
     * @param {object} options Contains default added options of the Context Menu.
     */
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(options) {
      options.items.push({
        name: "---------"
      }, copyItem(this), cutItem(this));
    }
    /**
     * Force focus on focusableElement.
     *
     * @private
     */
  }, {
    key: "onAfterOnCellMouseUp",
    value: function onAfterOnCellMouseUp() {
      if (!this.hot.isListening() || this.isEditorOpened() || this.hot.getSettings().fragmentSelection) {
        return;
      }
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
    }
    /**
     * Force focus on focusableElement after end of the selection.
     *
     * @private
     */
  }, {
    key: "onAfterSelectionEnd",
    value: function onAfterSelectionEnd() {
      var _privatePool$get = privatePool$d.get(this), isFragmentSelectionEnabled = _privatePool$get.isFragmentSelectionEnabled;
      if (this.isEditorOpened()) {
        return;
      }
      this.getOrCreateFocusableElement();
      if (isFragmentSelectionEnabled && this.focusableElement.getFocusableElement() !== this.hot.rootDocument.activeElement && getSelectionText()) {
        return;
      }
      this.setCopyableText();
      this.focusableElement.focus();
    }
    /**
     * `beforeKeyDown` listener to force focus of focusableElement.
     *
     * @private
     */
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown() {
      if (!this.hot.isListening() || this.isEditorOpened()) {
        return;
      }
      var activeElement = this.hot.rootDocument.activeElement;
      var activeEditor = this.hot.getActiveEditor();
      if (!activeEditor || activeElement !== this.focusableElement.getFocusableElement() && activeElement !== activeEditor.select) {
        return;
      }
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.focusableElement) {
        destroyElement(this.focusableElement);
        this.focusableElement = null;
      }
      _get$w(_getPrototypeOf$E(CopyPaste2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$n;
    }
  }, {
    key: "SETTING_KEYS",
    get: function get2() {
      return [PLUGIN_KEY$n].concat(SETTING_KEYS);
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$m;
    }
  }]);
  return CopyPaste2;
}(BasePlugin);
function createId(row, col) {
  return "border_row".concat(row, "col").concat(col);
}
function createDefaultCustomBorder() {
  return {
    width: 1,
    color: "#000"
  };
}
function createSingleEmptyBorder() {
  return {
    hide: true
  };
}
function createDefaultHtBorder() {
  return {
    width: 1,
    color: "#000",
    cornerVisible: false
  };
}
function normalizeBorder(border) {
  if (isDefined(border.start) || isDefined(border.left)) {
    var _border$start;
    border.start = (_border$start = border.start) !== null && _border$start !== void 0 ? _border$start : border.left;
  }
  if (isDefined(border.end) || isDefined(border.right)) {
    var _border$end;
    border.end = (_border$end = border.end) !== null && _border$end !== void 0 ? _border$end : border.right;
  }
  delete border.left;
  delete border.right;
  return border;
}
function denormalizeBorder(border) {
  if (isDefined(border.start)) {
    border.left = border.start;
  }
  if (isDefined(border.end)) {
    border.right = border.end;
  }
  return border;
}
function createEmptyBorders(row, col) {
  return {
    id: createId(row, col),
    border: createDefaultHtBorder(),
    row,
    col,
    top: createSingleEmptyBorder(),
    bottom: createSingleEmptyBorder(),
    start: createSingleEmptyBorder(),
    end: createSingleEmptyBorder()
  };
}
function extendDefaultBorder(defaultBorder, customBorder) {
  if (hasOwnProperty$2(customBorder, "border") && customBorder.border) {
    defaultBorder.border = customBorder.border;
  }
  if (hasOwnProperty$2(customBorder, "top") && isDefined(customBorder.top)) {
    if (customBorder.top) {
      if (!isObject$7(customBorder.top)) {
        customBorder.top = createDefaultCustomBorder();
      }
      defaultBorder.top = customBorder.top;
    } else {
      customBorder.top = createSingleEmptyBorder();
      defaultBorder.top = customBorder.top;
    }
  }
  if (hasOwnProperty$2(customBorder, "bottom") && isDefined(customBorder.bottom)) {
    if (customBorder.bottom) {
      if (!isObject$7(customBorder.bottom)) {
        customBorder.bottom = createDefaultCustomBorder();
      }
      defaultBorder.bottom = customBorder.bottom;
    } else {
      customBorder.bottom = createSingleEmptyBorder();
      defaultBorder.bottom = customBorder.bottom;
    }
  }
  if (hasOwnProperty$2(customBorder, "start") && isDefined(customBorder.start)) {
    if (customBorder.start) {
      if (!isObject$7(customBorder.start)) {
        customBorder.start = createDefaultCustomBorder();
      }
      defaultBorder.start = customBorder.start;
    } else {
      customBorder.start = createSingleEmptyBorder();
      defaultBorder.start = customBorder.start;
    }
  }
  if (hasOwnProperty$2(customBorder, "end") && isDefined(customBorder.end)) {
    if (customBorder.end) {
      if (!isObject$7(customBorder.end)) {
        customBorder.end = createDefaultCustomBorder();
      }
      defaultBorder.end = customBorder.end;
    } else {
      customBorder.end = createSingleEmptyBorder();
      defaultBorder.end = customBorder.end;
    }
  }
  return defaultBorder;
}
function checkSelectionBorders(hot, direction) {
  var atLeastOneHasBorder = false;
  arrayEach(hot.getSelectedRange(), function(range) {
    range.forAll(function(r2, c2) {
      if (r2 < 0 || c2 < 0) {
        return;
      }
      var metaBorders = hot.getCellMeta(r2, c2).borders;
      if (metaBorders) {
        if (direction) {
          if (!hasOwnProperty$2(metaBorders[direction], "hide") || metaBorders[direction].hide === false) {
            atLeastOneHasBorder = true;
            return false;
          }
        } else {
          atLeastOneHasBorder = true;
          return false;
        }
      }
    });
  });
  return atLeastOneHasBorder;
}
function markSelected(label) {
  return '<span class="selected">'.concat(String.fromCharCode(10003), "</span>").concat(label);
}
function hasLeftRightTypeOptions(borders) {
  return borders.some(function(border) {
    return isDefined(border.left) || isDefined(border.right);
  });
}
function hasStartEndTypeOptions(borders) {
  return borders.some(function(border) {
    return isDefined(border.start) || isDefined(border.end);
  });
}
var physicalToInlinePropNames = /* @__PURE__ */ new Map([["left", "start"], ["right", "end"]]);
function toInlinePropName(propName) {
  var _physicalToInlineProp;
  return (_physicalToInlineProp = physicalToInlinePropNames.get(propName)) !== null && _physicalToInlineProp !== void 0 ? _physicalToInlineProp : propName;
}
function bottom(customBordersPlugin) {
  return {
    key: "borders:bottom",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_BOTTOM);
      var hasBorder = checkSelectionBorders(this, "bottom");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "bottom");
      customBordersPlugin.prepareBorder(selected, "bottom", hasBorder);
    }
  };
}
function left(customBordersPlugin) {
  var borderDirection = customBordersPlugin.hot.isRtl() ? "end" : "start";
  return {
    key: "borders:left",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_LEFT);
      var hasBorder = checkSelectionBorders(this, borderDirection);
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, borderDirection);
      customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);
    }
  };
}
function noBorders(customBordersPlugin) {
  return {
    key: "borders:no_borders",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_BORDERS);
    },
    callback: function callback(key, selected) {
      customBordersPlugin.prepareBorder(selected, "noBorders");
    },
    disabled: function disabled() {
      return !checkSelectionBorders(this);
    }
  };
}
function right(customBordersPlugin) {
  var borderDirection = customBordersPlugin.hot.isRtl() ? "start" : "end";
  return {
    key: "borders:right",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_RIGHT);
      var hasBorder = checkSelectionBorders(this, borderDirection);
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, borderDirection);
      customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);
    }
  };
}
function top(customBordersPlugin) {
  return {
    key: "borders:top",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_TOP);
      var hasBorder = checkSelectionBorders(this, "top");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "top");
      customBordersPlugin.prepareBorder(selected, "top", hasBorder);
    }
  };
}
function _typeof$F(obj) {
  "@babel/helpers - typeof";
  return _typeof$F = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$F(obj);
}
function _slicedToArray$p(arr, i) {
  return _arrayWithHoles$q(arr) || _iterableToArrayLimit$p(arr, i) || _unsupportedIterableToArray$B(arr, i) || _nonIterableRest$q();
}
function _nonIterableRest$q() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$B(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$B(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$B(o, minLen);
}
function _arrayLikeToArray$B(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$p(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$q(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$Z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$Z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$Z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$Z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$Z(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$v() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$v = Reflect.get.bind();
  } else {
    _get$v = function _get2(target, property, receiver) {
      var base = _superPropBase$v(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$v.apply(this, arguments);
}
function _superPropBase$v(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$D(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$D(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$D(subClass, superClass);
}
function _setPrototypeOf$D(o, p2) {
  _setPrototypeOf$D = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$D(o, p2);
}
function _createSuper$D(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$D();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$D(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$D(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$D(this, result);
  };
}
function _possibleConstructorReturn$D(self2, call2) {
  if (call2 && (_typeof$F(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$D(self2);
}
function _assertThisInitialized$D(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$D() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$D(o) {
  _getPrototypeOf$D = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$D(o);
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var PLUGIN_KEY$m = "customBorders";
var PLUGIN_PRIORITY$l = 90;
var CustomBorders = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$D(CustomBorders2, _BasePlugin);
  var _super = _createSuper$D(CustomBorders2);
  function CustomBorders2() {
    var _this;
    _classCallCheck$Z(this, CustomBorders2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$a(_assertThisInitialized$D(_this), "savedBorders", []);
    return _this;
  }
  _createClass$Z(CustomBorders2, [{
    key: "isEnabled",
    value: (
      /**
       * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
       * hook and if it returns `true` than the {@link CustomBorders#enablePlugin} method is called.
       *
       * @returns {boolean}
       */
      function isEnabled() {
        return !!this.hot.getSettings()[PLUGIN_KEY$m];
      }
    )
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.onAfterContextMenuDefaultOptions(options);
      });
      this.addHook("init", function() {
        return _this2.onAfterInit();
      });
      _get$v(_getPrototypeOf$D(CustomBorders2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hideBorders();
      _get$v(_getPrototypeOf$D(CustomBorders2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`customBorders`](@/api/options.md#customborders)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.changeBorderSettings();
      _get$v(_getPrototypeOf$D(CustomBorders2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Set custom borders.
     *
     * @example
     * ```js
     * const customBordersPlugin = hot.getPlugin('customBorders');
     *
     * // Using an array of arrays (produced by `.getSelected()` method).
     * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: 2, color: 'blue'}});
     *
     * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
     * //  Selecting a cell range.
     * hot.selectCell(0, 0, 2, 2);
     * // Returning selected cells' range with the getSelectedRange method.
     * customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, width: 2, color: 'blue'}});
     * ```
     *
     * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
     * @param {object} borderObject Object with `top`, `right`, `bottom` and `start` properties.
     */
  }, {
    key: "setBorders",
    value: function setBorders(selectionRanges, borderObject) {
      var _this3 = this;
      var borderKeys = ["top", "bottom", "start", "end"];
      var normBorder = null;
      if (borderObject) {
        this.checkSettingsCohesion([borderObject]);
        borderKeys = Object.keys(borderObject);
        normBorder = normalizeBorder(borderObject);
      }
      var selectionType = detectSelectionType(selectionRanges);
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
      arrayEach(selectionRanges, function(selection) {
        var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray$p(_selectionSchemaNorma, 4), rowStart = _selectionSchemaNorma2[0], columnStart = _selectionSchemaNorma2[1], rowEnd = _selectionSchemaNorma2[2], columnEnd = _selectionSchemaNorma2[3];
        var _loop = function _loop2(row2) {
          var _loop22 = function _loop23(col2) {
            arrayEach(borderKeys, function(borderKey) {
              _this3.prepareBorderFromCustomAdded(row2, col2, normBorder, toInlinePropName(borderKey));
            });
          };
          for (var col = columnStart; col <= columnEnd; col += 1) {
            _loop22(col);
          }
        };
        for (var row = rowStart; row <= rowEnd; row += 1) {
          _loop(row);
        }
      });
      this.hot.view.render();
    }
    /**
     * Get custom borders.
     *
     * @example
     * ```js
     * const customBordersPlugin = hot.getPlugin('customBorders');
     *
     * // Using an array of arrays (produced by `.getSelected()` method).
     * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
     * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
     * customBordersPlugin.getBorders(hot.getSelectedRange());
     * // Using without param - return all customBorders.
     * customBordersPlugin.getBorders();
     * ```
     *
     * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
     * @returns {object[]} Returns array of border objects.
     */
  }, {
    key: "getBorders",
    value: function getBorders(selectionRanges) {
      var _this4 = this;
      if (!Array.isArray(selectionRanges)) {
        return this.savedBorders;
      }
      var selectionType = detectSelectionType(selectionRanges);
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
      var selectedBorders = [];
      arrayEach(selectionRanges, function(selection) {
        var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray$p(_selectionSchemaNorma3, 4), rowStart = _selectionSchemaNorma4[0], columnStart = _selectionSchemaNorma4[1], rowEnd = _selectionSchemaNorma4[2], columnEnd = _selectionSchemaNorma4[3];
        var _loop3 = function _loop32(row2) {
          var _loop4 = function _loop42(col2) {
            arrayEach(_this4.savedBorders, function(border) {
              if (border.row === row2 && border.col === col2) {
                selectedBorders.push(denormalizeBorder(border));
              }
            });
          };
          for (var col = columnStart; col <= columnEnd; col += 1) {
            _loop4(col);
          }
        };
        for (var row = rowStart; row <= rowEnd; row += 1) {
          _loop3(row);
        }
      });
      return selectedBorders;
    }
    /**
     * Clear custom borders.
     *
     * @example
     * ```js
     * const customBordersPlugin = hot.getPlugin('customBorders');
     *
     * // Using an array of arrays (produced by `.getSelected()` method).
     * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
     * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
     * customBordersPlugin.clearBorders(hot.getSelectedRange());
     * // Using without param - clear all customBorders.
     * customBordersPlugin.clearBorders();
     * ```
     *
     * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
     */
  }, {
    key: "clearBorders",
    value: function clearBorders(selectionRanges) {
      var _this5 = this;
      if (selectionRanges) {
        this.setBorders(selectionRanges);
      } else {
        arrayEach(this.savedBorders, function(border) {
          _this5.clearBordersFromSelectionSettings(border.id);
          _this5.clearNullCellRange();
          _this5.hot.removeCellMeta(border.row, border.col, "borders");
        });
        this.savedBorders.length = 0;
      }
    }
    /**
     * Insert WalkontableSelection instance into Walkontable settings.
     *
     * @private
     * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
     * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
     */
  }, {
    key: "insertBorderIntoSettings",
    value: function insertBorderIntoSettings(border, place) {
      var hasSavedBorders = this.checkSavedBorders(border);
      if (!hasSavedBorders) {
        this.savedBorders.push(border);
      }
      var visualCellRange = this.hot._createCellRange(this.hot._createCellCoords(border.row, border.col));
      var hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);
      if (!hasCustomSelections) {
        this.hot.selection.highlight.addCustomSelection({
          border,
          visualCellRange
        });
      }
    }
    /**
     * Prepare borders from setting (single cell).
     *
     * @private
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.
     * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
     */
  }, {
    key: "prepareBorderFromCustomAdded",
    value: function prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {
      var nrOfRows = this.hot.countRows();
      var nrOfColumns = this.hot.countCols();
      if (row >= nrOfRows || column >= nrOfColumns) {
        return;
      }
      var border = createEmptyBorders(row, column);
      if (borderDescriptor) {
        border = extendDefaultBorder(border, borderDescriptor);
        arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
          if (border.id === customSelection.settings.id) {
            Object.assign(customSelection.settings, borderDescriptor);
            border.id = customSelection.settings.id;
            border.top = customSelection.settings.top;
            border.bottom = customSelection.settings.bottom;
            border.start = customSelection.settings.start;
            border.end = customSelection.settings.end;
            return false;
          }
        });
      }
      this.hot.setCellMeta(row, column, "borders", denormalizeBorder(border));
      this.insertBorderIntoSettings(border, place);
    }
    /**
     * Prepare borders from setting (object).
     *
     * @private
     * @param {object} range {CellRange} The CellRange object.
     * @param {object} customBorder Object with `start`, `end`, `top` and `bottom` properties.
     */
  }, {
    key: "prepareBorderFromCustomAddedRange",
    value: function prepareBorderFromCustomAddedRange(range, customBorder) {
      var _this6 = this;
      var lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);
      var lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);
      rangeEach(range.from.row, lastRowIndex, function(rowIndex) {
        rangeEach(range.from.col, lastColumnIndex, function(colIndex) {
          var border = createEmptyBorders(rowIndex, colIndex);
          var add = 0;
          if (rowIndex === range.from.row) {
            if (hasOwnProperty$2(customBorder, "top")) {
              add += 1;
              border.top = customBorder.top;
            }
          }
          if (rowIndex === range.to.row) {
            if (hasOwnProperty$2(customBorder, "bottom")) {
              add += 1;
              border.bottom = customBorder.bottom;
            }
          }
          if (colIndex === range.from.col) {
            if (hasOwnProperty$2(customBorder, "start")) {
              add += 1;
              border.start = customBorder.start;
            }
          }
          if (colIndex === range.to.col) {
            if (hasOwnProperty$2(customBorder, "end")) {
              add += 1;
              border.end = customBorder.end;
            }
          }
          if (add > 0) {
            _this6.hot.setCellMeta(rowIndex, colIndex, "borders", denormalizeBorder(border));
            _this6.insertBorderIntoSettings(border);
          }
        });
      });
    }
    /**
     * Remove border (triggered from context menu).
     *
     * @private
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     */
  }, {
    key: "removeAllBorders",
    value: function removeAllBorders(row, column) {
      var borderId = createId(row, column);
      this.spliceBorder(borderId);
      this.clearBordersFromSelectionSettings(borderId);
      this.clearNullCellRange();
      this.hot.removeCellMeta(row, column, "borders");
    }
    /**
     * Set borders for each cell re. To border position.
     *
     * @private
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.
     * @param {boolean} remove True when remove borders, and false when add borders.
     */
  }, {
    key: "setBorder",
    value: function setBorder(row, column, place, remove) {
      var bordersMeta = this.hot.getCellMeta(row, column).borders;
      if (!bordersMeta || bordersMeta.border === void 0) {
        bordersMeta = createEmptyBorders(row, column);
      } else {
        bordersMeta = normalizeBorder(bordersMeta);
      }
      if (remove) {
        bordersMeta[place] = createSingleEmptyBorder();
        var hideCount = this.countHide(bordersMeta);
        if (hideCount === 4) {
          this.removeAllBorders(row, column);
        } else {
          var customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
          if (!customSelectionsChecker) {
            this.insertBorderIntoSettings(bordersMeta);
          }
          this.hot.setCellMeta(row, column, "borders", denormalizeBorder(bordersMeta));
        }
      } else {
        bordersMeta[place] = createDefaultCustomBorder();
        var _customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
        if (!_customSelectionsChecker) {
          this.insertBorderIntoSettings(bordersMeta);
        }
        this.hot.setCellMeta(row, column, "borders", denormalizeBorder(bordersMeta));
      }
    }
    /**
     * Prepare borders based on cell and border position.
     *
     * @private
     * @param {CellRange[]} selected An array of CellRange objects.
     * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.
     * @param {boolean} remove True when remove borders, and false when add borders.
     */
  }, {
    key: "prepareBorder",
    value: function prepareBorder(selected, place, remove) {
      var _this7 = this;
      arrayEach(selected, function(_ref2) {
        var start = _ref2.start, end = _ref2.end;
        if (start.row === end.row && start.col === end.col) {
          if (place === "noBorders") {
            _this7.removeAllBorders(start.row, start.col);
          } else {
            _this7.setBorder(start.row, start.col, place, remove);
          }
        } else {
          switch (place) {
            case "noBorders":
              rangeEach(start.col, end.col, function(colIndex) {
                rangeEach(start.row, end.row, function(rowIndex) {
                  _this7.removeAllBorders(rowIndex, colIndex);
                });
              });
              break;
            case "top":
              rangeEach(start.col, end.col, function(topCol) {
                _this7.setBorder(start.row, topCol, place, remove);
              });
              break;
            case "bottom":
              rangeEach(start.col, end.col, function(bottomCol) {
                _this7.setBorder(end.row, bottomCol, place, remove);
              });
              break;
            case "start":
              rangeEach(start.row, end.row, function(rowStart) {
                _this7.setBorder(rowStart, start.col, place, remove);
              });
              break;
            case "end":
              rangeEach(start.row, end.row, function(rowEnd) {
                _this7.setBorder(rowEnd, end.col, place, remove);
              });
              break;
          }
        }
      });
    }
    /**
     * Create borders from settings.
     *
     * @private
     * @param {Array} customBorders Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.
     */
  }, {
    key: "createCustomBorders",
    value: function createCustomBorders(customBorders) {
      var _this8 = this;
      arrayEach(customBorders, function(customBorder) {
        var normCustomBorder = normalizeBorder(customBorder);
        if (customBorder.range) {
          _this8.prepareBorderFromCustomAddedRange(customBorder.range, normCustomBorder);
        } else {
          _this8.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, normCustomBorder);
        }
      });
    }
    /**
     * Count hide property in border object.
     *
     * @private
     * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
     *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
     * @returns {number}
     */
  }, {
    key: "countHide",
    value: function countHide(border) {
      var top2 = border.top, bottom2 = border.bottom, start = border.start, end = border.end;
      var values3 = [top2, bottom2, start, end];
      return arrayReduce$1(values3, function(accumulator, value) {
        var result = accumulator;
        if (value && value.hide) {
          result += 1;
        }
        return result;
      }, 0);
    }
    /**
     * Clear borders settings from custom selections.
     *
     * @private
     * @param {string} borderId Border id name as string.
     */
  }, {
    key: "clearBordersFromSelectionSettings",
    value: function clearBordersFromSelectionSettings(borderId) {
      var index2 = arrayMap(this.hot.selection.highlight.customSelections, function(customSelection) {
        return customSelection.settings.id;
      }).indexOf(borderId);
      if (index2 > -1) {
        this.hot.selection.highlight.customSelections[index2].clear();
      }
    }
    /**
     * Clear cellRange with null value.
     *
     * @private
     */
  }, {
    key: "clearNullCellRange",
    value: function clearNullCellRange() {
      var _this9 = this;
      arrayEach(this.hot.selection.highlight.customSelections, function(customSelection, index2) {
        if (customSelection.cellRange === null) {
          _this9.hot.selection.highlight.customSelections[index2].destroy();
          _this9.hot.selection.highlight.customSelections.splice(index2, 1);
          return false;
        }
      });
    }
    /**
     * Hide custom borders.
     *
     * @private
     */
  }, {
    key: "hideBorders",
    value: function hideBorders() {
      var _this10 = this;
      arrayEach(this.savedBorders, function(border) {
        _this10.clearBordersFromSelectionSettings(border.id);
        _this10.clearNullCellRange();
      });
    }
    /**
     * Splice border from savedBorders.
     *
     * @private
     * @param {string} borderId Border id name as string.
     */
  }, {
    key: "spliceBorder",
    value: function spliceBorder(borderId) {
      var index2 = arrayMap(this.savedBorders, function(border) {
        return border.id;
      }).indexOf(borderId);
      if (index2 > -1) {
        this.savedBorders.splice(index2, 1);
      }
    }
    /**
     * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.
     *
     * @private
     * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
     *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
     *
     * @returns {boolean}
     */
  }, {
    key: "checkSavedBorders",
    value: function checkSavedBorders(border) {
      var _this11 = this;
      var check2 = false;
      var hideCount = this.countHide(border);
      if (hideCount === 4) {
        this.spliceBorder(border.id);
        check2 = true;
      } else {
        arrayEach(this.savedBorders, function(savedBorder, index2) {
          if (border.id === savedBorder.id) {
            _this11.savedBorders[index2] = border;
            check2 = true;
            return false;
          }
        });
      }
      return check2;
    }
    /**
     * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.
     *
     * @private
     * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
     *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
     * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.
     * @param {boolean} remove True when remove borders, and false when add borders.
     *
     * @returns {boolean}
     */
  }, {
    key: "checkCustomSelectionsFromContextMenu",
    value: function checkCustomSelectionsFromContextMenu(border, place, remove) {
      var check2 = false;
      arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
        if (border.id === customSelection.settings.id) {
          objectEach(customSelection.instanceBorders, function(borderObject) {
            borderObject.toggleHiddenClass(place, remove);
          });
          check2 = true;
          return false;
        }
      });
      return check2;
    }
    /**
     * Check if an border already exists in the customSelections, and if true reset cellRange.
     *
     * @private
     * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
     *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
     * @param {CellRange} cellRange The selection range to check.
     * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
     * @returns {boolean}
     */
  }, {
    key: "checkCustomSelections",
    value: function checkCustomSelections(border, cellRange, place) {
      var hideCount = this.countHide(border);
      var check2 = false;
      if (hideCount === 4) {
        this.removeAllBorders(border.row, border.col);
        check2 = true;
      } else {
        arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
          if (border.id === customSelection.settings.id) {
            customSelection.visualCellRange = cellRange;
            customSelection.commit();
            if (place) {
              objectEach(customSelection.instanceBorders, function(borderObject) {
                borderObject.changeBorderStyle(place, border);
              });
            }
            check2 = true;
            return false;
          }
        });
      }
      return check2;
    }
    /**
     * Change borders from settings.
     *
     * @private
     */
  }, {
    key: "changeBorderSettings",
    value: function changeBorderSettings() {
      var customBorders = this.hot.getSettings()[PLUGIN_KEY$m];
      if (Array.isArray(customBorders)) {
        var bordersClone = deepClone(customBorders);
        this.checkSettingsCohesion(bordersClone);
        if (!bordersClone.length) {
          this.savedBorders = bordersClone;
        }
        this.createCustomBorders(bordersClone);
      } else if (customBorders !== void 0) {
        this.createCustomBorders(this.savedBorders);
      }
    }
    /**
     * Checks the settings cohesion. The properties such like "left"/"right" are supported only
     * in the LTR mode and the "left"/"right" options can not be used together with "start"/"end" properties.
     *
     * @private
     * @param {object[]} customBorders The user defined custom border objects array.
     */
  }, {
    key: "checkSettingsCohesion",
    value: function checkSettingsCohesion(customBorders) {
      var hasLeftOrRight = hasLeftRightTypeOptions(customBorders);
      var hasStartOrEnd = hasStartEndTypeOptions(customBorders);
      if (hasLeftOrRight && hasStartOrEnd) {
        throw new Error('The "left"/"right" and "start"/"end" options should not be used together. Please use only the option "start"/"end".');
      }
      if (this.hot.isRtl() && hasLeftOrRight) {
        throw new Error('The "left"/"right" properties are not supported for RTL. Please use option "start"/"end".');
      }
    }
    /**
     * Add border options to context menu.
     *
     * @private
     * @param {object} defaultOptions Context menu items.
     */
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(defaultOptions) {
      if (!this.hot.getSettings()[PLUGIN_KEY$m]) {
        return;
      }
      defaultOptions.items.push({
        name: "---------"
      }, {
        key: "borders",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS);
        },
        disabled: function disabled() {
          return this.selection.isSelectedByCorner();
        },
        submenu: {
          items: [top(this), right(this), bottom(this), left(this), noBorders(this)]
        }
      });
    }
    /**
     * `afterInit` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.changeBorderSettings();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$v(_getPrototypeOf$D(CustomBorders2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$m;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$l;
    }
    /**
     * Saved borders.
     *
     * @private
     * @type {Array}
     */
  }]);
  return CustomBorders2;
}(BasePlugin);
function _typeof$E(obj) {
  "@babel/helpers - typeof";
  return _typeof$E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$E(obj);
}
function _classCallCheck$Y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$Y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$Y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$Y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$Y(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$u() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$u = Reflect.get.bind();
  } else {
    _get$u = function _get2(target, property, receiver) {
      var base = _superPropBase$u(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$u.apply(this, arguments);
}
function _superPropBase$u(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$C(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$C(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$C(subClass, superClass);
}
function _setPrototypeOf$C(o, p2) {
  _setPrototypeOf$C = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$C(o, p2);
}
function _createSuper$C(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$C();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$C(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$C(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$C(this, result);
  };
}
function _possibleConstructorReturn$C(self2, call2) {
  if (call2 && (_typeof$E(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$C(self2);
}
function _assertThisInitialized$C(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$C() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$C(o) {
  _getPrototypeOf$C = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$C(o);
}
var PLUGIN_KEY$l = "dragToScroll";
var PLUGIN_PRIORITY$k = 100;
var DragToScroll = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$C(DragToScroll2, _BasePlugin);
  var _super = _createSuper$C(DragToScroll2);
  function DragToScroll2(hotInstance) {
    var _this;
    _classCallCheck$Y(this, DragToScroll2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager$1(_assertThisInitialized$C(_this));
    _this.boundaries = null;
    _this.callback = null;
    _this.listening = false;
    return _this;
  }
  _createClass$Y(DragToScroll2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$l];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterOnCellMouseDown", function(event2) {
        return _this2.setupListening(event2);
      });
      this.addHook("afterOnCellCornerMouseDown", function(event2) {
        return _this2.setupListening(event2);
      });
      this.registerEvents();
      _get$u(_getPrototypeOf$C(DragToScroll2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`dragToScroll`](@/api/options.md#dragtoscroll)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$u(_getPrototypeOf$C(DragToScroll2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.unregisterEvents();
      _get$u(_getPrototypeOf$C(DragToScroll2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Sets the value of the visible element.
     *
     * @param {DOMRect} boundaries An object with coordinates compatible with DOMRect.
     */
  }, {
    key: "setBoundaries",
    value: function setBoundaries(boundaries) {
      this.boundaries = boundaries;
    }
    /**
     * Changes callback function.
     *
     * @param {Function} callback The callback function.
     */
  }, {
    key: "setCallback",
    value: function setCallback(callback) {
      this.callback = callback;
    }
    /**
     * Checks if the mouse position (X, Y) is outside of the viewport and fires a callback with calculated X an Y diffs
     * between passed boundaries.
     *
     * @param {number} x Mouse X coordinate to check.
     * @param {number} y Mouse Y coordinate to check.
     */
  }, {
    key: "check",
    value: function check2(x2, y2) {
      var diffX = 0;
      var diffY = 0;
      if (y2 < this.boundaries.top) {
        diffY = y2 - this.boundaries.top;
      } else if (y2 > this.boundaries.bottom) {
        diffY = y2 - this.boundaries.bottom;
      }
      if (x2 < this.boundaries.left) {
        diffX = x2 - this.boundaries.left;
      } else if (x2 > this.boundaries.right) {
        diffX = x2 - this.boundaries.right;
      }
      this.callback(diffX, diffY);
    }
    /**
     * Enables listening on `mousemove` event.
     *
     * @private
     */
  }, {
    key: "listen",
    value: function listen() {
      this.listening = true;
    }
    /**
     * Disables listening on `mousemove` event.
     *
     * @private
     */
  }, {
    key: "unlisten",
    value: function unlisten() {
      this.listening = false;
    }
    /**
     * Returns current state of listening.
     *
     * @private
     * @returns {boolean}
     */
  }, {
    key: "isListening",
    value: function isListening() {
      return this.listening;
    }
    /**
     * Registers dom listeners.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this3 = this;
      var rootWindow = this.hot.rootWindow;
      var frame = rootWindow;
      while (frame) {
        this.eventManager.addEventListener(frame.document, "contextmenu", function() {
          return _this3.unlisten();
        });
        this.eventManager.addEventListener(frame.document, "mouseup", function() {
          return _this3.unlisten();
        });
        this.eventManager.addEventListener(frame.document, "mousemove", function(event2) {
          return _this3.onMouseMove(event2);
        });
        frame = getParentWindow(frame);
      }
    }
    /**
     * Unbinds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
    /**
     * On after on cell/cellCorner mouse down listener.
     *
     * @private
     * @param {MouseEvent} event The mouse event object.
     */
  }, {
    key: "setupListening",
    value: function setupListening(event2) {
      if (isRightClick(event2)) {
        return;
      }
      var scrollHandler = this.hot.view._wt.wtTable.holder;
      if (scrollHandler === this.hot.rootWindow) {
        return;
      }
      this.setBoundaries(scrollHandler.getBoundingClientRect());
      this.setCallback(function(scrollX, scrollY) {
        if (scrollX < 0) {
          scrollHandler.scrollLeft -= 50;
        } else if (scrollX > 0) {
          scrollHandler.scrollLeft += 50;
        }
        if (scrollY < 0) {
          scrollHandler.scrollTop -= 20;
        } else if (scrollY > 0) {
          scrollHandler.scrollTop += 20;
        }
      });
      this.listen();
    }
    /**
     * 'mouseMove' event callback.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      if (!this.isListening()) {
        return;
      }
      this.check(event2.clientX, event2.clientY);
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$u(_getPrototypeOf$C(DragToScroll2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$l;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$k;
    }
  }]);
  return DragToScroll2;
}(BasePlugin);
function _typeof$D(obj) {
  "@babel/helpers - typeof";
  return _typeof$D = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$D(obj);
}
function _classCallCheck$X(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$X(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$X(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$X(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$X(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$t() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$t = Reflect.get.bind();
  } else {
    _get$t = function _get2(target, property, receiver) {
      var base = _superPropBase$t(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$t.apply(this, arguments);
}
function _superPropBase$t(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$B(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$B(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$B(subClass, superClass);
}
function _setPrototypeOf$B(o, p2) {
  _setPrototypeOf$B = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$B(o, p2);
}
function _createSuper$B(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$B();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$B(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$B(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$B(this, result);
  };
}
function _possibleConstructorReturn$B(self2, call2) {
  if (call2 && (_typeof$D(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$B(self2);
}
function _assertThisInitialized$B(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$B() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$B(o) {
  _getPrototypeOf$B = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$B(o);
}
Hooks$1.getSingleton().register("afterDropdownMenuDefaultOptions");
Hooks$1.getSingleton().register("beforeDropdownMenuShow");
Hooks$1.getSingleton().register("afterDropdownMenuShow");
Hooks$1.getSingleton().register("afterDropdownMenuHide");
Hooks$1.getSingleton().register("afterDropdownMenuExecute");
var PLUGIN_KEY$k = "dropdownMenu";
var PLUGIN_PRIORITY$j = 230;
var BUTTON_CLASS_NAME = "changeType";
var DropdownMenu = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$B(DropdownMenu2, _BasePlugin);
  var _super = _createSuper$B(DropdownMenu2);
  function DropdownMenu2(hotInstance) {
    var _this;
    _classCallCheck$X(this, DropdownMenu2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager$1(_assertThisInitialized$B(_this));
    _this.commandExecutor = new CommandExecutor$1(_this.hot);
    _this.itemsFactory = null;
    _this.menu = null;
    _this.hot.addHook("afterGetColHeader", function(col, TH) {
      return _this.onAfterGetColHeader(col, TH);
    });
    return _this;
  }
  _createClass$X(DropdownMenu2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$k];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     *
     * @fires Hooks#afterDropdownMenuDefaultOptions
     * @fires Hooks#beforeDropdownMenuSetItems
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.itemsFactory = new ItemsFactory$1(this.hot, DropdownMenu2.DEFAULT_ITEMS);
      var settings = this.hot.getSettings()[PLUGIN_KEY$k];
      var predefinedItems2 = {
        items: this.itemsFactory.getItems(settings)
      };
      this.registerEvents();
      if (typeof settings.callback === "function") {
        this.commandExecutor.setCommonCallback(settings.callback);
      }
      _get$t(_getPrototypeOf$B(DropdownMenu2.prototype), "enablePlugin", this).call(this);
      this.callOnPluginsReady(function() {
        _this2.hot.runHooks("afterDropdownMenuDefaultOptions", predefinedItems2);
        _this2.itemsFactory.setPredefinedItems(predefinedItems2.items);
        var menuItems = _this2.itemsFactory.getItems(settings);
        if (_this2.menu) {
          _this2.menu.destroy();
        }
        _this2.menu = new Menu$1(_this2.hot, {
          className: "htDropdownMenu",
          keepInViewport: true,
          container: settings.uiContainer || _this2.hot.rootDocument.body
        });
        _this2.hot.runHooks("beforeDropdownMenuSetItems", menuItems);
        _this2.menu.setMenuItems(menuItems);
        _this2.menu.addLocalHook("beforeOpen", function() {
          return _this2.onMenuBeforeOpen();
        });
        _this2.menu.addLocalHook("afterOpen", function() {
          return _this2.onMenuAfterOpen();
        });
        _this2.menu.addLocalHook("afterClose", function() {
          return _this2.onMenuAfterClose();
        });
        _this2.menu.addLocalHook("executeCommand", function() {
          var _this2$executeCommand;
          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
          }
          return (_this2$executeCommand = _this2.executeCommand).call.apply(_this2$executeCommand, [_this2].concat(params));
        });
        arrayEach(menuItems, function(command) {
          return _this2.commandExecutor.registerCommand(command.key, command);
        });
      });
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`dropdownMenu`](@/api/options.md#dropdownmenu)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$t(_getPrototypeOf$B(DropdownMenu2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
      }
      _get$t(_getPrototypeOf$B(DropdownMenu2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Registers the DOM listeners.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this3 = this;
      this.eventManager.addEventListener(this.hot.rootElement, "click", function(event2) {
        return _this3.onTableClick(event2);
      });
    }
    /**
     * Opens menu and re-position it based on the passed coordinates.
     *
     * @param {object|Event} position An object with `pageX` and `pageY` properties which contains values relative to
     *                                the top left of the fully rendered content area in the browser or with `clientX`
     *                                and `clientY`  properties which contains values relative to the upper left edge
     *                                of the content area (the viewport) of the browser window. This object is structurally
     *                                compatible with native mouse event so it can be used either.
     * @fires Hooks#beforeDropdownMenuShow
     * @fires Hooks#afterDropdownMenuShow
     */
  }, {
    key: "open",
    value: function open(position) {
      if (!this.menu) {
        return;
      }
      this.menu.open();
      if (position.width) {
        this.menu.setOffset("left", position.width);
      }
      this.menu.setPosition(position);
    }
    /**
     * Closes dropdown menu.
     */
  }, {
    key: "close",
    value: function close() {
      if (!this.menu) {
        return;
      }
      this.menu.close();
    }
    /**
     * Executes context menu command.
     *
     * The `executeCommand()` method works only for selected cells.
     *
     * When no cells are selected, `executeCommand()` doesn't do anything.
     *
     * You can execute all predefined commands:
     *  * `'row_above'` - Insert row above
     *  * `'row_below'` - Insert row below
     *  * `'col_left'` - Insert column left
     *  * `'col_right'` - Insert column right
     *  * `'clear_column'` - Clear selected column
     *  * `'remove_row'` - Remove row
     *  * `'remove_col'` - Remove column
     *  * `'undo'` - Undo last action
     *  * `'redo'` - Redo last action
     *  * `'make_read_only'` - Make cell read only
     *  * `'alignment:left'` - Alignment to the left
     *  * `'alignment:top'` - Alignment to the top
     *  * `'alignment:right'` - Alignment to the right
     *  * `'alignment:bottom'` - Alignment to the bottom
     *  * `'alignment:middle'` - Alignment to the middle
     *  * `'alignment:center'` - Alignment to the center (justify).
     *
     * Or you can execute command registered in settings where `key` is your command name.
     *
     * @param {string} commandName Command name to execute.
     * @param {*} params Additional parameters passed to the command executor.
     */
  }, {
    key: "executeCommand",
    value: function executeCommand(commandName) {
      var _this$commandExecutor;
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      (_this$commandExecutor = this.commandExecutor).execute.apply(_this$commandExecutor, [commandName].concat(params));
    }
    /**
     * Turns on / off listening on dropdown menu.
     *
     * @private
     * @param {boolean} listen Turn on listening when value is set to true, otherwise turn it off.
     */
  }, {
    key: "setListening",
    value: function setListening() {
      var listen = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (this.menu.isOpened()) {
        if (listen) {
          this.menu.hotMenu.listen();
        } else {
          this.menu.hotMenu.unlisten();
        }
      }
    }
    /**
     * Table click listener.
     *
     * @private
     * @param {Event} event The mouse event object.
     */
  }, {
    key: "onTableClick",
    value: function onTableClick(event2) {
      event2.stopPropagation();
      if (hasClass(event2.target, BUTTON_CLASS_NAME) && !this.menu.isOpened()) {
        var offsetTop = 0;
        var offsetLeft = 0;
        if (this.hot.rootDocument !== this.menu.container.ownerDocument) {
          var frameElement = this.hot.rootWindow.frameElement;
          var _frameElement$getBoun = frameElement.getBoundingClientRect(), top2 = _frameElement$getBoun.top, left2 = _frameElement$getBoun.left;
          offsetTop = top2;
          offsetLeft = left2;
        }
        var rect = event2.target.getBoundingClientRect();
        this.open({
          left: rect.left + offsetLeft,
          top: rect.top + event2.target.offsetHeight + 3 + offsetTop,
          width: rect.width,
          height: rect.height
        });
      }
    }
    /**
     * On after get column header listener.
     *
     * @private
     * @param {number} col Visual column index.
     * @param {HTMLTableCellElement} TH Header's TH element.
     */
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(col, TH) {
      var headerRow = TH.parentNode;
      if (!headerRow) {
        return;
      }
      var headerRowList = headerRow.parentNode.childNodes;
      var level = Array.prototype.indexOf.call(headerRowList, headerRow);
      if (col < 0 || level !== headerRowList.length - 1) {
        return;
      }
      var existingButton = TH.querySelector(".".concat(BUTTON_CLASS_NAME));
      if (this.enabled && existingButton) {
        return;
      }
      if (!this.enabled) {
        if (existingButton) {
          existingButton.parentNode.removeChild(existingButton);
        }
        return;
      }
      var button = this.hot.rootDocument.createElement("button");
      button.className = BUTTON_CLASS_NAME;
      button.type = "button";
      button.onclick = function() {
        return false;
      };
      TH.firstChild.insertBefore(button, TH.firstChild.firstChild);
    }
    /**
     * On menu before open listener.
     *
     * @private
     * @fires Hooks#beforeDropdownMenuShow
     */
  }, {
    key: "onMenuBeforeOpen",
    value: function onMenuBeforeOpen() {
      this.hot.runHooks("beforeDropdownMenuShow", this);
    }
    /**
     * On menu after open listener.
     *
     * @private
     * @fires Hooks#afterDropdownMenuShow
     */
  }, {
    key: "onMenuAfterOpen",
    value: function onMenuAfterOpen() {
      this.hot.runHooks("afterDropdownMenuShow", this);
    }
    /**
     * On menu after close listener.
     *
     * @private
     * @fires Hooks#afterDropdownMenuHide
     */
  }, {
    key: "onMenuAfterClose",
    value: function onMenuAfterClose() {
      this.hot.listen();
      this.hot.runHooks("afterDropdownMenuHide", this);
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
      }
      _get$t(_getPrototypeOf$B(DropdownMenu2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$k;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$j;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get2() {
      return ["plugin:AutoColumnSize"];
    }
    /**
     * Default menu items order when `dropdownMenu` is enabled by setting the config item to `true`.
     *
     * @returns {Array}
     */
  }, {
    key: "DEFAULT_ITEMS",
    get: function get2() {
      return [KEY$9, KEY$8, KEY$c, KEY$5, KEY$c, KEY$a, KEY$c, KEY$7, KEY$c, KEY$b];
    }
  }]);
  return DropdownMenu2;
}(BasePlugin);
DropdownMenu.SEPARATOR = {
  name: KEY$c
};
function _slicedToArray$o(arr, i) {
  return _arrayWithHoles$p(arr) || _iterableToArrayLimit$o(arr, i) || _unsupportedIterableToArray$A(arr, i) || _nonIterableRest$p();
}
function _nonIterableRest$p() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$A(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$A(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$A(o, minLen);
}
function _arrayLikeToArray$A(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$o(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$p(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$W(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$W(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$W(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$W(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$W(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DataProvider = /* @__PURE__ */ function() {
  function DataProvider2(hotInstance) {
    _classCallCheck$W(this, DataProvider2);
    this.hot = hotInstance;
    this.options = {};
  }
  _createClass$W(DataProvider2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Get table data based on provided settings to the class constructor.
     *
     * @returns {Array}
     */
  }, {
    key: "getData",
    value: function getData() {
      var _this = this;
      var _this$_getDataRange = this._getDataRange(), startRow = _this$_getDataRange.startRow, startCol = _this$_getDataRange.startCol, endRow = _this$_getDataRange.endRow, endCol = _this$_getDataRange.endCol;
      var options = this.options;
      var data2 = [];
      rangeEach(startRow, endRow, function(rowIndex) {
        var row = [];
        if (!options.exportHiddenRows && _this._isHiddenRow(rowIndex)) {
          return;
        }
        rangeEach(startCol, endCol, function(colIndex) {
          if (!options.exportHiddenColumns && _this._isHiddenColumn(colIndex)) {
            return;
          }
          row.push(_this.hot.getDataAtCell(rowIndex, colIndex));
        });
        data2.push(row);
      });
      return data2;
    }
    /**
     * Gets list of row headers.
     *
     * @returns {Array}
     */
  }, {
    key: "getRowHeaders",
    value: function getRowHeaders() {
      var _this2 = this;
      var headers = [];
      if (this.options.rowHeaders) {
        var _this$_getDataRange2 = this._getDataRange(), startRow = _this$_getDataRange2.startRow, endRow = _this$_getDataRange2.endRow;
        var rowHeaders = this.hot.getRowHeader();
        rangeEach(startRow, endRow, function(row) {
          if (!_this2.options.exportHiddenRows && _this2._isHiddenRow(row)) {
            return;
          }
          headers.push(rowHeaders[row]);
        });
      }
      return headers;
    }
    /**
     * Gets list of columns headers.
     *
     * @returns {Array}
     */
  }, {
    key: "getColumnHeaders",
    value: function getColumnHeaders() {
      var _this3 = this;
      var headers = [];
      if (this.options.columnHeaders) {
        var _this$_getDataRange3 = this._getDataRange(), startCol = _this$_getDataRange3.startCol, endCol = _this$_getDataRange3.endCol;
        var colHeaders = this.hot.getColHeader();
        rangeEach(startCol, endCol, function(column) {
          if (!_this3.options.exportHiddenColumns && _this3._isHiddenColumn(column)) {
            return;
          }
          headers.push(colHeaders[column]);
        });
      }
      return headers;
    }
    /**
     * Get data range object based on settings provided in the class constructor.
     *
     * @private
     * @returns {object} Returns object with keys `startRow`, `startCol`, `endRow` and `endCol`.
     */
  }, {
    key: "_getDataRange",
    value: function _getDataRange() {
      var cols = this.hot.countCols() - 1;
      var rows = this.hot.countRows() - 1;
      var _this$options$range = _slicedToArray$o(this.options.range, 4), _this$options$range$ = _this$options$range[0], startRow = _this$options$range$ === void 0 ? 0 : _this$options$range$, _this$options$range$2 = _this$options$range[1], startCol = _this$options$range$2 === void 0 ? 0 : _this$options$range$2, _this$options$range$3 = _this$options$range[2], endRow = _this$options$range$3 === void 0 ? rows : _this$options$range$3, _this$options$range$4 = _this$options$range[3], endCol = _this$options$range$4 === void 0 ? cols : _this$options$range$4;
      startRow = Math.max(startRow, 0);
      startCol = Math.max(startCol, 0);
      endRow = Math.min(endRow, rows);
      endCol = Math.min(endCol, cols);
      return {
        startRow,
        startCol,
        endRow,
        endCol
      };
    }
    /**
     * Check if row at specified row index is hidden.
     *
     * @private
     * @param {number} row Row index.
     * @returns {boolean}
     */
  }, {
    key: "_isHiddenRow",
    value: function _isHiddenRow(row) {
      return this.hot.rowIndexMapper.isHidden(this.hot.toPhysicalRow(row));
    }
    /**
     * Check if column at specified column index is hidden.
     *
     * @private
     * @param {number} column Visual column index.
     * @returns {boolean}
     */
  }, {
    key: "_isHiddenColumn",
    value: function _isHiddenColumn(column) {
      return this.hot.columnIndexMapper.isHidden(this.hot.toPhysicalColumn(column));
    }
  }]);
  return DataProvider2;
}();
const DataProvider$1 = DataProvider;
function _classCallCheck$V(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$V(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$V(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$V(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$V(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var BaseType = /* @__PURE__ */ function() {
  function BaseType2(dataProvider, options) {
    _classCallCheck$V(this, BaseType2);
    this.dataProvider = dataProvider;
    this.options = this._mergeOptions(options);
    this.dataProvider.setOptions(this.options);
  }
  _createClass$V(BaseType2, [{
    key: "_mergeOptions",
    value: function _mergeOptions(options) {
      var _options = clone$1(this.constructor.DEFAULT_OPTIONS);
      var date = /* @__PURE__ */ new Date();
      _options = extend(clone$1(BaseType2.DEFAULT_OPTIONS), _options);
      _options = extend(_options, options);
      _options.filename = substitute(_options.filename, {
        YYYY: date.getFullYear(),
        MM: "".concat(date.getMonth() + 1).padStart(2, "0"),
        DD: "".concat(date.getDate()).padStart(2, "0")
      });
      return _options;
    }
  }], [{
    key: "DEFAULT_OPTIONS",
    get: (
      /**
       * Default options.
       *
       * @returns {object}
       */
      function get2() {
        return {
          mimeType: "text/plain",
          fileExtension: "txt",
          filename: "Handsontable [YYYY]-[MM]-[DD]",
          encoding: "utf-8",
          bom: false,
          columnHeaders: false,
          rowHeaders: false,
          exportHiddenColumns: false,
          exportHiddenRows: false,
          range: []
        };
      }
    )
  }]);
  return BaseType2;
}();
const BaseType$1 = BaseType;
function _typeof$C(obj) {
  "@babel/helpers - typeof";
  return _typeof$C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$C(obj);
}
function _classCallCheck$U(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$U(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$U(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$U(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$U(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$A(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$A(subClass, superClass);
}
function _setPrototypeOf$A(o, p2) {
  _setPrototypeOf$A = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$A(o, p2);
}
function _createSuper$A(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$A();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$A(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$A(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$A(this, result);
  };
}
function _possibleConstructorReturn$A(self2, call2) {
  if (call2 && (_typeof$C(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$A(self2);
}
function _assertThisInitialized$A(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$A() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$A(o) {
  _getPrototypeOf$A = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$A(o);
}
var CHAR_CARRIAGE_RETURN = String.fromCharCode(13);
var CHAR_DOUBLE_QUOTES = String.fromCharCode(34);
var CHAR_LINE_FEED = String.fromCharCode(10);
var Csv = /* @__PURE__ */ function(_BaseType) {
  _inherits$A(Csv2, _BaseType);
  var _super = _createSuper$A(Csv2);
  function Csv2() {
    _classCallCheck$U(this, Csv2);
    return _super.apply(this, arguments);
  }
  _createClass$U(Csv2, [{
    key: "export",
    value: (
      /**
       * Create string body in desired format.
       *
       * @returns {string}
       */
      function _export2() {
        var _this = this;
        var options = this.options;
        var data2 = this.dataProvider.getData();
        var columnHeaders = this.dataProvider.getColumnHeaders();
        var hasColumnHeaders = columnHeaders.length > 0;
        var rowHeaders = this.dataProvider.getRowHeaders();
        var hasRowHeaders = rowHeaders.length > 0;
        var result = options.bom ? String.fromCharCode(65279) : "";
        if (hasColumnHeaders) {
          columnHeaders = arrayMap(columnHeaders, function(value) {
            return _this._escapeCell(value, true);
          });
          if (hasRowHeaders) {
            result += options.columnDelimiter;
          }
          result += columnHeaders.join(options.columnDelimiter);
          result += options.rowDelimiter;
        }
        arrayEach(data2, function(value, index2) {
          if (index2 > 0) {
            result += options.rowDelimiter;
          }
          if (hasRowHeaders) {
            result += _this._escapeCell(rowHeaders[index2]) + options.columnDelimiter;
          }
          result += value.map(function(cellValue) {
            return _this._escapeCell(cellValue);
          }).join(options.columnDelimiter);
        });
        return result;
      }
    )
    /**
     * Escape cell value.
     *
     * @param {*} value Cell value.
     * @param {boolean} [force=false] Indicates if cell value will be escaped forcefully.
     * @returns {string}
     */
  }, {
    key: "_escapeCell",
    value: function _escapeCell(value) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var escapedValue = stringify$1(value);
      if (escapedValue !== "" && (force || escapedValue.indexOf(CHAR_CARRIAGE_RETURN) >= 0 || escapedValue.indexOf(CHAR_DOUBLE_QUOTES) >= 0 || escapedValue.indexOf(CHAR_LINE_FEED) >= 0 || escapedValue.indexOf(this.options.columnDelimiter) >= 0)) {
        escapedValue = escapedValue.replace(new RegExp('"', "g"), '""');
        escapedValue = '"'.concat(escapedValue, '"');
      }
      return escapedValue;
    }
  }], [{
    key: "DEFAULT_OPTIONS",
    get: (
      /**
       * Default options for exporting CSV format.
       *
       * @returns {object}
       */
      function get2() {
        return {
          mimeType: "text/csv",
          fileExtension: "csv",
          bom: true,
          columnDelimiter: ",",
          rowDelimiter: "\r\n"
        };
      }
    )
  }]);
  return Csv2;
}(BaseType$1);
const Csv$1 = Csv;
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TYPE_CSV = "csv";
var EXPORT_TYPES = _defineProperty$9({}, TYPE_CSV, Csv$1);
function typeFactory(type, dataProvider, options) {
  if (typeof EXPORT_TYPES[type] === "function") {
    return new EXPORT_TYPES[type](dataProvider, options);
  }
  return null;
}
function _typeof$B(obj) {
  "@babel/helpers - typeof";
  return _typeof$B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$B(obj);
}
function _classCallCheck$T(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$T(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$T(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$T(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$T(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$z(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$z(subClass, superClass);
}
function _setPrototypeOf$z(o, p2) {
  _setPrototypeOf$z = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$z(o, p2);
}
function _createSuper$z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$z(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$z(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$z(this, result);
  };
}
function _possibleConstructorReturn$z(self2, call2) {
  if (call2 && (_typeof$B(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$z(self2);
}
function _assertThisInitialized$z(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$z() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$z(o) {
  _getPrototypeOf$z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$z(o);
}
var PLUGIN_KEY$j = "exportFile";
var PLUGIN_PRIORITY$i = 240;
var ExportFile = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$z(ExportFile2, _BasePlugin);
  var _super = _createSuper$z(ExportFile2);
  function ExportFile2() {
    _classCallCheck$T(this, ExportFile2);
    return _super.apply(this, arguments);
  }
  _createClass$T(ExportFile2, [{
    key: "isEnabled",
    value: (
      /**
       * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
       * hook and if it returns `true` than the {@link ExportFile#enablePlugin} method is called.
       *
       * @returns {boolean}
       */
      function isEnabled() {
        return true;
      }
    )
    /**
     * @typedef ExportOptions
     * @memberof ExportFile
     * @type {object}
     * @property {boolean} [exportHiddenRows=false] Include hidden rows in the exported file.
     * @property {boolean} [exportHiddenColumns=false] Include hidden columns in the exported file.
     * @property {boolean} [columnHeaders=false] Include column headers in the exported file.
     * @property {boolean} [rowHeaders=false] Include row headers in the exported file.
     * @property {string} [columnDelimiter=','] Column delimiter.
     * @property {string} [range=[]] Cell range that will be exported to file.
     */
    /**
     * Exports table data as a string.
     *
     * @param {string} format Export format type eq. `'csv'`.
     * @param {ExportOptions} options Export options.
     * @returns {string}
     */
  }, {
    key: "exportAsString",
    value: function exportAsString(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._createTypeFormatter(format, options).export();
    }
    /**
     * Exports table data as a blob object.
     *
     * @param {string} format Export format type eq. `'csv'`.
     * @param {ExportOptions} options Export options.
     * @returns {Blob}
     */
  }, {
    key: "exportAsBlob",
    value: function exportAsBlob(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._createBlob(this._createTypeFormatter(format, options));
    }
    /**
     * Exports table data as a downloadable file.
     *
     * @param {string} format Export format type eq. `'csv'`.
     * @param {ExportOptions} options Export options.
     */
  }, {
    key: "downloadFile",
    value: function downloadFile(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _this$hot = this.hot, rootDocument = _this$hot.rootDocument, rootWindow = _this$hot.rootWindow;
      var formatter = this._createTypeFormatter(format, options);
      var blob = this._createBlob(formatter);
      var URL = rootWindow.URL || rootWindow.webkitURL;
      var a = rootDocument.createElement("a");
      var name = "".concat(formatter.options.filename, ".").concat(formatter.options.fileExtension);
      if (a.download !== void 0) {
        var url = URL.createObjectURL(blob);
        a.style.display = "none";
        a.setAttribute("href", url);
        a.setAttribute("download", name);
        rootDocument.body.appendChild(a);
        a.dispatchEvent(new MouseEvent("click"));
        rootDocument.body.removeChild(a);
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, 100);
      } else if (navigator.msSaveOrOpenBlob) {
        navigator.msSaveOrOpenBlob(blob, name);
      }
    }
    /**
     * Creates and returns class formatter for specified export type.
     *
     * @private
     * @param {string} format Export format type eq. `'csv'`.
     * @param {ExportOptions} options Export options.
     * @returns {BaseType}
     */
  }, {
    key: "_createTypeFormatter",
    value: function _createTypeFormatter(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!EXPORT_TYPES[format]) {
        throw new Error('Export format type "'.concat(format, '" is not supported.'));
      }
      return typeFactory(format, new DataProvider$1(this.hot), options);
    }
    /**
     * Creates blob object based on provided type formatter class.
     *
     * @private
     * @param {BaseType} typeFormatter The instance of the specyfic formatter/exporter.
     * @returns {Blob}
     */
  }, {
    key: "_createBlob",
    value: function _createBlob(typeFormatter) {
      var formatter = null;
      if (typeof Blob !== "undefined") {
        formatter = new Blob([typeFormatter.export()], {
          type: "".concat(typeFormatter.options.mimeType, ";charset=").concat(typeFormatter.options.encoding)
        });
      }
      return formatter;
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$j;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$i;
    }
  }]);
  return ExportFile2;
}(BasePlugin);
function _classCallCheck$S(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$S(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$S(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$S(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$S(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var BaseComponent = /* @__PURE__ */ function() {
  function BaseComponent2(hotInstance, _ref2) {
    var id2 = _ref2.id, _ref$stateless = _ref2.stateless, stateless = _ref$stateless === void 0 ? true : _ref$stateless;
    _classCallCheck$S(this, BaseComponent2);
    this.hot = hotInstance;
    this.id = id2;
    this.elements = [];
    this.hidden = false;
    this.stateId = "Filters.component.".concat(this.id);
    this.state = stateless ? null : this.hot.columnIndexMapper.registerMap(this.stateId, new LinkedPhysicalIndexToValueMap());
  }
  _createClass$S(BaseComponent2, [{
    key: "reset",
    value: function reset() {
      arrayEach(this.elements, function(ui) {
        return ui.reset();
      });
    }
    /**
     * Hide component.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
    }
    /**
     * Show component.
     */
  }, {
    key: "show",
    value: function show() {
      this.hidden = false;
    }
    /**
     * Check if component is hidden.
     *
     * @returns {boolean}
     */
  }, {
    key: "isHidden",
    value: function isHidden() {
      return this.hot === null || this.hidden;
    }
    /**
     * Restores the component state from the given physical column index. The method
     * internally calls the `setState` method. The state then is individually processed
     * by each component.
     *
     * @param {number} physicalColumn The physical column index.
     */
  }, {
    key: "restoreState",
    value: function restoreState(physicalColumn) {
      if (this.state) {
        this.setState(this.state.getValueAtIndex(physicalColumn));
      }
    }
    /**
     * The custom logic for component state restoring.
     */
  }, {
    key: "setState",
    value: function setState() {
      throw new Error("The state setting logic is not implemented");
    }
    /**
     * Saves the component state to the given physical column index. The method
     * internally calls the `getState` method, which returns the current state of
     * the component.
     *
     * @param {number} physicalColumn The physical column index.
     */
  }, {
    key: "saveState",
    value: function saveState(physicalColumn) {
      if (this.state) {
        this.state.setValueAtIndex(physicalColumn, this.getState());
      }
    }
    /**
     * The custom logic for component state gathering (for stateful components).
     */
  }, {
    key: "getState",
    value: function getState() {
      throw new Error("The state gathering logic is not implemented");
    }
    /**
     * Destroy element.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.hot.columnIndexMapper.unregisterMap(this.stateId);
      this.clearLocalHooks();
      arrayEach(this.elements, function(ui) {
        return ui.destroy();
      });
      this.state = null;
      this.elements = null;
      this.hot = null;
    }
  }]);
  return BaseComponent2;
}();
mixin(BaseComponent, localHooks$1);
const BaseComponent$1 = BaseComponent;
var conditions = {};
function getCondition(name, args) {
  if (!conditions[name]) {
    throw Error('Filter condition "'.concat(name, '" does not exist.'));
  }
  var _conditions$name = conditions[name], condition2 = _conditions$name.condition, descriptor = _conditions$name.descriptor;
  var conditionArguments = args;
  if (descriptor.inputValuesDecorator) {
    conditionArguments = descriptor.inputValuesDecorator(conditionArguments);
  }
  return function(dataRow) {
    return condition2.apply(dataRow.meta.instance, [].concat([dataRow], [conditionArguments]));
  };
}
function getConditionDescriptor(name) {
  if (!conditions[name]) {
    throw Error('Filter condition "'.concat(name, '" does not exist.'));
  }
  return conditions[name].descriptor;
}
function registerCondition(name, condition2, descriptor) {
  descriptor.key = name;
  conditions[name] = {
    condition: condition2,
    descriptor
  };
}
var CONDITION_NAME$k = "none";
function condition$k() {
  return true;
}
registerCondition(CONDITION_NAME$k, condition$k, {
  name: FILTERS_CONDITIONS_NONE,
  inputsCount: 0,
  showOperators: false
});
var CONDITION_NAME$j = "empty";
function condition$j(dataRow) {
  return isEmpty(dataRow.value);
}
registerCondition(CONDITION_NAME$j, condition$j, {
  name: FILTERS_CONDITIONS_EMPTY,
  inputsCount: 0,
  showOperators: true
});
var CONDITION_NAME$i = "not_empty";
function condition$i(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$j, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$i, condition$i, {
  name: FILTERS_CONDITIONS_NOT_EMPTY,
  inputsCount: 0,
  showOperators: true
});
function _slicedToArray$n(arr, i) {
  return _arrayWithHoles$o(arr) || _iterableToArrayLimit$n(arr, i) || _unsupportedIterableToArray$z(arr, i) || _nonIterableRest$o();
}
function _nonIterableRest$o() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$z(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$z(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$z(o, minLen);
}
function _arrayLikeToArray$z(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$n(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$o(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$h = "eq";
function condition$h(dataRow, _ref2) {
  var _ref22 = _slicedToArray$n(_ref2, 1), value = _ref22[0];
  return stringify$1(dataRow.value).toLocaleLowerCase(dataRow.meta.locale) === stringify$1(value);
}
registerCondition(CONDITION_NAME$h, condition$h, {
  name: FILTERS_CONDITIONS_EQUAL,
  inputsCount: 1,
  showOperators: true
});
var CONDITION_NAME$g = "neq";
function condition$g(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$h, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$g, condition$g, {
  name: FILTERS_CONDITIONS_NOT_EQUAL,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$m(arr, i) {
  return _arrayWithHoles$n(arr) || _iterableToArrayLimit$m(arr, i) || _unsupportedIterableToArray$y(arr, i) || _nonIterableRest$n();
}
function _nonIterableRest$n() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$y(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$y(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$y(o, minLen);
}
function _arrayLikeToArray$y(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$m(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$n(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$f = "gt";
function condition$f(dataRow, _ref2) {
  var _ref22 = _slicedToArray$m(_ref2, 1), value = _ref22[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value > conditionValue;
}
registerCondition(CONDITION_NAME$f, condition$f, {
  name: FILTERS_CONDITIONS_GREATER_THAN,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$l(arr, i) {
  return _arrayWithHoles$m(arr) || _iterableToArrayLimit$l(arr, i) || _unsupportedIterableToArray$x(arr, i) || _nonIterableRest$m();
}
function _nonIterableRest$m() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$x(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$x(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$x(o, minLen);
}
function _arrayLikeToArray$x(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$l(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$m(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$e = "gte";
function condition$e(dataRow, _ref2) {
  var _ref22 = _slicedToArray$l(_ref2, 1), value = _ref22[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value >= conditionValue;
}
registerCondition(CONDITION_NAME$e, condition$e, {
  name: FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$k(arr, i) {
  return _arrayWithHoles$l(arr) || _iterableToArrayLimit$k(arr, i) || _unsupportedIterableToArray$w(arr, i) || _nonIterableRest$l();
}
function _nonIterableRest$l() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$w(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$w(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$w(o, minLen);
}
function _arrayLikeToArray$w(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$k(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$l(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$d = "lt";
function condition$d(dataRow, _ref2) {
  var _ref22 = _slicedToArray$k(_ref2, 1), value = _ref22[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value < conditionValue;
}
registerCondition(CONDITION_NAME$d, condition$d, {
  name: FILTERS_CONDITIONS_LESS_THAN,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$j(arr, i) {
  return _arrayWithHoles$k(arr) || _iterableToArrayLimit$j(arr, i) || _unsupportedIterableToArray$v(arr, i) || _nonIterableRest$k();
}
function _nonIterableRest$k() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$v(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$v(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$v(o, minLen);
}
function _arrayLikeToArray$v(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$j(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$k(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$c = "lte";
function condition$c(dataRow, _ref2) {
  var _ref22 = _slicedToArray$j(_ref2, 1), value = _ref22[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value <= conditionValue;
}
registerCondition(CONDITION_NAME$c, condition$c, {
  name: FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$i(arr, i) {
  return _arrayWithHoles$j(arr) || _iterableToArrayLimit$i(arr, i) || _unsupportedIterableToArray$u(arr, i) || _nonIterableRest$j();
}
function _nonIterableRest$j() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$u(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$u(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$u(o, minLen);
}
function _arrayLikeToArray$u(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$i(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$j(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$b = "date_after";
function condition$b(dataRow, _ref2) {
  var _ref22 = _slicedToArray$i(_ref2, 1), value = _ref22[0];
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  var inputDate = hooks(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) >= 0;
}
registerCondition(CONDITION_NAME$b, condition$b, {
  name: FILTERS_CONDITIONS_AFTER,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$h(arr, i) {
  return _arrayWithHoles$i(arr) || _iterableToArrayLimit$h(arr, i) || _unsupportedIterableToArray$t(arr, i) || _nonIterableRest$i();
}
function _nonIterableRest$i() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$t(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$t(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$t(o, minLen);
}
function _arrayLikeToArray$t(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$h(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$i(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$a = "date_before";
function condition$a(dataRow, _ref2) {
  var _ref22 = _slicedToArray$h(_ref2, 1), value = _ref22[0];
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  var inputDate = hooks(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) <= 0;
}
registerCondition(CONDITION_NAME$a, condition$a, {
  name: FILTERS_CONDITIONS_BEFORE,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$g(arr, i) {
  return _arrayWithHoles$h(arr) || _iterableToArrayLimit$g(arr, i) || _unsupportedIterableToArray$s(arr, i) || _nonIterableRest$h();
}
function _nonIterableRest$h() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$s(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$s(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$s(o, minLen);
}
function _arrayLikeToArray$s(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$g(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$h(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$9 = "between";
function condition$9(dataRow, _ref2) {
  var _ref22 = _slicedToArray$g(_ref2, 2), from3 = _ref22[0], to = _ref22[1];
  var fromValue = from3;
  var toValue = to;
  if (dataRow.meta.type === "numeric") {
    var _from = parseFloat(fromValue, 10);
    var _to = parseFloat(toValue, 10);
    fromValue = Math.min(_from, _to);
    toValue = Math.max(_from, _to);
  } else if (dataRow.meta.type === "date") {
    var dateBefore = getCondition(CONDITION_NAME$a, [toValue]);
    var dateAfter = getCondition(CONDITION_NAME$b, [fromValue]);
    return dateBefore(dataRow) && dateAfter(dataRow);
  }
  return dataRow.value >= fromValue && dataRow.value <= toValue;
}
registerCondition(CONDITION_NAME$9, condition$9, {
  name: FILTERS_CONDITIONS_BETWEEN,
  inputsCount: 2,
  showOperators: true
});
var CONDITION_NAME$8 = "not_between";
function condition$8(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$9, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$8, condition$8, {
  name: FILTERS_CONDITIONS_NOT_BETWEEN,
  inputsCount: 2,
  showOperators: true
});
function _slicedToArray$f(arr, i) {
  return _arrayWithHoles$g(arr) || _iterableToArrayLimit$f(arr, i) || _unsupportedIterableToArray$r(arr, i) || _nonIterableRest$g();
}
function _nonIterableRest$g() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$r(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$r(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$r(o, minLen);
}
function _arrayLikeToArray$r(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$f(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$g(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$7 = "begins_with";
function condition$7(dataRow, _ref2) {
  var _ref22 = _slicedToArray$f(_ref2, 1), value = _ref22[0];
  return stringify$1(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).startsWith(stringify$1(value));
}
registerCondition(CONDITION_NAME$7, condition$7, {
  name: FILTERS_CONDITIONS_BEGINS_WITH,
  inputsCount: 1,
  showOperators: true
});
var $$1 = _export;
var uncurryThis$1 = functionUncurryThis;
var getOwnPropertyDescriptor4 = objectGetOwnPropertyDescriptor.f;
var toLength = toLength$7;
var toString$1 = toString$j;
var notARegExp = notARegexp;
var requireObjectCoercible$1 = requireObjectCoercible$e;
var correctIsRegExpLogic = correctIsRegexpLogic;
var nativeEndsWith = uncurryThis$1("".endsWith);
var slice2 = uncurryThis$1("".slice);
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor4(String.prototype, "endsWith");
  return descriptor && !descriptor.writable;
}();
$$1({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  endsWith: function endsWith(searchString) {
    var that = toString$1(requireObjectCoercible$1(this));
    notARegExp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : void 0;
    var len = that.length;
    var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
    var search = toString$1(searchString);
    return nativeEndsWith ? nativeEndsWith(that, search, end) : slice2(that, end - search.length, end) === search;
  }
});
function _slicedToArray$e(arr, i) {
  return _arrayWithHoles$f(arr) || _iterableToArrayLimit$e(arr, i) || _unsupportedIterableToArray$q(arr, i) || _nonIterableRest$f();
}
function _nonIterableRest$f() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$q(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$q(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$q(o, minLen);
}
function _arrayLikeToArray$q(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$e(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$f(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$6 = "ends_with";
function condition$6(dataRow, _ref2) {
  var _ref22 = _slicedToArray$e(_ref2, 1), value = _ref22[0];
  return stringify$1(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).endsWith(stringify$1(value));
}
registerCondition(CONDITION_NAME$6, condition$6, {
  name: FILTERS_CONDITIONS_ENDS_WITH,
  inputsCount: 1,
  showOperators: true
});
function _slicedToArray$d(arr, i) {
  return _arrayWithHoles$e(arr) || _iterableToArrayLimit$d(arr, i) || _unsupportedIterableToArray$p(arr, i) || _nonIterableRest$e();
}
function _nonIterableRest$e() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$p(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$p(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$p(o, minLen);
}
function _arrayLikeToArray$p(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$d(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$e(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$5 = "contains";
function condition$5(dataRow, _ref2) {
  var _ref22 = _slicedToArray$d(_ref2, 1), value = _ref22[0];
  return stringify$1(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).indexOf(stringify$1(value)) >= 0;
}
registerCondition(CONDITION_NAME$5, condition$5, {
  name: FILTERS_CONDITIONS_CONTAINS,
  inputsCount: 1,
  showOperators: true
});
var CONDITION_NAME$4 = "not_contains";
function condition$4(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$5, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$4, condition$4, {
  name: FILTERS_CONDITIONS_NOT_CONTAIN,
  inputsCount: 1,
  showOperators: true
});
var CONDITION_NAME$3 = "date_tomorrow";
function condition$3(dataRow) {
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(hooks().subtract(-1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME$3, condition$3, {
  name: FILTERS_CONDITIONS_TOMORROW,
  inputsCount: 0
});
var CONDITION_NAME$2 = "date_today";
function condition$2(dataRow) {
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(hooks().startOf("day"), "d");
}
registerCondition(CONDITION_NAME$2, condition$2, {
  name: FILTERS_CONDITIONS_TODAY,
  inputsCount: 0
});
var CONDITION_NAME$1 = "date_yesterday";
function condition$1(dataRow) {
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(hooks().subtract(1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME$1, condition$1, {
  name: FILTERS_CONDITIONS_YESTERDAY,
  inputsCount: 0
});
getComparisonFunction();
function toVisualValue(value, defaultEmptyValue) {
  var visualValue = value;
  if (visualValue === "") {
    visualValue = "(".concat(defaultEmptyValue, ")");
  }
  return visualValue;
}
var SUPPORT_SET_CONSTRUCTOR = (/* @__PURE__ */ new Set([1])).has(1);
var SUPPORT_FAST_DEDUPE = SUPPORT_SET_CONSTRUCTOR && typeof Array.from === "function";
function createArrayAssertion(initialData) {
  var dataset = initialData;
  if (SUPPORT_SET_CONSTRUCTOR) {
    dataset = new Set(dataset);
  }
  return function(value) {
    var result;
    if (SUPPORT_SET_CONSTRUCTOR) {
      result = dataset.has(value);
    } else {
      result = !!~dataset.indexOf(value);
    }
    return result;
  };
}
function toEmptyString(value) {
  return value === null || value === void 0 ? "" : value;
}
function unifyColumnValues(values3) {
  var unifiedValues = values3;
  if (SUPPORT_FAST_DEDUPE) {
    unifiedValues = Array.from(new Set(unifiedValues));
  } else {
    unifiedValues = arrayUnique(unifiedValues);
  }
  unifiedValues = unifiedValues.sort(function(a, b2) {
    if (typeof a === "number" && typeof b2 === "number") {
      return a - b2;
    }
    if (a === b2) {
      return 0;
    }
    return a > b2 ? 1 : -1;
  });
  return unifiedValues;
}
function intersectValues(base, selected, defaultEmptyValue, callback) {
  var result = [];
  var same = base === selected;
  var selectedItemsAssertion;
  if (!same) {
    selectedItemsAssertion = createArrayAssertion(selected);
  }
  arrayEach(base, function(value) {
    var checked = false;
    if (same || selectedItemsAssertion(value)) {
      checked = true;
    }
    var item = {
      checked,
      value,
      visualValue: toVisualValue(value, defaultEmptyValue)
    };
    if (callback) {
      callback(item);
    }
    result.push(item);
  });
  return result;
}
function _slicedToArray$c(arr, i) {
  return _arrayWithHoles$d(arr) || _iterableToArrayLimit$c(arr, i) || _unsupportedIterableToArray$o(arr, i) || _nonIterableRest$d();
}
function _nonIterableRest$d() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$o(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$o(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$o(o, minLen);
}
function _arrayLikeToArray$o(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$c(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$d(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME = "by_value";
function condition(dataRow, _ref2) {
  var _ref22 = _slicedToArray$c(_ref2, 1), value = _ref22[0];
  return value(dataRow.value);
}
registerCondition(CONDITION_NAME, condition, {
  name: "By value",
  inputsCount: 0,
  inputValuesDecorator: function inputValuesDecorator(_ref3) {
    var _ref4 = _slicedToArray$c(_ref3, 1), data2 = _ref4[0];
    return [createArrayAssertion(data2)];
  },
  showOperators: false
});
var operations = {};
function getOperationFunc(id2) {
  if (!operations[id2]) {
    throw Error('Operation with id "'.concat(id2, '" does not exist.'));
  }
  var func = operations[id2].func;
  return function(conditions2, value) {
    return func(conditions2, value);
  };
}
function getOperationName(id2) {
  return operations[id2].name;
}
function registerOperation(id2, name, func) {
  operations[id2] = {
    name,
    func
  };
}
var OPERATION_ID$2 = "conjunction";
var SHORT_NAME_FOR_COMPONENT$2 = FILTERS_LABELS_CONJUNCTION;
function operationResult$2(conditions2, value) {
  return conditions2.every(function(condition2) {
    return condition2.func(value);
  });
}
registerOperation(OPERATION_ID$2, SHORT_NAME_FOR_COMPONENT$2, operationResult$2);
var OPERATION_ID$1 = "disjunction";
var SHORT_NAME_FOR_COMPONENT$1 = FILTERS_LABELS_DISJUNCTION;
function operationResult$1(conditions2, value) {
  return conditions2.some(function(condition2) {
    return condition2.func(value);
  });
}
registerOperation(OPERATION_ID$1, SHORT_NAME_FOR_COMPONENT$1, operationResult$1);
var OPERATION_ID = "disjunctionWithExtraCondition";
var SHORT_NAME_FOR_COMPONENT = FILTERS_LABELS_DISJUNCTION;
function operationResult(conditions2, value) {
  if (conditions2.length < 3) {
    throw Error("Operation doesn't work on less then three conditions.");
  }
  return conditions2.slice(0, conditions2.length - 1).some(function(condition2) {
    return condition2.func(value);
  }) && conditions2[conditions2.length - 1].func(value);
}
registerOperation(OPERATION_ID, SHORT_NAME_FOR_COMPONENT, operationResult);
var _TYPES;
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TYPE_NUMERIC = "numeric";
var TYPE_TEXT = "text";
var TYPE_DATE = "date";
var TYPES = (_TYPES = {}, _defineProperty$8(_TYPES, TYPE_NUMERIC, [CONDITION_NAME$k, KEY$c, CONDITION_NAME$j, CONDITION_NAME$i, KEY$c, CONDITION_NAME$h, CONDITION_NAME$g, KEY$c, CONDITION_NAME$f, CONDITION_NAME$e, CONDITION_NAME$d, CONDITION_NAME$c, CONDITION_NAME$9, CONDITION_NAME$8]), _defineProperty$8(_TYPES, TYPE_TEXT, [CONDITION_NAME$k, KEY$c, CONDITION_NAME$j, CONDITION_NAME$i, KEY$c, CONDITION_NAME$h, CONDITION_NAME$g, KEY$c, CONDITION_NAME$7, CONDITION_NAME$6, KEY$c, CONDITION_NAME$5, CONDITION_NAME$4]), _defineProperty$8(_TYPES, TYPE_DATE, [CONDITION_NAME$k, KEY$c, CONDITION_NAME$j, CONDITION_NAME$i, KEY$c, CONDITION_NAME$h, CONDITION_NAME$g, KEY$c, CONDITION_NAME$a, CONDITION_NAME$b, CONDITION_NAME$9, KEY$c, CONDITION_NAME$3, CONDITION_NAME$2, CONDITION_NAME$1]), _TYPES);
function getOptionsList(type) {
  var items = [];
  var typeName = type;
  if (!TYPES[typeName]) {
    typeName = TYPE_TEXT;
  }
  arrayEach(TYPES[typeName], function(typeValue) {
    var option;
    if (typeValue === KEY$c) {
      option = {
        name: KEY$c
      };
    } else {
      option = clone$1(getConditionDescriptor(typeValue));
    }
    items.push(option);
  });
  return items;
}
function _classCallCheck$R(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$R(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$R(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$R(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$R(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var STATE_BUILT$2 = "built";
var STATE_BUILDING = "building";
var EVENTS_TO_REGISTER = ["click", "input", "keydown", "keypress", "keyup", "focus", "blur", "change"];
var BaseUI$6 = /* @__PURE__ */ function() {
  function BaseUI3(hotInstance, options) {
    _classCallCheck$R(this, BaseUI3);
    this.hot = hotInstance;
    this.eventManager = new EventManager$1(this);
    this.options = extend(BaseUI3.DEFAULTS, options);
    this._element = this.hot.rootDocument.createElement(this.options.wrapIt ? "div" : this.options.tagName);
    this.buildState = null;
  }
  _createClass$R(BaseUI3, [{
    key: "setValue",
    value: function setValue(value) {
      this.options.value = value;
      this.update();
    }
    /**
     * Get the element value.
     *
     * @returns {*}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Get element as a DOM object.
     *
     * @returns {Element}
     */
  }, {
    key: "element",
    get: function get2() {
      if (this.buildState === STATE_BUILDING) {
        return this._element;
      }
      if (this.buildState === STATE_BUILT$2) {
        this.update();
        return this._element;
      }
      this.buildState = STATE_BUILDING;
      this.build();
      this.buildState = STATE_BUILT$2;
      return this._element;
    }
    /**
     * Check if element was built (built whole DOM structure).
     *
     * @returns {boolean}
     */
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.buildState === STATE_BUILT$2;
    }
    /**
     * Translate value if it is possible. It's checked if value belongs to namespace of translated phrases.
     *
     * @param {*} value Value which will may be translated.
     * @returns {*} Translated value if translation was possible, original value otherwise.
     */
  }, {
    key: "translateIfPossible",
    value: function translateIfPossible(value) {
      if (typeof value === "string" && value.startsWith(FILTERS_NAMESPACE)) {
        return this.hot.getTranslatedPhrase(value);
      }
      return value;
    }
    /**
     * Build DOM structure.
     */
  }, {
    key: "build",
    value: function build() {
      var _this = this;
      var registerEvent = function registerEvent2(element2, eventName) {
        _this.eventManager.addEventListener(element2, eventName, function(event2) {
          return _this.runLocalHooks(eventName, event2, _this);
        });
      };
      if (!this.buildState) {
        this.buildState = STATE_BUILDING;
      }
      if (this.options.className) {
        addClass(this._element, this.options.className);
      }
      if (this.options.children.length) {
        arrayEach(this.options.children, function(element2) {
          return _this._element.appendChild(element2.element);
        });
      } else if (this.options.wrapIt) {
        var element = this.hot.rootDocument.createElement(this.options.tagName);
        objectEach(this.options, function(value, key) {
          if (element[key] !== void 0 && key !== "className" && key !== "tagName" && key !== "children") {
            element[key] = _this.translateIfPossible(value);
          }
        });
        this._element.appendChild(element);
        arrayEach(EVENTS_TO_REGISTER, function(eventName) {
          return registerEvent(element, eventName);
        });
      } else {
        arrayEach(EVENTS_TO_REGISTER, function(eventName) {
          return registerEvent(_this._element, eventName);
        });
      }
    }
    /**
     * Update DOM structure.
     */
  }, {
    key: "update",
    value: function update() {
    }
    /**
     * Reset to initial state.
     */
  }, {
    key: "reset",
    value: function reset() {
      this.options.value = "";
      this.update();
    }
    /**
     * Show element.
     */
  }, {
    key: "show",
    value: function show() {
      this.element.style.display = "";
    }
    /**
     * Hide element.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.element.style.display = "none";
    }
    /**
     * Focus element.
     */
  }, {
    key: "focus",
    value: function focus() {
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroy();
      this.eventManager = null;
      this.hot = null;
      if (this._element.parentNode) {
        this._element.parentNode.removeChild(this._element);
      }
      this._element = null;
    }
  }], [{
    key: "DEFAULTS",
    get: function get2() {
      return clone$1({
        className: "",
        value: "",
        tagName: "div",
        children: [],
        wrapIt: true
      });
    }
  }]);
  return BaseUI3;
}();
mixin(BaseUI$6, localHooks$1);
const BaseUI$7 = BaseUI$6;
function _typeof$A(obj) {
  "@babel/helpers - typeof";
  return _typeof$A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$A(obj);
}
function _classCallCheck$Q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$Q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$Q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$Q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$Q(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$s() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$s = Reflect.get.bind();
  } else {
    _get$s = function _get2(target, property, receiver) {
      var base = _superPropBase$s(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$s.apply(this, arguments);
}
function _superPropBase$s(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$y(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$y(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$y(subClass, superClass);
}
function _setPrototypeOf$y(o, p2) {
  _setPrototypeOf$y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$y(o, p2);
}
function _createSuper$y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$y(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$y(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$y(this, result);
  };
}
function _possibleConstructorReturn$y(self2, call2) {
  if (call2 && (_typeof$A(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$y(self2);
}
function _assertThisInitialized$y(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$y() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$y(o) {
  _getPrototypeOf$y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$y(o);
}
var privatePool$c = /* @__PURE__ */ new WeakMap();
var InputUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$y(InputUI2, _BaseUI);
  var _super = _createSuper$y(InputUI2);
  function InputUI2(hotInstance, options) {
    var _this;
    _classCallCheck$Q(this, InputUI2);
    _this = _super.call(this, hotInstance, extend(InputUI2.DEFAULTS, options));
    privatePool$c.set(_assertThisInitialized$y(_this), {});
    _this.registerHooks();
    return _this;
  }
  _createClass$Q(InputUI2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.addLocalHook("click", function() {
        return _this2.onClick();
      });
      this.addLocalHook("keyup", function(event2) {
        return _this2.onKeyup(event2);
      });
    }
    /**
     * Build DOM structure.
     */
  }, {
    key: "build",
    value: function build() {
      _get$s(_getPrototypeOf$y(InputUI2.prototype), "build", this).call(this);
      var priv = privatePool$c.get(this);
      var icon = this.hot.rootDocument.createElement("div");
      priv.input = this._element.firstChild;
      addClass(this._element, "htUIInput");
      addClass(icon, "htUIInputIcon");
      this._element.appendChild(icon);
      this.update();
    }
    /**
     * Update element.
     */
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      var input = privatePool$c.get(this).input;
      input.type = this.options.type;
      input.placeholder = this.translateIfPossible(this.options.placeholder);
      input.value = this.translateIfPossible(this.options.value);
    }
    /**
     * Focus element.
     */
  }, {
    key: "focus",
    value: function focus() {
      if (this.isBuilt()) {
        privatePool$c.get(this).input.focus();
      }
    }
    /**
     * OnClick listener.
     */
  }, {
    key: "onClick",
    value: function onClick2() {
    }
    /**
     * OnKeyup listener.
     *
     * @param {Event} event The mouse event object.
     */
  }, {
    key: "onKeyup",
    value: function onKeyup(event2) {
      this.options.value = event2.target.value;
    }
  }], [{
    key: "DEFAULTS",
    get: function get2() {
      return clone$1({
        placeholder: "",
        type: "text",
        tagName: "input"
      });
    }
  }]);
  return InputUI2;
}(BaseUI$7);
const InputUI$1 = InputUI;
function _typeof$z(obj) {
  "@babel/helpers - typeof";
  return _typeof$z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$z(obj);
}
function _classCallCheck$P(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$P(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$P(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$P(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$P(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$r() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$r = Reflect.get.bind();
  } else {
    _get$r = function _get2(target, property, receiver) {
      var base = _superPropBase$r(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$r.apply(this, arguments);
}
function _superPropBase$r(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$x(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$x(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$x(subClass, superClass);
}
function _setPrototypeOf$x(o, p2) {
  _setPrototypeOf$x = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$x(o, p2);
}
function _createSuper$x(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$x();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$x(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$x(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$x(this, result);
  };
}
function _possibleConstructorReturn$x(self2, call2) {
  if (call2 && (_typeof$z(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$x(self2);
}
function _assertThisInitialized$x(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$x() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$x(o) {
  _getPrototypeOf$x = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$x(o);
}
var privatePool$b = /* @__PURE__ */ new WeakMap();
var SelectUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$x(SelectUI2, _BaseUI);
  var _super = _createSuper$x(SelectUI2);
  function SelectUI2(hotInstance, options) {
    var _this;
    _classCallCheck$P(this, SelectUI2);
    _this = _super.call(this, hotInstance, extend(SelectUI2.DEFAULTS, options));
    privatePool$b.set(_assertThisInitialized$x(_this), {});
    _this.menu = null;
    _this.items = [];
    _this.registerHooks();
    return _this;
  }
  _createClass$P(SelectUI2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.addLocalHook("click", function() {
        return _this2.onClick();
      });
    }
    /**
     * Set options which can be selected in the list.
     *
     * @param {Array} items Array of objects with required keys `key` and `name`.
     */
  }, {
    key: "setItems",
    value: function setItems(items) {
      this.items = this.translateNames(items);
      if (this.menu) {
        this.menu.setMenuItems(this.items);
      }
    }
    /**
     * Translate names of menu items.
     *
     * @param {Array} items Array of objects with required keys `key` and `name`.
     * @returns {Array} Items with translated `name` keys.
     */
  }, {
    key: "translateNames",
    value: function translateNames(items) {
      var _this3 = this;
      arrayEach(items, function(item) {
        item.name = _this3.translateIfPossible(item.name);
      });
      return items;
    }
    /**
     * Build DOM structure.
     */
  }, {
    key: "build",
    value: function build() {
      var _this4 = this;
      _get$r(_getPrototypeOf$x(SelectUI2.prototype), "build", this).call(this);
      this.menu = new Menu$1(this.hot, {
        className: "htSelectUI htFiltersConditionsMenu",
        keepInViewport: false,
        standalone: true,
        container: this.options.menuContainer
      });
      this.menu.setMenuItems(this.items);
      var caption = new BaseUI$7(this.hot, {
        className: "htUISelectCaption"
      });
      var dropdown = new BaseUI$7(this.hot, {
        className: "htUISelectDropdown"
      });
      var priv = privatePool$b.get(this);
      priv.caption = caption;
      priv.captionElement = caption.element;
      priv.dropdown = dropdown;
      arrayEach([caption, dropdown], function(element) {
        return _this4._element.appendChild(element.element);
      });
      this.menu.addLocalHook("select", function(command) {
        return _this4.onMenuSelect(command);
      });
      this.menu.addLocalHook("afterClose", function() {
        return _this4.onMenuClosed();
      });
      this.update();
    }
    /**
     * Update DOM structure.
     */
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      var conditionName;
      if (this.options.value) {
        conditionName = this.options.value.name;
      } else {
        conditionName = this.menu.hot.getTranslatedPhrase(FILTERS_CONDITIONS_NONE);
      }
      privatePool$b.get(this).captionElement.textContent = conditionName;
      _get$r(_getPrototypeOf$x(SelectUI2.prototype), "update", this).call(this);
    }
    /**
     * Open select dropdown menu with available options.
     */
  }, {
    key: "openOptions",
    value: function openOptions() {
      var rect = this.element.getBoundingClientRect();
      if (this.menu) {
        this.menu.open();
        this.menu.setPosition({
          left: this.hot.isLtr() ? rect.left - 5 : rect.left - 31,
          top: rect.top - 1,
          width: rect.width,
          height: rect.height
        });
      }
    }
    /**
     * Close select dropdown menu.
     */
  }, {
    key: "closeOptions",
    value: function closeOptions() {
      if (this.menu) {
        this.menu.close();
      }
    }
    /**
     * On menu selected listener.
     *
     * @private
     * @param {object} command Selected item.
     */
  }, {
    key: "onMenuSelect",
    value: function onMenuSelect(command) {
      if (command.name !== KEY$c) {
        this.options.value = command;
        this.update();
        this.runLocalHooks("select", this.options.value);
      }
    }
    /**
     * On menu closed listener.
     *
     * @private
     */
  }, {
    key: "onMenuClosed",
    value: function onMenuClosed() {
      this.runLocalHooks("afterClose");
    }
    /**
     * On element click listener.
     *
     * @private
     */
  }, {
    key: "onClick",
    value: function onClick2() {
      this.openOptions();
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.menu) {
        this.menu.destroy();
        this.menu = null;
      }
      var _privatePool$get = privatePool$b.get(this), caption = _privatePool$get.caption, dropdown = _privatePool$get.dropdown;
      if (caption) {
        caption.destroy();
      }
      if (dropdown) {
        dropdown.destroy();
      }
      _get$r(_getPrototypeOf$x(SelectUI2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "DEFAULTS",
    get: function get2() {
      return clone$1({
        className: "htUISelect",
        wrapIt: false
      });
    }
  }]);
  return SelectUI2;
}(BaseUI$7);
const SelectUI$1 = SelectUI;
function _typeof$y(obj) {
  "@babel/helpers - typeof";
  return _typeof$y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$y(obj);
}
function _classCallCheck$O(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$O(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$O(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$O(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$O(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$q() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$q = Reflect.get.bind();
  } else {
    _get$q = function _get2(target, property, receiver) {
      var base = _superPropBase$q(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$q.apply(this, arguments);
}
function _superPropBase$q(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$w(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$w(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$w(subClass, superClass);
}
function _setPrototypeOf$w(o, p2) {
  _setPrototypeOf$w = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$w(o, p2);
}
function _createSuper$w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$w();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$w(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$w(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$w(this, result);
  };
}
function _possibleConstructorReturn$w(self2, call2) {
  if (call2 && (_typeof$y(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$w(self2);
}
function _assertThisInitialized$w(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$w(o) {
  _getPrototypeOf$w = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$w(o);
}
var ConditionComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$w(ConditionComponent2, _BaseComponent);
  var _super = _createSuper$w(ConditionComponent2);
  function ConditionComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$O(this, ConditionComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: false
    });
    _this.name = options.name;
    _this.addSeparator = options.addSeparator;
    _this.elements.push(new SelectUI$1(_this.hot, {
      menuContainer: options.menuContainer
    }));
    _this.elements.push(new InputUI$1(_this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_VALUE
    }));
    _this.elements.push(new InputUI$1(_this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE
    }));
    _this.registerHooks();
    return _this;
  }
  _createClass$O(ConditionComponent2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.getSelectElement().addLocalHook("select", function(command) {
        return _this2.onConditionSelect(command);
      });
      this.getSelectElement().addLocalHook("afterClose", function() {
        return _this2.onSelectUIClosed();
      });
      arrayEach(this.getInputElements(), function(input) {
        input.addLocalHook("keydown", function(event2) {
          return _this2.onInputKeyDown(event2);
        });
      });
    }
    /**
     * Set state of the component.
     *
     * @param {object} value State to restore.
     */
  }, {
    key: "setState",
    value: function setState(value) {
      var _this3 = this;
      this.reset();
      if (!value) {
        return;
      }
      var copyOfCommand = clone$1(value.command);
      if (copyOfCommand.name.startsWith(FILTERS_CONDITIONS_NAMESPACE)) {
        copyOfCommand.name = this.hot.getTranslatedPhrase(copyOfCommand.name);
      }
      this.getSelectElement().setValue(copyOfCommand);
      arrayEach(value.args, function(arg, index2) {
        if (index2 > copyOfCommand.inputsCount - 1) {
          return false;
        }
        var element = _this3.getInputElement(index2);
        element.setValue(arg);
        element[copyOfCommand.inputsCount > index2 ? "show" : "hide"]();
        if (!index2) {
          setTimeout(function() {
            return element.focus();
          }, 10);
        }
      });
    }
    /**
     * Export state of the component (get selected filter and filter arguments).
     *
     * @returns {object} Returns object where `command` key keeps used condition filter and `args` key its arguments.
     */
  }, {
    key: "getState",
    value: function getState() {
      var command = this.getSelectElement().getValue() || getConditionDescriptor(CONDITION_NAME$k);
      var args = [];
      arrayEach(this.getInputElements(), function(element, index2) {
        if (command.inputsCount > index2) {
          args.push(element.getValue());
        }
      });
      return {
        command,
        args
      };
    }
    /**
     * Update state of component.
     *
     * @param {object} condition The condition object.
     * @param {object} condition.command The command object with condition name as `key` property.
     * @param {Array} condition.args An array of values to compare.
     * @param {number} column Physical column index.
     */
  }, {
    key: "updateState",
    value: function updateState(condition2, column) {
      var command = condition2 ? getConditionDescriptor(condition2.name) : getConditionDescriptor(CONDITION_NAME$k);
      this.state.setValueAtIndex(column, {
        command,
        args: condition2 ? condition2.args : []
      });
      if (!condition2) {
        arrayEach(this.getInputElements(), function(element) {
          return element.setValue(null);
        });
      }
    }
    /**
     * Get select element.
     *
     * @returns {SelectUI}
     */
  }, {
    key: "getSelectElement",
    value: function getSelectElement() {
      return this.elements.filter(function(element) {
        return element instanceof SelectUI$1;
      })[0];
    }
    /**
     * Get input element.
     *
     * @param {number} index Index an array of elements.
     * @returns {InputUI}
     */
  }, {
    key: "getInputElement",
    value: function getInputElement() {
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return this.getInputElements()[index2];
    }
    /**
     * Get input elements.
     *
     * @returns {Array}
     */
  }, {
    key: "getInputElements",
    value: function getInputElements() {
      return this.elements.filter(function(element) {
        return element instanceof InputUI$1;
      });
    }
    /**
     * Get menu object descriptor.
     *
     * @returns {object}
     */
  }, {
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this4 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this4.isHidden();
        },
        renderer: function renderer(hot, wrapper2, row, col, prop, value) {
          addClass(wrapper2.parentNode, "htFiltersMenuCondition");
          if (_this4.addSeparator) {
            addClass(wrapper2.parentNode, "border");
          }
          var label = _this4.hot.rootDocument.createElement("div");
          addClass(label, "htFiltersMenuLabel");
          label.textContent = value;
          wrapper2.appendChild(label);
          if (!wrapper2.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this4.elements, function(ui) {
              return wrapper2.appendChild(ui.element);
            });
          }
          return wrapper2;
        }
      };
    }
    /**
     * Reset elements to their initial state.
     */
  }, {
    key: "reset",
    value: function reset() {
      var selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
      var items = [getConditionDescriptor(CONDITION_NAME$k)];
      if (selectedColumn !== null) {
        var visualIndex = selectedColumn.visualIndex;
        items = getOptionsList(this.hot.getDataType(0, visualIndex, this.hot.countRows(), visualIndex));
      }
      arrayEach(this.getInputElements(), function(element) {
        return element.hide();
      });
      this.getSelectElement().setItems(items);
      _get$q(_getPrototypeOf$w(ConditionComponent2.prototype), "reset", this).call(this);
      this.getSelectElement().setValue(items[0]);
    }
    /**
     * On condition select listener.
     *
     * @private
     * @param {object} command Menu item object (command).
     */
  }, {
    key: "onConditionSelect",
    value: function onConditionSelect(command) {
      arrayEach(this.getInputElements(), function(element, index2) {
        element[command.inputsCount > index2 ? "show" : "hide"]();
        if (index2 === 0) {
          setTimeout(function() {
            return element.focus();
          }, 10);
        }
      });
      this.runLocalHooks("change", command);
    }
    /**
     * On component SelectUI closed listener.
     *
     * @private
     */
  }, {
    key: "onSelectUIClosed",
    value: function onSelectUIClosed() {
      this.runLocalHooks("afterClose");
    }
    /**
     * Key down listener.
     *
     * @private
     * @param {Event} event The DOM event object.
     */
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event2) {
      if (isKey(event2.keyCode, "ENTER")) {
        this.runLocalHooks("accept");
        stopImmediatePropagation(event2);
      } else if (isKey(event2.keyCode, "ESCAPE")) {
        this.runLocalHooks("cancel");
        stopImmediatePropagation(event2);
      }
    }
  }]);
  return ConditionComponent2;
}(BaseComponent$1);
const ConditionComponent$1 = ConditionComponent;
function _typeof$x(obj) {
  "@babel/helpers - typeof";
  return _typeof$x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$x(obj);
}
function _classCallCheck$N(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$N(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$N(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$N(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$N(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$p() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$p = Reflect.get.bind();
  } else {
    _get$p = function _get2(target, property, receiver) {
      var base = _superPropBase$p(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$p.apply(this, arguments);
}
function _superPropBase$p(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$v(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$v(subClass, superClass);
}
function _setPrototypeOf$v(o, p2) {
  _setPrototypeOf$v = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$v(o, p2);
}
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$v(this, result);
  };
}
function _possibleConstructorReturn$v(self2, call2) {
  if (call2 && (_typeof$x(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$v(self2);
}
function _assertThisInitialized$v(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$v(o) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$v(o);
}
var privatePool$a = /* @__PURE__ */ new WeakMap();
var RadioInputUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$v(RadioInputUI2, _BaseUI);
  var _super = _createSuper$v(RadioInputUI2);
  function RadioInputUI2(hotInstance, options) {
    var _this;
    _classCallCheck$N(this, RadioInputUI2);
    _this = _super.call(this, hotInstance, extend(RadioInputUI2.DEFAULTS, options));
    privatePool$a.set(_assertThisInitialized$v(_this), {});
    return _this;
  }
  _createClass$N(RadioInputUI2, [{
    key: "build",
    value: function build() {
      _get$p(_getPrototypeOf$v(RadioInputUI2.prototype), "build", this).call(this);
      var priv = privatePool$a.get(this);
      priv.input = this._element.firstChild;
      var label = this.hot.rootDocument.createElement("label");
      label.textContent = this.translateIfPossible(this.options.label.textContent);
      label.htmlFor = this.translateIfPossible(this.options.label.htmlFor);
      priv.label = label;
      this._element.appendChild(label);
      this.update();
    }
    /**
     * Update element.
     */
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      var priv = privatePool$a.get(this);
      priv.input.checked = this.options.checked;
      priv.label.textContent = this.translateIfPossible(this.options.label.textContent);
    }
    /**
     * Check if radio button is checked.
     *
     * @returns {boolean}
     */
  }, {
    key: "isChecked",
    value: function isChecked() {
      return this.options.checked;
    }
    /**
     * Set input checked attribute.
     *
     * @param {boolean} value Set the component state.
     */
  }, {
    key: "setChecked",
    value: function setChecked() {
      var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.options.checked = value;
      this.update();
    }
    /**
     * Focus element.
     */
  }, {
    key: "focus",
    value: function focus() {
      if (this.isBuilt()) {
        privatePool$a.get(this).input.focus();
      }
    }
  }], [{
    key: "DEFAULTS",
    get: function get2() {
      return clone$1({
        type: "radio",
        tagName: "input",
        className: "htUIRadio",
        label: {}
      });
    }
  }]);
  return RadioInputUI2;
}(BaseUI$7);
const RadioInputUI$1 = RadioInputUI;
function _typeof$w(obj) {
  "@babel/helpers - typeof";
  return _typeof$w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$w(obj);
}
var _templateObject$9;
function _taggedTemplateLiteral$9(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$M(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$M(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$M(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$M(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$M(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$u(subClass, superClass);
}
function _setPrototypeOf$u(o, p2) {
  _setPrototypeOf$u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$u(o, p2);
}
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$u(this, result);
  };
}
function _possibleConstructorReturn$u(self2, call2) {
  if (call2 && (_typeof$w(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$u(self2);
}
function _assertThisInitialized$u(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$u(o) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$u(o);
}
var SELECTED_AT_START_ELEMENT_INDEX = 0;
var OperatorsComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$u(OperatorsComponent2, _BaseComponent);
  var _super = _createSuper$u(OperatorsComponent2);
  function OperatorsComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$M(this, OperatorsComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: false
    });
    _this.name = options.name;
    _this.buildOperatorsElement();
    return _this;
  }
  _createClass$M(OperatorsComponent2, [{
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this2 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this2.isHidden();
        },
        renderer: function renderer(hot, wrapper2) {
          addClass(wrapper2.parentNode, "htFiltersMenuOperators");
          if (!wrapper2.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this2.elements, function(ui) {
              return wrapper2.appendChild(ui.element);
            });
          }
          return wrapper2;
        }
      };
    }
    /**
     * Add RadioInputUI elements to component.
     *
     * @private
     */
  }, {
    key: "buildOperatorsElement",
    value: function buildOperatorsElement() {
      var _this3 = this;
      var operationKeys = [OPERATION_ID$2, OPERATION_ID$1];
      arrayEach(operationKeys, function(operation) {
        var radioInput = new RadioInputUI$1(_this3.hot, {
          name: "operator",
          label: {
            htmlFor: operation,
            textContent: getOperationName(operation)
          },
          value: operation,
          checked: operation === operationKeys[SELECTED_AT_START_ELEMENT_INDEX],
          id: operation
        });
        radioInput.addLocalHook("change", function(event2) {
          return _this3.onRadioInputChange(event2);
        });
        _this3.elements.push(radioInput);
      });
    }
    /**
     * Set state of operators component to check radio input at specific `index`.
     *
     * @param {number} searchedIndex Index of radio input to check.
     */
  }, {
    key: "setChecked",
    value: function setChecked(searchedIndex) {
      if (this.elements.length < searchedIndex) {
        throw Error(toSingleLine(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteral$9(["Radio button with index ", " doesn't exist."])), searchedIndex));
      }
      arrayEach(this.elements, function(element, index2) {
        element.setChecked(index2 === searchedIndex);
      });
    }
    /**
     * Get `id` of active operator.
     *
     * @returns {string}
     */
  }, {
    key: "getActiveOperationId",
    value: function getActiveOperationId() {
      var operationElement = this.elements.find(function(element) {
        return element instanceof RadioInputUI$1 && element.isChecked();
      });
      if (operationElement) {
        return operationElement.getValue();
      }
      return OPERATION_ID$2;
    }
    /**
     * Export state of the component (get selected operator).
     *
     * @returns {string} Returns `id` of selected operator.
     */
  }, {
    key: "getState",
    value: function getState() {
      return this.getActiveOperationId();
    }
    /**
     * Set state of the component.
     *
     * @param {object} value State to restore.
     */
  }, {
    key: "setState",
    value: function setState(value) {
      this.reset();
      if (value && this.getActiveOperationId() !== value) {
        arrayEach(this.elements, function(element) {
          element.setChecked(element.getValue() === value);
        });
      }
    }
    /**
     * Update state of component.
     *
     * @param {string} [operationId='conjunction'] Id of selected operation.
     * @param {number} column Physical column index.
     */
  }, {
    key: "updateState",
    value: function updateState() {
      var operationId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OPERATION_ID$2;
      var column = arguments.length > 1 ? arguments[1] : void 0;
      var selectedOperationId = operationId;
      if (selectedOperationId === OPERATION_ID) {
        selectedOperationId = OPERATION_ID$1;
      }
      this.state.setValueAtIndex(column, selectedOperationId);
    }
    /**
     * Reset elements to their initial state.
     */
  }, {
    key: "reset",
    value: function reset() {
      this.setChecked(SELECTED_AT_START_ELEMENT_INDEX);
    }
    /**
     * OnChange listener.
     *
     * @private
     * @param {Event} event The DOM event object.
     */
  }, {
    key: "onRadioInputChange",
    value: function onRadioInputChange(event2) {
      this.setState(event2.target.value);
    }
  }]);
  return OperatorsComponent2;
}(BaseComponent$1);
const OperatorsComponent$1 = OperatorsComponent;
var uncurryThis = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$e;
var toString3 = toString$j;
var quot = /"/g;
var replace = uncurryThis("".replace);
var createHtml = function(string, tag, attribute, value) {
  var S = toString3(requireObjectCoercible(string));
  var p1 = "<" + tag;
  if (attribute !== "")
    p1 += " " + attribute + '="' + replace(toString3(value), quot, "&quot;") + '"';
  return p1 + ">" + S + "</" + tag + ">";
};
var fails = fails$G;
var stringHtmlForced = function(METHOD_NAME) {
  return fails(function() {
    var test2 = ""[METHOD_NAME]('"');
    return test2 !== test2.toLowerCase() || test2.split('"').length > 3;
  });
};
var $ = _export;
var createHTML = createHtml;
var forcedStringHTMLMethod = stringHtmlForced;
$({ target: "String", proto: true, forced: forcedStringHTMLMethod("link") }, {
  link: function link(url) {
    return createHTML(this, "a", "href", url);
  }
});
function _typeof$v(obj) {
  "@babel/helpers - typeof";
  return _typeof$v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$v(obj);
}
function _classCallCheck$L(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$L(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$L(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$L(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$L(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$o() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$o = Reflect.get.bind();
  } else {
    _get$o = function _get2(target, property, receiver) {
      var base = _superPropBase$o(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$o.apply(this, arguments);
}
function _superPropBase$o(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$t(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$t(subClass, superClass);
}
function _setPrototypeOf$t(o, p2) {
  _setPrototypeOf$t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$t(o, p2);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$t(this, result);
  };
}
function _possibleConstructorReturn$t(self2, call2) {
  if (call2 && (_typeof$v(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$t(self2);
}
function _assertThisInitialized$t(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$t(o) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$t(o);
}
var privatePool$9 = /* @__PURE__ */ new WeakMap();
var LinkUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$t(LinkUI2, _BaseUI);
  var _super = _createSuper$t(LinkUI2);
  function LinkUI2(hotInstance, options) {
    var _this;
    _classCallCheck$L(this, LinkUI2);
    _this = _super.call(this, hotInstance, extend(LinkUI2.DEFAULTS, options));
    privatePool$9.set(_assertThisInitialized$t(_this), {});
    return _this;
  }
  _createClass$L(LinkUI2, [{
    key: "build",
    value: function build() {
      _get$o(_getPrototypeOf$t(LinkUI2.prototype), "build", this).call(this);
      var priv = privatePool$9.get(this);
      priv.link = this._element.firstChild;
    }
    /**
     * Update element.
     */
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      privatePool$9.get(this).link.textContent = this.translateIfPossible(this.options.textContent);
    }
  }], [{
    key: "DEFAULTS",
    get: function get2() {
      return clone$1({
        href: "#",
        tagName: "a"
      });
    }
  }]);
  return LinkUI2;
}(BaseUI$7);
const LinkUI$1 = LinkUI;
function _typeof$u(obj) {
  "@babel/helpers - typeof";
  return _typeof$u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$u(obj);
}
function _toConsumableArray$d(arr) {
  return _arrayWithoutHoles$d(arr) || _iterableToArray$e(arr) || _unsupportedIterableToArray$n(arr) || _nonIterableSpread$d();
}
function _nonIterableSpread$d() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$n(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$n(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$n(o, minLen);
}
function _iterableToArray$e(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$d(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$n(arr);
}
function _arrayLikeToArray$n(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$K(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$K(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$K(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$K(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$K(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$n() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$n = Reflect.get.bind();
  } else {
    _get$n = function _get2(target, property, receiver) {
      var base = _superPropBase$n(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$n.apply(this, arguments);
}
function _superPropBase$n(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$s(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$s(subClass, superClass);
}
function _setPrototypeOf$s(o, p2) {
  _setPrototypeOf$s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$s(o, p2);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$s(this, result);
  };
}
function _possibleConstructorReturn$s(self2, call2) {
  if (call2 && (_typeof$u(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$s(self2);
}
function _assertThisInitialized$s(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$s(o) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$s(o);
}
var privatePool$8 = /* @__PURE__ */ new WeakMap();
var SHORTCUTS_GROUP$2 = "multipleSelect.itemBox";
var MultipleSelectUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$s(MultipleSelectUI2, _BaseUI);
  var _super = _createSuper$s(MultipleSelectUI2);
  function MultipleSelectUI2(hotInstance, options) {
    var _this;
    _classCallCheck$K(this, MultipleSelectUI2);
    _this = _super.call(this, hotInstance, extend(MultipleSelectUI2.DEFAULTS, options));
    privatePool$8.set(_assertThisInitialized$s(_this), {});
    _this.searchInput = new InputUI$1(_this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
      className: "htUIMultipleSelectSearch"
    });
    _this.selectAllUI = new LinkUI$1(_this.hot, {
      textContent: FILTERS_BUTTONS_SELECT_ALL,
      className: "htUISelectAll"
    });
    _this.clearAllUI = new LinkUI$1(_this.hot, {
      textContent: FILTERS_BUTTONS_CLEAR,
      className: "htUIClearAll"
    });
    _this.items = [];
    _this.itemsBox = null;
    _this.registerHooks();
    return _this;
  }
  _createClass$K(MultipleSelectUI2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.searchInput.addLocalHook("keydown", function(event2) {
        return _this2.onInputKeyDown(event2);
      });
      this.searchInput.addLocalHook("input", function(event2) {
        return _this2.onInput(event2);
      });
      this.selectAllUI.addLocalHook("click", function(event2) {
        return _this2.onSelectAllClick(event2);
      });
      this.clearAllUI.addLocalHook("click", function(event2) {
        return _this2.onClearAllClick(event2);
      });
    }
    /**
     * Set available options.
     *
     * @param {Array} items Array of objects with `checked` and `label` property.
     */
  }, {
    key: "setItems",
    value: function setItems(items) {
      this.items = items;
      if (this.itemsBox) {
        this.itemsBox.loadData(this.items);
      }
    }
    /**
     * Set a locale for the component.
     *
     * @param {string} locale Locale used for filter actions performed on data, ie. `en-US`.
     */
  }, {
    key: "setLocale",
    value: function setLocale(locale) {
      this.locale = locale;
    }
    /**
     * Get a locale for the component.
     *
     * @returns {string}
     */
  }, {
    key: "getLocale",
    value: function getLocale() {
      return this.locale;
    }
    /**
     * Get all available options.
     *
     * @returns {Array}
     */
  }, {
    key: "getItems",
    value: function getItems() {
      return _toConsumableArray$d(this.items);
    }
    /**
     * Get element value.
     *
     * @returns {Array} Array of selected values.
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return itemsToValue(this.items);
    }
    /**
     * Check if all values listed in element are selected.
     *
     * @returns {boolean}
     */
  }, {
    key: "isSelectedAllValues",
    value: function isSelectedAllValues() {
      return this.items.length === this.getValue().length;
    }
    /**
     * Build DOM structure.
     */
  }, {
    key: "build",
    value: function build() {
      var _this3 = this;
      _get$n(_getPrototypeOf$s(MultipleSelectUI2.prototype), "build", this).call(this);
      var rootDocument = this.hot.rootDocument;
      var itemsBoxWrapper = rootDocument.createElement("div");
      var selectionControl = new BaseUI$7(this.hot, {
        className: "htUISelectionControls",
        children: [this.selectAllUI, this.clearAllUI]
      });
      this._element.appendChild(this.searchInput.element);
      this._element.appendChild(selectionControl.element);
      this._element.appendChild(itemsBoxWrapper);
      var hotInitializer = function hotInitializer2(wrapper2) {
        if (!_this3._element) {
          return;
        }
        if (_this3.itemsBox) {
          _this3.itemsBox.destroy();
        }
        addClass(wrapper2, "htUIMultipleSelectHot");
        _this3.itemsBox = new _this3.hot.constructor(wrapper2, {
          data: _this3.items,
          columns: [{
            data: "checked",
            type: "checkbox",
            label: {
              property: "visualValue",
              position: "after"
            }
          }],
          beforeRenderer: function beforeRenderer(TD, row, col, prop, value, cellProperties) {
            TD.title = cellProperties.instance.getDataAtRowProp(row, cellProperties.label.property);
          },
          maxCols: 1,
          autoWrapCol: true,
          height: 110,
          // Workaround for #151.
          colWidths: function colWidths() {
            return _this3.itemsBox.container.scrollWidth - getScrollbarWidth(rootDocument);
          },
          copyPaste: false,
          disableVisualSelection: "area",
          fillHandle: false,
          fragmentSelection: "cell",
          tabMoves: {
            row: 1,
            col: 0
          },
          layoutDirection: _this3.hot.isRtl() ? "rtl" : "ltr"
        });
        _this3.itemsBox.init();
        var shortcutManager = _this3.itemsBox.getShortcutManager();
        var gridContext = shortcutManager.getContext("grid");
        gridContext.addShortcut({
          // TODO: Is this shortcut really needed? We have one test for that case, but focus is performed programmatically.
          keys: [["Escape"]],
          callback: function callback(event2) {
            _this3.runLocalHooks("keydown", event2, _this3);
          },
          group: SHORTCUTS_GROUP$2
        });
      };
      hotInitializer(itemsBoxWrapper);
      setTimeout(function() {
        return hotInitializer(itemsBoxWrapper);
      }, 100);
    }
    /**
     * Reset DOM structure.
     */
  }, {
    key: "reset",
    value: function reset() {
      this.searchInput.reset();
      this.selectAllUI.reset();
      this.clearAllUI.reset();
    }
    /**
     * Update DOM structure.
     */
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      this.itemsBox.loadData(valueToItems(this.items, this.options.value));
      _get$n(_getPrototypeOf$s(MultipleSelectUI2.prototype), "update", this).call(this);
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.itemsBox) {
        this.itemsBox.destroy();
      }
      this.searchInput.destroy();
      this.clearAllUI.destroy();
      this.selectAllUI.destroy();
      this.searchInput = null;
      this.clearAllUI = null;
      this.selectAllUI = null;
      this.itemsBox = null;
      this.items = null;
      _get$n(_getPrototypeOf$s(MultipleSelectUI2.prototype), "destroy", this).call(this);
    }
    /**
     * 'input' event listener for input element.
     *
     * @private
     * @param {Event} event DOM event.
     */
  }, {
    key: "onInput",
    value: function onInput(event2) {
      var _this4 = this;
      var value = event2.target.value.toLocaleLowerCase(this.getLocale());
      var filteredItems;
      if (value === "") {
        filteredItems = _toConsumableArray$d(this.items);
      } else {
        filteredItems = arrayFilter(this.items, function(item) {
          return "".concat(item.value).toLocaleLowerCase(_this4.getLocale()).indexOf(value) >= 0;
        });
      }
      this.itemsBox.loadData(filteredItems);
    }
    /**
     * 'keydown' event listener for input element.
     *
     * @private
     * @param {Event} event DOM event.
     */
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event2) {
      this.runLocalHooks("keydown", event2, this);
      var isKeyCode = partial(isKey, event2.keyCode);
      if (isKeyCode("ARROW_DOWN|TAB") && !this.itemsBox.isListening()) {
        stopImmediatePropagation(event2);
        this.itemsBox.listen();
        this.itemsBox.selectCell(0, 0);
      }
    }
    /**
     * On click listener for "Select all" link.
     *
     * @private
     * @param {DOMEvent} event The mouse event object.
     */
  }, {
    key: "onSelectAllClick",
    value: function onSelectAllClick(event2) {
      var changes = [];
      event2.preventDefault();
      arrayEach(this.itemsBox.getSourceData(), function(row, rowIndex) {
        row.checked = true;
        changes.push(dataRowToChangesArray(row, rowIndex)[0]);
      });
      this.itemsBox.setSourceDataAtCell(changes);
    }
    /**
     * On click listener for "Clear" link.
     *
     * @private
     * @param {DOMEvent} event The mouse event object.
     */
  }, {
    key: "onClearAllClick",
    value: function onClearAllClick(event2) {
      var changes = [];
      event2.preventDefault();
      arrayEach(this.itemsBox.getSourceData(), function(row, rowIndex) {
        row.checked = false;
        changes.push(dataRowToChangesArray(row, rowIndex)[0]);
      });
      this.itemsBox.setSourceDataAtCell(changes);
    }
  }], [{
    key: "DEFAULTS",
    get: function get2() {
      return clone$1({
        className: "htUIMultipleSelect",
        value: []
      });
    }
  }]);
  return MultipleSelectUI2;
}(BaseUI$7);
const MultipleSelectUI$1 = MultipleSelectUI;
function valueToItems(availableItems, selectedValue) {
  var arrayAssertion = createArrayAssertion(selectedValue);
  return arrayMap(availableItems, function(item) {
    item.checked = arrayAssertion(item.value);
    return item;
  });
}
function itemsToValue(availableItems) {
  var items = [];
  arrayEach(availableItems, function(item) {
    if (item.checked) {
      items.push(item.value);
    }
  });
  return items;
}
function _typeof$t(obj) {
  "@babel/helpers - typeof";
  return _typeof$t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$t(obj);
}
function _slicedToArray$b(arr, i) {
  return _arrayWithHoles$c(arr) || _iterableToArrayLimit$b(arr, i) || _unsupportedIterableToArray$m(arr, i) || _nonIterableRest$c();
}
function _nonIterableRest$c() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$m(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$m(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$m(o, minLen);
}
function _arrayLikeToArray$m(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$b(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$c(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$J(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$J(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$J(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$J(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$J(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$m() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$m = Reflect.get.bind();
  } else {
    _get$m = function _get2(target, property, receiver) {
      var base = _superPropBase$m(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$m.apply(this, arguments);
}
function _superPropBase$m(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$r(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$r(subClass, superClass);
}
function _setPrototypeOf$r(o, p2) {
  _setPrototypeOf$r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$r(o, p2);
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$r(this, result);
  };
}
function _possibleConstructorReturn$r(self2, call2) {
  if (call2 && (_typeof$t(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$r(self2);
}
function _assertThisInitialized$r(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$r(o) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$r(o);
}
var ValueComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$r(ValueComponent2, _BaseComponent);
  var _super = _createSuper$r(ValueComponent2);
  function ValueComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$J(this, ValueComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: false
    });
    _this.name = options.name;
    _this.elements.push(new MultipleSelectUI$1(_this.hot));
    _this.registerHooks();
    return _this;
  }
  _createClass$J(ValueComponent2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.getMultipleSelectElement().addLocalHook("keydown", function(event2) {
        return _this2.onInputKeyDown(event2);
      });
    }
    /**
     * Set state of the component.
     *
     * @param {object} value The component value.
     */
  }, {
    key: "setState",
    value: function setState(value) {
      this.reset();
      if (value && value.command.key === CONDITION_NAME) {
        var select = this.getMultipleSelectElement();
        select.setItems(value.itemsSnapshot);
        select.setValue(value.args[0]);
        select.setLocale(value.locale);
      }
    }
    /**
     * Export state of the component (get selected filter and filter arguments).
     *
     * @returns {object} Returns object where `command` key keeps used condition filter and `args` key its arguments.
     */
  }, {
    key: "getState",
    value: function getState() {
      var select = this.getMultipleSelectElement();
      var availableItems = select.getItems();
      return {
        command: {
          key: select.isSelectedAllValues() || !availableItems.length ? CONDITION_NAME$k : CONDITION_NAME
        },
        args: [select.getValue()],
        itemsSnapshot: availableItems
      };
    }
    /**
     * Update state of component.
     *
     * @param {object} stateInfo Information about state containing stack of edited column,
     * stack of dependent conditions, data factory and optional condition arguments change. It's described by object containing keys:
     * `editedConditionStack`, `dependentConditionStacks`, `visibleDataFactory` and `conditionArgsChange`.
     */
  }, {
    key: "updateState",
    value: function updateState(stateInfo) {
      var _this3 = this;
      var updateColumnState = function updateColumnState2(physicalColumn, conditions2, conditionArgsChange, filteredRowsFactory, conditionsStack) {
        var _arrayFilter = arrayFilter(conditions2, function(condition2) {
          return condition2.name === CONDITION_NAME;
        }), _arrayFilter2 = _slicedToArray$b(_arrayFilter, 1), firstByValueCondition = _arrayFilter2[0];
        var state = {};
        var defaultBlankCellValue = _this3.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
        if (firstByValueCondition) {
          var rowValues = unifyColumnValues(arrayMap(filteredRowsFactory(physicalColumn, conditionsStack), function(row) {
            return row.value;
          }));
          if (conditionArgsChange) {
            firstByValueCondition.args[0] = conditionArgsChange;
          }
          var selectedValues = [];
          var itemsSnapshot = intersectValues(rowValues, firstByValueCondition.args[0], defaultBlankCellValue, function(item) {
            if (item.checked) {
              selectedValues.push(item.value);
            }
          });
          var column = stateInfo.editedConditionStack.column;
          state.locale = _this3.hot.getCellMeta(0, column).locale;
          state.args = [selectedValues];
          state.command = getConditionDescriptor(CONDITION_NAME);
          state.itemsSnapshot = itemsSnapshot;
        } else {
          state.args = [];
          state.command = getConditionDescriptor(CONDITION_NAME$k);
        }
        _this3.state.setValueAtIndex(physicalColumn, state);
      };
      updateColumnState(stateInfo.editedConditionStack.column, stateInfo.editedConditionStack.conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory);
      if (stateInfo.dependentConditionStacks.length) {
        updateColumnState(stateInfo.dependentConditionStacks[0].column, stateInfo.dependentConditionStacks[0].conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory, stateInfo.editedConditionStack);
      }
    }
    /**
     * Get multiple select element.
     *
     * @returns {MultipleSelectUI}
     */
  }, {
    key: "getMultipleSelectElement",
    value: function getMultipleSelectElement() {
      return this.elements.filter(function(element) {
        return element instanceof MultipleSelectUI$1;
      })[0];
    }
    /**
     * Get object descriptor for menu item entry.
     *
     * @returns {object}
     */
  }, {
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this4 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this4.isHidden();
        },
        renderer: function renderer(hot, wrapper2, row, col, prop, value) {
          addClass(wrapper2.parentNode, "htFiltersMenuValue");
          var label = _this4.hot.rootDocument.createElement("div");
          addClass(label, "htFiltersMenuLabel");
          label.textContent = value;
          wrapper2.appendChild(label);
          if (!wrapper2.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this4.elements, function(ui) {
              return wrapper2.appendChild(ui.element);
            });
          }
          return wrapper2;
        }
      };
    }
    /**
     * Reset elements to their initial state.
     */
  }, {
    key: "reset",
    value: function reset() {
      var defaultBlankCellValue = this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
      var values3 = unifyColumnValues(this._getColumnVisibleValues());
      var items = intersectValues(values3, values3, defaultBlankCellValue);
      this.getMultipleSelectElement().setItems(items);
      _get$m(_getPrototypeOf$r(ValueComponent2.prototype), "reset", this).call(this);
      this.getMultipleSelectElement().setValue(values3);
      var selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
      if (selectedColumn !== null) {
        this.getMultipleSelectElement().setLocale(this.hot.getCellMeta(0, selectedColumn.visualIndex).locale);
      }
    }
    /**
     * Key down listener.
     *
     * @private
     * @param {Event} event The DOM event object.
     */
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event2) {
      if (isKey(event2.keyCode, "ESCAPE")) {
        this.runLocalHooks("cancel");
        stopImmediatePropagation(event2);
      }
    }
    /**
     * Get data for currently selected column.
     *
     * @returns {Array}
     * @private
     */
  }, {
    key: "_getColumnVisibleValues",
    value: function _getColumnVisibleValues() {
      var selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
      if (selectedColumn === null) {
        return [];
      }
      return arrayMap(this.hot.getDataAtCol(selectedColumn.visualIndex), function(v2) {
        return toEmptyString(v2);
      });
    }
  }]);
  return ValueComponent2;
}(BaseComponent$1);
const ValueComponent$1 = ValueComponent;
function _typeof$s(obj) {
  "@babel/helpers - typeof";
  return _typeof$s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$s(obj);
}
function _classCallCheck$I(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$I(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$I(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$I(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$I(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$q(subClass, superClass);
}
function _setPrototypeOf$q(o, p2) {
  _setPrototypeOf$q = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$q(o, p2);
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$q(this, result);
  };
}
function _possibleConstructorReturn$q(self2, call2) {
  if (call2 && (_typeof$s(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$q(self2);
}
function _assertThisInitialized$q(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$q(o) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$q(o);
}
var ActionBarComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$q(ActionBarComponent2, _BaseComponent);
  var _super = _createSuper$q(ActionBarComponent2);
  function ActionBarComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$I(this, ActionBarComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: true
    });
    _this.name = options.name;
    _this.elements.push(new InputUI$1(_this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_OK,
      className: "htUIButton htUIButtonOK",
      identifier: ActionBarComponent2.BUTTON_OK
    }));
    _this.elements.push(new InputUI$1(_this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_CANCEL,
      className: "htUIButton htUIButtonCancel",
      identifier: ActionBarComponent2.BUTTON_CANCEL
    }));
    _this.registerHooks();
    return _this;
  }
  _createClass$I(ActionBarComponent2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      arrayEach(this.elements, function(element) {
        element.addLocalHook("click", function(event2, button) {
          return _this2.onButtonClick(event2, button);
        });
      });
    }
    /**
     * Get menu object descriptor.
     *
     * @returns {object}
     */
  }, {
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this3 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this3.isHidden();
        },
        renderer: function renderer(hot, wrapper2) {
          addClass(wrapper2.parentNode, "htFiltersMenuActionBar");
          if (!wrapper2.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this3.elements, function(ui) {
              return wrapper2.appendChild(ui.element);
            });
          }
          return wrapper2;
        }
      };
    }
    /**
     * Fire accept event.
     */
  }, {
    key: "accept",
    value: function accept() {
      this.runLocalHooks("accept");
    }
    /**
     * Fire cancel event.
     */
  }, {
    key: "cancel",
    value: function cancel() {
      this.runLocalHooks("cancel");
    }
    /**
     * On button click listener.
     *
     * @private
     * @param {Event} event DOM event.
     * @param {InputUI} button InputUI object.
     */
  }, {
    key: "onButtonClick",
    value: function onButtonClick(event2, button) {
      if (button.options.identifier === ActionBarComponent2.BUTTON_OK) {
        this.accept();
      } else {
        this.cancel();
      }
    }
  }], [{
    key: "BUTTON_OK",
    get: function get2() {
      return "ok";
    }
  }, {
    key: "BUTTON_CANCEL",
    get: function get2() {
      return "cancel";
    }
  }]);
  return ActionBarComponent2;
}(BaseComponent$1);
const ActionBarComponent$1 = ActionBarComponent;
var _templateObject$8, _templateObject2$2;
function _slicedToArray$a(arr, i) {
  return _arrayWithHoles$b(arr) || _iterableToArrayLimit$a(arr, i) || _unsupportedIterableToArray$l(arr, i) || _nonIterableRest$b();
}
function _nonIterableRest$b() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$l(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$l(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$l(o, minLen);
}
function _arrayLikeToArray$l(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$a(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$b(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _taggedTemplateLiteral$8(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$H(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$H(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$H(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$H(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$H(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var MAP_NAME = "ConditionCollection.filteringStates";
var ConditionCollection = /* @__PURE__ */ function() {
  function ConditionCollection2(hot) {
    var isMapRegistrable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    _classCallCheck$H(this, ConditionCollection2);
    this.hot = hot;
    this.isMapRegistrable = isMapRegistrable;
    this.filteringStates = new LinkedPhysicalIndexToValueMap();
    if (this.isMapRegistrable === true) {
      this.hot.columnIndexMapper.registerMap(MAP_NAME, this.filteringStates);
    } else {
      this.filteringStates.init(this.hot.columnIndexMapper.getNumberOfIndexes());
    }
  }
  _createClass$H(ConditionCollection2, [{
    key: "isEmpty",
    value: function isEmpty2() {
      return this.getFilteredColumns().length === 0;
    }
    /**
     * Check if value is matched to the criteria of conditions chain.
     *
     * @param {object} value Object with `value` and `meta` keys.
     * @param {number} column The physical column index.
     * @returns {boolean}
     */
  }, {
    key: "isMatch",
    value: function isMatch(value, column) {
      var _stateForColumn$condi;
      var stateForColumn = this.filteringStates.getValueAtIndex(column);
      var conditions2 = (_stateForColumn$condi = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.conditions) !== null && _stateForColumn$condi !== void 0 ? _stateForColumn$condi : [];
      var operation = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.operation;
      return this.isMatchInConditions(conditions2, value, operation);
    }
    /**
     * Check if the value is matches the conditions.
     *
     * @param {Array} conditions List of conditions.
     * @param {object} value Object with `value` and `meta` keys.
     * @param {string} [operationType='conjunction'] Type of conditions operation.
     * @returns {boolean}
     */
  }, {
    key: "isMatchInConditions",
    value: function isMatchInConditions(conditions2, value) {
      var operationType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID$2;
      if (conditions2.length) {
        return getOperationFunc(operationType)(conditions2, value);
      }
      return true;
    }
    /**
     * Add condition to the collection.
     *
     * @param {number} column The physical column index.
     * @param {object} conditionDefinition Object with keys:
     *  * `command` Object, Command object with condition name as `key` property.
     *  * `args` Array, Condition arguments.
     * @param {string} [operation='conjunction'] Type of conditions operation.
     * @param {number} [position] Position to which condition will be added. When argument is undefined
     * the condition will be processed as the last condition.
     * @fires ConditionCollection#beforeAdd
     * @fires ConditionCollection#afterAdd
     */
  }, {
    key: "addCondition",
    value: function addCondition(column, conditionDefinition) {
      var operation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID$2;
      var position = arguments.length > 3 ? arguments[3] : void 0;
      var localeForColumn = this.hot.getCellMeta(0, column).locale;
      var args = arrayMap(conditionDefinition.args, function(v2) {
        return typeof v2 === "string" ? v2.toLocaleLowerCase(localeForColumn) : v2;
      });
      var name = conditionDefinition.name || conditionDefinition.command.key;
      this.runLocalHooks("beforeAdd", column);
      var columnType = this.getOperation(column);
      if (columnType) {
        if (columnType !== operation) {
          throw Error(toSingleLine(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteral$8(["The column of index ", " has been already applied with a `", "` \n        filter operation. Use `removeConditions` to clear the current conditions and then add new ones. \n        Mind that you cannot mix different types of operations (for instance, if you use `conjunction`, \n        use it consequently for a particular column)."], ["The column of index ", " has been already applied with a \\`", "\\`\\x20\n        filter operation. Use \\`removeConditions\\` to clear the current conditions and then add new ones.\\x20\n        Mind that you cannot mix different types of operations (for instance, if you use \\`conjunction\\`,\\x20\n        use it consequently for a particular column)."])), column, columnType));
        }
      } else if (isUndefined(operations[operation])) {
        throw new Error(toSingleLine(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral$8(["Unexpected operation named `", "`. Possible ones are \n        `disjunction` and `conjunction`."], ["Unexpected operation named \\`", "\\`. Possible ones are\\x20\n        \\`disjunction\\` and \\`conjunction\\`."])), operation));
      }
      var conditionsForColumn = this.getConditions(column);
      if (conditionsForColumn.length === 0) {
        this.filteringStates.setValueAtIndex(column, {
          operation,
          conditions: [{
            name,
            args,
            func: getCondition(name, args)
          }]
        }, position);
      } else {
        conditionsForColumn.push({
          name,
          args,
          func: getCondition(name, args)
        });
      }
      this.runLocalHooks("afterAdd", column);
    }
    /**
     * Get all added conditions from the collection at specified column index.
     *
     * @param {number} column The physical column index.
     * @returns {Array} Returns conditions collection as an array.
     */
  }, {
    key: "getConditions",
    value: function getConditions(column) {
      var _this$filteringStates, _this$filteringStates2;
      return (_this$filteringStates = (_this$filteringStates2 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates2 === void 0 ? void 0 : _this$filteringStates2.conditions) !== null && _this$filteringStates !== void 0 ? _this$filteringStates : [];
    }
    /**
     * Get operation for particular column.
     *
     * @param {number} column The physical column index.
     * @returns {string|undefined}
     */
  }, {
    key: "getOperation",
    value: function getOperation(column) {
      var _this$filteringStates3;
      return (_this$filteringStates3 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates3 === void 0 ? void 0 : _this$filteringStates3.operation;
    }
    /**
     * Get all filtered physical columns in the order in which actions are performed.
     *
     * @returns {Array}
     */
  }, {
    key: "getFilteredColumns",
    value: function getFilteredColumns() {
      return this.filteringStates.getEntries().map(function(_ref2) {
        var _ref22 = _slicedToArray$a(_ref2, 1), physicalColumn = _ref22[0];
        return physicalColumn;
      });
    }
    /**
     * Gets position in the filtering states stack for the specific column.
     *
     * @param {number} column The physical column index.
     * @returns {number} Returns -1 when the column doesn't exist in the stack.
     */
  }, {
    key: "getColumnStackPosition",
    value: function getColumnStackPosition(column) {
      return this.getFilteredColumns().indexOf(column);
    }
    /**
     * Export all previously added conditions.
     *
     * @returns {Array}
     */
  }, {
    key: "exportAllConditions",
    value: function exportAllConditions() {
      return arrayReduce$1(this.filteringStates.getEntries(), function(allConditions, _ref3) {
        var _ref4 = _slicedToArray$a(_ref3, 2), column = _ref4[0], _ref4$ = _ref4[1], operation = _ref4$.operation, conditions2 = _ref4$.conditions;
        allConditions.push({
          column,
          operation,
          conditions: arrayMap(conditions2, function(_ref5) {
            var name = _ref5.name, args = _ref5.args;
            return {
              name,
              args
            };
          })
        });
        return allConditions;
      }, []);
    }
    /**
     * Import conditions to the collection.
     *
     * @param {Array} conditions The collection of the conditions.
     */
  }, {
    key: "importAllConditions",
    value: function importAllConditions(conditions2) {
      var _this = this;
      this.clean();
      arrayEach(conditions2, function(stack) {
        arrayEach(stack.conditions, function(condition2) {
          return _this.addCondition(stack.column, condition2);
        });
      });
    }
    /**
     * Remove conditions at given column index.
     *
     * @param {number} column The physical column index.
     * @fires ConditionCollection#beforeRemove
     * @fires ConditionCollection#afterRemove
     */
  }, {
    key: "removeConditions",
    value: function removeConditions(column) {
      this.runLocalHooks("beforeRemove", column);
      this.filteringStates.clearValue(column);
      this.runLocalHooks("afterRemove", column);
    }
    /**
     * Clean all conditions collection and reset order stack.
     *
     * @fires ConditionCollection#beforeClean
     * @fires ConditionCollection#afterClean
     */
  }, {
    key: "clean",
    value: function clean() {
      this.runLocalHooks("beforeClean");
      this.filteringStates.clear();
      this.runLocalHooks("afterClean");
    }
    /**
     * Check if at least one condition was added at specified column index. And if second parameter is passed then additionally
     * check if condition exists under its name.
     *
     * @param {number} column The physical column index.
     * @param {string} [name] Condition name.
     * @returns {boolean}
     */
  }, {
    key: "hasConditions",
    value: function hasConditions(column, name) {
      var conditions2 = this.getConditions(column);
      if (name) {
        return conditions2.some(function(condition2) {
          return condition2.name === name;
        });
      }
      return conditions2.length > 0;
    }
    /**
     * Destroy object.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isMapRegistrable) {
        this.hot.columnIndexMapper.unregisterMap(MAP_NAME);
      }
      this.filteringStates = null;
      this.clearLocalHooks();
    }
  }]);
  return ConditionCollection2;
}();
mixin(ConditionCollection, localHooks$1);
const ConditionCollection$1 = ConditionCollection;
function _classCallCheck$G(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$G(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$G(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$G(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$G(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DataFilter = /* @__PURE__ */ function() {
  function DataFilter2(conditionCollection) {
    var columnDataFactory = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
      return [];
    };
    _classCallCheck$G(this, DataFilter2);
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
  }
  _createClass$G(DataFilter2, [{
    key: "filter",
    value: function filter2() {
      var _this = this;
      var filteredData = [];
      arrayEach(this.conditionCollection.getFilteredColumns(), function(physicalColumn, index2) {
        var columnData = _this.columnDataFactory(physicalColumn);
        if (index2) {
          columnData = _this._getIntersectData(columnData, filteredData);
        }
        filteredData = _this.filterByColumn(physicalColumn, columnData);
      });
      return filteredData;
    }
    /**
     * Filter data based on specified physical column index.
     *
     * @param {number} column The physical column index.
     * @param {Array} [dataSource] Data source as array of objects with `value` and `meta` keys (e.g. `{value: 'foo', meta: {}}`).
     * @returns {Array} Returns filtered data.
     */
  }, {
    key: "filterByColumn",
    value: function filterByColumn(column) {
      var _this2 = this;
      var dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var filteredData = [];
      arrayEach(dataSource, function(dataRow) {
        if (dataRow !== void 0 && _this2.conditionCollection.isMatch(dataRow, column)) {
          filteredData.push(dataRow);
        }
      });
      return filteredData;
    }
    /**
     * Intersect data.
     *
     * @private
     * @param {Array} data The data to intersect.
     * @param {Array} needles The collection intersected rows with the data.
     * @returns {Array}
     */
  }, {
    key: "_getIntersectData",
    value: function _getIntersectData(data2, needles) {
      var result = [];
      arrayEach(needles, function(needleRow) {
        var row = needleRow.meta.visualRow;
        if (data2[row] !== void 0) {
          result[row] = data2[row];
        }
      });
      return result;
    }
  }]);
  return DataFilter2;
}();
const DataFilter$1 = DataFilter;
function _classCallCheck$F(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$F(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$F(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$F(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$F(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var ConditionUpdateObserver = /* @__PURE__ */ function() {
  function ConditionUpdateObserver2(hot, conditionCollection) {
    var _this = this;
    var columnDataFactory = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      return [];
    };
    _classCallCheck$F(this, ConditionUpdateObserver2);
    this.hot = hot;
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
    this.changes = [];
    this.grouping = false;
    this.latestEditedColumnPosition = -1;
    this.latestOrderStack = [];
    this.conditionCollection.addLocalHook("beforeRemove", function(column) {
      return _this._onConditionBeforeModify(column);
    });
    this.conditionCollection.addLocalHook("afterRemove", function(column) {
      return _this.updateStatesAtColumn(column);
    });
    this.conditionCollection.addLocalHook("afterAdd", function(column) {
      return _this.updateStatesAtColumn(column);
    });
    this.conditionCollection.addLocalHook("beforeClean", function() {
      return _this._onConditionBeforeClean();
    });
    this.conditionCollection.addLocalHook("afterClean", function() {
      return _this._onConditionAfterClean();
    });
  }
  _createClass$F(ConditionUpdateObserver2, [{
    key: "groupChanges",
    value: function groupChanges() {
      this.grouping = true;
    }
    /**
     * Flush all collected changes. This trigger `update` hook for every previously collected change from condition collection.
     */
  }, {
    key: "flush",
    value: function flush() {
      var _this2 = this;
      this.grouping = false;
      arrayEach(this.changes, function(column) {
        _this2.updateStatesAtColumn(column);
      });
      this.changes.length = 0;
    }
    /**
     * On before modify condition (add or remove from collection),.
     *
     * @param {number} column Column index.
     * @private
     */
  }, {
    key: "_onConditionBeforeModify",
    value: function _onConditionBeforeModify(column) {
      this.latestEditedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
    }
    /**
     * Update all related states which should be changed after invoking changes applied to current column.
     *
     * @param {number} column The column index.
     * @param {object} conditionArgsChange Object describing condition changes which can be handled by filters on `update` hook.
     * It contains keys `conditionKey` and `conditionValue` which refers to change specified key of condition to specified value
     * based on referred keys.
     */
  }, {
    key: "updateStatesAtColumn",
    value: function updateStatesAtColumn(column, conditionArgsChange) {
      var _this3 = this;
      if (this.grouping) {
        if (this.changes.indexOf(column) === -1) {
          this.changes.push(column);
        }
        return;
      }
      var allConditions = this.conditionCollection.exportAllConditions();
      var editedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
      if (editedColumnPosition === -1) {
        editedColumnPosition = this.latestEditedColumnPosition;
      }
      var conditionsBefore = allConditions.slice(0, editedColumnPosition);
      var conditionsAfter = allConditions.slice(editedColumnPosition);
      if (conditionsAfter.length && conditionsAfter[0].column === column) {
        conditionsAfter.shift();
      }
      var visibleDataFactory = curry(function(curriedConditionsBefore, curriedColumn) {
        var conditionsStack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        var splitConditionCollection = new ConditionCollection$1(_this3.hot, false);
        var curriedConditionsBeforeArray = [].concat(curriedConditionsBefore, conditionsStack);
        splitConditionCollection.importAllConditions(curriedConditionsBeforeArray);
        var allRows = _this3.columnDataFactory(curriedColumn);
        var visibleRows;
        if (splitConditionCollection.isEmpty()) {
          visibleRows = allRows;
        } else {
          visibleRows = new DataFilter$1(splitConditionCollection, function(columnData) {
            return _this3.columnDataFactory(columnData);
          }).filter();
        }
        visibleRows = arrayMap(visibleRows, function(rowData) {
          return rowData.meta.visualRow;
        });
        var visibleRowsAssertion = createArrayAssertion(visibleRows);
        splitConditionCollection.destroy();
        return arrayFilter(allRows, function(rowData) {
          return visibleRowsAssertion(rowData.meta.visualRow);
        });
      })(conditionsBefore);
      var editedConditions = [].concat(this.conditionCollection.getConditions(column));
      this.runLocalHooks("update", {
        editedConditionStack: {
          column,
          conditions: editedConditions
        },
        dependentConditionStacks: conditionsAfter,
        filteredRowsFactory: visibleDataFactory,
        conditionArgsChange
      });
    }
    /**
     * On before conditions clean listener.
     *
     * @private
     */
  }, {
    key: "_onConditionBeforeClean",
    value: function _onConditionBeforeClean() {
      this.latestOrderStack = this.conditionCollection.getFilteredColumns();
    }
    /**
     * On after conditions clean listener.
     *
     * @private
     */
  }, {
    key: "_onConditionAfterClean",
    value: function _onConditionAfterClean() {
      var _this4 = this;
      arrayEach(this.latestOrderStack, function(column) {
        _this4.updateStatesAtColumn(column);
      });
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this5 = this;
      this.clearLocalHooks();
      objectEach(this, function(value, property) {
        _this5[property] = null;
      });
    }
  }]);
  return ConditionUpdateObserver2;
}();
mixin(ConditionUpdateObserver, localHooks$1);
const ConditionUpdateObserver$1 = ConditionUpdateObserver;
function _typeof$r(obj) {
  "@babel/helpers - typeof";
  return _typeof$r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$r(obj);
}
var _templateObject$7;
function _taggedTemplateLiteral$7(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _slicedToArray$9(arr, i) {
  return _arrayWithHoles$a(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$k(arr, i) || _nonIterableRest$a();
}
function _nonIterableRest$a() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$k(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$k(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$k(o, minLen);
}
function _arrayLikeToArray$k(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$9(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$a(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$E(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$E(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$E(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$E(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$E(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$l() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$l = Reflect.get.bind();
  } else {
    _get$l = function _get2(target, property, receiver) {
      var base = _superPropBase$l(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$l.apply(this, arguments);
}
function _superPropBase$l(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$p(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$p(subClass, superClass);
}
function _setPrototypeOf$p(o, p2) {
  _setPrototypeOf$p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$p(o, p2);
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$p(this, result);
  };
}
function _possibleConstructorReturn$p(self2, call2) {
  if (call2 && (_typeof$r(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$p(self2);
}
function _assertThisInitialized$p(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$p(o) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$p(o);
}
var PLUGIN_KEY$i = "filters";
var PLUGIN_PRIORITY$h = 250;
var Filters = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$p(Filters2, _BasePlugin);
  var _super = _createSuper$p(Filters2);
  function Filters2(hotInstance) {
    var _this;
    _classCallCheck$E(this, Filters2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager$1(_assertThisInitialized$p(_this));
    _this.dropdownMenuPlugin = null;
    _this.conditionCollection = null;
    _this.conditionUpdateObserver = null;
    _this.components = /* @__PURE__ */ new Map([["filter_by_condition", null], ["filter_operators", null], ["filter_by_condition2", null], ["filter_by_value", null], ["filter_action_bar", null]]);
    _this.lastSelectedColumn = null;
    _this.filtersRowsMap = null;
    _this.hot.addHook("afterGetColHeader", function(col, TH) {
      return _this.onAfterGetColHeader(col, TH);
    });
    return _this;
  }
  _createClass$E(Filters2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$i] ? true : false;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.filtersRowsMap = this.hot.rowIndexMapper.registerMap(this.pluginName, new TrimmingMap());
      this.dropdownMenuPlugin = this.hot.getPlugin("dropdownMenu");
      var dropdownSettings = this.hot.getSettings().dropdownMenu;
      var menuContainer = dropdownSettings && dropdownSettings.uiContainer || this.hot.rootDocument.body;
      var addConfirmationHooks = function addConfirmationHooks2(component) {
        component.addLocalHook("accept", function() {
          return _this2.onActionBarSubmit("accept");
        });
        component.addLocalHook("cancel", function() {
          return _this2.onActionBarSubmit("cancel");
        });
        component.addLocalHook("change", function(command) {
          return _this2.onComponentChange(component, command);
        });
        return component;
      };
      var filterByConditionLabel = function filterByConditionLabel2() {
        return "".concat(_this2.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_CONDITION), ":");
      };
      var filterValueLabel = function filterValueLabel2() {
        return "".concat(_this2.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_VALUE), ":");
      };
      if (!this.components.get("filter_by_condition")) {
        var conditionComponent = new ConditionComponent$1(this.hot, {
          id: "filter_by_condition",
          name: filterByConditionLabel,
          addSeparator: false,
          menuContainer
        });
        conditionComponent.addLocalHook("afterClose", function() {
          return _this2.onSelectUIClosed();
        });
        this.components.set("filter_by_condition", addConfirmationHooks(conditionComponent));
      }
      if (!this.components.get("filter_operators")) {
        this.components.set("filter_operators", new OperatorsComponent$1(this.hot, {
          id: "filter_operators",
          name: "Operators"
        }));
      }
      if (!this.components.get("filter_by_condition2")) {
        var _conditionComponent = new ConditionComponent$1(this.hot, {
          id: "filter_by_condition2",
          name: "",
          addSeparator: true,
          menuContainer
        });
        _conditionComponent.addLocalHook("afterClose", function() {
          return _this2.onSelectUIClosed();
        });
        this.components.set("filter_by_condition2", addConfirmationHooks(_conditionComponent));
      }
      if (!this.components.get("filter_by_value")) {
        this.components.set("filter_by_value", addConfirmationHooks(new ValueComponent$1(this.hot, {
          id: "filter_by_value",
          name: filterValueLabel
        })));
      }
      if (!this.components.get("filter_action_bar")) {
        this.components.set("filter_action_bar", addConfirmationHooks(new ActionBarComponent$1(this.hot, {
          id: "filter_action_bar",
          name: "Action bar"
        })));
      }
      if (!this.conditionCollection) {
        this.conditionCollection = new ConditionCollection$1(this.hot);
      }
      if (!this.conditionUpdateObserver) {
        this.conditionUpdateObserver = new ConditionUpdateObserver$1(this.hot, this.conditionCollection, function(physicalColumn) {
          return _this2.getDataMapAtColumn(physicalColumn);
        });
        this.conditionUpdateObserver.addLocalHook("update", function(conditionState) {
          return _this2.updateComponents(conditionState);
        });
      }
      this.components.forEach(function(component) {
        return component.show();
      });
      this.addHook("beforeDropdownMenuSetItems", function(items) {
        return _this2.onBeforeDropdownMenuSetItems(items);
      });
      this.addHook("afterDropdownMenuDefaultOptions", function(defaultOptions) {
        return _this2.onAfterDropdownMenuDefaultOptions(defaultOptions);
      });
      this.addHook("afterDropdownMenuShow", function() {
        return _this2.onAfterDropdownMenuShow();
      });
      this.addHook("afterDropdownMenuHide", function() {
        return _this2.onAfterDropdownMenuHide();
      });
      this.addHook("afterChange", function(changes) {
        return _this2.onAfterChange(changes);
      });
      if (this.hot.getSettings().dropdownMenu && this.dropdownMenuPlugin) {
        this.dropdownMenuPlugin.disablePlugin();
        this.dropdownMenuPlugin.enablePlugin();
      }
      _get$l(_getPrototypeOf$p(Filters2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      if (this.enabled) {
        var _this$dropdownMenuPlu;
        if ((_this$dropdownMenuPlu = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu !== void 0 && _this$dropdownMenuPlu.enabled) {
          this.dropdownMenuPlugin.menu.clearLocalHooks();
        }
        this.components.forEach(function(component, key) {
          component.destroy();
          _this3.components.set(key, null);
        });
        this.conditionCollection.destroy();
        this.conditionCollection = null;
        this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      }
      _get$l(_getPrototypeOf$p(Filters2.prototype), "disablePlugin", this).call(this);
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * @memberof Filters#
     * @function addCondition
     * @description
     * Adds condition to the conditions collection at specified column index.
     *
     * Possible predefined conditions:
     *  * `begins_with` - Begins with
     *  * `between` - Between
     *  * `by_value` - By value
     *  * `contains` - Contains
     *  * `empty` - Empty
     *  * `ends_with` - Ends with
     *  * `eq` - Equal
     *  * `gt` - Greater than
     *  * `gte` - Greater than or equal
     *  * `lt` - Less than
     *  * `lte` - Less than or equal
     *  * `none` - None (no filter)
     *  * `not_between` - Not between
     *  * `not_contains` - Not contains
     *  * `not_empty` - Not empty
     *  * `neq` - Not equal.
     *
     * Possible operations on collection of conditions:
     *  * `conjunction` - [**Conjunction**](https://en.wikipedia.org/wiki/Logical_conjunction) on conditions collection (by default), i.e. for such operation: <br/> c1 AND c2 AND c3 AND c4 ... AND cn === TRUE, where c1 ... cn are conditions.
     *  * `disjunction` - [**Disjunction**](https://en.wikipedia.org/wiki/Logical_disjunction) on conditions collection, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.
     *  * `disjunctionWithExtraCondition` - **Disjunction** on first `n - 1`\* conditions from collection with an extra requirement computed from the last condition, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn-1 AND cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.
     *
     * \* when `n` is collection size; it's used i.e. for one operation introduced from UI (when choosing from filter's drop-down menu two conditions with OR operator between them, mixed with choosing values from the multiple choice select)
     *
     * **Note**: Mind that you cannot mix different types of operations (for instance, if you use `conjunction`, use it consequently for a particular column).
     *
     * @example
     * ```js
     * const container = document.getElementById('example');
     * const hot = new Handsontable(container, {
     *   data: getData(),
     *   filters: true
     * });
     *
     * // access to filters plugin instance
     * const filtersPlugin = hot.getPlugin('filters');
     *
     * // add filter "Greater than" 95 to column at index 1
     * filtersPlugin.addCondition(1, 'gt', [95]);
     * filtersPlugin.filter();
     *
     * // add filter "By value" to column at index 1
     * // in this case all value's that don't match will be filtered.
     * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', 'as', 'on']]);
     * filtersPlugin.filter();
     *
     * // add filter "Begins with" with value "de" AND "Not contains" with value "ing"
     * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');
     * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');
     * filtersPlugin.filter();
     *
     * // add filter "Begins with" with value "de" OR "Not contains" with value "ing"
     * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');
     * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');
     * filtersPlugin.filter();
     * ```
     * @param {number} column Visual column index.
     * @param {string} name Condition short name.
     * @param {Array} args Condition arguments.
     * @param {string} [operationId=conjunction] `id` of operation which is performed on the column.
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "addCondition",
    value: function addCondition(column, name, args) {
      var operationId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : OPERATION_ID$2;
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.conditionCollection.addCondition(physicalColumn, {
        command: {
          key: name
        },
        args
      }, operationId);
    }
    /**
     * Removes conditions at specified column index.
     *
     * @param {number} column Visual column index.
     */
  }, {
    key: "removeConditions",
    value: function removeConditions(column) {
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.conditionCollection.removeConditions(physicalColumn);
    }
    /**
     * Clears all conditions previously added to the collection for the specified column index or, if the column index
     * was not passed, clear the conditions for all columns.
     *
     * @param {number} [column] Visual column index.
     */
  }, {
    key: "clearConditions",
    value: function clearConditions(column) {
      if (column === void 0) {
        this.conditionCollection.clean();
      } else {
        var physicalColumn = this.hot.toPhysicalColumn(column);
        this.conditionCollection.removeConditions(physicalColumn);
      }
    }
    /**
     * Filters data based on added filter conditions.
     *
     * @fires Hooks#beforeFilter
     * @fires Hooks#afterFilter
     */
  }, {
    key: "filter",
    value: function filter2() {
      var _this4 = this;
      var dataFilter = this._createDataFilter();
      var needToFilter = !this.conditionCollection.isEmpty();
      var visibleVisualRows = [];
      var conditions2 = this.conditionCollection.exportAllConditions();
      var allowFiltering = this.hot.runHooks("beforeFilter", conditions2);
      if (allowFiltering !== false) {
        if (needToFilter) {
          var trimmedRows = [];
          this.hot.batchExecution(function() {
            _this4.filtersRowsMap.clear();
            visibleVisualRows = arrayMap(dataFilter.filter(), function(rowData) {
              return rowData.meta.visualRow;
            });
            var visibleVisualRowsAssertion = createArrayAssertion(visibleVisualRows);
            rangeEach(_this4.hot.countSourceRows() - 1, function(row) {
              if (!visibleVisualRowsAssertion(row)) {
                trimmedRows.push(row);
              }
            });
            arrayEach(trimmedRows, function(physicalRow) {
              _this4.filtersRowsMap.setValueAtIndex(physicalRow, true);
            });
          }, true);
          if (!visibleVisualRows.length) {
            this.hot.deselectCell();
          }
        } else {
          this.filtersRowsMap.clear();
        }
      }
      this.hot.runHooks("afterFilter", conditions2);
      this.hot.view.adjustElementsSize(true);
      this.hot.render();
      this.clearColumnSelection();
    }
    /**
     * Gets last selected column index.
     *
     * @returns {{visualIndex: number, physicalIndex: number} | null} Returns `null` when a column is
     * not selected. Otherwise, returns an object with `visualIndex` and `physicalIndex` properties containing
     * the index of the column.
     */
  }, {
    key: "getSelectedColumn",
    value: function getSelectedColumn() {
      var _this$hot$getSelected;
      var highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
      if (!highlight) {
        return null;
      }
      return {
        visualIndex: highlight.col,
        physicalIndex: this.hot.toPhysicalColumn(highlight.col)
      };
    }
    /**
     * Clears column selection.
     *
     * @private
     */
  }, {
    key: "clearColumnSelection",
    value: function clearColumnSelection() {
      var selectedColumn = this.getSelectedColumn();
      if (selectedColumn !== null) {
        this.hot.selectCell(0, selectedColumn.visualIndex);
      }
    }
    /**
     * Returns handsontable source data with cell meta based on current selection.
     *
     * @param {number} [column] The physical column index. By default column index accept the value of the selected column.
     * @returns {Array} Returns array of objects where keys as row index.
     */
  }, {
    key: "getDataMapAtColumn",
    value: function getDataMapAtColumn(column) {
      var _this5 = this;
      var visualColumn = this.hot.toVisualColumn(column);
      var data2 = [];
      arrayEach(this.hot.getSourceDataAtCol(visualColumn), function(value, rowIndex) {
        var _this5$hot$getDataAtC;
        var _this5$hot$getCellMet = _this5.hot.getCellMeta(rowIndex, visualColumn), row = _this5$hot$getCellMet.row, col = _this5$hot$getCellMet.col, visualCol = _this5$hot$getCellMet.visualCol, visualRow = _this5$hot$getCellMet.visualRow, type = _this5$hot$getCellMet.type, instance = _this5$hot$getCellMet.instance, dateFormat = _this5$hot$getCellMet.dateFormat, locale = _this5$hot$getCellMet.locale;
        var dataValue = (_this5$hot$getDataAtC = _this5.hot.getDataAtCell(_this5.hot.toVisualRow(rowIndex), visualColumn)) !== null && _this5$hot$getDataAtC !== void 0 ? _this5$hot$getDataAtC : value;
        data2.push({
          meta: {
            row,
            col,
            visualCol,
            visualRow,
            type,
            instance,
            dateFormat,
            locale
          },
          value: toEmptyString(dataValue)
        });
      });
      return data2;
    }
    /**
     * `afterChange` listener.
     *
     * @private
     * @param {Array} changes Array of changes.
     */
  }, {
    key: "onAfterChange",
    value: function onAfterChange2(changes) {
      var _this6 = this;
      if (changes) {
        arrayEach(changes, function(change) {
          var _change = _slicedToArray$9(change, 2), prop = _change[1];
          var columnIndex = _this6.hot.propToCol(prop);
          if (_this6.conditionCollection.hasConditions(columnIndex)) {
            _this6.updateValueComponentCondition(columnIndex);
          }
        });
      }
    }
    /**
     * Update the condition of ValueComponent, based on the handled changes.
     *
     * @private
     * @param {number} columnIndex Column index of handled ValueComponent condition.
     */
  }, {
    key: "updateValueComponentCondition",
    value: function updateValueComponentCondition(columnIndex) {
      var dataAtCol = this.hot.getDataAtCol(columnIndex);
      var selectedValues = unifyColumnValues(dataAtCol);
      this.conditionUpdateObserver.updateStatesAtColumn(columnIndex, selectedValues);
    }
    /**
     * Restores components to its saved state.
     *
     * @private
     * @param {Array} components List of components.
     */
  }, {
    key: "restoreComponents",
    value: function restoreComponents(components) {
      var _this$getSelectedColu;
      var physicalIndex = (_this$getSelectedColu = this.getSelectedColumn()) === null || _this$getSelectedColu === void 0 ? void 0 : _this$getSelectedColu.physicalIndex;
      components.forEach(function(component) {
        if (component.isHidden()) {
          return;
        }
        component.restoreState(physicalIndex);
      });
      this.updateDependentComponentsVisibility();
    }
    /**
     * After dropdown menu show listener.
     *
     * @private
     */
  }, {
    key: "onAfterDropdownMenuShow",
    value: function onAfterDropdownMenuShow() {
      this.restoreComponents(Array.from(this.components.values()));
    }
    /**
     * After dropdown menu hide listener.
     *
     * @private
     */
  }, {
    key: "onAfterDropdownMenuHide",
    value: function onAfterDropdownMenuHide() {
      this.components.get("filter_by_condition").getSelectElement().closeOptions();
      this.components.get("filter_by_condition2").getSelectElement().closeOptions();
    }
    /**
     * Before dropdown menu set menu items listener.
     *
     * @private
     */
  }, {
    key: "onBeforeDropdownMenuSetItems",
    value: function onBeforeDropdownMenuSetItems() {
      var _this7 = this;
      if (this.dropdownMenuPlugin) {
        this.dropdownMenuPlugin.menu.addLocalHook("afterOpen", function() {
          _this7.dropdownMenuPlugin.menu.hotMenu.updateSettings({
            hiddenRows: true
          });
        });
      }
    }
    /**
     * After dropdown menu default options listener.
     *
     * @private
     * @param {object} defaultOptions ContextMenu default item options.
     */
  }, {
    key: "onAfterDropdownMenuDefaultOptions",
    value: function onAfterDropdownMenuDefaultOptions(defaultOptions) {
      defaultOptions.items.push({
        name: KEY$c
      });
      this.components.forEach(function(component) {
        defaultOptions.items.push(component.getMenuItemDescriptor());
      });
    }
    /**
     * Get an operation, based on the number and types of arguments (where arguments are states of components).
     *
     * @param {string} suggestedOperation Operation which was chosen by user from UI.
     * @param {object} byConditionState1 State of first condition component.
     * @param {object} byConditionState2 State of second condition component.
     * @param {object} byValueState State of value component.
     * @private
     * @returns {string}
     */
  }, {
    key: "getOperationBasedOnArguments",
    value: function getOperationBasedOnArguments(suggestedOperation, byConditionState1, byConditionState2, byValueState) {
      var operation = suggestedOperation;
      if (operation === OPERATION_ID$1 && byConditionState1.command.key !== CONDITION_NAME$k && byConditionState2.command.key !== CONDITION_NAME$k && byValueState.command.key !== CONDITION_NAME$k) {
        operation = OPERATION_ID;
      } else if (byValueState.command.key !== CONDITION_NAME$k) {
        if (byConditionState1.command.key === CONDITION_NAME$k || byConditionState2.command.key === CONDITION_NAME$k) {
          operation = OPERATION_ID$2;
        }
      }
      return operation;
    }
    /**
     * On action bar submit listener.
     *
     * @private
     * @param {string} submitType The submit type.
     */
  }, {
    key: "onActionBarSubmit",
    value: function onActionBarSubmit(submitType) {
      var _this$dropdownMenuPlu3;
      if (submitType === "accept") {
        var selectedColumn = this.getSelectedColumn();
        if (selectedColumn === null) {
          var _this$dropdownMenuPlu2;
          (_this$dropdownMenuPlu2 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu2 === void 0 ? void 0 : _this$dropdownMenuPlu2.close();
          return;
        }
        var physicalIndex = selectedColumn.physicalIndex;
        var byConditionState1 = this.components.get("filter_by_condition").getState();
        var byConditionState2 = this.components.get("filter_by_condition2").getState();
        var byValueState = this.components.get("filter_by_value").getState();
        var operation = this.getOperationBasedOnArguments(this.components.get("filter_operators").getActiveOperationId(), byConditionState1, byConditionState2, byValueState);
        this.conditionUpdateObserver.groupChanges();
        var columnStackPosition = this.conditionCollection.getColumnStackPosition(physicalIndex);
        if (columnStackPosition === -1) {
          columnStackPosition = void 0;
        }
        this.conditionCollection.removeConditions(physicalIndex);
        if (byConditionState1.command.key !== CONDITION_NAME$k) {
          this.conditionCollection.addCondition(physicalIndex, byConditionState1, operation, columnStackPosition);
          if (byConditionState2.command.key !== CONDITION_NAME$k) {
            this.conditionCollection.addCondition(physicalIndex, byConditionState2, operation, columnStackPosition);
          }
        }
        if (byValueState.command.key !== CONDITION_NAME$k) {
          this.conditionCollection.addCondition(physicalIndex, byValueState, operation, columnStackPosition);
        }
        this.conditionUpdateObserver.flush();
        this.components.forEach(function(component) {
          return component.saveState(physicalIndex);
        });
        this.filtersRowsMap.clear();
        this.filter();
      }
      (_this$dropdownMenuPlu3 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu3 === void 0 ? void 0 : _this$dropdownMenuPlu3.close();
    }
    /**
     * On component change listener.
     *
     * @private
     * @param {BaseComponent} component Component inheriting BaseComponent.
     * @param {object} command Menu item object (command).
     */
  }, {
    key: "onComponentChange",
    value: function onComponentChange(component, command) {
      this.updateDependentComponentsVisibility();
      if (component.constructor === ConditionComponent$1 && !command.inputsCount) {
        this.setListeningDropdownMenu();
      }
    }
    /**
     * On component SelectUI closed listener.
     *
     * @private
     */
  }, {
    key: "onSelectUIClosed",
    value: function onSelectUIClosed() {
      this.setListeningDropdownMenu();
    }
    /**
     * Listen to the keyboard input on document body and forward events to instance of Handsontable
     * created by DropdownMenu plugin.
     *
     * @private
     */
  }, {
    key: "setListeningDropdownMenu",
    value: function setListeningDropdownMenu() {
      if (this.dropdownMenuPlugin) {
        this.dropdownMenuPlugin.setListening();
      }
    }
    /**
     * Updates visibility of some of the components, based on the state of the parent component.
     *
     * @private
     */
  }, {
    key: "updateDependentComponentsVisibility",
    value: function updateDependentComponentsVisibility() {
      var component = this.components.get("filter_by_condition");
      var _component$getState = component.getState(), command = _component$getState.command;
      var componentsToShow = [this.components.get("filter_by_condition2"), this.components.get("filter_operators")];
      if (command.showOperators) {
        this.showComponents.apply(this, componentsToShow);
      } else {
        this.hideComponents.apply(this, componentsToShow);
      }
    }
    /**
     * On after get column header listener.
     *
     * @private
     * @param {number} col Visual column index.
     * @param {HTMLTableCellElement} TH Header's TH element.
     */
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(col, TH) {
      var physicalColumn = this.hot.toPhysicalColumn(col);
      if (this.enabled && this.conditionCollection.hasConditions(physicalColumn)) {
        addClass(TH, "htFiltersActive");
      } else {
        removeClass(TH, "htFiltersActive");
      }
    }
    /**
     * Creates DataFilter instance based on condition collection.
     *
     * @private
     * @param {ConditionCollection} conditionCollection Condition collection object.
     * @returns {DataFilter}
     */
  }, {
    key: "_createDataFilter",
    value: function _createDataFilter() {
      var _this8 = this;
      var conditionCollection = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.conditionCollection;
      return new DataFilter$1(conditionCollection, function(physicalColumn) {
        return _this8.getDataMapAtColumn(physicalColumn);
      });
    }
    /**
     * It updates the components state. The state is triggered by ConditionUpdateObserver, which
     * reacts to any condition added to the condition collection. It may be added through the UI
     * components or by API call.
     *
     * @private
     * @param {object} conditionsState An object with the state generated by UI components.
     */
  }, {
    key: "updateComponents",
    value: function updateComponents(conditionsState) {
      var _this$dropdownMenuPlu4;
      if (!((_this$dropdownMenuPlu4 = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu4 !== void 0 && _this$dropdownMenuPlu4.enabled)) {
        return;
      }
      var _conditionsState$edit = conditionsState.editedConditionStack, conditions2 = _conditionsState$edit.conditions, column = _conditionsState$edit.column;
      var conditionsByValue = conditions2.filter(function(condition2) {
        return condition2.name === CONDITION_NAME;
      });
      var conditionsWithoutByValue = conditions2.filter(function(condition2) {
        return condition2.name !== CONDITION_NAME;
      });
      if (conditionsByValue.length >= 2 || conditionsWithoutByValue.length >= 3) {
        warn$1(toSingleLine(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral$7(["The filter conditions have been applied properly, but couldnât be displayed visually. \n        The overall amount of conditions exceed the capability of the dropdown menu. \n        For more details see the documentation."], ["The filter conditions have been applied properly, but couldnât be displayed visually.\\x20\n        The overall amount of conditions exceed the capability of the dropdown menu.\\x20\n        For more details see the documentation."]))));
      } else {
        var operationType = this.conditionCollection.getOperation(column);
        this.components.get("filter_by_condition").updateState(conditionsWithoutByValue[0], column);
        this.components.get("filter_by_condition2").updateState(conditionsWithoutByValue[1], column);
        this.components.get("filter_operators").updateState(operationType, column);
        this.components.get("filter_by_value").updateState(conditionsState);
      }
    }
    /**
     * Returns indexes of passed components inside list of `dropdownMenu` items.
     *
     * @private
     * @param {...BaseComponent} components List of components.
     * @returns {Array}
     */
  }, {
    key: "getIndexesOfComponents",
    value: function getIndexesOfComponents() {
      var indexes = [];
      if (!this.dropdownMenuPlugin) {
        return indexes;
      }
      var menu = this.dropdownMenuPlugin.menu;
      for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {
        components[_key] = arguments[_key];
      }
      arrayEach(components, function(component) {
        arrayEach(menu.menuItems, function(item, index2) {
          if (item.key === component.getMenuItemDescriptor().key) {
            indexes.push(index2);
          }
        });
      });
      return indexes;
    }
    /**
     * Changes visibility of component.
     *
     * @private
     * @param {boolean} visible Determine if components should be visible.
     * @param {...BaseComponent} components List of components.
     */
  }, {
    key: "changeComponentsVisibility",
    value: function changeComponentsVisibility() {
      var visible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!this.dropdownMenuPlugin) {
        return;
      }
      var menu = this.dropdownMenuPlugin.menu;
      var hotMenu = menu.hotMenu;
      var hiddenRows = hotMenu.getPlugin("hiddenRows");
      for (var _len2 = arguments.length, components = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        components[_key2 - 1] = arguments[_key2];
      }
      var indexes = this.getIndexesOfComponents.apply(this, components);
      if (visible) {
        hiddenRows.showRows(indexes);
      } else {
        hiddenRows.hideRows(indexes);
      }
      hotMenu.render();
    }
    /**
     * Hides components of filters `dropdownMenu`.
     *
     * @private
     * @param {...BaseComponent} components List of components.
     */
  }, {
    key: "hideComponents",
    value: function hideComponents() {
      for (var _len3 = arguments.length, components = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        components[_key3] = arguments[_key3];
      }
      this.changeComponentsVisibility.apply(this, [false].concat(components));
    }
    /**
     * Shows components of filters `dropdownMenu`.
     *
     * @private
     * @param {...BaseComponent} components List of components.
     */
  }, {
    key: "showComponents",
    value: function showComponents() {
      for (var _len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        components[_key4] = arguments[_key4];
      }
      this.changeComponentsVisibility.apply(this, [true].concat(components));
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this9 = this;
      if (this.enabled) {
        this.components.forEach(function(component, key) {
          if (component !== null) {
            component.destroy();
            _this9.components.set(key, null);
          }
        });
        this.conditionCollection.destroy();
        this.conditionUpdateObserver.destroy();
        this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      }
      _get$l(_getPrototypeOf$p(Filters2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$i;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$h;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get2() {
      return ["plugin:DropdownMenu", "plugin:HiddenRows", "cell-type:checkbox"];
    }
  }]);
  return Filters2;
}(BasePlugin);
function ownKeys$5(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$7(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DEFAULT_LICENSE_KEY = "internal-use-in-handsontable";
var DEFAULT_SETTINGS = {
  licenseKey: DEFAULT_LICENSE_KEY,
  useArrayArithmetic: true,
  useColumnIndex: false,
  useStats: false,
  evaluateNullToZero: true,
  precisionEpsilon: 1e-13,
  precisionRounding: 14,
  smartRounding: true,
  leapYear1900: true,
  nullDate: {
    year: 1899,
    month: 12,
    day: 31
  },
  nullYear: 30,
  dateFormats: ["DD/MM/YYYY", "DD/MM/YY"],
  timeFormats: ["hh:mm", "hh:mm:ss.sss"],
  matchWholeCell: true,
  useRegularExpressions: false,
  useWildcards: true,
  functionArgSeparator: ",",
  thousandSeparator: "",
  decimalSeparator: ".",
  language: "enGB"
};
function getEngineSettingsOverrides(hotSettings) {
  var _hotSettings$PLUGIN_K, _hotSettings$PLUGIN_K2;
  return {
    maxColumns: hotSettings.maxColumns,
    maxRows: hotSettings.maxRows,
    language: (_hotSettings$PLUGIN_K = hotSettings[PLUGIN_KEY$h]) === null || _hotSettings$PLUGIN_K === void 0 ? void 0 : (_hotSettings$PLUGIN_K2 = _hotSettings$PLUGIN_K.language) === null || _hotSettings$PLUGIN_K2 === void 0 ? void 0 : _hotSettings$PLUGIN_K2.langCode
  };
}
function cleanEngineSettings(pluginSettings) {
  return Object.keys(pluginSettings).reduce(function(obj, key) {
    if (key !== "hyperformula") {
      obj[key] = pluginSettings[key];
    }
    return obj;
  }, {});
}
function getEngineSettingsWithDefaultsAndOverrides(hotSettings) {
  var _pluginSettings$engin;
  var pluginSettings = hotSettings[PLUGIN_KEY$h];
  var userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin = pluginSettings.engine) !== null && _pluginSettings$engin !== void 0 && _pluginSettings$engin.hyperformula ? pluginSettings.engine : {});
  var overrides = getEngineSettingsOverrides(hotSettings);
  return _objectSpread$5(_objectSpread$5(_objectSpread$5({}, DEFAULT_SETTINGS), userSettings), overrides);
}
function getEngineSettingsWithOverrides(hotSettings) {
  var _pluginSettings$engin2;
  var pluginSettings = hotSettings[PLUGIN_KEY$h];
  var userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin2 = pluginSettings.engine) !== null && _pluginSettings$engin2 !== void 0 && _pluginSettings$engin2.hyperformula ? pluginSettings.engine : {});
  var overrides = getEngineSettingsOverrides(hotSettings);
  return _objectSpread$5(_objectSpread$5({}, userSettings), overrides);
}
function _typeof$q(obj) {
  "@babel/helpers - typeof";
  return _typeof$q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$q(obj);
}
function getEngineRelationshipRegistry() {
  var registryKey = "engine_relationship";
  var pluginStaticRegistry = staticRegister(PLUGIN_KEY$h);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function getSharedEngineUsageRegistry() {
  var registryKey = "shared_engine_usage";
  var pluginStaticRegistry = staticRegister(PLUGIN_KEY$h);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function setupEngine(hotInstance) {
  var hotSettings = hotInstance.getSettings();
  var pluginSettings = hotSettings[PLUGIN_KEY$h];
  var engineConfigItem = pluginSettings === null || pluginSettings === void 0 ? void 0 : pluginSettings.engine;
  if (pluginSettings === true) {
    return null;
  }
  if (isUndefined(engineConfigItem)) {
    return null;
  }
  if (typeof engineConfigItem.hyperformula === "function" || typeof engineConfigItem === "function") {
    var _engineConfigItem$hyp;
    return registerEngine((_engineConfigItem$hyp = engineConfigItem.hyperformula) !== null && _engineConfigItem$hyp !== void 0 ? _engineConfigItem$hyp : engineConfigItem, hotSettings, hotInstance);
  } else if (_typeof$q(engineConfigItem) === "object" && isUndefined(engineConfigItem.hyperformula)) {
    var engineRelationship = getEngineRelationshipRegistry();
    var sharedEngineUsage = getSharedEngineUsageRegistry().get(engineConfigItem);
    if (!engineRelationship.has(engineConfigItem)) {
      engineRelationship.set(engineConfigItem, []);
    }
    engineRelationship.get(engineConfigItem).push(hotInstance);
    if (sharedEngineUsage) {
      sharedEngineUsage.push(hotInstance.guid);
    }
    if (!engineConfigItem.getConfig().licenseKey) {
      engineConfigItem.updateConfig({
        licenseKey: DEFAULT_LICENSE_KEY
      });
    }
    return engineConfigItem;
  }
  return null;
}
function registerEngine(engineClass, hotSettings, hotInstance) {
  var pluginSettings = hotSettings[PLUGIN_KEY$h];
  var engineSettings = getEngineSettingsWithDefaultsAndOverrides(hotSettings);
  var engineRegistry = getEngineRelationshipRegistry();
  var sharedEngineRegistry = getSharedEngineUsageRegistry();
  registerCustomFunctions(engineClass, pluginSettings.functions);
  registerLanguage(engineClass, pluginSettings.language);
  var engineInstance = engineClass.buildEmpty(engineSettings);
  engineRegistry.set(engineInstance, [hotInstance]);
  sharedEngineRegistry.set(engineInstance, [hotInstance.guid]);
  registerNamedExpressions(engineInstance, pluginSettings.namedExpressions);
  engineInstance.on("sheetAdded", function() {
    engineInstance.rebuildAndRecalculate();
  });
  engineInstance.on("sheetRemoved", function() {
    engineInstance.rebuildAndRecalculate();
  });
  return engineInstance;
}
function getRegisteredHotInstances(engine) {
  var _engineRegistry$get;
  var engineRegistry = getEngineRelationshipRegistry();
  var hotInstances = engineRegistry.size === 0 ? [] : Array.from((_engineRegistry$get = engineRegistry.get(engine)) !== null && _engineRegistry$get !== void 0 ? _engineRegistry$get : []);
  return new Map(hotInstances.map(function(hot) {
    return [hot.getPlugin("formulas").sheetId, hot];
  }));
}
function unregisterEngine(engine, hotInstance) {
  if (engine) {
    var engineRegistry = getEngineRelationshipRegistry();
    var engineHotRelationship = engineRegistry.get(engine);
    var sharedEngineRegistry = getSharedEngineUsageRegistry();
    var sharedEngineUsage = sharedEngineRegistry.get(engine);
    if (engineHotRelationship && engineHotRelationship.includes(hotInstance)) {
      engineHotRelationship.splice(engineHotRelationship.indexOf(hotInstance), 1);
      if (engineHotRelationship.length === 0) {
        engineRegistry.delete(engine);
      }
    }
    if (sharedEngineUsage && sharedEngineUsage.includes(hotInstance.guid)) {
      sharedEngineUsage.splice(sharedEngineUsage.indexOf(hotInstance.guid), 1);
      if (sharedEngineUsage.length === 0) {
        sharedEngineRegistry.delete(engine);
        engine.destroy();
      }
    }
  }
}
function registerCustomFunctions(engineClass, customFunctions) {
  if (customFunctions) {
    customFunctions.forEach(function(func) {
      var name = func.name, plugin = func.plugin, translations = func.translations;
      try {
        engineClass.registerFunction(name, plugin, translations);
      } catch (e2) {
        warn$1(e2.message);
      }
    });
  }
}
function registerLanguage(engineClass, languageSetting) {
  if (languageSetting) {
    var langCode = languageSetting.langCode;
    try {
      engineClass.registerLanguage(langCode, languageSetting);
    } catch (e2) {
      warn$1(e2.message);
    }
  }
}
function registerNamedExpressions(engineInstance, namedExpressions) {
  if (namedExpressions) {
    engineInstance.suspendEvaluation();
    namedExpressions.forEach(function(namedExp) {
      var name = namedExp.name, expression = namedExp.expression, scope = namedExp.scope, options = namedExp.options;
      try {
        engineInstance.addNamedExpression(name, expression, scope, options);
      } catch (e2) {
        warn$1(e2.message);
      }
    });
    engineInstance.resumeEvaluation();
  }
}
function setupSheet(engineInstance, sheetName) {
  if (isUndefined(sheetName) || !engineInstance.doesSheetExist(sheetName)) {
    sheetName = engineInstance.addSheet(sheetName);
  }
  return sheetName;
}
function isEscapedFormulaExpression(expression) {
  return typeof expression === "string" && expression.charAt(0) === "'" && expression.charAt(1) === "=";
}
function unescapeFormulaExpression(expression) {
  return isEscapedFormulaExpression(expression) ? expression.substr(1) : expression;
}
function _toConsumableArray$c(arr) {
  return _arrayWithoutHoles$c(arr) || _iterableToArray$d(arr) || _unsupportedIterableToArray$j(arr) || _nonIterableSpread$c();
}
function _nonIterableSpread$c() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$d(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$c(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$j(arr);
}
function ownKeys$4(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof$p(obj) {
  "@babel/helpers - typeof";
  return _typeof$p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$p(obj);
}
function _slicedToArray$8(arr, i) {
  return _arrayWithHoles$9(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$j(arr, i) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$j(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$j(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$j(o, minLen);
}
function _arrayLikeToArray$j(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$8(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$9(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$D(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$D(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$D(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$D(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$D(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$k() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$k = Reflect.get.bind();
  } else {
    _get$k = function _get2(target, property, receiver) {
      var base = _superPropBase$k(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$k.apply(this, arguments);
}
function _superPropBase$k(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$o(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$o(subClass, superClass);
}
function _setPrototypeOf$o(o, p2) {
  _setPrototypeOf$o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$o(o, p2);
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$o(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$o(this, result);
  };
}
function _possibleConstructorReturn$o(self2, call2) {
  if (call2 && (_typeof$p(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$o(self2);
}
function _assertThisInitialized$o(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$o(o) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$o(o);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldInitSpec$6(obj, privateMap, value) {
  _checkPrivateRedeclaration$6(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$6(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet$6(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$6(receiver, privateMap, "set");
  _classApplyDescriptorSet$6(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet$6(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet$6(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$6(receiver, privateMap, "get");
  return _classApplyDescriptorGet$6(receiver, descriptor);
}
function _classExtractFieldDescriptor$6(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet$6(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY$h = "formulas";
var PLUGIN_PRIORITY$g = 260;
var ROW_MOVE_UNDO_REDO_NAME = "row_move";
Hooks$1.getSingleton().register("afterNamedExpressionAdded");
Hooks$1.getSingleton().register("afterNamedExpressionRemoved");
Hooks$1.getSingleton().register("afterSheetAdded");
Hooks$1.getSingleton().register("afterSheetRemoved");
Hooks$1.getSingleton().register("afterSheetRenamed");
Hooks$1.getSingleton().register("afterFormulasValuesUpdate");
var isBlockedSource = function isBlockedSource2(source) {
  return source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto";
};
var _internalOperationPending = /* @__PURE__ */ new WeakMap();
var _hotWasInitializedWithEmptyData = /* @__PURE__ */ new WeakMap();
var _engineListeners = /* @__PURE__ */ new WeakMap();
var Formulas = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$o(Formulas2, _BasePlugin);
  var _super = _createSuper$o(Formulas2);
  function Formulas2() {
    var _this;
    _classCallCheck$D(this, Formulas2);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(_args));
    _classPrivateFieldInitSpec$6(_assertThisInitialized$o(_this), _internalOperationPending, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$6(_assertThisInitialized$o(_this), _hotWasInitializedWithEmptyData, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$6(_assertThisInitialized$o(_this), _engineListeners, {
      writable: true,
      value: [["valuesUpdated", function() {
        var _this2;
        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);
      }], ["namedExpressionAdded", function() {
        var _this3;
        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);
      }], ["namedExpressionRemoved", function() {
        var _this4;
        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);
      }], ["sheetAdded", function() {
        var _this5;
        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);
      }], ["sheetRenamed", function() {
        var _this6;
        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);
      }], ["sheetRemoved", function() {
        var _this7;
        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);
      }]]
    });
    _defineProperty$6(_assertThisInitialized$o(_this), "staticRegister", staticRegister("formulas"));
    _defineProperty$6(_assertThisInitialized$o(_this), "engine", null);
    _defineProperty$6(_assertThisInitialized$o(_this), "sheetName", null);
    return _this;
  }
  _createClass$D(Formulas2, [{
    key: "sheetId",
    get: (
      /**
       * HyperFormula's sheet id.
       *
       * @type {number|null}
       */
      function get2() {
        return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);
      }
    )
    /**
     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
     * hook and if it returns `true` than the {@link Formulas#enablePlugin} method is called.
     *
     * @returns {boolean}
     */
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$h] ? true : false;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _setupEngine, _this8 = this;
      if (this.enabled) {
        return;
      }
      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;
      if (!this.engine) {
        warn$1("Missing the required `engine` key in the Formulas settings. Please fill it with either an engine class or an engine instance.");
        return;
      }
      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {
        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());
        if (newSheetName !== false) {
          this.sheetName = newSheetName;
        }
      }
      this.addHook("beforeLoadData", function() {
        return _this8.onBeforeLoadData.apply(_this8, arguments);
      });
      this.addHook("afterLoadData", function() {
        return _this8.onAfterLoadData.apply(_this8, arguments);
      });
      this.addHook("modifyData", function() {
        return _this8.onModifyData.apply(_this8, arguments);
      });
      this.addHook("modifySourceData", function() {
        return _this8.onModifySourceData.apply(_this8, arguments);
      });
      this.addHook("beforeValidate", function() {
        return _this8.onBeforeValidate.apply(_this8, arguments);
      });
      this.addHook("afterSetSourceDataAtCell", function() {
        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);
      });
      this.addHook("afterSetDataAtCell", function() {
        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);
      });
      this.addHook("afterSetDataAtRowProp", function() {
        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);
      });
      this.addHook("beforeCreateRow", function() {
        return _this8.onBeforeCreateRow.apply(_this8, arguments);
      });
      this.addHook("beforeCreateCol", function() {
        return _this8.onBeforeCreateCol.apply(_this8, arguments);
      });
      this.addHook("afterCreateRow", function() {
        return _this8.onAfterCreateRow.apply(_this8, arguments);
      });
      this.addHook("afterCreateCol", function() {
        return _this8.onAfterCreateCol.apply(_this8, arguments);
      });
      this.addHook("beforeRemoveRow", function() {
        return _this8.onBeforeRemoveRow.apply(_this8, arguments);
      });
      this.addHook("beforeRemoveCol", function() {
        return _this8.onBeforeRemoveCol.apply(_this8, arguments);
      });
      this.addHook("afterRemoveRow", function() {
        return _this8.onAfterRemoveRow.apply(_this8, arguments);
      });
      this.addHook("afterRemoveCol", function() {
        return _this8.onAfterRemoveCol.apply(_this8, arguments);
      });
      this.addHook("beforeUndo", function(action) {
        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {
          return;
        }
        _this8.engine.undo();
      });
      this.addHook("beforeRedo", function(action) {
        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {
          return;
        }
        _this8.engine.redo();
      });
      this.addHook("afterDetachChild", function() {
        return _this8.onAfterDetachChild.apply(_this8, arguments);
      });
      this.addHook("beforeAutofill", function() {
        return _this8.onBeforeAutofill.apply(_this8, arguments);
      });
      _classPrivateFieldGet$6(this, _engineListeners).forEach(function(_ref2) {
        var _ref22 = _slicedToArray$8(_ref2, 2), eventName = _ref22[0], listener2 = _ref22[1];
        return _this8.engine.on(eventName, listener2);
      });
      _get$k(_getPrototypeOf$o(Formulas2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this9 = this;
      _classPrivateFieldGet$6(this, _engineListeners).forEach(function(_ref3) {
        var _ref4 = _slicedToArray$8(_ref3, 2), eventName = _ref4[0], listener2 = _ref4[1];
        return _this9.engine.off(eventName, listener2);
      });
      unregisterEngine(this.engine, this.hot);
      this.engine = null;
      _get$k(_getPrototypeOf$o(Formulas2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Triggered on `updateSettings`.
     *
     * @private
     * @param {object} newSettings New set of settings passed to the `updateSettings` method.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin(newSettings) {
      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$h];
      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {
        this.switchSheet(pluginSettings.sheetName);
      }
      if (!newSettings.data && this.sheetName === null) {
        var sheetName = this.hot.getSettings()[PLUGIN_KEY$h].sheetName;
        if (sheetName && this.engine.doesSheetExist(sheetName)) {
          this.switchSheet(this.sheetName);
        } else {
          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());
        }
      }
      _get$k(_getPrototypeOf$o(Formulas2.prototype), "updatePlugin", this).call(this, newSettings);
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this10 = this;
      _classPrivateFieldGet$6(this, _engineListeners).forEach(function(_ref5) {
        var _this10$engine;
        var _ref6 = _slicedToArray$8(_ref5, 2), eventName = _ref6[0], listener2 = _ref6[1];
        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener2);
      });
      _classPrivateFieldSet$6(this, _engineListeners, null);
      unregisterEngine(this.engine, this.hot);
      this.engine = null;
      _get$k(_getPrototypeOf$o(Formulas2.prototype), "destroy", this).call(this);
    }
    /**
     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.
     *
     * @private
     * @param {number} visualIndex Visual entry index.
     * @param {number} physicalIndex Physical entry index.
     * @param {number} entriesCount Visual entries count.
     * @param {number} sourceEntriesCount Source entries count.
     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically
     * `toPhysical` alias.
     * @returns {*}
     */
  }, {
    key: "getPhysicalIndexPosition",
    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {
      if (!contained) {
        if (visualIndex >= entriesCount) {
          return sourceEntriesCount + (visualIndex - entriesCount);
        }
      }
      return physicalIndex;
    }
    /**
     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return
     * `null` on rows with indexes higher than the number of rows.
     *
     * @private
     * @param {number} row Visual row index.
     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically
     * `toPhysical` alias.
     * @returns {number} The physical row index.
     */
  }, {
    key: "toPhysicalRowPosition",
    value: function toPhysicalRowPosition(row) {
      var contained = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);
    }
    /**
     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return
     * `null` on columns with indexes higher than the number of columns.
     *
     * @private
     * @param {number} column Visual column index.
     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically
     * `toPhysical` alias.
     * @returns {number} The physical column index.
     */
  }, {
    key: "toPhysicalColumnPosition",
    value: function toPhysicalColumnPosition(column) {
      var contained = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);
    }
    /**
     * Add a sheet to the shared HyperFormula instance.
     *
     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be
     * auto-generated by HyperFormula.
     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of
     * arrays - array of objects is not supported in this scenario.
     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the
     * engine, the created sheet name otherwise.
     */
  }, {
    key: "addSheet",
    value: function addSheet(sheetName, sheetData) {
      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {
        warn$1("The provided data should be an array of arrays.");
        return false;
      }
      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {
        warn$1("Sheet with the provided name already exists.");
        return false;
      }
      try {
        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);
        if (sheetData) {
          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);
        }
        return actualSheetName;
      } catch (e2) {
        warn$1(e2.message);
        return false;
      }
    }
    /**
     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula
     * instance).
     *
     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.
     */
  }, {
    key: "switchSheet",
    value: function switchSheet(sheetName) {
      if (!this.engine.doesSheetExist(sheetName)) {
        error("The sheet named `".concat(sheetName, "` does not exist, switch aborted."));
        return;
      }
      this.sheetName = sheetName;
      var serialized = this.engine.getSheetSerialized(this.sheetId);
      if (serialized.length > 0) {
        this.hot.loadData(serialized, "".concat(toUpperCaseFirst(PLUGIN_KEY$h), ".switchSheet"));
      }
    }
    /**
     * Get the cell type under specified visual coordinates.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {number} [sheet] The target sheet id, defaults to the current sheet.
     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.
     */
  }, {
    key: "getCellType",
    value: function getCellType(row, column) {
      var sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
      var physicalRow = this.hot.toPhysicalRow(row);
      var physicalColumn = this.hot.toPhysicalColumn(column);
      if (physicalRow !== null && physicalColumn !== null) {
        return this.engine.getCellType({
          sheet,
          row: physicalRow,
          col: physicalColumn
        });
      } else {
        return "EMPTY";
      }
    }
    /**
     * Returns `true` if under specified visual coordinates is formula.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {number} [sheet] The target sheet id, defaults to the current sheet.
     * @returns {boolean}
     */
  }, {
    key: "isFormulaCellType",
    value: function isFormulaCellType(row, column) {
      var sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
      var physicalRow = this.hot.toPhysicalRow(row);
      var physicalColumn = this.hot.toPhysicalColumn(column);
      if (physicalRow === null || physicalColumn === null) {
        return false;
      }
      return this.engine.doesCellHaveFormula({
        sheet,
        row: physicalRow,
        col: physicalColumn
      });
    }
    /**
     * Renders dependent sheets (handsontable instances) based on the changes - list of the
     * recalculated dependent cells.
     *
     * @private
     * @param {object[]} dependentCells The values and location of applied changes within HF engine.
     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.
     */
  }, {
    key: "renderDependentSheets",
    value: function renderDependentSheets(dependentCells) {
      var _this11 = this;
      var renderSelf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var affectedSheetIds = /* @__PURE__ */ new Set();
      dependentCells.forEach(function(change) {
        var _change$address;
        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;
        if (sheetId !== void 0) {
          if (!affectedSheetIds.has(sheetId)) {
            affectedSheetIds.add(sheetId);
          }
        }
      });
      getRegisteredHotInstances(this.engine).forEach(function(relatedHot, sheetId) {
        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {
          var _relatedHot$view;
          relatedHot.render();
          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();
        }
      });
    }
    /**
     * Validates dependent cells based on the cells that are modified by the change.
     *
     * @private
     * @param {object[]} dependentCells The values and location of applied changes within HF engine.
     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).
     */
  }, {
    key: "validateDependentCells",
    value: function validateDependentCells(dependentCells) {
      var _this12 = this;
      var changedCells = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var stringifyAddress = function stringifyAddress2(change) {
        var _change$address2;
        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {}, row = _ref7.row, col = _ref7.col, sheet = _ref7.sheet;
        return isDefined(sheet) ? "".concat(sheet, ":").concat(row, "x").concat(col) : "";
      };
      var changedCellsSet = new Set(changedCells.map(function(change) {
        return stringifyAddress(change);
      }));
      dependentCells.forEach(function(change) {
        var _change$address3, _change$address4;
        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {}, row = _ref8.row, col = _ref8.col;
        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;
        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null;
        if (visualRow === null || visualColumn === null) {
          return;
        }
        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;
        var addressId = stringifyAddress(change);
        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {
          var boundHot = getRegisteredHotInstances(_this12.engine).get(sheetId);
          if (!boundHot) {
            return;
          }
          boundHot.validateCell(boundHot.getDataAtCell(visualRow, visualColumn), boundHot.getCellMeta(visualRow, visualColumn), function() {
          });
        }
      });
    }
    /**
     * Sync a change from the change-related hooks with the engine.
     *
     * @private
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {Handsontable.CellValue} newValue New value.
     * @returns {Array} Array of changes exported from the engine.
     */
  }, {
    key: "syncChangeWithEngine",
    value: function syncChangeWithEngine(row, column, newValue) {
      var address = {
        row: this.toPhysicalRowPosition(row),
        col: this.toPhysicalColumnPosition(column),
        sheet: this.sheetId
      };
      if (!this.engine.isItPossibleToSetCellContents(address)) {
        warn$1("Not possible to set cell data at ".concat(JSON.stringify(address)));
        return;
      }
      return this.engine.setCellContents(address, newValue);
    }
    /**
     * The hook allows to translate the formula value to calculated value before it goes to the
     * validator function.
     *
     * @private
     * @param {*} value The cell value to validate.
     * @param {number} visualRow The visual row index.
     * @param {number|string} prop The visual column index or property name of the column.
     * @returns {*} Returns value to validate.
     */
  }, {
    key: "onBeforeValidate",
    value: function onBeforeValidate(value, visualRow, prop) {
      var visualColumn = this.hot.propToCol(prop);
      if (this.isFormulaCellType(visualRow, visualColumn)) {
        var address = {
          row: this.hot.toPhysicalRow(visualRow),
          col: this.hot.toPhysicalColumn(visualColumn),
          sheet: this.sheetId
        };
        var cellValue = this.engine.getCellValue(address);
        return _typeof$p(cellValue) === "object" && cellValue !== null ? cellValue.value : cellValue;
      }
      return value;
    }
    /**
     * `onBeforeAutofill` hook callback.
     *
     * @private
     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used
     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.
     * @param {CellRange} sourceRange The range values will be filled from.
     * @param {CellRange} targetRange The range new values will be filled into.
     * @returns {boolean|*}
     */
  }, {
    key: "onBeforeAutofill",
    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {
      var _this13 = this;
      var withSheetId = function withSheetId2(range) {
        return _objectSpread$4(_objectSpread$4({}, range), {}, {
          sheet: _this13.sheetId
        });
      };
      var engineSourceRange = {
        start: withSheetId(sourceRange.getTopStartCorner()),
        end: withSheetId(sourceRange.getBottomEndCorner())
      };
      var engineTargetRange = {
        start: withSheetId(targetRange.getTopStartCorner()),
        end: withSheetId(targetRange.getBottomEndCorner())
      };
      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {
        return false;
      }
      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);
    }
    /**
     * `beforeLoadData` hook callback.
     *
     * @param {Array} sourceData Array of arrays or array of objects containing data.
     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.
     * @param {string} [source] Source of the call.
     * @private
     */
  }, {
    key: "onBeforeLoadData",
    value: function onBeforeLoadData(sourceData, initialLoad) {
      var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      if (source.includes(toUpperCaseFirst(PLUGIN_KEY$h))) {
        return;
      }
      _classPrivateFieldSet$6(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));
    }
    /**
     * `afterLoadData` hook callback.
     *
     * @param {Array} sourceData Array of arrays or array of objects containing data.
     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.
     * @param {string} [source] Source of the call.
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(sourceData, initialLoad) {
      var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      if (source.includes(toUpperCaseFirst(PLUGIN_KEY$h))) {
        return;
      }
      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY$h].sheetName);
      if (!_classPrivateFieldGet$6(this, _hotWasInitializedWithEmptyData)) {
        var sourceDataArray = this.hot.getSourceDataArray();
        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {
          _classPrivateFieldSet$6(this, _internalOperationPending, true);
          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());
          this.renderDependentSheets(dependentCells);
          _classPrivateFieldSet$6(this, _internalOperationPending, false);
        }
      } else {
        this.switchSheet(this.sheetName);
      }
    }
    /**
     * `modifyData` hook callback.
     *
     * @private
     * @param {number} row Physical row height.
     * @param {number} column Physical column index.
     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`
     *   property.
     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
     */
  }, {
    key: "onModifyData",
    value: function onModifyData(row, column, valueHolder, ioMode) {
      if (ioMode !== "get" || _classPrivateFieldGet$6(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
        return;
      }
      var visualRow = this.hot.toVisualRow(row);
      var isFormulaCellType = this.isFormulaCellType(visualRow, column);
      if (!isFormulaCellType) {
        var cellType = this.getCellType(visualRow, column);
        if (cellType !== "ARRAY") {
          if (isEscapedFormulaExpression(valueHolder.value)) {
            valueHolder.value = unescapeFormulaExpression(valueHolder.value);
          }
          return;
        }
      }
      var address = {
        row,
        col: this.toPhysicalColumnPosition(column),
        sheet: this.sheetId
      };
      var cellValue = this.engine.getCellValue(address);
      var value = _typeof$p(cellValue) === "object" && cellValue !== null ? cellValue.value : cellValue;
      valueHolder.value = value;
    }
    /**
     * `modifySourceData` hook callback.
     *
     * @private
     * @param {number} row Physical row index.
     * @param {number|string} columnOrProp Physical column index or prop.
     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`
     *   property.
     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
     */
  }, {
    key: "onModifySourceData",
    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {
      if (ioMode !== "get" || _classPrivateFieldGet$6(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
        return;
      }
      var visualRow = this.hot.toVisualRow(row);
      var visualColumn = this.hot.propToCol(columnOrProp);
      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);
      if (!isFormulaCellType) {
        var cellType = this.getCellType(visualRow, visualColumn);
        if (cellType !== "ARRAY") {
          return;
        }
      }
      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));
      if (dimensions.width === 0 && dimensions.height === 0) {
        return;
      }
      var address = {
        row,
        // Workaround for inconsistencies in `src/dataSource.js`
        col: this.toPhysicalColumnPosition(visualColumn),
        sheet: this.sheetId
      };
      valueHolder.value = this.engine.getCellSerialized(address);
    }
    /**
     * `onAfterSetDataAtCell` hook callback.
     *
     * @private
     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].
     * @param {string} [source] String that identifies source of hook call
     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
     */
  }, {
    key: "onAfterSetDataAtCell",
    value: function onAfterSetDataAtCell(changes, source) {
      var _this14 = this;
      if (isBlockedSource(source)) {
        return;
      }
      var outOfBoundsChanges = [];
      var changedCells = [];
      var dependentCells = this.engine.batch(function() {
        changes.forEach(function(_ref9) {
          var _ref10 = _slicedToArray$8(_ref9, 4), row = _ref10[0], prop = _ref10[1], newValue = _ref10[3];
          var column = _this14.hot.propToCol(prop);
          var physicalRow = _this14.hot.toPhysicalRow(row);
          var physicalColumn = _this14.hot.toPhysicalColumn(column);
          var address = {
            row: physicalRow,
            col: physicalColumn,
            sheet: _this14.sheetId
          };
          if (physicalRow !== null && physicalColumn !== null) {
            _this14.syncChangeWithEngine(row, column, newValue);
          } else {
            outOfBoundsChanges.push([row, column, newValue]);
          }
          changedCells.push({
            address
          });
        });
      });
      if (outOfBoundsChanges.length) {
        this.hot.addHookOnce("afterChange", function() {
          var outOfBoundsDependentCells = _this14.engine.batch(function() {
            outOfBoundsChanges.forEach(function(_ref11) {
              var _ref12 = _slicedToArray$8(_ref11, 3), row = _ref12[0], column = _ref12[1], newValue = _ref12[2];
              _this14.syncChangeWithEngine(row, column, newValue);
            });
          });
          _this14.renderDependentSheets(outOfBoundsDependentCells, true);
        });
      }
      this.renderDependentSheets(dependentCells);
      this.validateDependentCells(dependentCells, changedCells);
    }
    /**
     * `onAfterSetSourceDataAtCell` hook callback.
     *
     * @private
     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].
     * @param {string} [source] String that identifies source of hook call
     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
     */
  }, {
    key: "onAfterSetSourceDataAtCell",
    value: function onAfterSetSourceDataAtCell(changes, source) {
      var _this15 = this;
      if (isBlockedSource(source)) {
        return;
      }
      var dependentCells = [];
      var changedCells = [];
      changes.forEach(function(_ref13) {
        var _ref14 = _slicedToArray$8(_ref13, 4), row = _ref14[0], prop = _ref14[1], newValue = _ref14[3];
        var column = _this15.hot.propToCol(prop);
        if (!isNumeric(column)) {
          return;
        }
        var address = {
          row,
          col: _this15.toPhysicalColumnPosition(column),
          sheet: _this15.sheetId
        };
        if (!_this15.engine.isItPossibleToSetCellContents(address)) {
          warn$1("Not possible to set source cell data at ".concat(JSON.stringify(address)));
          return;
        }
        changedCells.push({
          address
        });
        dependentCells.push.apply(dependentCells, _toConsumableArray$c(_this15.engine.setCellContents(address, newValue)));
      });
      this.renderDependentSheets(dependentCells);
      this.validateDependentCells(dependentCells, changedCells);
    }
    /**
     * `beforeCreateRow` hook callback.
     *
     * @private
     * @param {number} row Represents the visual index of first newly created row in the data source array.
     * @param {number} amount Number of newly created rows in the data source array.
     * @returns {*|boolean} If false is returned the action is canceled.
     */
  }, {
    key: "onBeforeCreateRow",
    value: function onBeforeCreateRow(row, amount) {
      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {
        return false;
      }
    }
    /**
     * `beforeCreateCol` hook callback.
     *
     * @private
     * @param {number} col Represents the visual index of first newly created column in the data source.
     * @param {number} amount Number of newly created columns in the data source.
     * @returns {*|boolean} If false is returned the action is canceled.
     */
  }, {
    key: "onBeforeCreateCol",
    value: function onBeforeCreateCol(col, amount) {
      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {
        return false;
      }
    }
    /**
     * `beforeRemoveRow` hook callback.
     *
     * @private
     * @param {number} row Visual index of starter row.
     * @param {number} amount Amount of rows to be removed.
     * @param {number[]} physicalRows An array of physical rows removed from the data source.
     * @returns {*|boolean} If false is returned the action is canceled.
     */
  }, {
    key: "onBeforeRemoveRow",
    value: function onBeforeRemoveRow(row, amount, physicalRows) {
      var _this16 = this;
      var possible = physicalRows.every(function(physicalRow) {
        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);
      });
      return possible === false ? false : void 0;
    }
    /**
     * `beforeRemoveCol` hook callback.
     *
     * @private
     * @param {number} col Visual index of starter column.
     * @param {number} amount Amount of columns to be removed.
     * @param {number[]} physicalColumns An array of physical columns removed from the data source.
     * @returns {*|boolean} If false is returned the action is canceled.
     */
  }, {
    key: "onBeforeRemoveCol",
    value: function onBeforeRemoveCol(col, amount, physicalColumns) {
      var _this17 = this;
      var possible = physicalColumns.every(function(physicalColumn) {
        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);
      });
      return possible === false ? false : void 0;
    }
    /**
     * `afterCreateRow` hook callback.
     *
     * @private
     * @param {number} row Represents the visual index of first newly created row in the data source array.
     * @param {number} amount Number of newly created rows in the data source array.
     * @param {string} [source] String that identifies source of hook call
     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
     */
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(row, amount, source) {
      if (isBlockedSource(source)) {
        return;
      }
      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);
      this.renderDependentSheets(changes);
    }
    /**
     * `afterCreateCol` hook callback.
     *
     * @private
     * @param {number} col Represents the visual index of first newly created column in the data source.
     * @param {number} amount Number of newly created columns in the data source.
     * @param {string} [source] String that identifies source of hook call
     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
     */
  }, {
    key: "onAfterCreateCol",
    value: function onAfterCreateCol(col, amount, source) {
      if (isBlockedSource(source)) {
        return;
      }
      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);
      this.renderDependentSheets(changes);
    }
    /**
     * `afterRemoveRow` hook callback.
     *
     * @private
     * @param {number} row Visual index of starter row.
     * @param {number} amount An amount of removed rows.
     * @param {number[]} physicalRows An array of physical rows removed from the data source.
     * @param {string} [source] String that identifies source of hook call
     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
     */
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(row, amount, physicalRows, source) {
      var _this18 = this;
      if (isBlockedSource(source)) {
        return;
      }
      var descendingPhysicalRows = physicalRows.sort().reverse();
      var changes = this.engine.batch(function() {
        descendingPhysicalRows.forEach(function(physicalRow) {
          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);
        });
      });
      this.renderDependentSheets(changes);
    }
    /**
     * `afterRemoveCol` hook callback.
     *
     * @private
     * @param {number} col Visual index of starter column.
     * @param {number} amount An amount of removed columns.
     * @param {number[]} physicalColumns An array of physical columns removed from the data source.
     * @param {string} [source] String that identifies source of hook call
     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
     */
  }, {
    key: "onAfterRemoveCol",
    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {
      var _this19 = this;
      if (isBlockedSource(source)) {
        return;
      }
      var descendingPhysicalColumns = physicalColumns.sort().reverse();
      var changes = this.engine.batch(function() {
        descendingPhysicalColumns.forEach(function(physicalColumn) {
          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);
        });
      });
      this.renderDependentSheets(changes);
    }
    /**
     * `afterDetachChild` hook callback.
     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.
     *
     * @private
     * @param {object} parent An object representing the parent from which the element was detached.
     * @param {object} element The detached element.
     * @param {number} finalElementRowIndex The final row index of the detached element.
     */
  }, {
    key: "onAfterDetachChild",
    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {
      var _element$__children, _this20 = this;
      _classPrivateFieldSet$6(this, _internalOperationPending, true);
      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());
      _classPrivateFieldSet$6(this, _internalOperationPending, false);
      rowsData.forEach(function(row, relativeRowIndex) {
        row.forEach(function(value, colIndex) {
          _this20.engine.setCellContents({
            col: colIndex,
            row: finalElementRowIndex + relativeRowIndex,
            sheet: _this20.sheetId
          }, [[value]]);
        });
      });
    }
    /**
     * Called when a value is updated in the engine.
     *
     * @private
     * @fires Hooks#afterFormulasValuesUpdate
     * @param {Array} changes The values and location of applied changes.
     */
  }, {
    key: "onEngineValuesUpdated",
    value: function onEngineValuesUpdated(changes) {
      this.hot.runHooks("afterFormulasValuesUpdate", changes);
    }
    /**
     * Called when a named expression is added to the engine instance.
     *
     * @private
     * @fires Hooks#afterNamedExpressionAdded
     * @param {string} namedExpressionName The name of the added expression.
     * @param {Array} changes The values and location of applied changes.
     */
  }, {
    key: "onEngineNamedExpressionsAdded",
    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {
      this.hot.runHooks("afterNamedExpressionAdded", namedExpressionName, changes);
    }
    /**
     * Called when a named expression is removed from the engine instance.
     *
     * @private
     * @fires Hooks#afterNamedExpressionRemoved
     * @param {string} namedExpressionName The name of the removed expression.
     * @param {Array} changes The values and location of applied changes.
     */
  }, {
    key: "onEngineNamedExpressionsRemoved",
    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {
      this.hot.runHooks("afterNamedExpressionRemoved", namedExpressionName, changes);
    }
    /**
     * Called when a new sheet is added to the engine instance.
     *
     * @private
     * @fires Hooks#afterSheetAdded
     * @param {string} addedSheetDisplayName The name of the added sheet.
     */
  }, {
    key: "onEngineSheetAdded",
    value: function onEngineSheetAdded(addedSheetDisplayName) {
      this.hot.runHooks("afterSheetAdded", addedSheetDisplayName);
    }
    /**
     * Called when a sheet in the engine instance is renamed.
     *
     * @private
     * @fires Hooks#afterSheetRenamed
     * @param {string} oldDisplayName The old name of the sheet.
     * @param {string} newDisplayName The new name of the sheet.
     */
  }, {
    key: "onEngineSheetRenamed",
    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {
      this.hot.runHooks("afterSheetRenamed", oldDisplayName, newDisplayName);
    }
    /**
     * Called when a sheet is removed from the engine instance.
     *
     * @private
     * @fires Hooks#afterSheetRemoved
     * @param {string} removedSheetDisplayName The removed sheet name.
     * @param {Array} changes The values and location of applied changes.
     */
  }, {
    key: "onEngineSheetRemoved",
    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {
      this.hot.runHooks("afterSheetRemoved", removedSheetDisplayName, changes);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$h;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$g;
    }
    /**
     * Flag used to bypass hooks in internal operations.
     *
     * @private
     * @type {boolean}
     */
  }]);
  return Formulas2;
}(BasePlugin);
function _slicedToArray$7(arr, i) {
  return _arrayWithHoles$8(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$i(arr, i) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$i(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$i(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$i(o, minLen);
}
function _arrayLikeToArray$i(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$7(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$8(arr) {
  if (Array.isArray(arr))
    return arr;
}
function hideColumnItem(hiddenColumnsPlugin) {
  return {
    key: "hidden_columns_hide",
    name: function name() {
      var selection = this.getSelectedLast();
      var pluralForm = 0;
      if (Array.isArray(selection)) {
        var _selection = _slicedToArray$7(selection, 4), fromColumn = _selection[1], toColumn = _selection[3];
        if (fromColumn - toColumn !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_COLUMN, pluralForm);
    },
    callback: function callback() {
      var _this$getSelectedRang = this.getSelectedRangeLast(), from3 = _this$getSelectedRang.from, to = _this$getSelectedRang.to;
      var start = Math.max(Math.min(from3.col, to.col), 0);
      var end = Math.max(from3.col, to.col);
      var columnsToHide = [];
      for (var visualColumn = start; visualColumn <= end; visualColumn += 1) {
        columnsToHide.push(visualColumn);
      }
      hiddenColumnsPlugin.hideColumns(columnsToHide);
      var lastHiddenColumn = columnsToHide[columnsToHide.length - 1];
      var columnToSelect = this.columnIndexMapper.getNearestNotHiddenIndex(lastHiddenColumn, 1, true);
      if (Number.isInteger(columnToSelect) && columnToSelect >= 0) {
        this.selectColumns(columnToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden: function hidden() {
      return !(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner());
    }
  };
}
function _toConsumableArray$b(arr) {
  return _arrayWithoutHoles$b(arr) || _iterableToArray$c(arr) || _unsupportedIterableToArray$h(arr) || _nonIterableSpread$b();
}
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$h(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$h(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$h(o, minLen);
}
function _iterableToArray$c(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$b(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$h(arr);
}
function _arrayLikeToArray$h(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function showColumnItem(hiddenColumnsPlugin) {
  var columns = [];
  return {
    key: "hidden_columns_show",
    name: function name() {
      var pluralForm = columns.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_COLUMN, pluralForm);
    },
    callback: function callback() {
      var _this$columnIndexMapp, _this$columnIndexMapp2;
      if (columns.length === 0) {
        return;
      }
      var startVisualColumn = columns[0];
      var endVisualColumn = columns[columns.length - 1];
      startVisualColumn = (_this$columnIndexMapp = this.columnIndexMapper.getNearestNotHiddenIndex(startVisualColumn - 1, -1)) !== null && _this$columnIndexMapp !== void 0 ? _this$columnIndexMapp : 0;
      endVisualColumn = (_this$columnIndexMapp2 = this.columnIndexMapper.getNearestNotHiddenIndex(endVisualColumn + 1, 1)) !== null && _this$columnIndexMapp2 !== void 0 ? _this$columnIndexMapp2 : this.countCols() - 1;
      hiddenColumnsPlugin.showColumns(columns);
      this.render();
      this.view.adjustElementsSize(true);
      var allColumnsSelected = endVisualColumn - startVisualColumn + 1 === this.countCols();
      if (!allColumnsSelected) {
        this.selectColumns(startVisualColumn, endVisualColumn);
      }
    },
    disabled: false,
    hidden: function hidden() {
      var _this = this;
      var hiddenPhysicalColumns = arrayMap(hiddenColumnsPlugin.getHiddenColumns(), function(visualColumnIndex) {
        return _this.toPhysicalColumn(visualColumnIndex);
      });
      if (!(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalColumns.length < 1) {
        return true;
      }
      columns.length = 0;
      var selectedRangeLast = this.getSelectedRangeLast();
      var visualStartColumn = selectedRangeLast.getTopStartCorner().col;
      var visualEndColumn = selectedRangeLast.getBottomEndCorner().col;
      var columnIndexMapper = this.columnIndexMapper;
      var renderableStartColumn = columnIndexMapper.getRenderableFromVisualIndex(visualStartColumn);
      var renderableEndColumn = columnIndexMapper.getRenderableFromVisualIndex(visualEndColumn);
      var notTrimmedColumnIndexes = columnIndexMapper.getNotTrimmedIndexes();
      var physicalColumnIndexes = [];
      if (visualStartColumn !== visualEndColumn) {
        var visualColumnsInRange = visualEndColumn - visualStartColumn + 1;
        var renderedColumnsInRange = renderableEndColumn - renderableStartColumn + 1;
        if (visualColumnsInRange > renderedColumnsInRange) {
          var physicalIndexesInRange = notTrimmedColumnIndexes.slice(visualStartColumn, visualEndColumn + 1);
          physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$b(physicalIndexesInRange.filter(function(physicalIndex) {
            return hiddenPhysicalColumns.includes(physicalIndex);
          })));
        }
      } else if (renderableStartColumn === 0 && renderableStartColumn < visualStartColumn) {
        physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$b(notTrimmedColumnIndexes.slice(0, visualStartColumn)));
      } else if (renderableStartColumn === null) {
        physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$b(notTrimmedColumnIndexes.slice(0, this.countCols())));
      } else {
        var lastVisualIndex = this.countCols() - 1;
        var lastRenderableIndex = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndColumn === lastRenderableIndex && lastVisualIndex > visualEndColumn) {
          physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$b(notTrimmedColumnIndexes.slice(visualEndColumn + 1)));
        }
      }
      arrayEach(physicalColumnIndexes, function(physicalColumnIndex) {
        columns.push(_this.toVisualColumn(physicalColumnIndex));
      });
      return columns.length === 0;
    }
  };
}
function _typeof$o(obj) {
  "@babel/helpers - typeof";
  return _typeof$o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$o(obj);
}
function _classCallCheck$C(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$C(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$C(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$C(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$C(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$j() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$j = Reflect.get.bind();
  } else {
    _get$j = function _get2(target, property, receiver) {
      var base = _superPropBase$j(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$j.apply(this, arguments);
}
function _superPropBase$j(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$n(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$n(subClass, superClass);
}
function _setPrototypeOf$n(o, p2) {
  _setPrototypeOf$n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$n(o, p2);
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$n(this, result);
  };
}
function _possibleConstructorReturn$n(self2, call2) {
  if (call2 && (_typeof$o(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$n(self2);
}
function _assertThisInitialized$n(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$n(o) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$n(o);
}
function _classPrivateFieldInitSpec$5(obj, privateMap, value) {
  _checkPrivateRedeclaration$5(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$5(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet$5(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$5(receiver, privateMap, "get");
  return _classApplyDescriptorGet$5(receiver, descriptor);
}
function _classApplyDescriptorGet$5(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$5(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$5(receiver, privateMap, "set");
  _classApplyDescriptorSet$5(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$5(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$5(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
Hooks$1.getSingleton().register("beforeHideColumns");
Hooks$1.getSingleton().register("afterHideColumns");
Hooks$1.getSingleton().register("beforeUnhideColumns");
Hooks$1.getSingleton().register("afterUnhideColumns");
var PLUGIN_KEY$g = "hiddenColumns";
var PLUGIN_PRIORITY$f = 310;
var _settings$1 = /* @__PURE__ */ new WeakMap();
var _hiddenColumnsMap = /* @__PURE__ */ new WeakMap();
var HiddenColumns = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$n(HiddenColumns2, _BasePlugin);
  var _super = _createSuper$n(HiddenColumns2);
  function HiddenColumns2() {
    var _this;
    _classCallCheck$C(this, HiddenColumns2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _classPrivateFieldInitSpec$5(_assertThisInitialized$n(_this), _settings$1, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec$5(_assertThisInitialized$n(_this), _hiddenColumnsMap, {
      writable: true,
      value: null
    });
    return _this;
  }
  _createClass$C(HiddenColumns2, [{
    key: "isEnabled",
    value: (
      /**
       * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
       * hook and if it returns `true` than the {@link HiddenColumns#enablePlugin} method is called.
       *
       * @returns {boolean}
       */
      function isEnabled() {
        return !!this.hot.getSettings()[PLUGIN_KEY$g];
      }
    )
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$g];
      if (isObject$7(pluginSettings)) {
        _classPrivateFieldSet$5(this, _settings$1, pluginSettings);
        if (isUndefined(pluginSettings.copyPasteEnabled)) {
          pluginSettings.copyPasteEnabled = true;
        }
      }
      _classPrivateFieldSet$5(this, _hiddenColumnsMap, new HidingMap());
      _classPrivateFieldGet$5(this, _hiddenColumnsMap).addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.columnIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet$5(this, _hiddenColumnsMap));
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.onAfterContextMenuDefaultOptions.apply(_this2, arguments);
      });
      this.addHook("afterGetCellMeta", function(row, col, cellProperties) {
        return _this2.onAfterGetCellMeta(row, col, cellProperties);
      });
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.onModifyColWidth(width, col);
      });
      this.addHook("afterGetColHeader", function() {
        return _this2.onAfterGetColHeader.apply(_this2, arguments);
      });
      this.addHook("modifyCopyableRange", function(ranges) {
        return _this2.onModifyCopyableRange(ranges);
      });
      _get$j(_getPrototypeOf$n(HiddenColumns2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`hiddenColumns`](@/api/options.md#hiddencolumns)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$j(_getPrototypeOf$n(HiddenColumns2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.columnIndexMapper.unregisterMap(this.pluginName);
      _classPrivateFieldSet$5(this, _settings$1, {});
      _get$j(_getPrototypeOf$n(HiddenColumns2.prototype), "disablePlugin", this).call(this);
      this.resetCellsMeta();
    }
    /**
     * Shows the provided columns.
     *
     * @param {number[]} columns Array of visual column indexes.
     */
  }, {
    key: "showColumns",
    value: function showColumns(columns) {
      var _this3 = this;
      var currentHideConfig = this.getHiddenColumns();
      var isValidConfig = this.isValidConfig(columns);
      var destinationHideConfig = currentHideConfig;
      var hidingMapValues = _classPrivateFieldGet$5(this, _hiddenColumnsMap).getValues().slice();
      var isAnyColumnShowed = columns.length > 0;
      if (isValidConfig && isAnyColumnShowed) {
        var physicalColumns = columns.map(function(visualColumn) {
          return _this3.hot.toPhysicalColumn(visualColumn);
        });
        arrayEach(physicalColumns, function(physicalColumn) {
          hidingMapValues[physicalColumn] = false;
        });
        destinationHideConfig = arrayReduce$1(hidingMapValues, function(hiddenIndexes, isHidden, physicalIndex) {
          if (isHidden) {
            hiddenIndexes.push(_this3.hot.toVisualColumn(physicalIndex));
          }
          return hiddenIndexes;
        }, []);
      }
      var continueHiding = this.hot.runHooks("beforeUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed);
      if (continueHiding === false) {
        return;
      }
      if (isValidConfig && isAnyColumnShowed) {
        _classPrivateFieldGet$5(this, _hiddenColumnsMap).setValues(hidingMapValues);
      }
      this.hot.view.adjustElementsSize();
      this.hot.runHooks("afterUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
    }
    /**
     * Shows a single column.
     *
     * @param {...number} column Visual column index.
     */
  }, {
    key: "showColumn",
    value: function showColumn2() {
      for (var _len2 = arguments.length, column = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        column[_key2] = arguments[_key2];
      }
      this.showColumns(column);
    }
    /**
     * Hides the columns provided in the array.
     *
     * @param {number[]} columns Array of visual column indexes.
     */
  }, {
    key: "hideColumns",
    value: function hideColumns(columns) {
      var _this4 = this;
      var currentHideConfig = this.getHiddenColumns();
      var isConfigValid = this.isValidConfig(columns);
      var destinationHideConfig = currentHideConfig;
      if (isConfigValid) {
        destinationHideConfig = Array.from(new Set(currentHideConfig.concat(columns)));
      }
      var continueHiding = this.hot.runHooks("beforeHideColumns", currentHideConfig, destinationHideConfig, isConfigValid);
      if (continueHiding === false) {
        return;
      }
      if (isConfigValid) {
        this.hot.batchExecution(function() {
          arrayEach(columns, function(visualColumn) {
            _classPrivateFieldGet$5(_this4, _hiddenColumnsMap).setValueAtIndex(_this4.hot.toPhysicalColumn(visualColumn), true);
          });
        }, true);
      }
      this.hot.runHooks("afterHideColumns", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
    }
    /**
     * Hides a single column.
     *
     * @param {...number} column Visual column index.
     */
  }, {
    key: "hideColumn",
    value: function hideColumn2() {
      for (var _len3 = arguments.length, column = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        column[_key3] = arguments[_key3];
      }
      this.hideColumns(column);
    }
    /**
     * Returns an array of visual indexes of hidden columns.
     *
     * @returns {number[]}
     */
  }, {
    key: "getHiddenColumns",
    value: function getHiddenColumns() {
      var _this5 = this;
      return arrayMap(_classPrivateFieldGet$5(this, _hiddenColumnsMap).getHiddenIndexes(), function(physicalColumnIndex) {
        return _this5.hot.toVisualColumn(physicalColumnIndex);
      });
    }
    /**
     * Checks if the provided column is hidden.
     *
     * @param {number} column Visual column index.
     * @returns {boolean}
     */
  }, {
    key: "isHidden",
    value: function isHidden(column) {
      return _classPrivateFieldGet$5(this, _hiddenColumnsMap).getValueAtIndex(this.hot.toPhysicalColumn(column)) || false;
    }
    /**
     * Get if trim config is valid. Check whether all of the provided column indexes are within the bounds of the table.
     *
     * @param {Array} hiddenColumns List of hidden column indexes.
     * @returns {boolean}
     */
  }, {
    key: "isValidConfig",
    value: function isValidConfig(hiddenColumns) {
      var nrOfColumns = this.hot.countCols();
      if (Array.isArray(hiddenColumns) && hiddenColumns.length > 0) {
        return hiddenColumns.every(function(visualColumn) {
          return Number.isInteger(visualColumn) && visualColumn >= 0 && visualColumn < nrOfColumns;
        });
      }
      return false;
    }
    /**
     * Reset all rendered cells meta.
     *
     * @private
     */
  }, {
    key: "resetCellsMeta",
    value: function resetCellsMeta() {
      arrayEach(this.hot.getCellsMeta(), function(meta2) {
        if (meta2) {
          meta2.skipColumnOnPaste = false;
        }
      });
    }
    /**
     * Adds the additional column width for the hidden column indicators.
     *
     * @private
     * @param {number|undefined} width Column width.
     * @param {number} column Visual column index.
     * @returns {number}
     */
  }, {
    key: "onModifyColWidth",
    value: function onModifyColWidth(width, column) {
      if (this.isHidden(column)) {
        return 0;
      }
      if (_classPrivateFieldGet$5(this, _settings$1).indicators && (this.isHidden(column + 1) || this.isHidden(column - 1))) {
        if (typeof width === "number" && this.hot.hasColHeaders()) {
          return width + 15;
        }
      }
    }
    /**
     * Sets the copy-related cell meta.
     *
     * @private
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {object} cellProperties Object containing the cell properties.
     */
  }, {
    key: "onAfterGetCellMeta",
    value: function onAfterGetCellMeta(row, column, cellProperties) {
      if (_classPrivateFieldGet$5(this, _settings$1).copyPasteEnabled === false && this.isHidden(column)) {
        cellProperties.skipColumnOnPaste = true;
      }
      if (this.isHidden(column - 1)) {
        cellProperties.className = cellProperties.className || "";
        if (cellProperties.className.indexOf("afterHiddenColumn") === -1) {
          cellProperties.className += " afterHiddenColumn";
        }
      } else if (cellProperties.className) {
        var classArr = cellProperties.className.split(" ");
        if (classArr.length > 0) {
          var containAfterHiddenColumn = classArr.indexOf("afterHiddenColumn");
          if (containAfterHiddenColumn > -1) {
            classArr.splice(containAfterHiddenColumn, 1);
          }
          cellProperties.className = classArr.join(" ");
        }
      }
    }
    /**
     * Modifies the copyable range, accordingly to the provided config.
     *
     * @private
     * @param {Array} ranges An array of objects defining copyable cells.
     * @returns {Array}
     */
  }, {
    key: "onModifyCopyableRange",
    value: function onModifyCopyableRange(ranges) {
      var _this6 = this;
      if (_classPrivateFieldGet$5(this, _settings$1).copyPasteEnabled) {
        return ranges;
      }
      var newRanges = [];
      var pushRange = function pushRange2(startRow, endRow, startCol, endCol) {
        newRanges.push({
          startRow,
          endRow,
          startCol,
          endCol
        });
      };
      arrayEach(ranges, function(range) {
        var isHidden = true;
        var rangeStart = 0;
        rangeEach(range.startCol, range.endCol, function(visualColumn) {
          if (_this6.isHidden(visualColumn)) {
            if (!isHidden) {
              pushRange(range.startRow, range.endRow, rangeStart, visualColumn - 1);
            }
            isHidden = true;
          } else {
            if (isHidden) {
              rangeStart = visualColumn;
            }
            if (visualColumn === range.endCol) {
              pushRange(range.startRow, range.endRow, rangeStart, visualColumn);
            }
            isHidden = false;
          }
        });
      });
      return newRanges;
    }
    /**
     * Adds the needed classes to the headers.
     *
     * @private
     * @param {number} column Visual column index.
     * @param {HTMLElement} TH Header's TH element.
     */
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(column, TH) {
      if (!_classPrivateFieldGet$5(this, _settings$1).indicators || column < 0) {
        return;
      }
      var classList2 = [];
      if (column >= 1 && this.isHidden(column - 1)) {
        classList2.push("afterHiddenColumn");
      }
      if (column < this.hot.countCols() - 1 && this.isHidden(column + 1)) {
        classList2.push("beforeHiddenColumn");
      }
      addClass(TH, classList2);
    }
    /**
     * Add Show-hide columns to context menu.
     *
     * @private
     * @param {object} options An array of objects containing information about the pre-defined Context Menu items.
     */
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(options) {
      options.items.push({
        name: KEY$c
      }, hideColumnItem(this), showColumnItem(this));
    }
    /**
     * On map initialized hook callback.
     *
     * @private
     */
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      if (Array.isArray(_classPrivateFieldGet$5(this, _settings$1).columns)) {
        this.hideColumns(_classPrivateFieldGet$5(this, _settings$1).columns);
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet$5(this, _settings$1, null);
      _classPrivateFieldSet$5(this, _hiddenColumnsMap, null);
      _get$j(_getPrototypeOf$n(HiddenColumns2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$g;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$f;
    }
    /**
     * Cached plugin settings.
     *
     * @private
     * @type {object}
     */
  }]);
  return HiddenColumns2;
}(BasePlugin);
function _slicedToArray$6(arr, i) {
  return _arrayWithHoles$7(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$g(arr, i) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$g(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$g(o, minLen);
}
function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$6(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$7(arr) {
  if (Array.isArray(arr))
    return arr;
}
function hideRowItem(hiddenRowsPlugin) {
  return {
    key: "hidden_rows_hide",
    name: function name() {
      var selection = this.getSelectedLast();
      var pluralForm = 0;
      if (Array.isArray(selection)) {
        var _selection = _slicedToArray$6(selection, 3), fromRow = _selection[0], toRow = _selection[2];
        if (fromRow - toRow !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_ROW, pluralForm);
    },
    callback: function callback() {
      var _this$getSelectedRang = this.getSelectedRangeLast(), from3 = _this$getSelectedRang.from, to = _this$getSelectedRang.to;
      var start = Math.max(Math.min(from3.row, to.row), 0);
      var end = Math.max(from3.row, to.row);
      var rowsToHide = [];
      for (var visualRow = start; visualRow <= end; visualRow += 1) {
        rowsToHide.push(visualRow);
      }
      hiddenRowsPlugin.hideRows(rowsToHide);
      var lastHiddenRow = rowsToHide[rowsToHide.length - 1];
      var rowToSelect = this.rowIndexMapper.getNearestNotHiddenIndex(lastHiddenRow, 1, true);
      if (Number.isInteger(rowToSelect) && rowToSelect >= 0) {
        this.selectRows(rowToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden: function hidden() {
      return !(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner());
    }
  };
}
function _toConsumableArray$a(arr) {
  return _arrayWithoutHoles$a(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$f(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$f(o, minLen);
}
function _iterableToArray$b(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$a(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$f(arr);
}
function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function showRowItem(hiddenRowsPlugin) {
  var rows = [];
  return {
    key: "hidden_rows_show",
    name: function name() {
      var pluralForm = rows.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_ROW, pluralForm);
    },
    callback: function callback() {
      var _this$rowIndexMapper$, _this$rowIndexMapper$2;
      if (rows.length === 0) {
        return;
      }
      var startVisualRow = rows[0];
      var endVisualRow = rows[rows.length - 1];
      startVisualRow = (_this$rowIndexMapper$ = this.rowIndexMapper.getNearestNotHiddenIndex(startVisualRow - 1, -1)) !== null && _this$rowIndexMapper$ !== void 0 ? _this$rowIndexMapper$ : 0;
      endVisualRow = (_this$rowIndexMapper$2 = this.rowIndexMapper.getNearestNotHiddenIndex(endVisualRow + 1, 1)) !== null && _this$rowIndexMapper$2 !== void 0 ? _this$rowIndexMapper$2 : this.countRows() - 1;
      hiddenRowsPlugin.showRows(rows);
      this.render();
      this.view.adjustElementsSize(true);
      var allRowsSelected = endVisualRow - startVisualRow + 1 === this.countRows();
      if (!allRowsSelected) {
        this.selectRows(startVisualRow, endVisualRow);
      }
    },
    disabled: false,
    hidden: function hidden() {
      var _this = this;
      var hiddenPhysicalRows = arrayMap(hiddenRowsPlugin.getHiddenRows(), function(visualRowIndex) {
        return _this.toPhysicalRow(visualRowIndex);
      });
      if (!(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalRows.length < 1) {
        return true;
      }
      rows.length = 0;
      var selectedRangeLast = this.getSelectedRangeLast();
      var visualStartRow = selectedRangeLast.getTopStartCorner().row;
      var visualEndRow = selectedRangeLast.getBottomEndCorner().row;
      var rowIndexMapper = this.rowIndexMapper;
      var renderableStartRow = rowIndexMapper.getRenderableFromVisualIndex(visualStartRow);
      var renderableEndRow = rowIndexMapper.getRenderableFromVisualIndex(visualEndRow);
      var notTrimmedRowIndexes = rowIndexMapper.getNotTrimmedIndexes();
      var physicalRowIndexes = [];
      if (visualStartRow !== visualEndRow) {
        var visualRowsInRange = visualEndRow - visualStartRow + 1;
        var renderedRowsInRange = renderableEndRow - renderableStartRow + 1;
        if (visualRowsInRange > renderedRowsInRange) {
          var physicalIndexesInRange = notTrimmedRowIndexes.slice(visualStartRow, visualEndRow + 1);
          physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$a(physicalIndexesInRange.filter(function(physicalIndex) {
            return hiddenPhysicalRows.includes(physicalIndex);
          })));
        }
      } else if (renderableStartRow === 0 && renderableStartRow < visualStartRow) {
        physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$a(notTrimmedRowIndexes.slice(0, visualStartRow)));
      } else if (renderableStartRow === null) {
        physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$a(notTrimmedRowIndexes.slice(0, this.countRows())));
      } else {
        var lastVisualIndex = this.countRows() - 1;
        var lastRenderableIndex = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndRow === lastRenderableIndex && lastVisualIndex > visualEndRow) {
          physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$a(notTrimmedRowIndexes.slice(visualEndRow + 1)));
        }
      }
      arrayEach(physicalRowIndexes, function(physicalRowIndex) {
        rows.push(_this.toVisualRow(physicalRowIndex));
      });
      return rows.length === 0;
    }
  };
}
function _typeof$n(obj) {
  "@babel/helpers - typeof";
  return _typeof$n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$n(obj);
}
function _classCallCheck$B(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$B(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$B(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$B(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$B(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$i() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$i = Reflect.get.bind();
  } else {
    _get$i = function _get2(target, property, receiver) {
      var base = _superPropBase$i(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$i.apply(this, arguments);
}
function _superPropBase$i(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$m(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$m(subClass, superClass);
}
function _setPrototypeOf$m(o, p2) {
  _setPrototypeOf$m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$m(o, p2);
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$m(this, result);
  };
}
function _possibleConstructorReturn$m(self2, call2) {
  if (call2 && (_typeof$n(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$m(self2);
}
function _assertThisInitialized$m(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$m(o) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$m(o);
}
function _classPrivateFieldInitSpec$4(obj, privateMap, value) {
  _checkPrivateRedeclaration$4(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$4(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet$4(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$4(receiver, privateMap, "get");
  return _classApplyDescriptorGet$4(receiver, descriptor);
}
function _classApplyDescriptorGet$4(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$4(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$4(receiver, privateMap, "set");
  _classApplyDescriptorSet$4(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$4(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$4(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
Hooks$1.getSingleton().register("beforeHideRows");
Hooks$1.getSingleton().register("afterHideRows");
Hooks$1.getSingleton().register("beforeUnhideRows");
Hooks$1.getSingleton().register("afterUnhideRows");
var PLUGIN_KEY$f = "hiddenRows";
var PLUGIN_PRIORITY$e = 320;
var _settings = /* @__PURE__ */ new WeakMap();
var _hiddenRowsMap = /* @__PURE__ */ new WeakMap();
var HiddenRows = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$m(HiddenRows2, _BasePlugin);
  var _super = _createSuper$m(HiddenRows2);
  function HiddenRows2() {
    var _this;
    _classCallCheck$B(this, HiddenRows2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _classPrivateFieldInitSpec$4(_assertThisInitialized$m(_this), _settings, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec$4(_assertThisInitialized$m(_this), _hiddenRowsMap, {
      writable: true,
      value: null
    });
    return _this;
  }
  _createClass$B(HiddenRows2, [{
    key: "isEnabled",
    value: (
      /**
       * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
       * hook and if it returns `true` than the {@link HiddenRows#enablePlugin} method is called.
       *
       * @returns {boolean}
       */
      function isEnabled() {
        return !!this.hot.getSettings()[PLUGIN_KEY$f];
      }
    )
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$f];
      if (isObject$7(pluginSettings)) {
        _classPrivateFieldSet$4(this, _settings, pluginSettings);
        if (isUndefined(pluginSettings.copyPasteEnabled)) {
          pluginSettings.copyPasteEnabled = true;
        }
      }
      _classPrivateFieldSet$4(this, _hiddenRowsMap, new HidingMap());
      _classPrivateFieldGet$4(this, _hiddenRowsMap).addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.rowIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet$4(this, _hiddenRowsMap));
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.onAfterContextMenuDefaultOptions.apply(_this2, arguments);
      });
      this.addHook("afterGetCellMeta", function(row, col, cellProperties) {
        return _this2.onAfterGetCellMeta(row, col, cellProperties);
      });
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.onModifyRowHeight(height, row);
      });
      this.addHook("afterGetRowHeader", function() {
        return _this2.onAfterGetRowHeader.apply(_this2, arguments);
      });
      this.addHook("modifyCopyableRange", function(ranges) {
        return _this2.onModifyCopyableRange(ranges);
      });
      _get$i(_getPrototypeOf$m(HiddenRows2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`hiddenRows`](@/api/options.md#hiddenrows)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$i(_getPrototypeOf$m(HiddenRows2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      _classPrivateFieldSet$4(this, _settings, {});
      _get$i(_getPrototypeOf$m(HiddenRows2.prototype), "disablePlugin", this).call(this);
      this.resetCellsMeta();
    }
    /**
     * Shows the rows provided in the array.
     *
     * @param {number[]} rows Array of visual row indexes.
     */
  }, {
    key: "showRows",
    value: function showRows(rows) {
      var _this3 = this;
      var currentHideConfig = this.getHiddenRows();
      var isValidConfig = this.isValidConfig(rows);
      var destinationHideConfig = currentHideConfig;
      var hidingMapValues = _classPrivateFieldGet$4(this, _hiddenRowsMap).getValues().slice();
      var isAnyRowShowed = rows.length > 0;
      if (isValidConfig && isAnyRowShowed) {
        var physicalRows = rows.map(function(visualRow) {
          return _this3.hot.toPhysicalRow(visualRow);
        });
        arrayEach(physicalRows, function(physicalRow) {
          hidingMapValues[physicalRow] = false;
        });
        destinationHideConfig = arrayReduce$1(hidingMapValues, function(hiddenIndexes, isHidden, physicalIndex) {
          if (isHidden) {
            hiddenIndexes.push(_this3.hot.toVisualRow(physicalIndex));
          }
          return hiddenIndexes;
        }, []);
      }
      var continueHiding = this.hot.runHooks("beforeUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed);
      if (continueHiding === false) {
        return;
      }
      if (isValidConfig && isAnyRowShowed) {
        _classPrivateFieldGet$4(this, _hiddenRowsMap).setValues(hidingMapValues);
      }
      this.hot.runHooks("afterUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
    }
    /**
     * Shows the row provided as row index (counting from 0).
     *
     * @param {...number} row Visual row index.
     */
  }, {
    key: "showRow",
    value: function showRow() {
      for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        row[_key2] = arguments[_key2];
      }
      this.showRows(row);
    }
    /**
     * Hides the rows provided in the array.
     *
     * @param {number[]} rows Array of visual row indexes.
     */
  }, {
    key: "hideRows",
    value: function hideRows(rows) {
      var _this4 = this;
      var currentHideConfig = this.getHiddenRows();
      var isConfigValid = this.isValidConfig(rows);
      var destinationHideConfig = currentHideConfig;
      if (isConfigValid) {
        destinationHideConfig = Array.from(new Set(currentHideConfig.concat(rows)));
      }
      var continueHiding = this.hot.runHooks("beforeHideRows", currentHideConfig, destinationHideConfig, isConfigValid);
      if (continueHiding === false) {
        return;
      }
      if (isConfigValid) {
        this.hot.batchExecution(function() {
          arrayEach(rows, function(visualRow) {
            _classPrivateFieldGet$4(_this4, _hiddenRowsMap).setValueAtIndex(_this4.hot.toPhysicalRow(visualRow), true);
          });
        }, true);
      }
      this.hot.runHooks("afterHideRows", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
    }
    /**
     * Hides the row provided as row index (counting from 0).
     *
     * @param {...number} row Visual row index.
     */
  }, {
    key: "hideRow",
    value: function hideRow() {
      for (var _len3 = arguments.length, row = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        row[_key3] = arguments[_key3];
      }
      this.hideRows(row);
    }
    /**
     * Returns an array of visual indexes of hidden rows.
     *
     * @returns {number[]}
     */
  }, {
    key: "getHiddenRows",
    value: function getHiddenRows() {
      var _this5 = this;
      return arrayMap(_classPrivateFieldGet$4(this, _hiddenRowsMap).getHiddenIndexes(), function(physicalRowIndex) {
        return _this5.hot.toVisualRow(physicalRowIndex);
      });
    }
    /**
     * Checks if the provided row is hidden.
     *
     * @param {number} row Visual row index.
     * @returns {boolean}
     */
  }, {
    key: "isHidden",
    value: function isHidden(row) {
      return _classPrivateFieldGet$4(this, _hiddenRowsMap).getValueAtIndex(this.hot.toPhysicalRow(row)) || false;
    }
    /**
     * Checks whether all of the provided row indexes are within the bounds of the table.
     *
     * @param {Array} hiddenRows List of hidden visual row indexes.
     * @returns {boolean}
     */
  }, {
    key: "isValidConfig",
    value: function isValidConfig(hiddenRows) {
      var nrOfRows = this.hot.countRows();
      if (Array.isArray(hiddenRows) && hiddenRows.length > 0) {
        return hiddenRows.every(function(visualRow) {
          return Number.isInteger(visualRow) && visualRow >= 0 && visualRow < nrOfRows;
        });
      }
      return false;
    }
    /**
     * Resets all rendered cells meta.
     *
     * @private
     */
  }, {
    key: "resetCellsMeta",
    value: function resetCellsMeta() {
      arrayEach(this.hot.getCellsMeta(), function(meta2) {
        if (meta2) {
          meta2.skipRowOnPaste = false;
        }
      });
    }
    /**
     * Adds the additional row height for the hidden row indicators.
     *
     * @private
     * @param {number|undefined} height Row height.
     * @param {number} row Visual row index.
     * @returns {number}
     */
  }, {
    key: "onModifyRowHeight",
    value: function onModifyRowHeight(height, row) {
      if (this.isHidden(row)) {
        return 0;
      }
      return height;
    }
    /**
     * Sets the copy-related cell meta.
     *
     * @private
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @param {object} cellProperties Object containing the cell properties.
     */
  }, {
    key: "onAfterGetCellMeta",
    value: function onAfterGetCellMeta(row, column, cellProperties) {
      if (_classPrivateFieldGet$4(this, _settings).copyPasteEnabled === false && this.isHidden(row)) {
        cellProperties.skipRowOnPaste = true;
      }
      if (this.isHidden(row - 1)) {
        cellProperties.className = cellProperties.className || "";
        if (cellProperties.className.indexOf("afterHiddenRow") === -1) {
          cellProperties.className += " afterHiddenRow";
        }
      } else if (cellProperties.className) {
        var classArr = cellProperties.className.split(" ");
        if (classArr.length > 0) {
          var containAfterHiddenRow = classArr.indexOf("afterHiddenRow");
          if (containAfterHiddenRow > -1) {
            classArr.splice(containAfterHiddenRow, 1);
          }
          cellProperties.className = classArr.join(" ");
        }
      }
    }
    /**
     * Modifies the copyable range, accordingly to the provided config.
     *
     * @private
     * @param {Array} ranges An array of objects defining copyable cells.
     * @returns {Array}
     */
  }, {
    key: "onModifyCopyableRange",
    value: function onModifyCopyableRange(ranges) {
      var _this6 = this;
      if (_classPrivateFieldGet$4(this, _settings).copyPasteEnabled) {
        return ranges;
      }
      var newRanges = [];
      var pushRange = function pushRange2(startRow, endRow, startCol, endCol) {
        newRanges.push({
          startRow,
          endRow,
          startCol,
          endCol
        });
      };
      arrayEach(ranges, function(range) {
        var isHidden = true;
        var rangeStart = 0;
        rangeEach(range.startRow, range.endRow, function(visualRow) {
          if (_this6.isHidden(visualRow)) {
            if (!isHidden) {
              pushRange(rangeStart, visualRow - 1, range.startCol, range.endCol);
            }
            isHidden = true;
          } else {
            if (isHidden) {
              rangeStart = visualRow;
            }
            if (visualRow === range.endRow) {
              pushRange(rangeStart, visualRow, range.startCol, range.endCol);
            }
            isHidden = false;
          }
        });
      });
      return newRanges;
    }
    /**
     * Adds the needed classes to the headers.
     *
     * @private
     * @param {number} row Visual row index.
     * @param {HTMLElement} TH Header's TH element.
     */
  }, {
    key: "onAfterGetRowHeader",
    value: function onAfterGetRowHeader(row, TH) {
      if (!_classPrivateFieldGet$4(this, _settings).indicators || row < 0) {
        return;
      }
      var classList2 = [];
      if (row >= 1 && this.isHidden(row - 1)) {
        classList2.push("afterHiddenRow");
      }
      if (row < this.hot.countRows() - 1 && this.isHidden(row + 1)) {
        classList2.push("beforeHiddenRow");
      }
      addClass(TH, classList2);
    }
    /**
     * Add Show-hide rows to context menu.
     *
     * @private
     * @param {object} options An array of objects containing information about the pre-defined Context Menu items.
     */
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(options) {
      options.items.push({
        name: KEY$c
      }, hideRowItem(this), showRowItem(this));
    }
    /**
     * On map initialized hook callback.
     *
     * @private
     */
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      if (Array.isArray(_classPrivateFieldGet$4(this, _settings).rows)) {
        this.hideRows(_classPrivateFieldGet$4(this, _settings).rows);
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet$4(this, _settings, null);
      _classPrivateFieldSet$4(this, _hiddenRowsMap, null);
      _get$i(_getPrototypeOf$m(HiddenRows2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$f;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$e;
    }
    /**
     * Cached settings from Handsontable settings.
     *
     * @private
     * @type {object}
     */
  }]);
  return HiddenRows2;
}(BasePlugin);
function _slicedToArray$5(arr, i) {
  return _arrayWithHoles$6(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$e(arr, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$e(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$e(o, minLen);
}
function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$5(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr))
    return arr;
}
function freezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "freeze_column",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_FREEZE_COLUMN);
    },
    callback: function callback(key, selected) {
      var _selected = _slicedToArray$5(selected, 1), selectedColumn = _selected[0].start.col;
      manualColumnFreezePlugin.freezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden: function hidden() {
      var selection = this.getSelectedRange();
      var hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col <= this.getSettings().fixedColumnsStart - 1) {
        hide = true;
      }
      return hide;
    }
  };
}
function _slicedToArray$4(arr, i) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$d(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$d(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$d(o, minLen);
}
function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$4(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr))
    return arr;
}
function unfreezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "unfreeze_column",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNFREEZE_COLUMN);
    },
    callback: function callback(key, selected) {
      var _selected = _slicedToArray$4(selected, 1), selectedColumn = _selected[0].start.col;
      manualColumnFreezePlugin.unfreezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden: function hidden() {
      var selection = this.getSelectedRange();
      var hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col >= this.getSettings().fixedColumnsStart) {
        hide = true;
      }
      return hide;
    }
  };
}
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$m(obj);
}
function _classCallCheck$A(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$A(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$A(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$A(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$A(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$h() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$h = Reflect.get.bind();
  } else {
    _get$h = function _get2(target, property, receiver) {
      var base = _superPropBase$h(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$h.apply(this, arguments);
}
function _superPropBase$h(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$l(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$l(subClass, superClass);
}
function _setPrototypeOf$l(o, p2) {
  _setPrototypeOf$l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$l(o, p2);
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$l(this, result);
  };
}
function _possibleConstructorReturn$l(self2, call2) {
  if (call2 && (_typeof$m(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$l(self2);
}
function _assertThisInitialized$l(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$l(o) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$l(o);
}
Hooks$1.getSingleton().register("beforeColumnFreeze");
Hooks$1.getSingleton().register("afterColumnFreeze");
Hooks$1.getSingleton().register("beforeColumnUnfreeze");
Hooks$1.getSingleton().register("afterColumnUnfreeze");
var PLUGIN_KEY$e = "manualColumnFreeze";
var PLUGIN_PRIORITY$d = 110;
var privatePool$7 = /* @__PURE__ */ new WeakMap();
var ManualColumnFreeze = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$l(ManualColumnFreeze2, _BasePlugin);
  var _super = _createSuper$l(ManualColumnFreeze2);
  function ManualColumnFreeze2(hotInstance) {
    var _this;
    _classCallCheck$A(this, ManualColumnFreeze2);
    _this = _super.call(this, hotInstance);
    privatePool$7.set(_assertThisInitialized$l(_this), {
      afterFirstUse: false
    });
    return _this;
  }
  _createClass$A(ManualColumnFreeze2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$e];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.addContextMenuEntry(options);
      });
      this.addHook("beforeColumnMove", function(columns, finalIndex) {
        return _this2.onBeforeColumnMove(columns, finalIndex);
      });
      _get$h(_getPrototypeOf$l(ManualColumnFreeze2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var priv = privatePool$7.get(this);
      priv.afterFirstUse = false;
      _get$h(_getPrototypeOf$l(ManualColumnFreeze2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`manualColumnFreeze`](@/api/options.md#manualcolumnfreeze)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$h(_getPrototypeOf$l(ManualColumnFreeze2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Freezes the specified column (adds it to fixed columns).
     *
     * `freezeColumn()` doesn't re-render the table,
     * so you need to call the `render()` method afterward.
     *
     * @param {number} column Visual column index.
     */
  }, {
    key: "freezeColumn",
    value: function freezeColumn(column) {
      var priv = privatePool$7.get(this);
      var settings = this.hot.getSettings();
      var freezePerformed = settings.fixedColumnsStart < this.hot.countCols() && column > settings.fixedColumnsStart - 1;
      if (!priv.afterFirstUse) {
        priv.afterFirstUse = true;
      }
      var beforeColumnFreezeHook = this.hot.runHooks("beforeColumnFreeze", column, freezePerformed);
      if (beforeColumnFreezeHook === false) {
        return;
      }
      if (freezePerformed) {
        this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);
        settings._fixedColumnsStart += 1;
      }
      this.hot.runHooks("afterColumnFreeze", column, freezePerformed);
    }
    /**
     * Unfreezes the given column (remove it from fixed columns and bring to it's previous position).
     *
     * @param {number} column Visual column index.
     */
  }, {
    key: "unfreezeColumn",
    value: function unfreezeColumn(column) {
      var priv = privatePool$7.get(this);
      var settings = this.hot.getSettings();
      var unfreezePerformed = settings.fixedColumnsStart > 0 && column <= settings.fixedColumnsStart - 1;
      if (!priv.afterFirstUse) {
        priv.afterFirstUse = true;
      }
      var beforeColumnUnfreezeHook = this.hot.runHooks("beforeColumnUnfreeze", column, unfreezePerformed);
      if (beforeColumnUnfreezeHook === false) {
        return;
      }
      if (unfreezePerformed) {
        settings._fixedColumnsStart -= 1;
        this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);
      }
      this.hot.runHooks("afterColumnUnfreeze", column, unfreezePerformed);
    }
    /**
     * Adds the manualColumnFreeze context menu entries.
     *
     * @private
     * @param {object} options Context menu options.
     */
  }, {
    key: "addContextMenuEntry",
    value: function addContextMenuEntry(options) {
      options.items.push({
        name: "---------"
      }, freezeColumnItem(this), unfreezeColumnItem(this));
    }
    /**
     * Prevents moving the columns from/to fixed area.
     *
     * @private
     * @param {Array} columns Array of visual column indexes to be moved.
     * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
     * @returns {boolean|undefined}
     */
  }, {
    key: "onBeforeColumnMove",
    value: function onBeforeColumnMove(columns, finalIndex) {
      var priv = privatePool$7.get(this);
      if (priv.afterFirstUse) {
        var freezeLine = this.hot.getSettings().fixedColumnsStart;
        if (finalIndex < freezeLine) {
          return false;
        }
        if (columns.some(function(column) {
          return column < freezeLine;
        })) {
          return false;
        }
      }
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$e;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$d;
    }
  }]);
  return ManualColumnFreeze2;
}(BasePlugin);
function _classCallCheck$z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$z(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var STATE_INITIALIZED$1 = 0;
var STATE_BUILT$1 = 1;
var STATE_APPENDED$1 = 2;
var UNIT$1 = "px";
var BaseUI$4 = /* @__PURE__ */ function() {
  function BaseUI3(hotInstance) {
    _classCallCheck$z(this, BaseUI3);
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED$1;
    this.inlineProperty = hotInstance.isRtl() ? "right" : "left";
  }
  _createClass$z(BaseUI3, [{
    key: "appendTo",
    value: function appendTo(wrapper2) {
      wrapper2.appendChild(this._element);
      this.state = STATE_APPENDED$1;
    }
    /**
     * Method for create UI element. Only create, without append to table.
     */
  }, {
    key: "build",
    value: function build() {
      if (this.state !== STATE_INITIALIZED$1) {
        return;
      }
      this._element = this.hot.rootDocument.createElement("div");
      this.state = STATE_BUILT$1;
    }
    /**
     * Method for remove UI element.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isAppended()) {
        this._element.parentElement.removeChild(this._element);
      }
      this._element = null;
      this.state = STATE_INITIALIZED$1;
    }
    /**
     * Check if UI element are appended.
     *
     * @returns {boolean}
     */
  }, {
    key: "isAppended",
    value: function isAppended() {
      return this.state === STATE_APPENDED$1;
    }
    /**
     * Check if UI element are built.
     *
     * @returns {boolean}
     */
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.state >= STATE_BUILT$1;
    }
    /**
     * Setter for position.
     *
     * @param {number} top New top position of the element.
     * @param {number} inlinePosition New left/right (depends on LTR/RTL document mode) position of the element.
     */
  }, {
    key: "setPosition",
    value: function setPosition(top2, inlinePosition) {
      if (isNumeric(top2)) {
        this._element.style.top = top2 + UNIT$1;
      }
      if (isNumeric(inlinePosition)) {
        this._element.style[this.inlineProperty] = inlinePosition + UNIT$1;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {object} Object contains left and top position of the element.
     */
  }, {
    key: "getPosition",
    value: function getPosition() {
      var style = this._element.style;
      return {
        top: style.top ? parseInt(style.top, 10) : 0,
        start: style[this.inlineProperty] ? parseInt(style[this.inlineProperty], 10) : 0
      };
    }
    /**
     * Setter for the element size.
     *
     * @param {number} width New width of the element.
     * @param {number} height New height of the element.
     */
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (isNumeric(width)) {
        this._element.style.width = width + UNIT$1;
      }
      if (isNumeric(height)) {
        this._element.style.height = height + UNIT$1;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {object} Object contains height and width of the element.
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
        height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
      };
    }
    /**
     * Setter for the element offset. Offset means marginTop and marginLeft of the element.
     *
     * @param {number} top New margin top of the element.
     * @param {number} inlineOffset New margin left/right (depends on LTR/RTL document mode) of the element.
     */
  }, {
    key: "setOffset",
    value: function setOffset(top2, inlineOffset) {
      if (isNumeric(top2)) {
        this._element.style.marginTop = top2 + UNIT$1;
      }
      if (isNumeric(inlineOffset)) {
        this._element.style["margin".concat(toUpperCaseFirst(this.inlineProperty))] = inlineOffset + UNIT$1;
      }
    }
    /**
     * Getter for the element offset.
     *
     * @returns {object} Object contains top and left offset of the element.
     */
  }, {
    key: "getOffset",
    value: function getOffset() {
      var style = this._element.style;
      var inlineProp = "margin".concat(toUpperCaseFirst(this.inlineProperty));
      return {
        top: style.marginTop ? parseInt(style.marginTop, 10) : 0,
        start: style[inlineProp] ? parseInt(style[inlineProp], 10) : 0
      };
    }
  }]);
  return BaseUI3;
}();
const BaseUI$5 = BaseUI$4;
function _typeof$l(obj) {
  "@babel/helpers - typeof";
  return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$l(obj);
}
function _classCallCheck$y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$y(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$g() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$g = Reflect.get.bind();
  } else {
    _get$g = function _get2(target, property, receiver) {
      var base = _superPropBase$g(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$g.apply(this, arguments);
}
function _superPropBase$g(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$k(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$k(subClass, superClass);
}
function _setPrototypeOf$k(o, p2) {
  _setPrototypeOf$k = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$k(o, p2);
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$k(this, result);
  };
}
function _possibleConstructorReturn$k(self2, call2) {
  if (call2 && (_typeof$l(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$k(self2);
}
function _assertThisInitialized$k(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$k(o) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$k(o);
}
var CSS_CLASSNAME$3 = "ht__manualColumnMove--backlight";
var BacklightUI$2 = /* @__PURE__ */ function(_BaseUI) {
  _inherits$k(BacklightUI2, _BaseUI);
  var _super = _createSuper$k(BacklightUI2);
  function BacklightUI2() {
    _classCallCheck$y(this, BacklightUI2);
    return _super.apply(this, arguments);
  }
  _createClass$y(BacklightUI2, [{
    key: "build",
    value: (
      /**
       * Custom className on build process.
       */
      function build() {
        _get$g(_getPrototypeOf$k(BacklightUI2.prototype), "build", this).call(this);
        addClass(this._element, CSS_CLASSNAME$3);
      }
    )
  }]);
  return BacklightUI2;
}(BaseUI$5);
const BacklightUI$3 = BacklightUI$2;
function _typeof$k(obj) {
  "@babel/helpers - typeof";
  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$k(obj);
}
function _classCallCheck$x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$x(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$x(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$x(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$f() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$f = Reflect.get.bind();
  } else {
    _get$f = function _get2(target, property, receiver) {
      var base = _superPropBase$f(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$f.apply(this, arguments);
}
function _superPropBase$f(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$j(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o, p2) {
  _setPrototypeOf$j = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$j(o, p2);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self2, call2) {
  if (call2 && (_typeof$k(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$j(self2);
}
function _assertThisInitialized$j(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$j(o) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$j(o);
}
var CSS_CLASSNAME$2 = "ht__manualColumnMove--guideline";
var GuidelineUI$2 = /* @__PURE__ */ function(_BaseUI) {
  _inherits$j(GuidelineUI2, _BaseUI);
  var _super = _createSuper$j(GuidelineUI2);
  function GuidelineUI2() {
    _classCallCheck$x(this, GuidelineUI2);
    return _super.apply(this, arguments);
  }
  _createClass$x(GuidelineUI2, [{
    key: "build",
    value: (
      /**
       * Custom className on build process.
       */
      function build() {
        _get$f(_getPrototypeOf$j(GuidelineUI2.prototype), "build", this).call(this);
        addClass(this._element, CSS_CLASSNAME$2);
      }
    )
  }]);
  return GuidelineUI2;
}(BaseUI$5);
const GuidelineUI$3 = GuidelineUI$2;
function _typeof$j(obj) {
  "@babel/helpers - typeof";
  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$j(obj);
}
function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$w(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$e() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$e = Reflect.get.bind();
  } else {
    _get$e = function _get2(target, property, receiver) {
      var base = _superPropBase$e(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$e.apply(this, arguments);
}
function _superPropBase$e(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$i(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$i(subClass, superClass);
}
function _setPrototypeOf$i(o, p2) {
  _setPrototypeOf$i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$i(o, p2);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self2, call2) {
  if (call2 && (_typeof$j(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$i(self2);
}
function _assertThisInitialized$i(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$i(o) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$i(o);
}
Hooks$1.getSingleton().register("beforeColumnMove");
Hooks$1.getSingleton().register("afterColumnMove");
var PLUGIN_KEY$d = "manualColumnMove";
var PLUGIN_PRIORITY$c = 120;
var privatePool$6 = /* @__PURE__ */ new WeakMap();
var CSS_PLUGIN$1 = "ht__manualColumnMove";
var CSS_SHOW_UI$1 = "show-ui";
var CSS_ON_MOVING$1 = "on-moving--columns";
var CSS_AFTER_SELECTION$1 = "after-selection--columns";
var ManualColumnMove = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$i(ManualColumnMove2, _BasePlugin);
  var _super = _createSuper$i(ManualColumnMove2);
  function ManualColumnMove2(hotInstance) {
    var _this;
    _classCallCheck$w(this, ManualColumnMove2);
    _this = _super.call(this, hotInstance);
    privatePool$6.set(_assertThisInitialized$i(_this), {
      columnsToMove: [],
      countCols: 0,
      fixedColumns: 0,
      pressed: void 0,
      target: {
        eventPageX: void 0,
        coords: void 0,
        TD: void 0,
        col: void 0
      },
      cachedDropIndex: void 0
    });
    _this.eventManager = new EventManager$1(_assertThisInitialized$i(_this));
    _this.backlight = new BacklightUI$3(hotInstance);
    _this.guideline = new GuidelineUI$3(hotInstance);
    return _this;
  }
  _createClass$w(ManualColumnMove2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$d];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("beforeOnCellMouseDown", function() {
        return _this2.onBeforeOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseOver", function() {
        return _this2.onBeforeOnCellMouseOver.apply(_this2, arguments);
      });
      this.addHook("afterScrollVertically", function() {
        return _this2.onAfterScrollVertically();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.buildPluginUI();
      this.registerEvents();
      addClass(this.hot.rootElement, CSS_PLUGIN$1);
      _get$e(_getPrototypeOf$i(ManualColumnMove2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`manualColumnMove`](@/api/options.md#manualcolumnmove)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.moveBySettingsOrLoad();
      _get$e(_getPrototypeOf$i(ManualColumnMove2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      removeClass(this.hot.rootElement, CSS_PLUGIN$1);
      this.unregisterEvents();
      this.backlight.destroy();
      this.guideline.destroy();
      _get$e(_getPrototypeOf$i(ManualColumnMove2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Moves a single column.
     *
     * @param {number} column Visual column index to be moved.
     * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
     * @fires Hooks#beforeColumnMove
     * @fires Hooks#afterColumnMove
     * @returns {boolean}
     */
  }, {
    key: "moveColumn",
    value: function moveColumn(column, finalIndex) {
      return this.moveColumns([column], finalIndex);
    }
    /**
     * Moves a multiple columns.
     *
     * @param {Array} columns Array of visual column indexes to be moved.
     * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
     * @fires Hooks#beforeColumnMove
     * @fires Hooks#afterColumnMove
     * @returns {boolean}
     */
  }, {
    key: "moveColumns",
    value: function moveColumns(columns, finalIndex) {
      var priv = privatePool$6.get(this);
      var dropIndex = priv.cachedDropIndex;
      var movePossible = this.isMovePossible(columns, finalIndex);
      var beforeMoveHook = this.hot.runHooks("beforeColumnMove", columns, finalIndex, dropIndex, movePossible);
      priv.cachedDropIndex = void 0;
      if (beforeMoveHook === false) {
        return;
      }
      if (movePossible) {
        this.hot.columnIndexMapper.moveIndexes(columns, finalIndex);
      }
      var movePerformed = movePossible && this.isColumnOrderChanged(columns, finalIndex);
      this.hot.runHooks("afterColumnMove", columns, finalIndex, dropIndex, movePossible, movePerformed);
      return movePerformed;
    }
    /**
     * Drag a single column to drop index position.
     *
     * @param {number} column Visual column index to be dragged.
     * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.
     * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
     * @fires Hooks#beforeColumnMove
     * @fires Hooks#afterColumnMove
     * @returns {boolean}
     */
  }, {
    key: "dragColumn",
    value: function dragColumn(column, dropIndex) {
      return this.dragColumns([column], dropIndex);
    }
    /**
     * Drag multiple columns to drop index position.
     *
     * @param {Array} columns Array of visual column indexes to be dragged.
     * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.
     * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
     * @fires Hooks#beforeColumnMove
     * @fires Hooks#afterColumnMove
     * @returns {boolean}
     */
  }, {
    key: "dragColumns",
    value: function dragColumns(columns, dropIndex) {
      var finalIndex = this.countFinalIndex(columns, dropIndex);
      var priv = privatePool$6.get(this);
      priv.cachedDropIndex = dropIndex;
      return this.moveColumns(columns, finalIndex);
    }
    /**
     * Indicates if it's possible to move columns to the desired position. Some of the actions aren't
     * possible, i.e. You canât move more than one element to the last position.
     *
     * @param {Array} movedColumns Array of visual column indexes to be moved.
     * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
     * @returns {boolean}
     */
  }, {
    key: "isMovePossible",
    value: function isMovePossible(movedColumns, finalIndex) {
      var length = this.hot.columnIndexMapper.getNotTrimmedIndexesLength();
      var tooHighDestinationIndex = movedColumns.length + finalIndex > length;
      var tooLowDestinationIndex = finalIndex < 0;
      var tooLowMovedColumnIndex = movedColumns.some(function(movedColumn) {
        return movedColumn < 0;
      });
      var tooHighMovedColumnIndex = movedColumns.some(function(movedColumn) {
        return movedColumn >= length;
      });
      if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedColumnIndex || tooHighMovedColumnIndex) {
        return false;
      }
      return true;
    }
    /**
     * Indicates if order of columns was changed.
     *
     * @private
     * @param {Array} movedColumns Array of visual column indexes to be moved.
     * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
     * @returns {boolean}
     */
  }, {
    key: "isColumnOrderChanged",
    value: function isColumnOrderChanged(movedColumns, finalIndex) {
      return movedColumns.some(function(column, nrOfMovedElement) {
        return column - nrOfMovedElement !== finalIndex;
      });
    }
    /**
     * Count the final column index from the drop index.
     *
     * @private
     * @param {Array} movedColumns Array of visual column indexes to be moved.
     * @param {number} dropIndex Visual column index, being a drop index for the moved columns.
     * @returns {number} Visual column index, being a start index for the moved columns.
     */
  }, {
    key: "countFinalIndex",
    value: function countFinalIndex(movedColumns, dropIndex) {
      var numberOfColumnsLowerThanDropIndex = arrayReduce$1(movedColumns, function(numberOfColumns, currentColumnIndex) {
        if (currentColumnIndex < dropIndex) {
          numberOfColumns += 1;
        }
        return numberOfColumns;
      }, 0);
      return dropIndex - numberOfColumnsLowerThanDropIndex;
    }
    /**
     * Gets the sum of the widths of columns in the provided range.
     *
     * @private
     * @param {number} fromColumn Visual column index.
     * @param {number} toColumn Visual column index.
     * @returns {number}
     */
  }, {
    key: "getColumnsWidth",
    value: function getColumnsWidth(fromColumn, toColumn) {
      var columnMapper = this.hot.columnIndexMapper;
      var columnsWidth = 0;
      for (var visualColumnIndex = fromColumn; visualColumnIndex <= toColumn; visualColumnIndex += 1) {
        var renderableIndex = columnMapper.getRenderableFromVisualIndex(visualColumnIndex);
        if (visualColumnIndex < 0) {
          columnsWidth += this.hot.view._wt.wtViewport.getRowHeaderWidth() || 0;
        } else if (renderableIndex !== null) {
          columnsWidth += this.hot.view._wt.wtTable.getStretchedColumnWidth(renderableIndex) || 0;
        }
      }
      return columnsWidth;
    }
    /**
     * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
     *
     * @private
     */
  }, {
    key: "moveBySettingsOrLoad",
    value: function moveBySettingsOrLoad() {
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$d];
      if (Array.isArray(pluginSettings)) {
        this.moveColumns(pluginSettings, 0);
      } else if (pluginSettings !== void 0) {
        var persistentState = this.persistentStateLoad();
        if (persistentState.length) {
          this.moveColumns(persistentState, 0);
        }
      }
    }
    /**
     * Checks if the provided column is in the fixedColumnsTop section.
     *
     * @private
     * @param {number} column Visual column index to check.
     * @returns {boolean}
     */
  }, {
    key: "isFixedColumnsStart",
    value: function isFixedColumnsStart(column) {
      return column < this.hot.getSettings().fixedColumnsStart;
    }
    /**
     * Saves the manual column positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
     *
     * @private
     * @fires Hooks#persistentStateSave
     */
  }, {
    key: "persistentStateSave",
    value: function persistentStateSave() {
      this.hot.runHooks("persistentStateSave", "manualColumnMove", this.hot.columnIndexMapper.getIndexesSequence());
    }
    /**
     * Loads the manual column positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
     *
     * @private
     * @fires Hooks#persistentStateLoad
     * @returns {Array} Stored state.
     */
  }, {
    key: "persistentStateLoad",
    value: function persistentStateLoad() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualColumnMove", storedState);
      return storedState.value ? storedState.value : [];
    }
    /**
     * Prepares an array of indexes based on actual selection.
     *
     * @private
     * @param {number} start The start index.
     * @param {number} end The end index.
     * @returns {Array}
     */
  }, {
    key: "prepareColumnsToMoving",
    value: function prepareColumnsToMoving(start, end) {
      var selectedColumns = [];
      rangeEach(start, end, function(i) {
        selectedColumns.push(i);
      });
      return selectedColumns;
    }
    /**
     * Update the UI visual position.
     *
     * @private
     */
  }, {
    key: "refreshPositions",
    value: function refreshPositions() {
      var priv = privatePool$6.get(this);
      var firstVisible = this.hot.view.getFirstFullyVisibleColumn();
      if (this.isFixedColumnsStart(priv.hoveredColumn) && firstVisible > 0) {
        this.hot.scrollViewportTo(void 0, this.hot.columnIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));
      }
      var wtTable = this.hot.view._wt.wtTable;
      var scrollableElement = this.hot.view._wt.wtOverlays.scrollableElement;
      var scrollStart = typeof scrollableElement.scrollX === "number" ? scrollableElement.scrollX : scrollableElement.scrollLeft;
      var tdOffsetStart = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, priv.hoveredColumn - 1);
      var hiderWidth = wtTable.hider.offsetWidth;
      var tbodyOffsetLeft = wtTable.TBODY.offsetLeft;
      var backlightElemMarginStart = this.backlight.getOffset().start;
      var backlightElemWidth = this.backlight.getSize().width;
      var rowHeaderWidth = 0;
      var mouseOffsetStart = 0;
      if (this.hot.isRtl()) {
        var rootWindow = this.hot.rootWindow;
        var containerWidth = outerWidth(this.hot.rootElement);
        var gridMostRightPos = rootWindow.innerWidth - priv.rootElementOffset - containerWidth;
        mouseOffsetStart = rootWindow.innerWidth - priv.target.eventPageX - gridMostRightPos - (scrollableElement.scrollX === void 0 ? scrollStart : 0);
      } else {
        mouseOffsetStart = priv.target.eventPageX - (priv.rootElementOffset - (scrollableElement.scrollX === void 0 ? scrollStart : 0));
      }
      if (priv.hasRowHeaders) {
        rowHeaderWidth = this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth;
      }
      if (this.isFixedColumnsStart(priv.hoveredColumn)) {
        tdOffsetStart += scrollStart;
      }
      tdOffsetStart += rowHeaderWidth;
      if (priv.hoveredColumn < 0) {
        if (priv.fixedColumnsStart > 0) {
          priv.target.col = 0;
        } else {
          priv.target.col = firstVisible > 0 ? firstVisible - 1 : firstVisible;
        }
      } else if (priv.target.TD.offsetWidth / 2 + tdOffsetStart <= mouseOffsetStart) {
        var newCoordsCol = priv.hoveredColumn >= priv.countCols ? priv.countCols - 1 : priv.hoveredColumn;
        priv.target.col = newCoordsCol + 1;
        tdOffsetStart += priv.target.TD.offsetWidth;
      } else {
        priv.target.col = priv.hoveredColumn;
      }
      var backlightStart = mouseOffsetStart;
      var guidelineStart = tdOffsetStart;
      if (mouseOffsetStart + backlightElemWidth + backlightElemMarginStart >= hiderWidth) {
        backlightStart = hiderWidth - backlightElemWidth - backlightElemMarginStart;
      } else if (mouseOffsetStart + backlightElemMarginStart < tbodyOffsetLeft + rowHeaderWidth) {
        backlightStart = tbodyOffsetLeft + rowHeaderWidth + Math.abs(backlightElemMarginStart);
      }
      if (tdOffsetStart >= hiderWidth - 1) {
        guidelineStart = hiderWidth - 1;
      } else if (guidelineStart === 0) {
        guidelineStart = 1;
      } else if (scrollableElement.scrollX !== void 0 && priv.hoveredColumn < priv.fixedColumnsStart) {
        guidelineStart -= priv.rootElementOffset <= scrollableElement.scrollX ? priv.rootElementOffset : 0;
      }
      this.backlight.setPosition(null, backlightStart);
      this.guideline.setPosition(null, guidelineStart);
    }
    /**
     * Binds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this3 = this;
      var documentElement = this.hot.rootDocument.documentElement;
      this.eventManager.addEventListener(documentElement, "mousemove", function(event2) {
        return _this3.onMouseMove(event2);
      });
      this.eventManager.addEventListener(documentElement, "mouseup", function() {
        return _this3.onMouseUp();
      });
    }
    /**
     * Unbinds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
    /**
     * Change the behavior of selection / dragging.
     *
     * @private
     * @param {MouseEvent} event `mousedown` event properties.
     * @param {CellCoords} coords Visual cell coordinates where was fired event.
     * @param {HTMLElement} TD Cell represented as HTMLElement.
     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
     *                            a boolean value that allows or disallows changing the selection for that particular area.
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD, controller) {
      var wtTable = this.hot.view._wt.wtTable;
      var isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();
      var selection = this.hot.getSelectedRangeLast();
      var priv = privatePool$6.get(this);
      var isSortingElement = hasClass(event2.target, "sortAction");
      if (!selection || !isHeaderSelection || priv.pressed || event2.button !== 0 || isSortingElement) {
        priv.pressed = false;
        priv.columnsToMove.length = 0;
        removeClass(this.hot.rootElement, [CSS_ON_MOVING$1, CSS_SHOW_UI$1]);
        return;
      }
      var guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
      var backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
      if (guidelineIsNotReady && backlightIsNotReady) {
        this.guideline.appendTo(wtTable.hider);
        this.backlight.appendTo(wtTable.hider);
      }
      var from3 = selection.from, to = selection.to;
      var start = Math.min(from3.col, to.col);
      var end = Math.max(from3.col, to.col);
      if (coords.row < 0 && coords.col >= start && coords.col <= end) {
        controller.column = true;
        priv.pressed = true;
        priv.target.eventPageX = event2.pageX;
        priv.target.eventOffsetX = event2.offsetX;
        priv.hoveredColumn = coords.col;
        priv.target.TD = TD;
        priv.target.col = coords.col;
        priv.columnsToMove = this.prepareColumnsToMoving(start, end);
        priv.hasRowHeaders = !!this.hot.getSettings().rowHeaders;
        priv.countCols = this.hot.countCols();
        priv.fixedColumnsStart = this.hot.getSettings().fixedColumnsStart;
        priv.rootElementOffset = offset(this.hot.rootElement).left;
        var countColumnsFrom = priv.hasRowHeaders ? -1 : 0;
        var topPos = wtTable.holder.scrollTop + wtTable.getColumnHeaderHeight(0) + 1;
        var fixedColumnsStart = coords.col < priv.fixedColumnsStart;
        var horizontalScrollPosition = Math.abs(this.hot.view._wt.wtOverlays.inlineStartOverlay.getScrollPosition());
        var offsetX = Math.abs(event2.offsetX - (this.hot.isRtl() ? event2.target.offsetWidth : 0));
        var inlineOffset = this.getColumnsWidth(start, coords.col - 1) + offsetX;
        var inlinePos = this.getColumnsWidth(countColumnsFrom, start - 1) + (fixedColumnsStart ? horizontalScrollPosition : 0) + inlineOffset;
        this.backlight.setPosition(topPos, inlinePos);
        this.backlight.setSize(this.getColumnsWidth(start, end), wtTable.hider.offsetHeight - topPos);
        this.backlight.setOffset(null, -inlineOffset);
        addClass(this.hot.rootElement, CSS_ON_MOVING$1);
      } else {
        removeClass(this.hot.rootElement, CSS_AFTER_SELECTION$1);
        priv.pressed = false;
        priv.columnsToMove.length = 0;
      }
    }
    /**
     * 'mouseMove' event callback. Fired when pointer move on document.documentElement.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var priv = privatePool$6.get(this);
      if (!priv.pressed) {
        return;
      }
      if (event2.target === this.backlight.element) {
        var width = this.backlight.getSize().width;
        this.backlight.setSize(0);
        setTimeout(function() {
          this.backlight.setPosition(width);
        });
      }
      priv.target.eventPageX = event2.pageX;
      this.refreshPositions();
    }
    /**
     * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.
     *
     * @private
     * @param {MouseEvent} event `mouseover` event properties.
     * @param {CellCoords} coords Visual cell coordinates where was fired event.
     * @param {HTMLElement} TD Cell represented as HTMLElement.
     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
     *                            a boolean value that allows or disallows changing the selection for that particular area.
     */
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event2, coords, TD, controller) {
      var selectedRange = this.hot.getSelectedRangeLast();
      var priv = privatePool$6.get(this);
      if (!selectedRange || !priv.pressed) {
        return;
      }
      if (priv.columnsToMove.indexOf(coords.col) > -1) {
        removeClass(this.hot.rootElement, CSS_SHOW_UI$1);
      } else {
        addClass(this.hot.rootElement, CSS_SHOW_UI$1);
      }
      controller.row = true;
      controller.column = true;
      controller.cell = true;
      priv.hoveredColumn = coords.col;
      priv.target.TD = TD;
    }
    /**
     * `onMouseUp` hook callback.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var priv = privatePool$6.get(this);
      var target = priv.target.col;
      var columnsLen = priv.columnsToMove.length;
      priv.hoveredColumn = void 0;
      priv.pressed = false;
      priv.backlightWidth = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING$1, CSS_SHOW_UI$1, CSS_AFTER_SELECTION$1]);
      if (this.hot.selection.isSelectedByColumnHeader()) {
        addClass(this.hot.rootElement, CSS_AFTER_SELECTION$1);
      }
      if (columnsLen < 1 || target === void 0) {
        return;
      }
      var firstMovedVisualColumn = priv.columnsToMove[0];
      var firstMovedPhysicalColumn = this.hot.toPhysicalColumn(firstMovedVisualColumn);
      var movePerformed = this.dragColumns(priv.columnsToMove, target);
      priv.columnsToMove.length = 0;
      if (movePerformed === true) {
        this.persistentStateSave();
        this.hot.render();
        this.hot.view.adjustElementsSize(true);
        var selectionStart = this.hot.toVisualColumn(firstMovedPhysicalColumn);
        var selectionEnd = selectionStart + columnsLen - 1;
        this.hot.selectColumns(selectionStart, selectionEnd);
      }
    }
    /**
     * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.
     *
     * @private
     */
  }, {
    key: "onAfterScrollVertically",
    value: function onAfterScrollVertically() {
      var wtTable = this.hot.view._wt.wtTable;
      var headerHeight = wtTable.getColumnHeaderHeight(0) + 1;
      var scrollTop = wtTable.holder.scrollTop;
      var posTop = headerHeight + scrollTop;
      this.backlight.setPosition(posTop);
      this.backlight.setSize(null, wtTable.hider.offsetHeight - posTop);
    }
    /**
     * Builds the plugin's UI.
     *
     * @private
     */
  }, {
    key: "buildPluginUI",
    value: function buildPluginUI() {
      this.backlight.build();
      this.guideline.build();
    }
    /**
     * Callback for the `afterLoadData` hook.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      this.moveBySettingsOrLoad();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.backlight.destroy();
      this.guideline.destroy();
      _get$e(_getPrototypeOf$i(ManualColumnMove2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$d;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$c;
    }
  }]);
  return ManualColumnMove2;
}(BasePlugin);
function _typeof$i(obj) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$i(obj);
}
function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$v(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$d() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$d = Reflect.get.bind();
  } else {
    _get$d = function _get2(target, property, receiver) {
      var base = _superPropBase$d(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$d.apply(this, arguments);
}
function _superPropBase$d(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$h(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o, p2) {
  _setPrototypeOf$h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$h(o, p2);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self2, call2) {
  if (call2 && (_typeof$i(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$h(self2);
}
function _assertThisInitialized$h(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$h(o) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$h(o);
}
var PLUGIN_KEY$c = "manualColumnResize";
var PLUGIN_PRIORITY$b = 130;
var PERSISTENT_STATE_KEY$1 = "manualColumnWidths";
var privatePool$5 = /* @__PURE__ */ new WeakMap();
var ManualColumnResize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$h(ManualColumnResize2, _BasePlugin);
  var _super = _createSuper$h(ManualColumnResize2);
  function ManualColumnResize2(hotInstance) {
    var _this;
    _classCallCheck$v(this, ManualColumnResize2);
    _this = _super.call(this, hotInstance);
    var rootDocument = _this.hot.rootDocument;
    _this.currentTH = null;
    _this.currentCol = null;
    _this.selectedCols = [];
    _this.currentWidth = null;
    _this.newSize = null;
    _this.startY = null;
    _this.startWidth = null;
    _this.startOffset = null;
    _this.handle = rootDocument.createElement("DIV");
    _this.guide = rootDocument.createElement("DIV");
    _this.eventManager = new EventManager$1(_assertThisInitialized$h(_this));
    _this.pressed = null;
    _this.dblclick = 0;
    _this.autoresizeTimeout = null;
    _this.columnWidthsMap = void 0;
    privatePool$5.set(_assertThisInitialized$h(_this), {
      config: void 0
    });
    addClass(_this.handle, "manualColumnResizer");
    addClass(_this.guide, "manualColumnResizerGuide");
    return _this;
  }
  _createClass$v(ManualColumnResize2, [{
    key: "inlineDir",
    get: function get2() {
      return this.hot.isRtl() ? "right" : "left";
    }
    /**
     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
     * hook and if it returns `true` than the {@link ManualColumnResize#enablePlugin} method is called.
     *
     * @returns {boolean}
     */
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$c];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.columnWidthsMap = new PhysicalIndexToValueMap();
      this.columnWidthsMap.addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.columnIndexMapper.registerMap(this.pluginName, this.columnWidthsMap);
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.onModifyColWidth(width, col);
      });
      this.addHook("beforeStretchingColumnWidth", function(stretchedWidth, column) {
        return _this2.onBeforeStretchingColumnWidth(stretchedWidth, column);
      });
      this.addHook("beforeColumnResize", function(newSize, column, isDoubleClick) {
        return _this2.onBeforeColumnResize(newSize, column, isDoubleClick);
      });
      this.bindEvents();
      _get$d(_getPrototypeOf$h(ManualColumnResize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`manualColumnResize`](@/api/options.md#manualcolumnresize)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$d(_getPrototypeOf$h(ManualColumnResize2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var priv = privatePool$5.get(this);
      priv.config = this.columnWidthsMap.getValues();
      this.hot.columnIndexMapper.unregisterMap(this.pluginName);
      _get$d(_getPrototypeOf$h(ManualColumnResize2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
     *
     * @fires Hooks#persistentStateSave
     */
  }, {
    key: "saveManualColumnWidths",
    value: function saveManualColumnWidths() {
      this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY$1, this.columnWidthsMap.getValues());
    }
    /**
     * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
     *
     * @returns {Array}
     * @fires Hooks#persistentStateLoad
     */
  }, {
    key: "loadManualColumnWidths",
    value: function loadManualColumnWidths() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY$1, storedState);
      return storedState.value;
    }
    /**
     * Sets the new width for specified column index.
     *
     * @param {number} column Visual column index.
     * @param {number} width Column width (no less than 20px).
     * @returns {number} Returns new width.
     */
  }, {
    key: "setManualSize",
    value: function setManualSize(column, width) {
      var newWidth = Math.max(width, 20);
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.columnWidthsMap.setValueAtIndex(physicalColumn, newWidth);
      return newWidth;
    }
    /**
     * Clears the cache for the specified column index.
     *
     * @param {number} column Visual column index.
     */
  }, {
    key: "clearManualSize",
    value: function clearManualSize(column) {
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.columnWidthsMap.setValueAtIndex(physicalColumn, null);
    }
    /**
     * Callback to call on map's `init` local hook.
     *
     * @private
     */
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      var _this3 = this;
      var priv = privatePool$5.get(this);
      var initialSetting = this.hot.getSettings()[PLUGIN_KEY$c];
      var loadedManualColumnWidths = this.loadManualColumnWidths();
      if (typeof loadedManualColumnWidths !== "undefined") {
        this.hot.batchExecution(function() {
          loadedManualColumnWidths.forEach(function(width, physicalIndex) {
            _this3.columnWidthsMap.setValueAtIndex(physicalIndex, width);
          });
        }, true);
      } else if (Array.isArray(initialSetting)) {
        this.hot.batchExecution(function() {
          initialSetting.forEach(function(width, physicalIndex) {
            _this3.columnWidthsMap.setValueAtIndex(physicalIndex, width);
          });
        }, true);
        priv.config = initialSetting;
      } else if (initialSetting === true && Array.isArray(priv.config)) {
        this.hot.batchExecution(function() {
          priv.config.forEach(function(width, physicalIndex) {
            _this3.columnWidthsMap.setValueAtIndex(physicalIndex, width);
          });
        }, true);
      }
    }
    /**
     * Set the resize handle position.
     *
     * @private
     * @param {HTMLCellElement} TH TH HTML element.
     */
  }, {
    key: "setupHandlePosition",
    value: function setupHandlePosition(TH) {
      var _this4 = this;
      if (!TH.parentNode) {
        return;
      }
      this.currentTH = TH;
      var wt = this.hot.view._wt;
      var cellCoords = wt.wtTable.getCoords(this.currentTH);
      var col = cellCoords.col;
      if (col < 0) {
        return;
      }
      var headerHeight = outerHeight(this.currentTH);
      var box = this.currentTH.getBoundingClientRect();
      var fixedColumn = col < wt.getSetting("fixedColumnsStart");
      var relativeHeaderPosition;
      if (fixedColumn) {
        relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      if (!relativeHeaderPosition) {
        relativeHeaderPosition = wt.wtOverlays.topOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      this.currentCol = this.hot.columnIndexMapper.getVisualFromRenderableIndex(col);
      this.selectedCols = [];
      var isFullColumnSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByColumnHeader();
      if (this.hot.selection.isSelected() && isFullColumnSelected) {
        var selectionRanges = this.hot.getSelectedRange();
        arrayEach(selectionRanges, function(selectionRange) {
          var fromColumn = selectionRange.getTopStartCorner().col;
          var toColumn = selectionRange.getBottomEndCorner().col;
          rangeEach(fromColumn, toColumn, function(columnIndex) {
            if (!_this4.selectedCols.includes(columnIndex)) {
              _this4.selectedCols.push(columnIndex);
            }
          });
        });
      }
      if (!this.selectedCols.includes(this.currentCol)) {
        this.selectedCols = [this.currentCol];
      }
      this.startOffset = relativeHeaderPosition.start - 6;
      this.startWidth = parseInt(box.width, 10);
      this.handle.style.top = "".concat(relativeHeaderPosition.top, "px");
      this.handle.style[this.inlineDir] = "".concat(this.startOffset + this.startWidth, "px");
      this.handle.style.height = "".concat(headerHeight, "px");
      this.hot.rootElement.appendChild(this.handle);
    }
    /**
     * Refresh the resize handle position.
     *
     * @private
     */
  }, {
    key: "refreshHandlePosition",
    value: function refreshHandlePosition() {
      this.handle.style[this.inlineDir] = "".concat(this.startOffset + this.currentWidth, "px");
    }
    /**
     * Sets the resize guide position.
     *
     * @private
     */
  }, {
    key: "setupGuidePosition",
    value: function setupGuidePosition() {
      var handleHeight = parseInt(outerHeight(this.handle), 10);
      var handleBottomPosition = parseInt(this.handle.style.top, 10) + handleHeight;
      var maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
      addClass(this.handle, "active");
      addClass(this.guide, "active");
      this.guide.style.top = "".concat(handleBottomPosition, "px");
      this.refreshGuidePosition();
      this.guide.style.height = "".concat(maximumVisibleElementHeight - handleHeight, "px");
      this.hot.rootElement.appendChild(this.guide);
    }
    /**
     * Refresh the resize guide position.
     *
     * @private
     */
  }, {
    key: "refreshGuidePosition",
    value: function refreshGuidePosition() {
      this.guide.style[this.inlineDir] = this.handle.style[this.inlineDir];
    }
    /**
     * Hides both the resize handle and resize guide.
     *
     * @private
     */
  }, {
    key: "hideHandleAndGuide",
    value: function hideHandleAndGuide() {
      removeClass(this.handle, "active");
      removeClass(this.guide, "active");
    }
    /**
     * Checks if provided element is considered a column header.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {boolean}
     */
  }, {
    key: "checkIfColumnHeader",
    value: function checkIfColumnHeader(element) {
      return !!closest(element, ["THEAD"], this.hot.rootElement);
    }
    /**
     * Gets the TH element from the provided element.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {HTMLElement}
     */
  }, {
    key: "getClosestTHParent",
    value: function getClosestTHParent(element) {
      if (element.tagName !== "TABLE") {
        if (element.tagName === "TH") {
          return element;
        }
        return this.getClosestTHParent(element.parentNode);
      }
      return null;
    }
    /**
     * 'mouseover' event callback - set the handle position.
     *
     * @private
     * @param {MouseEvent} event The mouse event.
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      if (isDetached(event2.target)) {
        return;
      }
      if (this.checkIfColumnHeader(event2.target)) {
        var th = this.getClosestTHParent(event2.target);
        if (!th) {
          return;
        }
        var colspan = th.getAttribute("colspan");
        if (th && (colspan === null || colspan === "1")) {
          if (!this.pressed) {
            this.setupHandlePosition(th);
          }
        }
      }
    }
    /**
     * Auto-size row after doubleclick - callback.
     *
     * @private
     * @fires Hooks#beforeColumnResize
     * @fires Hooks#afterColumnResize
     */
  }, {
    key: "afterMouseDownTimeout",
    value: function afterMouseDownTimeout() {
      var _this5 = this;
      var render = function render2() {
        _this5.hot.forceFullRender = true;
        _this5.hot.view.render();
        _this5.hot.view.adjustElementsSize(true);
      };
      var resize = function resize2(column, forceRender) {
        var hookNewSize = _this5.hot.runHooks("beforeColumnResize", _this5.newSize, column, true);
        if (hookNewSize !== void 0) {
          _this5.newSize = hookNewSize;
        }
        if (_this5.hot.getSettings().stretchH === "all") {
          _this5.clearManualSize(column);
        } else {
          _this5.setManualSize(column, _this5.newSize);
        }
        _this5.saveManualColumnWidths();
        _this5.hot.runHooks("afterColumnResize", _this5.newSize, column, true);
        if (forceRender) {
          render();
        }
      };
      if (this.dblclick >= 2) {
        var selectedColsLength = this.selectedCols.length;
        if (selectedColsLength > 1) {
          arrayEach(this.selectedCols, function(selectedCol) {
            resize(selectedCol);
          });
          render();
        } else {
          arrayEach(this.selectedCols, function(selectedCol) {
            resize(selectedCol, true);
          });
        }
      }
      this.dblclick = 0;
      this.autoresizeTimeout = null;
    }
    /**
     * 'mousedown' event callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event.
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      var _this6 = this;
      if (hasClass(event2.target, "manualColumnResizer")) {
        this.setupHandlePosition(this.currentTH);
        this.setupGuidePosition();
        this.pressed = true;
        if (this.autoresizeTimeout === null) {
          this.autoresizeTimeout = setTimeout(function() {
            return _this6.afterMouseDownTimeout();
          }, 500);
          this.hot._registerTimeout(this.autoresizeTimeout);
        }
        this.dblclick += 1;
        this.startX = event2.pageX;
        this.newSize = this.startWidth;
      }
    }
    /**
     * 'mousemove' event callback - refresh the handle and guide positions, cache the new column width.
     *
     * @private
     * @param {MouseEvent} event The mouse event.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var _this7 = this;
      if (this.pressed) {
        var change = (event2.pageX - this.startX) * this.hot.getDirectionFactor();
        this.currentWidth = this.startWidth + change;
        arrayEach(this.selectedCols, function(selectedCol) {
          _this7.newSize = _this7.setManualSize(selectedCol, _this7.currentWidth);
        });
        this.refreshHandlePosition();
        this.refreshGuidePosition();
      }
    }
    /**
     * 'mouseup' event callback - apply the column resizing.
     *
     * @private
     *
     * @fires Hooks#beforeColumnResize
     * @fires Hooks#afterColumnResize
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var _this8 = this;
      var render = function render2() {
        _this8.hot.forceFullRender = true;
        _this8.hot.view.render();
        _this8.hot.view.adjustElementsSize(true);
      };
      var resize = function resize2(column, forceRender) {
        _this8.hot.runHooks("beforeColumnResize", _this8.newSize, column, false);
        if (forceRender) {
          render();
        }
        _this8.saveManualColumnWidths();
        _this8.hot.runHooks("afterColumnResize", _this8.newSize, column, false);
      };
      if (this.pressed) {
        this.hideHandleAndGuide();
        this.pressed = false;
        if (this.newSize !== this.startWidth) {
          var selectedColsLength = this.selectedCols.length;
          if (selectedColsLength > 1) {
            arrayEach(this.selectedCols, function(selectedCol) {
              resize(selectedCol);
            });
            render();
          } else {
            arrayEach(this.selectedCols, function(selectedCol) {
              resize(selectedCol, true);
            });
          }
        }
        this.setupHandlePosition(this.currentTH);
      }
    }
    /**
     * Binds the mouse events.
     *
     * @private
     */
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this9 = this;
      var _this$hot = this.hot, rootWindow = _this$hot.rootWindow, rootElement = _this$hot.rootElement;
      this.eventManager.addEventListener(rootElement, "mouseover", function(e2) {
        return _this9.onMouseOver(e2);
      });
      this.eventManager.addEventListener(rootElement, "mousedown", function(e2) {
        return _this9.onMouseDown(e2);
      });
      this.eventManager.addEventListener(rootWindow, "mousemove", function(e2) {
        return _this9.onMouseMove(e2);
      });
      this.eventManager.addEventListener(rootWindow, "mouseup", function() {
        return _this9.onMouseUp();
      });
    }
    /**
     * Modifies the provided column width, based on the plugin settings.
     *
     * @private
     * @param {number} width Column width.
     * @param {number} column Visual column index.
     * @returns {number}
     */
  }, {
    key: "onModifyColWidth",
    value: function onModifyColWidth(width, column) {
      var newWidth = width;
      if (this.enabled) {
        var physicalColumn = this.hot.toPhysicalColumn(column);
        var columnWidth = this.columnWidthsMap.getValueAtIndex(physicalColumn);
        if (this.hot.getSettings()[PLUGIN_KEY$c] && columnWidth) {
          newWidth = columnWidth;
        }
      }
      return newWidth;
    }
    /**
     * Modifies the provided column stretched width. This hook decides if specified column should be stretched or not.
     *
     * @private
     * @param {number} stretchedWidth Stretched width.
     * @param {number} column Visual column index.
     * @returns {number}
     */
  }, {
    key: "onBeforeStretchingColumnWidth",
    value: function onBeforeStretchingColumnWidth(stretchedWidth, column) {
      var width = this.columnWidthsMap.getValueAtIndex(column);
      if (width === null) {
        width = stretchedWidth;
      }
      return width;
    }
    /**
     * `beforeColumnResize` hook callback.
     *
     * @private
     */
  }, {
    key: "onBeforeColumnResize",
    value: function onBeforeColumnResize() {
      this.hot.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$d(_getPrototypeOf$h(ManualColumnResize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$c;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$b;
    }
  }]);
  return ManualColumnResize2;
}(BasePlugin);
function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$u(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var STATE_INITIALIZED = 0;
var STATE_BUILT = 1;
var STATE_APPENDED = 2;
var UNIT = "px";
var BaseUI$2 = /* @__PURE__ */ function() {
  function BaseUI3(hotInstance) {
    _classCallCheck$u(this, BaseUI3);
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED;
  }
  _createClass$u(BaseUI3, [{
    key: "appendTo",
    value: function appendTo(wrapper2) {
      wrapper2.appendChild(this._element);
      this.state = STATE_APPENDED;
    }
    /**
     * Method for create UI element. Only create, without append to table.
     */
  }, {
    key: "build",
    value: function build() {
      if (this.state !== STATE_INITIALIZED) {
        return;
      }
      this._element = this.hot.rootDocument.createElement("div");
      this.state = STATE_BUILT;
    }
    /**
     * Method for remove UI element.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isAppended()) {
        this._element.parentElement.removeChild(this._element);
      }
      this._element = null;
      this.state = STATE_INITIALIZED;
    }
    /**
     * Check if UI element are appended.
     *
     * @returns {boolean}
     */
  }, {
    key: "isAppended",
    value: function isAppended() {
      return this.state === STATE_APPENDED;
    }
    /**
     * Check if UI element are built.
     *
     * @returns {boolean}
     */
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.state >= STATE_BUILT;
    }
    /**
     * Setter for position.
     *
     * @param {number} top New top position of the element.
     * @param {number} left New left position of the element.
     */
  }, {
    key: "setPosition",
    value: function setPosition(top2, left2) {
      if (top2 !== void 0) {
        this._element.style.top = top2 + UNIT;
      }
      if (left2 !== void 0) {
        this._element.style.left = left2 + UNIT;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {object} Object contains left and top position of the element.
     */
  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        top: this._element.style.top ? parseInt(this._element.style.top, 10) : 0,
        left: this._element.style.left ? parseInt(this._element.style.left, 10) : 0
      };
    }
    /**
     * Setter for the element size.
     *
     * @param {number} width New width of the element.
     * @param {number} height New height of the element.
     */
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (width) {
        this._element.style.width = width + UNIT;
      }
      if (height) {
        this._element.style.height = height + UNIT;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {object} Object contains height and width of the element.
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
        height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
      };
    }
    /**
     * Setter for the element offset. Offset means marginTop and marginLeft of the element.
     *
     * @param {number} top New margin top of the element.
     * @param {number} left New margin left of the element.
     */
  }, {
    key: "setOffset",
    value: function setOffset(top2, left2) {
      if (top2) {
        this._element.style.marginTop = top2 + UNIT;
      }
      if (left2) {
        this._element.style.marginLeft = left2 + UNIT;
      }
    }
    /**
     * Getter for the element offset.
     *
     * @returns {object} Object contains top and left offset of the element.
     */
  }, {
    key: "getOffset",
    value: function getOffset() {
      return {
        top: this._element.style.marginTop ? parseInt(this._element.style.marginTop, 10) : 0,
        left: this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) : 0
      };
    }
  }]);
  return BaseUI3;
}();
const BaseUI$3 = BaseUI$2;
function _typeof$h(obj) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$h(obj);
}
function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$t(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$c() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$c = Reflect.get.bind();
  } else {
    _get$c = function _get2(target, property, receiver) {
      var base = _superPropBase$c(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$c.apply(this, arguments);
}
function _superPropBase$c(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$g(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o, p2) {
  _setPrototypeOf$g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$g(o, p2);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self2, call2) {
  if (call2 && (_typeof$h(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$g(self2);
}
function _assertThisInitialized$g(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$g(o) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$g(o);
}
var CSS_CLASSNAME$1 = "ht__manualRowMove--backlight";
var BacklightUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$g(BacklightUI2, _BaseUI);
  var _super = _createSuper$g(BacklightUI2);
  function BacklightUI2() {
    _classCallCheck$t(this, BacklightUI2);
    return _super.apply(this, arguments);
  }
  _createClass$t(BacklightUI2, [{
    key: "build",
    value: (
      /**
       * Custom className on build process.
       */
      function build() {
        _get$c(_getPrototypeOf$g(BacklightUI2.prototype), "build", this).call(this);
        addClass(this._element, CSS_CLASSNAME$1);
      }
    )
  }]);
  return BacklightUI2;
}(BaseUI$3);
const BacklightUI$1 = BacklightUI;
function _typeof$g(obj) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$g(obj);
}
function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$s(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$b() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$b = Reflect.get.bind();
  } else {
    _get$b = function _get2(target, property, receiver) {
      var base = _superPropBase$b(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$b.apply(this, arguments);
}
function _superPropBase$b(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$f(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o, p2) {
  _setPrototypeOf$f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$f(o, p2);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self2, call2) {
  if (call2 && (_typeof$g(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$f(self2);
}
function _assertThisInitialized$f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$f(o);
}
var CSS_CLASSNAME = "ht__manualRowMove--guideline";
var GuidelineUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$f(GuidelineUI2, _BaseUI);
  var _super = _createSuper$f(GuidelineUI2);
  function GuidelineUI2() {
    _classCallCheck$s(this, GuidelineUI2);
    return _super.apply(this, arguments);
  }
  _createClass$s(GuidelineUI2, [{
    key: "build",
    value: (
      /**
       * Custom className on build process.
       */
      function build() {
        _get$b(_getPrototypeOf$f(GuidelineUI2.prototype), "build", this).call(this);
        addClass(this._element, CSS_CLASSNAME);
      }
    )
  }]);
  return GuidelineUI2;
}(BaseUI$3);
const GuidelineUI$1 = GuidelineUI;
function _typeof$f(obj) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$f(obj);
}
function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$r(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$a() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$a = Reflect.get.bind();
  } else {
    _get$a = function _get2(target, property, receiver) {
      var base = _superPropBase$a(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$a.apply(this, arguments);
}
function _superPropBase$a(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$e(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o, p2) {
  _setPrototypeOf$e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$e(o, p2);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self2, call2) {
  if (call2 && (_typeof$f(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$e(o);
}
Hooks$1.getSingleton().register("beforeRowMove");
Hooks$1.getSingleton().register("afterRowMove");
var PLUGIN_KEY$b = "manualRowMove";
var PLUGIN_PRIORITY$a = 140;
var privatePool$4 = /* @__PURE__ */ new WeakMap();
var CSS_PLUGIN = "ht__manualRowMove";
var CSS_SHOW_UI = "show-ui";
var CSS_ON_MOVING = "on-moving--rows";
var CSS_AFTER_SELECTION = "after-selection--rows";
var ManualRowMove = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$e(ManualRowMove2, _BasePlugin);
  var _super = _createSuper$e(ManualRowMove2);
  function ManualRowMove2(hotInstance) {
    var _this;
    _classCallCheck$r(this, ManualRowMove2);
    _this = _super.call(this, hotInstance);
    privatePool$4.set(_assertThisInitialized$e(_this), {
      rowsToMove: [],
      pressed: void 0,
      target: {
        eventPageY: void 0,
        coords: void 0,
        TD: void 0,
        row: void 0
      },
      cachedDropIndex: void 0
    });
    _this.eventManager = new EventManager$1(_assertThisInitialized$e(_this));
    _this.backlight = new BacklightUI$1(hotInstance);
    _this.guideline = new GuidelineUI$1(hotInstance);
    return _this;
  }
  _createClass$r(ManualRowMove2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$b];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("beforeOnCellMouseDown", function() {
        return _this2.onBeforeOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseOver", function() {
        return _this2.onBeforeOnCellMouseOver.apply(_this2, arguments);
      });
      this.addHook("afterScrollHorizontally", function() {
        return _this2.onAfterScrollHorizontally();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.buildPluginUI();
      this.registerEvents();
      addClass(this.hot.rootElement, CSS_PLUGIN);
      _get$a(_getPrototypeOf$e(ManualRowMove2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`manualRowMove`](@/api/options.md#manualrowmove)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.moveBySettingsOrLoad();
      _get$a(_getPrototypeOf$e(ManualRowMove2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      removeClass(this.hot.rootElement, CSS_PLUGIN);
      this.unregisterEvents();
      this.backlight.destroy();
      this.guideline.destroy();
      _get$a(_getPrototypeOf$e(ManualRowMove2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Moves a single row.
     *
     * @param {number} row Visual row index to be moved.
     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
     * @fires Hooks#beforeRowMove
     * @fires Hooks#afterRowMove
     * @returns {boolean}
     */
  }, {
    key: "moveRow",
    value: function moveRow(row, finalIndex) {
      return this.moveRows([row], finalIndex);
    }
    /**
     * Moves a multiple rows.
     *
     * @param {Array} rows Array of visual row indexes to be moved.
     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
     * @fires Hooks#beforeRowMove
     * @fires Hooks#afterRowMove
     * @returns {boolean}
     */
  }, {
    key: "moveRows",
    value: function moveRows(rows, finalIndex) {
      var priv = privatePool$4.get(this);
      var dropIndex = priv.cachedDropIndex;
      var movePossible = this.isMovePossible(rows, finalIndex);
      var beforeMoveHook = this.hot.runHooks("beforeRowMove", rows, finalIndex, dropIndex, movePossible);
      priv.cachedDropIndex = void 0;
      if (beforeMoveHook === false) {
        return;
      }
      if (movePossible) {
        this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);
      }
      var movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);
      this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePerformed);
      return movePerformed;
    }
    /**
     * Drag a single row to drop index position.
     *
     * @param {number} row Visual row index to be dragged.
     * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.
     * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
     * @fires Hooks#beforeRowMove
     * @fires Hooks#afterRowMove
     * @returns {boolean}
     */
  }, {
    key: "dragRow",
    value: function dragRow(row, dropIndex) {
      return this.dragRows([row], dropIndex);
    }
    /**
     * Drag multiple rows to drop index position.
     *
     * @param {Array} rows Array of visual row indexes to be dragged.
     * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.
     * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
     * @fires Hooks#beforeRowMove
     * @fires Hooks#afterRowMove
     * @returns {boolean}
     */
  }, {
    key: "dragRows",
    value: function dragRows(rows, dropIndex) {
      var finalIndex = this.countFinalIndex(rows, dropIndex);
      var priv = privatePool$4.get(this);
      priv.cachedDropIndex = dropIndex;
      return this.moveRows(rows, finalIndex);
    }
    /**
     * Indicates if it's possible to move rows to the desired position. Some of the actions aren't possible, i.e. You canât move more than one element to the last position.
     *
     * @param {Array} movedRows Array of visual row indexes to be moved.
     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
     * @returns {boolean}
     */
  }, {
    key: "isMovePossible",
    value: function isMovePossible(movedRows, finalIndex) {
      var length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();
      var tooHighDestinationIndex = movedRows.length + finalIndex > length;
      var tooLowDestinationIndex = finalIndex < 0;
      var tooLowMovedRowIndex = movedRows.some(function(movedRow) {
        return movedRow < 0;
      });
      var tooHighMovedRowIndex = movedRows.some(function(movedRow) {
        return movedRow >= length;
      });
      if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {
        return false;
      }
      return true;
    }
    /**
     * Indicates if order of rows was changed.
     *
     * @private
     * @param {Array} movedRows Array of visual row indexes to be moved.
     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
     * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
     * @returns {boolean}
     */
  }, {
    key: "isRowOrderChanged",
    value: function isRowOrderChanged(movedRows, finalIndex) {
      return movedRows.some(function(row, nrOfMovedElement) {
        return row - nrOfMovedElement !== finalIndex;
      });
    }
    /**
     * Count the final row index from the drop index.
     *
     * @private
     * @param {Array} movedRows Array of visual row indexes to be moved.
     * @param {number} dropIndex Visual row index, being a drop index for the moved rows.
     * @returns {number} Visual row index, being a start index for the moved rows.
     */
  }, {
    key: "countFinalIndex",
    value: function countFinalIndex(movedRows, dropIndex) {
      var numberOfRowsLowerThanDropIndex = arrayReduce$1(movedRows, function(numberOfRows, currentRowIndex) {
        if (currentRowIndex < dropIndex) {
          numberOfRows += 1;
        }
        return numberOfRows;
      }, 0);
      return dropIndex - numberOfRowsLowerThanDropIndex;
    }
    /**
     * Gets the sum of the heights of rows in the provided range.
     *
     * @private
     * @param {number} fromRow Visual row index.
     * @param {number} toRow Visual row index.
     * @returns {number}
     */
  }, {
    key: "getRowsHeight",
    value: function getRowsHeight(fromRow, toRow) {
      var rowMapper = this.hot.rowIndexMapper;
      var rowsHeight = 0;
      for (var visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {
        var renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);
        if (renderableIndex !== null) {
          rowsHeight += this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;
        }
      }
      return rowsHeight;
    }
    /**
     * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
     *
     * @private
     */
  }, {
    key: "moveBySettingsOrLoad",
    value: function moveBySettingsOrLoad() {
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$b];
      if (Array.isArray(pluginSettings)) {
        this.moveRows(pluginSettings, 0);
      } else if (pluginSettings !== void 0) {
        var persistentState = this.persistentStateLoad();
        if (persistentState.length) {
          this.moveRows(persistentState, 0);
        }
      }
    }
    /**
     * Checks if the provided row is in the fixedRowsTop section.
     *
     * @private
     * @param {number} row Visual row index to check.
     * @returns {boolean}
     */
  }, {
    key: "isFixedRowTop",
    value: function isFixedRowTop(row) {
      return row < this.hot.getSettings().fixedRowsTop;
    }
    /**
     * Checks if the provided row is in the fixedRowsBottom section.
     *
     * @private
     * @param {number} row Visual row index to check.
     * @returns {boolean}
     */
  }, {
    key: "isFixedRowBottom",
    value: function isFixedRowBottom(row) {
      return row > this.hot.countRows() - 1 - this.hot.getSettings().fixedRowsBottom;
    }
    /**
     * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
     *
     * @private
     * @fires Hooks#persistentStateSave
     */
  }, {
    key: "persistentStateSave",
    value: function persistentStateSave() {
      this.hot.runHooks("persistentStateSave", "manualRowMove", this.hot.rowIndexMapper.getIndexesSequence());
    }
    /**
     * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
     *
     * @private
     * @fires Hooks#persistentStateLoad
     * @returns {Array} Stored state.
     */
  }, {
    key: "persistentStateLoad",
    value: function persistentStateLoad() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualRowMove", storedState);
      return storedState.value ? storedState.value : [];
    }
    /**
     * Prepares an array of indexes based on actual selection.
     *
     * @private
     * @returns {Array}
     */
  }, {
    key: "prepareRowsToMoving",
    value: function prepareRowsToMoving() {
      var selection = this.hot.getSelectedRangeLast();
      var selectedRows = [];
      if (!selection) {
        return selectedRows;
      }
      var from3 = selection.from, to = selection.to;
      var start = Math.min(from3.row, to.row);
      var end = Math.max(from3.row, to.row);
      rangeEach(start, end, function(i) {
        selectedRows.push(i);
      });
      return selectedRows;
    }
    /**
     * Update the UI visual position.
     *
     * @private
     */
  }, {
    key: "refreshPositions",
    value: function refreshPositions() {
      var priv = privatePool$4.get(this);
      var coords = priv.target.coords;
      var firstVisible = this.hot.view.getFirstFullyVisibleRow();
      var lastVisible = this.hot.view.getLastFullyVisibleRow();
      var countRows = this.hot.countRows();
      if (this.isFixedRowTop(coords.row) && firstVisible > 0) {
        this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));
      }
      if (this.isFixedRowBottom(coords.row) && lastVisible < countRows) {
        this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(lastVisible + 1, 1), void 0, true);
      }
      var wtTable = this.hot.view._wt.wtTable;
      var TD = priv.target.TD;
      var rootElementOffset = offset(this.hot.rootElement);
      var tdOffsetTop = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);
      var mouseOffsetTop = priv.target.eventPageY - rootElementOffset.top + wtTable.holder.scrollTop;
      var hiderHeight = wtTable.hider.offsetHeight;
      var tbodyOffsetTop = wtTable.TBODY.offsetTop;
      var backlightElemMarginTop = this.backlight.getOffset().top;
      var backlightElemHeight = this.backlight.getSize().height;
      if (this.isFixedRowTop(coords.row)) {
        tdOffsetTop += wtTable.holder.scrollTop;
      }
      if (coords.row < 0) {
        priv.target.row = firstVisible > 0 ? firstVisible - 1 : firstVisible;
      } else if (TD.offsetHeight / 2 + tdOffsetTop <= mouseOffsetTop) {
        priv.target.row = coords.row + 1;
        tdOffsetTop += coords.row === 0 ? TD.offsetHeight - 1 : TD.offsetHeight;
      } else {
        priv.target.row = coords.row;
      }
      var backlightTop = mouseOffsetTop;
      var guidelineTop = tdOffsetTop;
      if (mouseOffsetTop + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {
        backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;
      } else if (mouseOffsetTop + backlightElemMarginTop < tbodyOffsetTop) {
        backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);
      }
      if (tdOffsetTop >= hiderHeight - 1) {
        guidelineTop = hiderHeight - 1;
      }
      this.backlight.setPosition(backlightTop);
      this.guideline.setPosition(guidelineTop);
    }
    /**
     * Binds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this3 = this;
      var documentElement = this.hot.rootDocument.documentElement;
      this.eventManager.addEventListener(documentElement, "mousemove", function(event2) {
        return _this3.onMouseMove(event2);
      });
      this.eventManager.addEventListener(documentElement, "mouseup", function() {
        return _this3.onMouseUp();
      });
    }
    /**
     * Unbinds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
    /**
     * Change the behavior of selection / dragging.
     *
     * @private
     * @param {MouseEvent} event `mousedown` event properties.
     * @param {CellCoords} coords Visual cell coordinates where was fired event.
     * @param {HTMLElement} TD Cell represented as HTMLElement.
     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
     *                            a boolean value that allows or disallows changing the selection for that particular area.
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD, controller) {
      var _this$hot$view$_wt = this.hot.view._wt, wtTable = _this$hot$view$_wt.wtTable, wtViewport = _this$hot$view$_wt.wtViewport;
      var isHeaderSelection = this.hot.selection.isSelectedByRowHeader();
      var selection = this.hot.getSelectedRangeLast();
      var priv = privatePool$4.get(this);
      if (!selection || !isHeaderSelection || priv.pressed || event2.button !== 0) {
        priv.pressed = false;
        priv.rowsToMove.length = 0;
        removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);
        return;
      }
      var guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
      var backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
      if (guidelineIsNotReady && backlightIsNotReady) {
        this.guideline.appendTo(wtTable.hider);
        this.backlight.appendTo(wtTable.hider);
      }
      var from3 = selection.from, to = selection.to;
      var start = Math.min(from3.row, to.row);
      var end = Math.max(from3.row, to.row);
      if (coords.col < 0 && coords.row >= start && coords.row <= end) {
        controller.row = true;
        priv.pressed = true;
        priv.target.eventPageY = event2.pageY;
        priv.target.coords = coords;
        priv.target.TD = TD;
        priv.rowsToMove = this.prepareRowsToMoving();
        var leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();
        this.backlight.setPosition(null, leftPos);
        this.backlight.setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));
        this.backlight.setOffset((this.getRowsHeight(start, coords.row - 1) + event2.offsetY) * -1, null);
        addClass(this.hot.rootElement, CSS_ON_MOVING);
        this.refreshPositions();
      } else {
        removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);
        priv.pressed = false;
        priv.rowsToMove.length = 0;
      }
    }
    /**
     * 'mouseMove' event callback. Fired when pointer move on document.documentElement.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var priv = privatePool$4.get(this);
      if (!priv.pressed) {
        return;
      }
      if (event2.target === this.backlight.element) {
        var height = this.backlight.getSize().height;
        this.backlight.setSize(null, 0);
        setTimeout(function() {
          this.backlight.setPosition(null, height);
        });
      }
      priv.target.eventPageY = event2.pageY;
      this.refreshPositions();
    }
    /**
     * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.
     *
     * @private
     * @param {MouseEvent} event `mouseover` event properties.
     * @param {CellCoords} coords Visual cell coordinates where was fired event.
     * @param {HTMLElement} TD Cell represented as HTMLElement.
     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
     *                            a boolean value that allows or disallows changing the selection for that particular area.
     */
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event2, coords, TD, controller) {
      var selectedRange = this.hot.getSelectedRangeLast();
      var priv = privatePool$4.get(this);
      if (!selectedRange || !priv.pressed) {
        return;
      }
      if (priv.rowsToMove.indexOf(coords.row) > -1) {
        removeClass(this.hot.rootElement, CSS_SHOW_UI);
      } else {
        addClass(this.hot.rootElement, CSS_SHOW_UI);
      }
      controller.row = true;
      controller.column = true;
      controller.cell = true;
      priv.target.coords = coords;
      priv.target.TD = TD;
    }
    /**
     * `onMouseUp` hook callback.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var priv = privatePool$4.get(this);
      var target = priv.target.row;
      var rowsLen = priv.rowsToMove.length;
      priv.pressed = false;
      priv.backlightHeight = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);
      if (this.hot.selection.isSelectedByRowHeader()) {
        addClass(this.hot.rootElement, CSS_AFTER_SELECTION);
      }
      if (rowsLen < 1 || target === void 0) {
        return;
      }
      var firstMovedVisualRow = priv.rowsToMove[0];
      var firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);
      var movePerformed = this.dragRows(priv.rowsToMove, target);
      priv.rowsToMove.length = 0;
      if (movePerformed === true) {
        this.persistentStateSave();
        this.hot.render();
        this.hot.view.adjustElementsSize(true);
        var selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);
        var selectionEnd = selectionStart + rowsLen - 1;
        this.hot.selectRows(selectionStart, selectionEnd);
      }
    }
    /**
     * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.
     *
     * @private
     */
  }, {
    key: "onAfterScrollHorizontally",
    value: function onAfterScrollHorizontally() {
      var wtTable = this.hot.view._wt.wtTable;
      var headerWidth = this.hot.view._wt.wtViewport.getRowHeaderWidth();
      var scrollLeft = wtTable.holder.scrollLeft;
      var posLeft = headerWidth + scrollLeft;
      this.backlight.setPosition(null, posLeft);
      this.backlight.setSize(wtTable.hider.offsetWidth - posLeft);
    }
    /**
     * Builds the plugin's UI.
     *
     * @private
     */
  }, {
    key: "buildPluginUI",
    value: function buildPluginUI() {
      this.backlight.build();
      this.guideline.build();
    }
    /**
     * Callback for the `afterLoadData` hook.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      this.moveBySettingsOrLoad();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.backlight.destroy();
      this.guideline.destroy();
      _get$a(_getPrototypeOf$e(ManualRowMove2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$b;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$a;
    }
  }]);
  return ManualRowMove2;
}(BasePlugin);
function _typeof$e(obj) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$e(obj);
}
function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$q(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$9() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$9 = Reflect.get.bind();
  } else {
    _get$9 = function _get2(target, property, receiver) {
      var base = _superPropBase$9(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$9.apply(this, arguments);
}
function _superPropBase$9(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$d(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o, p2) {
  _setPrototypeOf$d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$d(o, p2);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self2, call2) {
  if (call2 && (_typeof$e(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$d(o);
}
var PLUGIN_KEY$a = "manualRowResize";
var PLUGIN_PRIORITY$9 = 30;
var PERSISTENT_STATE_KEY = "manualRowHeights";
var privatePool$3 = /* @__PURE__ */ new WeakMap();
var ManualRowResize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$d(ManualRowResize2, _BasePlugin);
  var _super = _createSuper$d(ManualRowResize2);
  function ManualRowResize2(hotInstance) {
    var _this;
    _classCallCheck$q(this, ManualRowResize2);
    _this = _super.call(this, hotInstance);
    var rootDocument = _this.hot.rootDocument;
    _this.currentTH = null;
    _this.currentRow = null;
    _this.selectedRows = [];
    _this.currentHeight = null;
    _this.newSize = null;
    _this.startY = null;
    _this.startHeight = null;
    _this.startOffset = null;
    _this.handle = rootDocument.createElement("DIV");
    _this.guide = rootDocument.createElement("DIV");
    _this.eventManager = new EventManager$1(_assertThisInitialized$d(_this));
    _this.pressed = null;
    _this.dblclick = 0;
    _this.autoresizeTimeout = null;
    _this.rowHeightsMap = void 0;
    privatePool$3.set(_assertThisInitialized$d(_this), {
      config: void 0
    });
    addClass(_this.handle, "manualRowResizer");
    addClass(_this.guide, "manualRowResizerGuide");
    return _this;
  }
  _createClass$q(ManualRowResize2, [{
    key: "inlineDir",
    get: function get2() {
      return this.hot.isRtl() ? "right" : "left";
    }
    /**
     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
     * hook and if it returns `true` than the {@link ManualRowResize#enablePlugin} method is called.
     *
     * @returns {boolean}
     */
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$a];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.rowHeightsMap = new PhysicalIndexToValueMap();
      this.rowHeightsMap.addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.rowIndexMapper.registerMap(this.pluginName, this.rowHeightsMap);
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.onModifyRowHeight(height, row);
      });
      this.bindEvents();
      _get$9(_getPrototypeOf$d(ManualRowResize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`manualRowResize`](@/api/options.md#manualrowresize)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$9(_getPrototypeOf$d(ManualRowResize2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var priv = privatePool$3.get(this);
      priv.config = this.rowHeightsMap.getValues();
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      _get$9(_getPrototypeOf$d(ManualRowResize2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be
     * enabled).
     *
     * @fires Hooks#persistentStateSave
     */
  }, {
    key: "saveManualRowHeights",
    value: function saveManualRowHeights() {
      this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY, this.rowHeightsMap.getValues());
    }
    /**
     * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option
     * has be enabled).
     *
     * @returns {Array}
     * @fires Hooks#persistentStateLoad
     */
  }, {
    key: "loadManualRowHeights",
    value: function loadManualRowHeights() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY, storedState);
      return storedState.value;
    }
    /**
     * Sets the new height for specified row index.
     *
     * @param {number} row Visual row index.
     * @param {number} height Row height.
     * @returns {number} Returns new height.
     */
  }, {
    key: "setManualSize",
    value: function setManualSize(row, height) {
      var physicalRow = this.hot.toPhysicalRow(row);
      var newHeight = Math.max(height, ViewportRowsCalculator$1.DEFAULT_HEIGHT);
      this.rowHeightsMap.setValueAtIndex(physicalRow, newHeight);
      return newHeight;
    }
    /**
     * Sets the resize handle position.
     *
     * @private
     * @param {HTMLCellElement} TH TH HTML element.
     */
  }, {
    key: "setupHandlePosition",
    value: function setupHandlePosition(TH) {
      var _this3 = this;
      this.currentTH = TH;
      var view = this.hot.view;
      var wt = view._wt;
      var cellCoords = wt.wtTable.getCoords(this.currentTH);
      var row = cellCoords.row;
      if (row < 0) {
        return;
      }
      var headerWidth = outerWidth(this.currentTH);
      var box = this.currentTH.getBoundingClientRect();
      var fixedRowTop = row < wt.getSetting("fixedRowsTop");
      var fixedRowBottom = row >= view.countNotHiddenRowIndexes(0, 1) - wt.getSetting("fixedRowsBottom");
      var relativeHeaderPosition;
      if (fixedRowTop) {
        relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      } else if (fixedRowBottom) {
        relativeHeaderPosition = wt.wtOverlays.bottomInlineStartCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      if (!relativeHeaderPosition) {
        relativeHeaderPosition = wt.wtOverlays.inlineStartOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      this.currentRow = this.hot.rowIndexMapper.getVisualFromRenderableIndex(row);
      this.selectedRows = [];
      var isFullRowSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByRowHeader();
      if (this.hot.selection.isSelected() && isFullRowSelected) {
        var selectionRanges = this.hot.getSelectedRange();
        arrayEach(selectionRanges, function(selectionRange) {
          var fromRow = selectionRange.getTopStartCorner().row;
          var toRow = selectionRange.getBottomStartCorner().row;
          rangeEach(fromRow, toRow, function(rowIndex) {
            if (!_this3.selectedRows.includes(rowIndex)) {
              _this3.selectedRows.push(rowIndex);
            }
          });
        });
      }
      if (!this.selectedRows.includes(this.currentRow)) {
        this.selectedRows = [this.currentRow];
      }
      this.startOffset = relativeHeaderPosition.top - 6;
      this.startHeight = parseInt(box.height, 10);
      this.handle.style.top = "".concat(this.startOffset + this.startHeight, "px");
      this.handle.style[this.inlineDir] = "".concat(relativeHeaderPosition.start, "px");
      this.handle.style.width = "".concat(headerWidth, "px");
      this.hot.rootElement.appendChild(this.handle);
    }
    /**
     * Refresh the resize handle position.
     *
     * @private
     */
  }, {
    key: "refreshHandlePosition",
    value: function refreshHandlePosition() {
      this.handle.style.top = "".concat(this.startOffset + this.currentHeight, "px");
    }
    /**
     * Sets the resize guide position.
     *
     * @private
     */
  }, {
    key: "setupGuidePosition",
    value: function setupGuidePosition() {
      var handleWidth = parseInt(outerWidth(this.handle), 10);
      var handleEndPosition = parseInt(this.handle.style[this.inlineDir], 10) + handleWidth;
      var maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
      addClass(this.handle, "active");
      addClass(this.guide, "active");
      this.guide.style.top = this.handle.style.top;
      this.guide.style[this.inlineDir] = "".concat(handleEndPosition, "px");
      this.guide.style.width = "".concat(maximumVisibleElementWidth - handleWidth, "px");
      this.hot.rootElement.appendChild(this.guide);
    }
    /**
     * Refresh the resize guide position.
     *
     * @private
     */
  }, {
    key: "refreshGuidePosition",
    value: function refreshGuidePosition() {
      this.guide.style.top = this.handle.style.top;
    }
    /**
     * Hides both the resize handle and resize guide.
     *
     * @private
     */
  }, {
    key: "hideHandleAndGuide",
    value: function hideHandleAndGuide() {
      removeClass(this.handle, "active");
      removeClass(this.guide, "active");
    }
    /**
     * Checks if provided element is considered as a row header.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {boolean}
     */
  }, {
    key: "checkIfRowHeader",
    value: function checkIfRowHeader(element) {
      var _element$parentNode, _element$parentNode$p;
      var thElement = closest(element, ["TH"], this.hot.rootElement);
      return thElement && ((_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 ? void 0 : (_element$parentNode$p = _element$parentNode.parentNode) === null || _element$parentNode$p === void 0 ? void 0 : _element$parentNode$p.tagName) === "TBODY";
    }
    /**
     * Gets the TH element from the provided element.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {HTMLElement}
     */
  }, {
    key: "getClosestTHParent",
    value: function getClosestTHParent(element) {
      if (element.tagName !== "TABLE") {
        if (element.tagName === "TH") {
          return element;
        }
        return this.getClosestTHParent(element.parentNode);
      }
      return null;
    }
    /**
     * Returns the actual height for the provided row index.
     *
     * @private
     * @param {number} row Visual row index.
     * @returns {number} Actual row height.
     */
  }, {
    key: "getActualRowHeight",
    value: function getActualRowHeight(row) {
      var walkontableHeight = this.hot.view._wt.wtTable.getRowHeight(row);
      if (walkontableHeight !== void 0 && this.newSize < walkontableHeight) {
        return walkontableHeight;
      }
      return this.newSize;
    }
    /**
     * 'mouseover' event callback - set the handle position.
     *
     * @private
     * @param {MouseEvent} event The mouse event.
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      if (isDetached(event2.target)) {
        return;
      }
      if (this.checkIfRowHeader(event2.target)) {
        var th = this.getClosestTHParent(event2.target);
        if (th) {
          if (!this.pressed) {
            this.setupHandlePosition(th);
          }
        }
      }
    }
    /**
     * Auto-size row after doubleclick - callback.
     *
     * @private
     * @fires Hooks#beforeRowResize
     * @fires Hooks#afterRowResize
     */
  }, {
    key: "afterMouseDownTimeout",
    value: function afterMouseDownTimeout() {
      var _this4 = this;
      var render = function render2() {
        _this4.hot.forceFullRender = true;
        _this4.hot.view.render();
        _this4.hot.view.adjustElementsSize(true);
      };
      var resize = function resize2(row, forceRender) {
        var hookNewSize = _this4.hot.runHooks("beforeRowResize", _this4.getActualRowHeight(row), row, true);
        if (hookNewSize !== void 0) {
          _this4.newSize = hookNewSize;
        }
        _this4.setManualSize(row, _this4.newSize);
        _this4.hot.runHooks("afterRowResize", _this4.getActualRowHeight(row), row, true);
        if (forceRender) {
          render();
        }
      };
      if (this.dblclick >= 2) {
        var selectedRowsLength = this.selectedRows.length;
        if (selectedRowsLength > 1) {
          arrayEach(this.selectedRows, function(selectedRow) {
            resize(selectedRow);
          });
          render();
        } else {
          arrayEach(this.selectedRows, function(selectedRow) {
            resize(selectedRow, true);
          });
        }
      }
      this.dblclick = 0;
      this.autoresizeTimeout = null;
    }
    /**
     * 'mousedown' event callback.
     *
     * @private
     * @param {MouseEvent} event The mouse event.
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      var _this5 = this;
      if (hasClass(event2.target, "manualRowResizer")) {
        this.setupHandlePosition(this.currentTH);
        this.setupGuidePosition();
        this.pressed = true;
        if (this.autoresizeTimeout === null) {
          this.autoresizeTimeout = setTimeout(function() {
            return _this5.afterMouseDownTimeout();
          }, 500);
          this.hot._registerTimeout(this.autoresizeTimeout);
        }
        this.dblclick += 1;
        this.startY = event2.pageY;
        this.newSize = this.startHeight;
      }
    }
    /**
     * 'mousemove' event callback - refresh the handle and guide positions, cache the new row height.
     *
     * @private
     * @param {MouseEvent} event The mouse event.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var _this6 = this;
      if (this.pressed) {
        this.currentHeight = this.startHeight + (event2.pageY - this.startY);
        arrayEach(this.selectedRows, function(selectedRow) {
          _this6.newSize = _this6.setManualSize(selectedRow, _this6.currentHeight);
        });
        this.refreshHandlePosition();
        this.refreshGuidePosition();
      }
    }
    /**
     * 'mouseup' event callback - apply the row resizing.
     *
     * @private
     *
     * @fires Hooks#beforeRowResize
     * @fires Hooks#afterRowResize
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var _this7 = this;
      var render = function render2() {
        _this7.hot.forceFullRender = true;
        _this7.hot.view.render();
        _this7.hot.view.adjustElementsSize(true);
      };
      var runHooks = function runHooks2(row, forceRender) {
        _this7.hot.runHooks("beforeRowResize", _this7.getActualRowHeight(row), row, false);
        if (forceRender) {
          render();
        }
        _this7.saveManualRowHeights();
        _this7.hot.runHooks("afterRowResize", _this7.getActualRowHeight(row), row, false);
      };
      if (this.pressed) {
        this.hideHandleAndGuide();
        this.pressed = false;
        if (this.newSize !== this.startHeight) {
          var selectedRowsLength = this.selectedRows.length;
          if (selectedRowsLength > 1) {
            arrayEach(this.selectedRows, function(selectedRow) {
              runHooks(selectedRow);
            });
            render();
          } else {
            arrayEach(this.selectedRows, function(selectedRow) {
              runHooks(selectedRow, true);
            });
          }
        }
        this.setupHandlePosition(this.currentTH);
      }
    }
    /**
     * Binds the mouse events.
     *
     * @private
     */
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this8 = this;
      var _this$hot = this.hot, rootElement = _this$hot.rootElement, rootWindow = _this$hot.rootWindow;
      this.eventManager.addEventListener(rootElement, "mouseover", function(e2) {
        return _this8.onMouseOver(e2);
      });
      this.eventManager.addEventListener(rootElement, "mousedown", function(e2) {
        return _this8.onMouseDown(e2);
      });
      this.eventManager.addEventListener(rootWindow, "mousemove", function(e2) {
        return _this8.onMouseMove(e2);
      });
      this.eventManager.addEventListener(rootWindow, "mouseup", function() {
        return _this8.onMouseUp();
      });
    }
    /**
     * Modifies the provided row height, based on the plugin settings.
     *
     * @private
     * @param {number} height Row height.
     * @param {number} row Visual row index.
     * @returns {number}
     */
  }, {
    key: "onModifyRowHeight",
    value: function onModifyRowHeight(height, row) {
      var newHeight = height;
      if (this.enabled) {
        var physicalRow = this.hot.toPhysicalRow(row);
        var rowHeight = this.rowHeightsMap.getValueAtIndex(physicalRow);
        if (this.hot.getSettings()[PLUGIN_KEY$a] && rowHeight) {
          newHeight = rowHeight;
        }
      }
      return newHeight;
    }
    /**
     * Callback to call on map's `init` local hook.
     *
     * @private
     */
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      var _this9 = this;
      var priv = privatePool$3.get(this);
      var initialSetting = this.hot.getSettings()[PLUGIN_KEY$a];
      var loadedManualRowHeights = this.loadManualRowHeights();
      this.hot.batchExecution(function() {
        if (typeof loadedManualRowHeights !== "undefined") {
          loadedManualRowHeights.forEach(function(height, index2) {
            _this9.rowHeightsMap.setValueAtIndex(index2, height);
          });
        } else if (Array.isArray(initialSetting)) {
          initialSetting.forEach(function(height, index2) {
            _this9.rowHeightsMap.setValueAtIndex(index2, height);
          });
          priv.config = initialSetting;
        } else if (initialSetting === true && Array.isArray(priv.config)) {
          priv.config.forEach(function(height, index2) {
            _this9.rowHeightsMap.setValueAtIndex(index2, height);
          });
        }
      }, true);
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$9(_getPrototypeOf$d(ManualRowResize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$a;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$9;
    }
  }]);
  return ManualRowResize2;
}(BasePlugin);
var _templateObject$6, _templateObject2$1, _templateObject3, _templateObject4;
function _taggedTemplateLiteral$6(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$p(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var MergedCellCoords = /* @__PURE__ */ function() {
  function MergedCellCoords2(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {
    _classCallCheck$p(this, MergedCellCoords2);
    this.row = row;
    this.col = column;
    this.rowspan = rowspan;
    this.colspan = colspan;
    this.removed = false;
    this.cellCoordsFactory = cellCoordsFactory;
    this.cellRangeFactory = cellRangeFactory;
  }
  _createClass$p(MergedCellCoords2, [{
    key: "normalize",
    value: (
      /**
       * Sanitize (prevent from going outside the boundaries) the merged cell.
       *
       * @param {Core} hotInstance The Handsontable instance.
       */
      function normalize2(hotInstance) {
        var totalRows = hotInstance.countRows();
        var totalColumns = hotInstance.countCols();
        if (this.row < 0) {
          this.row = 0;
        } else if (this.row > totalRows - 1) {
          this.row = totalRows - 1;
        }
        if (this.col < 0) {
          this.col = 0;
        } else if (this.col > totalColumns - 1) {
          this.col = totalColumns - 1;
        }
        if (this.row + this.rowspan > totalRows - 1) {
          this.rowspan = totalRows - this.row;
        }
        if (this.col + this.colspan > totalColumns - 1) {
          this.colspan = totalColumns - this.col;
        }
      }
    )
    /**
     * Returns `true` if the provided coordinates are inside the merged cell.
     *
     * @param {number} row The row index.
     * @param {number} column The column index.
     * @returns {boolean}
     */
  }, {
    key: "includes",
    value: function includes3(row, column) {
      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;
    }
    /**
     * Returns `true` if the provided `column` property is within the column span of the merged cell.
     *
     * @param {number} column The column index.
     * @returns {boolean}
     */
  }, {
    key: "includesHorizontally",
    value: function includesHorizontally(column) {
      return this.col <= column && this.col + this.colspan - 1 >= column;
    }
    /**
     * Returns `true` if the provided `row` property is within the row span of the merged cell.
     *
     * @param {number} row Row index.
     * @returns {boolean}
     */
  }, {
    key: "includesVertically",
    value: function includesVertically(row) {
      return this.row <= row && this.row + this.rowspan - 1 >= row;
    }
    /**
     * Shift (and possibly resize, if needed) the merged cell.
     *
     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.
     * @param {number} indexOfChange Index of the preceding change.
     * @returns {boolean} Returns `false` if the whole merged cell was removed.
     */
  }, {
    key: "shift",
    value: function shift(shiftVector, indexOfChange) {
      var shiftValue = shiftVector[0] || shiftVector[1];
      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;
      var span = shiftVector[0] ? "colspan" : "rowspan";
      var index2 = shiftVector[0] ? "col" : "row";
      var changeStart = Math.min(indexOfChange, shiftedIndex);
      var changeEnd = Math.max(indexOfChange, shiftedIndex);
      var mergeStart = this[index2];
      var mergeEnd = this[index2] + this[span] - 1;
      if (mergeStart >= indexOfChange) {
        this[index2] += shiftValue;
      }
      if (shiftValue > 0) {
        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {
          this[span] += shiftValue;
        }
      } else if (shiftValue < 0) {
        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {
          this.removed = true;
          return false;
        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {
          var removedOffset = changeEnd - mergeStart + 1;
          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;
          this[index2] -= preRemovedOffset + shiftValue;
          this[span] -= removedOffset;
        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {
          this[span] += shiftValue;
        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {
          var removedPart = mergeEnd - changeStart + 1;
          this[span] -= removedPart;
        }
      }
      return true;
    }
    /**
     * Check if the second provided merged cell is "farther" in the provided direction.
     *
     * @param {MergedCellCoords} mergedCell The merged cell to check.
     * @param {string} direction Drag direction.
     * @returns {boolean|null} `true` if the second provided merged cell is "farther".
     */
  }, {
    key: "isFarther",
    value: function isFarther(mergedCell, direction) {
      if (!mergedCell) {
        return true;
      }
      if (direction === "down") {
        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;
      } else if (direction === "up") {
        return mergedCell.row > this.row;
      } else if (direction === "right") {
        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;
      } else if (direction === "left") {
        return mergedCell.col > this.col;
      }
      return null;
    }
    /**
     * Get the bottom row index of the merged cell.
     *
     * @returns {number}
     */
  }, {
    key: "getLastRow",
    value: function getLastRow() {
      return this.row + this.rowspan - 1;
    }
    /**
     * Get the rightmost column index of the merged cell.
     *
     * @returns {number}
     */
  }, {
    key: "getLastColumn",
    value: function getLastColumn() {
      return this.col + this.colspan - 1;
    }
    /**
     * Get the range coordinates of the merged cell.
     *
     * @returns {CellRange}
     */
  }, {
    key: "getRange",
    value: function getRange() {
      return this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));
    }
  }], [{
    key: "NEGATIVE_VALUES_WARNING",
    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {
      return toSingleLine(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral$6(["The merged cell declared with {row: ", ", col: ", ", \n      rowspan: ", ", colspan: ", "} contains negative values, which is \n      not supported. It will not be added to the collection."], ["The merged cell declared with {row: ", ", col: ", ",\\x20\n      rowspan: ", ", colspan: ", "} contains negative values, which is\\x20\n      not supported. It will not be added to the collection."])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);
    }
    /**
     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.
     *
     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
     * @returns {string}
     */
  }, {
    key: "IS_OUT_OF_BOUNDS_WARNING",
    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {
      return toSingleLine(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral$6(["The merged cell declared at [", ", ", "] is positioned \n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup."], ["The merged cell declared at [", ", ", "] is positioned\\x20\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup."])), newMergedCell.row, newMergedCell.col);
    }
    /**
     * Get a warning message for when the declared merged cell data represents a single cell.
     *
     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
     * @returns {string}
     */
  }, {
    key: "IS_SINGLE_CELL",
    value: function IS_SINGLE_CELL(newMergedCell) {
      return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral$6(["The merged cell declared at [", ", ", '] has both "rowspan" \n      and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.'], ["The merged cell declared at [", ", ", '] has both "rowspan"\\x20\n      and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.'])), newMergedCell.row, newMergedCell.col);
    }
    /**
     * Get a warning message for when the declared merged cell data contains "colspan" or "rowspan", that equals 0.
     *
     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
     * @returns {string}
     */
  }, {
    key: "ZERO_SPAN_WARNING",
    value: function ZERO_SPAN_WARNING(newMergedCell) {
      return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral$6(["The merged cell declared at [", ", ", '] has "rowspan" \n      or "colspan" declared as "0", which is not supported. It cannot be added to the collection.'], ["The merged cell declared at [", ", ", '] has "rowspan"\\x20\n      or "colspan" declared as "0", which is not supported. It cannot be added to the collection.'])), newMergedCell.row, newMergedCell.col);
    }
    /**
     * Check whether the values provided for a merged cell contain any negative values.
     *
     * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.
     * @returns {boolean}
     */
  }, {
    key: "containsNegativeValues",
    value: function containsNegativeValues(mergedCellInfo) {
      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;
    }
    /**
     * Check whether the provided merged cell information object represents a single cell.
     *
     * @private
     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
     * @returns {boolean}
     */
  }, {
    key: "isSingleCell",
    value: function isSingleCell(mergedCellInfo) {
      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;
    }
    /**
     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.
     *
     * @private
     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
     * @returns {boolean}
     */
  }, {
    key: "containsZeroSpan",
    value: function containsZeroSpan(mergedCellInfo) {
      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;
    }
    /**
     * Check whether the provided merged cell object is to be declared out of bounds of the table.
     *
     * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.
     * @param {number} rowCount Number of rows in the table.
     * @param {number} columnCount Number of rows in the table.
     * @returns {boolean}
     */
  }, {
    key: "isOutOfBounds",
    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {
      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;
    }
  }]);
  return MergedCellCoords2;
}();
const MergedCellCoords$1 = MergedCellCoords;
function applySpanProperties(TD, mergedCellInfo, row, col) {
  if (mergedCellInfo) {
    if (mergedCellInfo.row === row && mergedCellInfo.col === col) {
      TD.setAttribute("rowspan", mergedCellInfo.rowspan.toString());
      TD.setAttribute("colspan", mergedCellInfo.colspan.toString());
    } else {
      TD.removeAttribute("rowspan");
      TD.removeAttribute("colspan");
      TD.style.display = "none";
    }
  } else {
    TD.removeAttribute("rowspan");
    TD.removeAttribute("colspan");
    TD.style.display = "";
  }
}
var _templateObject$5;
function _taggedTemplateLiteral$5(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _toConsumableArray$9(arr) {
  return _arrayWithoutHoles$9(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$c(arr) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$c(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$c(o, minLen);
}
function _iterableToArray$a(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$9(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$c(arr);
}
function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$o(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var MergedCellsCollection = /* @__PURE__ */ function() {
  function MergedCellsCollection2(plugin) {
    _classCallCheck$o(this, MergedCellsCollection2);
    this.plugin = plugin;
    this.mergedCells = [];
    this.hot = plugin.hot;
  }
  _createClass$o(MergedCellsCollection2, [{
    key: "get",
    value: (
      /**
       * Get a merged cell from the container, based on the provided arguments. You can provide either the "starting coordinates"
       * of a merged cell, or any coordinates from the body of the merged cell.
       *
       * @param {number} row Row index.
       * @param {number} column Column index.
       * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.
       */
      function get2(row, column) {
        var mergedCells = this.mergedCells;
        var result = false;
        arrayEach(mergedCells, function(mergedCell) {
          if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {
            result = mergedCell;
            return false;
          }
          return true;
        });
        return result;
      }
    )
    /**
     * Get a merged cell containing the provided range.
     *
     * @param {CellRange|object} range The range to search merged cells for.
     * @returns {MergedCellCoords|boolean}
     */
  }, {
    key: "getByRange",
    value: function getByRange(range) {
      var mergedCells = this.mergedCells;
      var result = false;
      arrayEach(mergedCells, function(mergedCell) {
        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {
          result = mergedCell;
          return result;
        }
        return true;
      });
      return result;
    }
    /**
     * Get a merged cell contained in the provided range.
     *
     * @param {CellRange|object} range The range to search merged cells in.
     * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.
     * @returns {Array|boolean} Array of found merged cells of `false` if none were found.
     */
  }, {
    key: "getWithinRange",
    value: function getWithinRange(range) {
      var _this = this;
      var countPartials = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedCells = this.mergedCells;
      var foundMergedCells = [];
      var testedRange = range;
      if (!testedRange.includesRange) {
        var from3 = this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);
        var to = this.hot._createCellCoords(testedRange.to.row, testedRange.to.col);
        testedRange = this.hot._createCellRange(from3, from3, to);
      }
      arrayEach(mergedCells, function(mergedCell) {
        var mergedCellTopLeft = _this.hot._createCellCoords(mergedCell.row, mergedCell.col);
        var mergedCellBottomRight = _this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);
        var mergedCellRange = _this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
        if (countPartials) {
          if (testedRange.overlaps(mergedCellRange)) {
            foundMergedCells.push(mergedCell);
          }
        } else if (testedRange.includesRange(mergedCellRange)) {
          foundMergedCells.push(mergedCell);
        }
      });
      return foundMergedCells.length ? foundMergedCells : false;
    }
    /**
     * Add a merged cell to the container.
     *
     * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.
     * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.
     */
  }, {
    key: "add",
    value: function add(mergedCellInfo) {
      var mergedCells = this.mergedCells;
      var row = mergedCellInfo.row;
      var column = mergedCellInfo.col;
      var rowspan = mergedCellInfo.rowspan;
      var colspan = mergedCellInfo.colspan;
      var newMergedCell = new MergedCellCoords$1(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);
      var alreadyExists = this.get(row, column);
      var isOverlapping = this.isOverlapping(newMergedCell);
      if (!alreadyExists && !isOverlapping) {
        if (this.hot) {
          newMergedCell.normalize(this.hot);
        }
        mergedCells.push(newMergedCell);
        return newMergedCell;
      }
      warn$1(MergedCellsCollection2.IS_OVERLAPPING_WARNING(newMergedCell));
      return false;
    }
    /**
     * Remove a merged cell from the container. You can provide either the "starting coordinates"
     * of a merged cell, or any coordinates from the body of the merged cell.
     *
     * @param {number} row Row index.
     * @param {number} column Column index.
     * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.
     */
  }, {
    key: "remove",
    value: function remove(row, column) {
      var mergedCells = this.mergedCells;
      var wantedCollection = this.get(row, column);
      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;
      if (wantedCollection && wantedCollectionIndex !== -1) {
        mergedCells.splice(wantedCollectionIndex, 1);
        return wantedCollection;
      }
      return false;
    }
    /**
     * Clear all the merged cells.
     */
  }, {
    key: "clear",
    value: function clear2() {
      var _this2 = this;
      var mergedCells = this.mergedCells;
      var mergedCellParentsToClear = [];
      var hiddenCollectionElements = [];
      arrayEach(mergedCells, function(mergedCell) {
        var TD = _this2.hot.getCell(mergedCell.row, mergedCell.col);
        if (TD) {
          mergedCellParentsToClear.push([TD, _this2.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);
        }
      });
      this.mergedCells.length = 0;
      arrayEach(mergedCellParentsToClear, function(mergedCell, i) {
        rangeEach(0, mergedCell.rowspan - 1, function(j) {
          rangeEach(0, mergedCell.colspan - 1, function(k2) {
            if (k2 !== 0 || j !== 0) {
              var TD = _this2.hot.getCell(mergedCell.row + j, mergedCell.col + k2);
              if (TD) {
                hiddenCollectionElements.push([TD, null, null, null]);
              }
            }
          });
        });
        mergedCellParentsToClear[i][1] = null;
      });
      arrayEach(mergedCellParentsToClear, function(mergedCellParents) {
        applySpanProperties.apply(void 0, _toConsumableArray$9(mergedCellParents));
      });
      arrayEach(hiddenCollectionElements, function(hiddenCollectionElement) {
        applySpanProperties.apply(void 0, _toConsumableArray$9(hiddenCollectionElement));
      });
    }
    /**
     * Check if the provided merged cell overlaps with the others in the container.
     *
     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.
     * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.
     */
  }, {
    key: "isOverlapping",
    value: function isOverlapping(mergedCell) {
      var _this3 = this;
      var mergedCellRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(mergedCell.row, mergedCell.col), this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));
      var result = false;
      arrayEach(this.mergedCells, function(col) {
        var currentRange = _this3.hot._createCellRange(_this3.hot._createCellCoords(0, 0), _this3.hot._createCellCoords(col.row, col.col), _this3.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));
        if (currentRange.overlaps(mergedCellRange)) {
          result = true;
          return false;
        }
        return true;
      });
      return result;
    }
    /**
     * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @returns {boolean}
     */
  }, {
    key: "isFirstRenderableMergedCell",
    value: function isFirstRenderableMergedCell(row, column) {
      var mergeParent = this.get(row, column);
      return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;
    }
    /**
     * Get the first renderable coords of the merged cell at the provided coordinates.
     *
     * @param {number} row Visual row index.
     * @param {number} column Visual column index.
     * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the
     *                        merged cell.
     */
  }, {
    key: "getFirstRenderableCoords",
    value: function getFirstRenderableCoords(row, column) {
      var mergeParent = this.get(row, column);
      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {
        return this.hot._createCellCoords(row, column);
      }
      var firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);
      var firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);
      return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);
    }
    /**
     * Shift the merged cell in the direction and by an offset defined in the arguments.
     *
     * @param {string} direction `right`, `left`, `up` or `down`.
     * @param {number} index Index where the change, which caused the shifting took place.
     * @param {number} count Number of rows/columns added/removed in the preceding action.
     */
  }, {
    key: "shiftCollections",
    value: function shiftCollections(direction, index2, count) {
      var _this4 = this;
      var shiftVector = [0, 0];
      switch (direction) {
        case "right":
          shiftVector[0] += count;
          break;
        case "left":
          shiftVector[0] -= count;
          break;
        case "down":
          shiftVector[1] += count;
          break;
        case "up":
          shiftVector[1] -= count;
          break;
      }
      arrayEach(this.mergedCells, function(currentMerge) {
        currentMerge.shift(shiftVector, index2);
      });
      rangeEachReverse(this.mergedCells.length - 1, 0, function(i) {
        var currentMerge = _this4.mergedCells[i];
        if (currentMerge && currentMerge.removed) {
          _this4.mergedCells.splice(_this4.mergedCells.indexOf(currentMerge), 1);
        }
      });
    }
  }], [{
    key: "IS_OVERLAPPING_WARNING",
    value: function IS_OVERLAPPING_WARNING(newMergedCell) {
      return toSingleLine(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral$5(["The merged cell declared at [", ", ", "], overlaps \n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \n      fix your setup."], ["The merged cell declared at [", ", ", "], overlaps\\x20\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\x20\n      fix your setup."])), newMergedCell.row, newMergedCell.col);
    }
  }]);
  return MergedCellsCollection2;
}();
const MergedCellsCollection$1 = MergedCellsCollection;
function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$b(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$b(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$b(o, minLen);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$3(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$n(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var AutofillCalculations = /* @__PURE__ */ function() {
  function AutofillCalculations2(plugin) {
    _classCallCheck$n(this, AutofillCalculations2);
    this.plugin = plugin;
    this.mergedCellsCollection = this.plugin.mergedCellsCollection;
    this.currentFillData = null;
  }
  _createClass$n(AutofillCalculations2, [{
    key: "correctSelectionAreaSize",
    value: function correctSelectionAreaSize(selectionArea) {
      if (selectionArea[0] === selectionArea[2] && selectionArea[1] === selectionArea[3]) {
        var mergedCell = this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);
        if (mergedCell) {
          selectionArea[2] = selectionArea[0] + mergedCell.rowspan - 1;
          selectionArea[3] = selectionArea[1] + mergedCell.colspan - 1;
        }
      }
    }
    /**
     * Get the direction of the autofill process.
     *
     * @param {Array} selectionArea The selection area.
     * @param {Array} finalArea The final area (base + drag).
     * @returns {string} `up`, `down`, `left` or `right`.
     */
  }, {
    key: "getDirection",
    value: function getDirection(selectionArea, finalArea) {
      var direction = null;
      if (finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
        direction = "down";
      } else if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
        direction = "up";
      } else if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) {
        direction = "right";
      } else {
        direction = "left";
      }
      return direction;
    }
    /**
     * Snap the drag area to the farthest merged cell, so it won't clip any of the merged cells.
     *
     * @param {Array} baseArea The base selected area.
     * @param {Array} dragArea The drag area.
     * @param {string} dragDirection The autofill drag direction.
     * @param {Array} foundMergedCells MergeCellCoords found in the base selection area.
     * @returns {Array} The new drag area.
     */
  }, {
    key: "snapDragArea",
    value: function snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {
      var newDragArea = dragArea.slice(0);
      var fillSize = this.getAutofillSize(baseArea, dragArea, dragDirection);
      var _baseArea = _slicedToArray$3(baseArea, 4), baseAreaStartRow = _baseArea[0], baseAreaStartColumn = _baseArea[1], baseAreaEndRow = _baseArea[2], baseAreaEndColumn = _baseArea[3];
      var verticalDirection = ["up", "down"].indexOf(dragDirection) > -1;
      var fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
      var fulls = Math.floor(fillSize / fullCycle) * fullCycle;
      var partials = fillSize - fulls;
      var farthestCollection = this.getFarthestCollection(baseArea, dragArea, dragDirection, foundMergedCells);
      if (farthestCollection) {
        if (dragDirection === "down") {
          var fill3 = farthestCollection.row + farthestCollection.rowspan - baseAreaStartRow - partials;
          var newLimit = newDragArea[2] + fill3;
          if (newLimit >= this.plugin.hot.countRows()) {
            newDragArea[2] -= partials;
          } else {
            newDragArea[2] += partials ? fill3 : 0;
          }
        } else if (dragDirection === "right") {
          var _fill = farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - partials;
          var _newLimit = newDragArea[3] + _fill;
          if (_newLimit >= this.plugin.hot.countCols()) {
            newDragArea[3] -= partials;
          } else {
            newDragArea[3] += partials ? _fill : 0;
          }
        } else if (dragDirection === "up") {
          var _fill2 = baseAreaEndRow - partials - farthestCollection.row + 1;
          var _newLimit2 = newDragArea[0] + _fill2;
          if (_newLimit2 < 0) {
            newDragArea[0] += partials;
          } else {
            newDragArea[0] -= partials ? _fill2 : 0;
          }
        } else if (dragDirection === "left") {
          var _fill3 = baseAreaEndColumn - partials - farthestCollection.col + 1;
          var _newLimit3 = newDragArea[1] + _fill3;
          if (_newLimit3 < 0) {
            newDragArea[1] += partials;
          } else {
            newDragArea[1] -= partials ? _fill3 : 0;
          }
        }
      }
      this.updateCurrentFillCache({
        baseArea,
        dragDirection,
        foundMergedCells,
        fillSize,
        dragArea: newDragArea,
        cycleLength: fullCycle
      });
      return newDragArea;
    }
    /**
     * Update the current fill cache with the provided object.
     *
     * @private
     * @param {object} updateObject The current filled object cache.
     */
  }, {
    key: "updateCurrentFillCache",
    value: function updateCurrentFillCache(updateObject) {
      if (!this.currentFillData) {
        this.currentFillData = {};
      }
      extend(this.currentFillData, updateObject);
    }
    /**
     * Get the "length" of the drag area.
     *
     * @private
     * @param {Array} baseArea The base selection area.
     * @param {Array} dragArea The drag area (containing the base area).
     * @param {string} direction The drag direction.
     * @returns {number|null} The "length" (height or width, depending on the direction) of the drag.
     */
  }, {
    key: "getAutofillSize",
    value: function getAutofillSize(baseArea, dragArea, direction) {
      var _baseArea2 = _slicedToArray$3(baseArea, 4), baseAreaStartRow = _baseArea2[0], baseAreaStartColumn = _baseArea2[1], baseAreaEndRow = _baseArea2[2], baseAreaEndColumn = _baseArea2[3];
      var _dragArea = _slicedToArray$3(dragArea, 4), dragAreaStartRow = _dragArea[0], dragAreaStartColumn = _dragArea[1], dragAreaEndRow = _dragArea[2], dragAreaEndColumn = _dragArea[3];
      switch (direction) {
        case "up":
          return baseAreaStartRow - dragAreaStartRow;
        case "down":
          return dragAreaEndRow - baseAreaEndRow;
        case "left":
          return baseAreaStartColumn - dragAreaStartColumn;
        case "right":
          return dragAreaEndColumn - baseAreaEndColumn;
        default:
          return null;
      }
    }
    /**
     * Trim the default drag area (containing the selection area) to the drag-only area.
     *
     * @private
     * @param {Array} baseArea The base selection area.
     * @param {Array} dragArea The base selection area extended by the drag area.
     * @param {string} direction Drag direction.
     * @returns {Array|null} Array representing the drag area coordinates.
     */
  }, {
    key: "getDragArea",
    value: function getDragArea(baseArea, dragArea, direction) {
      var _baseArea3 = _slicedToArray$3(baseArea, 4), baseAreaStartRow = _baseArea3[0], baseAreaStartColumn = _baseArea3[1], baseAreaEndRow = _baseArea3[2], baseAreaEndColumn = _baseArea3[3];
      var _dragArea2 = _slicedToArray$3(dragArea, 4), dragAreaStartRow = _dragArea2[0], dragAreaStartColumn = _dragArea2[1], dragAreaEndRow = _dragArea2[2], dragAreaEndColumn = _dragArea2[3];
      switch (direction) {
        case "up":
          return [dragAreaStartRow, dragAreaStartColumn, baseAreaStartRow - 1, baseAreaEndColumn];
        case "down":
          return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, baseAreaEndColumn];
        case "left":
          return [dragAreaStartRow, dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];
        case "right":
          return [baseAreaStartRow, baseAreaEndColumn + 1, dragAreaEndRow, dragAreaEndColumn];
        default:
          return null;
      }
    }
    /**
     * Get the to-be-farthest merged cell in the newly filled area.
     *
     * @private
     * @param {Array} baseArea The base selection area.
     * @param {Array} dragArea The drag area (containing the base area).
     * @param {string} direction The drag direction.
     * @param {Array} mergedCellArray Array of the merged cells found in the base area.
     * @returns {MergedCellCoords|null}
     */
  }, {
    key: "getFarthestCollection",
    value: function getFarthestCollection(baseArea, dragArea, direction, mergedCellArray) {
      var _baseArea4 = _slicedToArray$3(baseArea, 4), baseAreaStartRow = _baseArea4[0], baseAreaStartColumn = _baseArea4[1], baseAreaEndRow = _baseArea4[2], baseAreaEndColumn = _baseArea4[3];
      var verticalDirection = ["up", "down"].indexOf(direction) > -1;
      var baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;
      var baseStart = verticalDirection ? baseAreaStartRow : baseAreaStartColumn;
      var fillSize = this.getAutofillSize(baseArea, dragArea, direction);
      var fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
      var fulls = Math.floor(fillSize / fullCycle) * fullCycle;
      var partials = fillSize - fulls;
      var inclusionFunctionName = null;
      var farthestCollection = null;
      var endOfDragRecreationIndex = null;
      switch (direction) {
        case "up":
          inclusionFunctionName = "includesVertically";
          endOfDragRecreationIndex = baseEnd - partials + 1;
          break;
        case "left":
          inclusionFunctionName = "includesHorizontally";
          endOfDragRecreationIndex = baseEnd - partials + 1;
          break;
        case "down":
          inclusionFunctionName = "includesVertically";
          endOfDragRecreationIndex = baseStart + partials - 1;
          break;
        case "right":
          inclusionFunctionName = "includesHorizontally";
          endOfDragRecreationIndex = baseStart + partials - 1;
          break;
      }
      arrayEach(mergedCellArray, function(currentCollection) {
        if (currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && currentCollection.isFarther(farthestCollection, direction)) {
          farthestCollection = currentCollection;
        }
      });
      return farthestCollection;
    }
    /**
     * Recreate the merged cells after the autofill process.
     *
     * @param {Array} changes Changes made.
     */
  }, {
    key: "recreateAfterDataPopulation",
    value: function recreateAfterDataPopulation(changes) {
      if (!this.currentFillData) {
        return;
      }
      var fillRange = this.getRangeFromChanges(changes);
      var foundMergedCells = this.currentFillData.foundMergedCells;
      var dragDirection = this.currentFillData.dragDirection;
      var inBounds = function inBounds2(current2, offset2) {
        switch (dragDirection) {
          case "up":
            return current2.row - offset2 >= fillRange.from.row;
          case "down":
            return current2.row + current2.rowspan - 1 + offset2 <= fillRange.to.row;
          case "left":
            return current2.col - offset2 >= fillRange.from.column;
          case "right":
            return current2.col + current2.colspan - 1 + offset2 <= fillRange.to.column;
          default:
            return null;
        }
      };
      var fillOffset = 0;
      var current = null;
      var multiplier = 1;
      do {
        for (var j = 0; j < foundMergedCells.length; j += 1) {
          current = foundMergedCells[j];
          fillOffset = multiplier * this.currentFillData.cycleLength;
          if (inBounds(current, fillOffset)) {
            switch (dragDirection) {
              case "up":
                this.plugin.mergedCellsCollection.add({
                  row: current.row - fillOffset,
                  rowspan: current.rowspan,
                  col: current.col,
                  colspan: current.colspan
                });
                break;
              case "down":
                this.plugin.mergedCellsCollection.add({
                  row: current.row + fillOffset,
                  rowspan: current.rowspan,
                  col: current.col,
                  colspan: current.colspan
                });
                break;
              case "left":
                this.plugin.mergedCellsCollection.add({
                  row: current.row,
                  rowspan: current.rowspan,
                  col: current.col - fillOffset,
                  colspan: current.colspan
                });
                break;
              case "right":
                this.plugin.mergedCellsCollection.add({
                  row: current.row,
                  rowspan: current.rowspan,
                  col: current.col + fillOffset,
                  colspan: current.colspan
                });
                break;
            }
          }
          if (j === foundMergedCells.length - 1) {
            multiplier += 1;
          }
        }
      } while (inBounds(current, fillOffset));
      this.currentFillData = null;
      this.plugin.hot.render();
    }
    /**
     * Get the drag range from the changes made.
     *
     * @private
     * @param {Array} changes The changes made.
     * @returns {object} Object with `from` and `to` properties, both containing `row` and `column` keys.
     */
  }, {
    key: "getRangeFromChanges",
    value: function getRangeFromChanges(changes) {
      var _this = this;
      var rows = {
        min: null,
        max: null
      };
      var columns = {
        min: null,
        max: null
      };
      arrayEach(changes, function(change) {
        var rowIndex = change[0];
        var columnIndex = _this.plugin.hot.propToCol(change[1]);
        if (rows.min === null || rowIndex < rows.min) {
          rows.min = rowIndex;
        }
        if (rows.max === null || rowIndex > rows.max) {
          rows.max = rowIndex;
        }
        if (columns.min === null || columnIndex < columns.min) {
          columns.min = columnIndex;
        }
        if (columns.max === null || columnIndex > columns.max) {
          columns.max = columnIndex;
        }
      });
      return {
        from: {
          row: rows.min,
          column: columns.min
        },
        to: {
          row: rows.max,
          column: columns.max
        }
      };
    }
    /**
     * Check if the drag area contains any merged cells.
     *
     * @param {Array} baseArea The base selection area.
     * @param {Array} fullArea The base area extended by the drag area.
     * @param {string} direction Drag direction.
     * @returns {boolean}
     */
  }, {
    key: "dragAreaOverlapsCollections",
    value: function dragAreaOverlapsCollections(baseArea, fullArea, direction) {
      var dragArea = this.getDragArea(baseArea, fullArea, direction);
      var _dragArea3 = _slicedToArray$3(dragArea, 4), dragAreaStartRow = _dragArea3[0], dragAreaStartColumn = _dragArea3[1], dragAreaEndRow = _dragArea3[2], dragAreaEndColumn = _dragArea3[3];
      var topLeft = this.plugin.hot._createCellCoords(dragAreaStartRow, dragAreaStartColumn);
      var bottomRight = this.plugin.hot._createCellCoords(dragAreaEndRow, dragAreaEndColumn);
      var dragRange = this.plugin.hot._createCellRange(topLeft, topLeft, bottomRight);
      return !!this.mergedCellsCollection.getWithinRange(dragRange, true);
    }
  }]);
  return AutofillCalculations2;
}();
const AutofillCalculations$1 = AutofillCalculations;
function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$m(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var SelectionCalculations = /* @__PURE__ */ function() {
  function SelectionCalculations2(plugin) {
    _classCallCheck$m(this, SelectionCalculations2);
    this.plugin = plugin;
    this.hot = plugin.hot;
    this.fullySelectedMergedCellClassName = "fullySelectedMergedCell";
  }
  _createClass$m(SelectionCalculations2, [{
    key: "snapDelta",
    value: function snapDelta(delta, selectionRange, mergedCell) {
      var cellCoords = selectionRange.to;
      var newRow = cellCoords.row + delta.row;
      var newColumn = cellCoords.col + delta.col;
      if (delta.row) {
        this.jumpOverMergedCell(delta, mergedCell, newRow);
      } else if (delta.col) {
        this.jumpOverMergedCell(delta, mergedCell, newColumn);
      }
    }
    /**
     * "Jump" over the merged cell (compensate for the indexes within the merged cell to get past it).
     *
     * @private
     * @param {object} delta The delta object.
     * @param {MergedCellCoords} mergedCell The merge cell object.
     * @param {number} newIndex New row/column index, created with the delta.
     */
  }, {
    key: "jumpOverMergedCell",
    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {
      var flatDelta = delta.row || delta.col;
      var includesIndex = null;
      var firstIndex = null;
      var lastIndex = null;
      if (delta.row) {
        includesIndex = mergedCell.includesVertically(newIndex);
        firstIndex = mergedCell.row;
        lastIndex = mergedCell.getLastRow();
      } else if (delta.col) {
        includesIndex = mergedCell.includesHorizontally(newIndex);
        firstIndex = mergedCell.col;
        lastIndex = mergedCell.getLastColumn();
      }
      if (flatDelta === 0) {
        return;
      } else if (flatDelta > 0) {
        if (includesIndex && newIndex !== firstIndex) {
          flatDelta += lastIndex - newIndex + 1;
        }
      } else if (includesIndex && newIndex !== lastIndex) {
        flatDelta -= newIndex - firstIndex + 1;
      }
      if (delta.row) {
        delta.row = flatDelta;
      } else if (delta.col) {
        delta.col = flatDelta;
      }
    }
    /**
     * Get a selection range with `to` property incremented by the provided delta.
     *
     * @param {CellRange} oldSelectionRange The base selection range.
     * @param {object} delta The delta object with `row` and `col` properties.
     * @returns {CellRange} A new `CellRange` object.
     */
  }, {
    key: "getUpdatedSelectionRange",
    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {
      return this.hot._createCellRange(oldSelectionRange.highlight, oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));
    }
    /**
     * Generate an additional class name for the entirely-selected merged cells.
     *
     * @param {number} currentRow Visual row index of the currently processed cell.
     * @param {number} currentColumn Visual column index of the currently cell.
     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.
     */
  }, {
    key: "getSelectedMergedCellClassName",
    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {
      var startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);
      var startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);
      var endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);
      var endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);
      if (layerLevel === void 0) {
        return;
      }
      var isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);
      if (!isFirstRenderableMergedCell) {
        return;
      }
      var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);
      if (!mergedCell) {
        return;
      }
      var mergeRowEnd = mergedCell.getLastRow();
      var mergeColumnEnd = mergedCell.getLastColumn();
      var fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;
      if (fullMergeAreaWithinSelection) {
        return "".concat(this.fullySelectedMergedCellClassName, "-").concat(layerLevel);
      } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {
        return "".concat(this.fullySelectedMergedCellClassName, "-multiple");
      }
    }
    /**
     * Check if the provided merged cell is fully selected (by one or many layers of selection).
     *
     * @param {MergedCellCoords} mergedCell The merged cell to be processed.
     * @param {CellRange[]} selectionRangesArray Array of selection ranges.
     * @returns {boolean}
     */
  }, {
    key: "isMergeCellFullySelected",
    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {
      var mergedCellIndividualCoords = [];
      if (!selectionRangesArray || !mergedCell) {
        return false;
      }
      for (var r2 = 0; r2 < mergedCell.rowspan; r2 += 1) {
        for (var c2 = 0; c2 < mergedCell.colspan; c2 += 1) {
          mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r2, mergedCell.col + c2));
        }
      }
      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {
        var insideSelections = [];
        for (var s = 0; s < selectionRangesArray.length; s += 1) {
          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);
        }
        if (!insideSelections.includes(true)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Generate an array of the entirely-selected merged cells' class names.
     *
     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
     */
  }, {
    key: "getSelectedMergedCellClassNameToRemove",
    value: function getSelectedMergedCellClassNameToRemove() {
      var classNames = [];
      for (var i = 0; i <= 7; i += 1) {
        classNames.push("".concat(this.fullySelectedMergedCellClassName, "-").concat(i));
      }
      classNames.push("".concat(this.fullySelectedMergedCellClassName, "-multiple"));
      return classNames;
    }
  }]);
  return SelectionCalculations2;
}();
const SelectionCalculations$1 = SelectionCalculations;
function toggleMergeItem(plugin) {
  return {
    key: "mergeCells",
    name: function name() {
      var sel = this.getSelectedLast();
      if (sel) {
        var info = plugin.mergedCellsCollection.get(sel[0], sel[1]);
        if (info.row === sel[0] && info.col === sel[1] && info.row + info.rowspan - 1 === sel[2] && info.col + info.colspan - 1 === sel[3]) {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNMERGE_CELLS);
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_MERGE_CELLS);
    },
    callback: function callback() {
      plugin.toggleMergeOnSelection();
    },
    disabled: function disabled() {
      var sel = this.getSelectedLast();
      if (!sel) {
        return true;
      }
      var isSingleCell = MergedCellCoords$1.isSingleCell({
        row: sel[0],
        col: sel[1],
        rowspan: sel[2] - sel[0] + 1,
        colspan: sel[3] - sel[1] + 1
      });
      return isSingleCell || this.selection.isSelectedByCorner();
    },
    hidden: false
  };
}
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$d(obj);
}
function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$a(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$8(arr) {
  return _arrayWithoutHoles$8(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$a(arr) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$a(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$a(o, minLen);
}
function _iterableToArray$9(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$8(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$a(arr);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$l(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$8() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$8 = Reflect.get.bind();
  } else {
    _get$8 = function _get2(target, property, receiver) {
      var base = _superPropBase$8(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$8.apply(this, arguments);
}
function _superPropBase$8(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$c(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o, p2) {
  _setPrototypeOf$c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$c(o, p2);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self2, call2) {
  if (call2 && (_typeof$d(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$c(o);
}
Hooks$1.getSingleton().register("beforeMergeCells");
Hooks$1.getSingleton().register("afterMergeCells");
Hooks$1.getSingleton().register("beforeUnmergeCells");
Hooks$1.getSingleton().register("afterUnmergeCells");
var PLUGIN_KEY$9 = "mergeCells";
var PLUGIN_PRIORITY$8 = 150;
var privatePool$2 = /* @__PURE__ */ new WeakMap();
var SHORTCUTS_GROUP$1 = PLUGIN_KEY$9;
var MergeCells = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$c(MergeCells2, _BasePlugin);
  var _super = _createSuper$c(MergeCells2);
  function MergeCells2(hotInstance) {
    var _this;
    _classCallCheck$l(this, MergeCells2);
    _this = _super.call(this, hotInstance);
    privatePool$2.set(_assertThisInitialized$c(_this), {
      lastDesiredCoords: null
    });
    _this.mergedCellsCollection = null;
    _this.autofillCalculations = null;
    _this.selectionCalculations = null;
    return _this;
  }
  _createClass$l(MergeCells2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$9];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.mergedCellsCollection = new MergedCellsCollection$1(this);
      this.autofillCalculations = new AutofillCalculations$1(this);
      this.selectionCalculations = new SelectionCalculations$1(this);
      this.addHook("afterInit", function() {
        return _this2.onAfterInit.apply(_this2, arguments);
      });
      this.addHook("modifyTransformStart", function() {
        return _this2.onModifyTransformStart.apply(_this2, arguments);
      });
      this.addHook("afterModifyTransformStart", function() {
        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);
      });
      this.addHook("modifyTransformEnd", function() {
        return _this2.onModifyTransformEnd.apply(_this2, arguments);
      });
      this.addHook("modifyGetCellCoords", function() {
        return _this2.onModifyGetCellCoords.apply(_this2, arguments);
      });
      this.addHook("beforeSetRangeStart", function() {
        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);
      });
      this.addHook("beforeSetRangeStartOnly", function() {
        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);
      });
      this.addHook("beforeSetRangeEnd", function() {
        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);
      });
      this.addHook("afterIsMultipleSelection", function() {
        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);
      });
      this.addHook("afterRenderer", function() {
        return _this2.onAfterRenderer.apply(_this2, arguments);
      });
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);
      });
      this.addHook("afterGetCellMeta", function() {
        return _this2.onAfterGetCellMeta.apply(_this2, arguments);
      });
      this.addHook("afterViewportRowCalculatorOverride", function() {
        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);
      });
      this.addHook("afterViewportColumnCalculatorOverride", function() {
        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);
      });
      this.addHook("modifyAutofillRange", function() {
        return _this2.onModifyAutofillRange.apply(_this2, arguments);
      });
      this.addHook("afterCreateCol", function() {
        return _this2.onAfterCreateCol.apply(_this2, arguments);
      });
      this.addHook("afterRemoveCol", function() {
        return _this2.onAfterRemoveCol.apply(_this2, arguments);
      });
      this.addHook("afterCreateRow", function() {
        return _this2.onAfterCreateRow.apply(_this2, arguments);
      });
      this.addHook("afterRemoveRow", function() {
        return _this2.onAfterRemoveRow.apply(_this2, arguments);
      });
      this.addHook("afterChange", function() {
        return _this2.onAfterChange.apply(_this2, arguments);
      });
      this.addHook("beforeDrawBorders", function() {
        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);
      });
      this.addHook("afterDrawSelection", function() {
        return _this2.onAfterDrawSelection.apply(_this2, arguments);
      });
      this.addHook("beforeRemoveCellClassNames", function() {
        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);
      });
      this.addHook("beforeUndoStackChange", function(action, source) {
        if (source === "MergeCells") {
          return false;
        }
      });
      this.registerShortcuts();
      _get$8(_getPrototypeOf$c(MergeCells2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearCollections();
      this.unregisterShortcuts();
      this.hot.render();
      _get$8(_getPrototypeOf$c(MergeCells2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`mergeCells`](@/api/options.md#mergecells)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$9];
      this.disablePlugin();
      this.enablePlugin();
      this.generateFromSettings(settings);
      _get$8(_getPrototypeOf$c(MergeCells2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Validates a single setting object, represented by a single merged cell information object.
     *
     * @private
     * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.
     * @returns {boolean}
     */
  }, {
    key: "validateSetting",
    value: function validateSetting(setting) {
      var valid = true;
      if (!setting) {
        return false;
      }
      if (MergedCellCoords$1.containsNegativeValues(setting)) {
        warn$1(MergedCellCoords$1.NEGATIVE_VALUES_WARNING(setting));
        valid = false;
      } else if (MergedCellCoords$1.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {
        warn$1(MergedCellCoords$1.IS_OUT_OF_BOUNDS_WARNING(setting));
        valid = false;
      } else if (MergedCellCoords$1.isSingleCell(setting)) {
        warn$1(MergedCellCoords$1.IS_SINGLE_CELL(setting));
        valid = false;
      } else if (MergedCellCoords$1.containsZeroSpan(setting)) {
        warn$1(MergedCellCoords$1.ZERO_SPAN_WARNING(setting));
        valid = false;
      }
      return valid;
    }
    /**
     * Generates the merged cells from the settings provided to the plugin.
     *
     * @private
     * @param {Array|boolean} settings The settings provided to the plugin.
     */
  }, {
    key: "generateFromSettings",
    value: function generateFromSettings(settings) {
      var _this3 = this;
      if (Array.isArray(settings)) {
        var _this$hot;
        var populationArgumentsList = [];
        arrayEach(settings, function(setting) {
          if (!_this3.validateSetting(setting)) {
            return;
          }
          var highlight = _this3.hot._createCellCoords(setting.row, setting.col);
          var rangeEnd = _this3.hot._createCellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);
          var mergeRange = _this3.hot._createCellRange(highlight, highlight, rangeEnd);
          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));
        });
        populationArgumentsList = populationArgumentsList.filter(function(value) {
          return value !== true;
        });
        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);
        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray$8(bulkPopulationData));
      }
    }
    /**
     * Generates a bulk set of all the data to be populated to fill the data "under" the added merged cells.
     *
     * @private
     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.
     * @returns {Array} Array in a form of `[row, column, dataOfAllCollections]`.
     */
  }, {
    key: "getBulkCollectionData",
    value: function getBulkCollectionData(populationArgumentsList) {
      var _this$hot2;
      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);
      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray$8(populationDataRange));
      var newDataAtRange = dataAtRange.splice(0);
      arrayEach(populationArgumentsList, function(mergedCellArguments) {
        var _mergedCellArguments = _slicedToArray$2(mergedCellArguments, 3), mergedCellRowIndex = _mergedCellArguments[0], mergedCellColumnIndex = _mergedCellArguments[1], mergedCellData = _mergedCellArguments[2];
        arrayEach(mergedCellData, function(mergedCellRow, rowIndex) {
          arrayEach(mergedCellRow, function(mergedCellElement, columnIndex) {
            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement;
          });
        });
      });
      return [populationDataRange[0], populationDataRange[1], newDataAtRange];
    }
    /**
     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection]).
     *
     * @private
     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.
     * @returns {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex]).
     */
  }, {
    key: "getBulkCollectionDataRange",
    value: function getBulkCollectionDataRange(populationArgumentsList) {
      var start = [0, 0];
      var end = [0, 0];
      var mergedCellRow = null;
      var mergedCellColumn = null;
      var mergedCellData = null;
      arrayEach(populationArgumentsList, function(mergedCellArguments) {
        mergedCellRow = mergedCellArguments[0];
        mergedCellColumn = mergedCellArguments[1];
        mergedCellData = mergedCellArguments[2];
        start[0] = Math.min(mergedCellRow, start[0]);
        start[1] = Math.min(mergedCellColumn, start[1]);
        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);
        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);
      });
      return [].concat(start, end);
    }
    /**
     * Clears the merged cells from the merged cell container.
     */
  }, {
    key: "clearCollections",
    value: function clearCollections() {
      this.mergedCellsCollection.clear();
    }
    /**
     * Returns `true` if a range is mergeable.
     *
     * @private
     * @param {object} newMergedCellInfo Merged cell information object to test.
     * @param {boolean} [auto=false] `true` if triggered at initialization.
     * @returns {boolean}
     */
  }, {
    key: "canMergeRange",
    value: function canMergeRange(newMergedCellInfo) {
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return auto ? true : this.validateSetting(newMergedCellInfo);
    }
    /**
     * Merge or unmerge, based on last selected range.
     *
     * @private
     */
  }, {
    key: "toggleMergeOnSelection",
    value: function toggleMergeOnSelection() {
      var currentRange = this.hot.getSelectedRangeLast();
      if (!currentRange) {
        return;
      }
      currentRange.setDirection(this.hot.isRtl() ? "NE-SW" : "NW-SE");
      var from3 = currentRange.from, to = currentRange.to;
      this.toggleMerge(currentRange);
      this.hot.selectCell(from3.row, from3.col, to.row, to.col, false);
    }
    /**
     * Merges the selection provided as a cell range.
     *
     * @param {CellRange} [cellRange] Selection cell range.
     */
  }, {
    key: "mergeSelection",
    value: function mergeSelection() {
      var cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
      if (!cellRange) {
        return;
      }
      cellRange.setDirection(this.hot.isRtl() ? "NE-SW" : "NW-SE");
      var from3 = cellRange.from, to = cellRange.to;
      this.unmergeRange(cellRange, true);
      this.mergeRange(cellRange);
      this.hot.selectCell(from3.row, from3.col, to.row, to.col, false);
    }
    /**
     * Unmerges the selection provided as a cell range.
     *
     * @param {CellRange} [cellRange] Selection cell range.
     */
  }, {
    key: "unmergeSelection",
    value: function unmergeSelection() {
      var cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
      if (!cellRange) {
        return;
      }
      var from3 = cellRange.from, to = cellRange.to;
      this.unmergeRange(cellRange, true);
      this.hot.selectCell(from3.row, from3.col, to.row, to.col, false);
    }
    /**
     * Merges cells in the provided cell range.
     *
     * @private
     * @param {CellRange} cellRange Cell range to merge.
     * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.
     * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.
     * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.
     * @fires Hooks#beforeMergeCells
     * @fires Hooks#afterMergeCells
     */
  }, {
    key: "mergeRange",
    value: function mergeRange(cellRange) {
      var _this4 = this;
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var preventPopulation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var topStart = cellRange.getTopStartCorner();
      var bottomEnd = cellRange.getBottomEndCorner();
      var mergeParent = {
        row: topStart.row,
        col: topStart.col,
        rowspan: bottomEnd.row - topStart.row + 1,
        colspan: bottomEnd.col - topStart.col + 1
      };
      var clearedData = [];
      var populationInfo = null;
      if (!this.canMergeRange(mergeParent, auto)) {
        return false;
      }
      this.hot.runHooks("beforeMergeCells", cellRange, auto);
      rangeEach(0, mergeParent.rowspan - 1, function(i) {
        rangeEach(0, mergeParent.colspan - 1, function(j) {
          var clearedValue = null;
          if (!clearedData[i]) {
            clearedData[i] = [];
          }
          if (i === 0 && j === 0) {
            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);
          } else {
            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, "hidden", true);
          }
          clearedData[i][j] = clearedValue;
        });
      });
      this.hot.setCellMeta(mergeParent.row, mergeParent.col, "spanned", true);
      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);
      if (mergedCellAdded) {
        if (preventPopulation) {
          populationInfo = [mergeParent.row, mergeParent.col, clearedData];
        } else {
          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);
        }
        this.hot.runHooks("afterMergeCells", cellRange, mergeParent, auto);
        return populationInfo;
      }
      return true;
    }
    /**
     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.
     *
     * @private
     * @param {CellRange} cellRange Selection cell range.
     * @param {boolean} [auto=false] `true` if called automatically by the plugin.
     *
     * @fires Hooks#beforeUnmergeCells
     * @fires Hooks#afterUnmergeCells
     */
  }, {
    key: "unmergeRange",
    value: function unmergeRange(cellRange) {
      var _this5 = this;
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);
      if (!mergedCells) {
        return;
      }
      this.hot.runHooks("beforeUnmergeCells", cellRange, auto);
      arrayEach(mergedCells, function(currentCollection) {
        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);
        rangeEach(0, currentCollection.rowspan - 1, function(i) {
          rangeEach(0, currentCollection.colspan - 1, function(j) {
            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, "hidden");
          });
        });
        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, "spanned");
      });
      this.hot.runHooks("afterUnmergeCells", cellRange, auto);
      this.hot.render();
    }
    /**
     * Merges or unmerges, based on the cell range provided as `cellRange`.
     *
     * @private
     * @param {CellRange} cellRange The cell range to merge or unmerged.
     */
  }, {
    key: "toggleMerge",
    value: function toggleMerge(cellRange) {
      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);
      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;
      if (mergedCellCoversWholeRange) {
        this.unmergeRange(cellRange);
      } else {
        this.mergeSelection(cellRange);
      }
    }
    /**
     * Merges the specified range.
     *
     * @param {number} startRow Start row of the merged cell.
     * @param {number} startColumn Start column of the merged cell.
     * @param {number} endRow End row of the merged cell.
     * @param {number} endColumn End column of the merged cell.
     * @fires Hooks#beforeMergeCells
     * @fires Hooks#afterMergeCells
     */
  }, {
    key: "merge",
    value: function merge2(startRow, startColumn, endRow, endColumn) {
      var start = this.hot._createCellCoords(startRow, startColumn);
      var end = this.hot._createCellCoords(endRow, endColumn);
      this.mergeRange(this.hot._createCellRange(start, start, end));
    }
    /**
     * Unmerges the merged cell in the provided range.
     *
     * @param {number} startRow Start row of the merged cell.
     * @param {number} startColumn Start column of the merged cell.
     * @param {number} endRow End row of the merged cell.
     * @param {number} endColumn End column of the merged cell.
     * @fires Hooks#beforeUnmergeCells
     * @fires Hooks#afterUnmergeCells
     */
  }, {
    key: "unmerge",
    value: function unmerge(startRow, startColumn, endRow, endColumn) {
      var start = this.hot._createCellCoords(startRow, startColumn);
      var end = this.hot._createCellCoords(endRow, endColumn);
      this.unmergeRange(this.hot._createCellRange(start, start, end));
    }
    /**
     * `afterInit` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY$9]);
      this.hot.render();
    }
    /**
     * Register shortcuts responsible for toggling a merge.
     *
     * @private
     */
  }, {
    key: "registerShortcuts",
    value: function registerShortcuts() {
      var _this6 = this;
      var shortcutManager = this.hot.getShortcutManager();
      var gridContext = shortcutManager.getContext("grid");
      gridContext.addShortcut({
        keys: [["Control", "m"]],
        callback: function callback() {
          _this6.toggleMerge(_this6.hot.getSelectedRangeLast());
          _this6.hot.render();
        },
        runOnlyIf: function runOnlyIf(event2) {
          return !event2.altKey;
        },
        // right ALT in some systems triggers ALT+CTRL
        group: SHORTCUTS_GROUP$1
      });
    }
    /**
     * Unregister shortcuts responsible for toggling a merge.
     *
     * @private
     */
  }, {
    key: "unregisterShortcuts",
    value: function unregisterShortcuts() {
      var shortcutManager = this.hot.getShortcutManager();
      var gridContext = shortcutManager.getContext("grid");
      gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP$1);
    }
    /**
     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.
     *
     * @private
     * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.
     * @returns {boolean}
     */
  }, {
    key: "onAfterIsMultipleSelection",
    value: function onAfterIsMultipleSelection(isMultiple) {
      if (isMultiple) {
        var mergedCells = this.mergedCellsCollection.mergedCells;
        var selectionRange = this.hot.getSelectedRangeLast();
        for (var group = 0; group < mergedCells.length; group += 1) {
          if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {
            return false;
          }
        }
      }
      return isMultiple;
    }
    /**
     * `modifyTransformStart` hook callback.
     *
     * @private
     * @param {object} delta The transformation delta.
     */
  }, {
    key: "onModifyTransformStart",
    value: function onModifyTransformStart(delta) {
      var priv = privatePool$2.get(this);
      var currentlySelectedRange = this.hot.getSelectedRangeLast();
      var newDelta = {
        row: delta.row,
        col: delta.col
      };
      var nextPosition = null;
      var currentPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);
      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);
      if (!priv.lastDesiredCoords) {
        priv.lastDesiredCoords = this.hot._createCellCoords(null, null);
      }
      if (mergedParent) {
        var mergeTopLeft = this.hot._createCellCoords(mergedParent.row, mergedParent.col);
        var mergeBottomRight = this.hot._createCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);
        var mergeRange = this.hot._createCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);
        if (!mergeRange.includes(priv.lastDesiredCoords)) {
          priv.lastDesiredCoords = this.hot._createCellCoords(null, null);
        }
        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;
        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;
        if (delta.row > 0) {
          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;
        } else if (delta.row < 0) {
          newDelta.row = currentPosition.row - mergedParent.row + delta.row;
        }
        if (delta.col > 0) {
          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;
        } else if (delta.col < 0) {
          newDelta.col = currentPosition.col - mergedParent.col + delta.col;
        }
      }
      nextPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);
      var nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);
      if (nextPositionMergedCell) {
        var firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);
        priv.lastDesiredCoords = nextPosition;
        newDelta = {
          row: firstRenderableCoords.row - currentPosition.row,
          col: firstRenderableCoords.col - currentPosition.col
        };
      }
      if (newDelta.row !== 0) {
        delta.row = newDelta.row;
      }
      if (newDelta.col !== 0) {
        delta.col = newDelta.col;
      }
    }
    /**
     * `modifyTransformEnd` hook callback. Needed to handle "jumping over" merged merged cells, while selecting.
     *
     * @private
     * @param {object} delta The transformation delta.
     */
  }, {
    key: "onModifyTransformEnd",
    value: function onModifyTransformEnd(delta) {
      var _this7 = this;
      var currentSelectionRange = this.hot.getSelectedRangeLast();
      var newDelta = clone$1(delta);
      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);
      var tempDelta = clone$1(newDelta);
      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);
      do {
        tempDelta = clone$1(newDelta);
        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);
        arrayEach(mergedCellsWithinRange, function(mergedCell) {
          _this7.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);
        });
      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);
      delta.row = newDelta.row;
      delta.col = newDelta.col;
    }
    /**
     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.
     *
     * @private
     * @param {number} row Row index.
     * @param {number} column Visual column index.
     * @returns {Array|undefined} Visual coordinates of the merge.
     */
  }, {
    key: "onModifyGetCellCoords",
    value: function onModifyGetCellCoords(row, column) {
      if (row < 0 || column < 0) {
        return;
      }
      var mergeParent = this.mergedCellsCollection.get(row, column);
      if (!mergeParent) {
        return;
      }
      var mergeRow = mergeParent.row, mergeColumn = mergeParent.col, colspan = mergeParent.colspan, rowspan = mergeParent.rowspan;
      return [
        // Most top-left merged cell coords.
        mergeRow,
        mergeColumn,
        // Most bottom-right merged cell coords.
        mergeRow + rowspan - 1,
        mergeColumn + colspan - 1
      ];
    }
    /**
     * `afterContextMenuDefaultOptions` hook callback.
     *
     * @private
     * @param {object} defaultOptions The default context menu options.
     */
  }, {
    key: "addMergeActionsToContextMenu",
    value: function addMergeActionsToContextMenu(defaultOptions) {
      defaultOptions.items.push({
        name: "---------"
      }, toggleMergeItem(this));
    }
    /**
     * `afterRenderer` hook callback.
     *
     * @private
     * @param {HTMLElement} TD The cell to be modified.
     * @param {number} row Row index.
     * @param {number} col Visual column index.
     */
  }, {
    key: "onAfterRenderer",
    value: function onAfterRenderer(TD, row, col) {
      var mergedCell = this.mergedCellsCollection.get(row, col);
      var mergedCellCopy = isObject$7(mergedCell) ? clone$1(mergedCell) : void 0;
      if (isObject$7(mergedCellCopy)) {
        var _this$hot3 = this.hot, rowMapper = _this$hot3.rowIndexMapper, columnMapper = _this$hot3.columnIndexMapper;
        var mergeRow = mergedCellCopy.row, mergeColumn = mergedCellCopy.col, colspan = mergedCellCopy.colspan, rowspan = mergedCellCopy.rowspan;
        var _this$translateMerged = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan), _this$translateMerged2 = _slicedToArray$2(_this$translateMerged, 2), lastMergedRowIndex = _this$translateMerged2[0], lastMergedColumnIndex = _this$translateMerged2[1];
        var renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);
        var renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);
        var maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1;
        var maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1;
        mergedCellCopy.row = rowMapper.getNearestNotHiddenIndex(mergedCellCopy.row, 1);
        mergedCellCopy.col = columnMapper.getNearestNotHiddenIndex(mergedCellCopy.col, 1);
        mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan);
        mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);
      }
      applySpanProperties(TD, mergedCellCopy, row, col);
    }
    /**
     * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.
     * A selection within merge area should be rewritten to the start of merge area.
     *
     * @private
     * @param {object} coords Cell coords.
     */
  }, {
    key: "onBeforeSetRangeStart",
    value: function onBeforeSetRangeStart(coords) {
      if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {
        var mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);
        var _ref2 = [mergeParent.row, mergeParent.col];
        coords.row = _ref2[0];
        coords.col = _ref2[1];
      }
    }
    /**
     * `beforeSetRangeEnd` hook callback.
     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell.
     *
     * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.
     *
     * @private
     * @param {object} coords Cell coords.
     */
  }, {
    key: "onBeforeSetRangeEnd",
    value: function onBeforeSetRangeEnd(coords) {
      var selRange = this.hot.getSelectedRangeLast();
      selRange.highlight = this.hot._createCellCoords(selRange.highlight.row, selRange.highlight.col);
      selRange.to = coords;
      var rangeExpanded = false;
      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {
        return;
      }
      do {
        rangeExpanded = false;
        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {
          var cellInfo = this.mergedCellsCollection.mergedCells[i];
          var mergedCellRange = cellInfo.getRange();
          if (selRange.expandByRange(mergedCellRange)) {
            coords.row = selRange.to.row;
            coords.col = selRange.to.col;
            rangeExpanded = true;
          }
        }
      } while (rangeExpanded);
    }
    /**
     * The `afterGetCellMeta` hook callback.
     *
     * @private
     * @param {number} row Row index.
     * @param {number} col Column index.
     * @param {object} cellProperties The cell properties object.
     */
  }, {
    key: "onAfterGetCellMeta",
    value: function onAfterGetCellMeta(row, col, cellProperties) {
      var mergeParent = this.mergedCellsCollection.get(row, col);
      if (mergeParent) {
        if (mergeParent.row !== row || mergeParent.col !== col) {
          cellProperties.copyable = false;
        } else {
          cellProperties.rowspan = mergeParent.rowspan;
          cellProperties.colspan = mergeParent.colspan;
        }
      }
    }
    /**
     * `afterViewportRowCalculatorOverride` hook callback.
     *
     * @private
     * @param {object} calc The row calculator object.
     */
  }, {
    key: "onAfterViewportRowCalculatorOverride",
    value: function onAfterViewportRowCalculatorOverride(calc) {
      var nrOfColumns = this.hot.countCols();
      this.modifyViewportRowStart(calc, nrOfColumns);
      this.modifyViewportRowEnd(calc, nrOfColumns);
    }
    /**
     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.
     *
     * @private
     * @param {object} calc The row calculator object.
     * @param {number} nrOfColumns Number of visual columns.
     */
  }, {
    key: "modifyViewportRowStart",
    value: function modifyViewportRowStart(calc, nrOfColumns) {
      var rowMapper = this.hot.rowIndexMapper;
      var visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);
      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);
        if (isObject$7(mergeParentForViewportStart)) {
          var renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.row, 1));
          if (renderableIndexAtMergeStart < calc.startRow) {
            calc.startRow = renderableIndexAtMergeStart;
            this.modifyViewportRowStart(calc, nrOfColumns);
            return;
          }
        }
      }
    }
    /**
     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.
     *
     * @private
     * @param {object} calc The row calculator object.
     * @param {number} nrOfColumns Number of visual columns.
     */
  }, {
    key: "modifyViewportRowEnd",
    value: function modifyViewportRowEnd(calc, nrOfColumns) {
      var rowMapper = this.hot.rowIndexMapper;
      var visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);
      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);
        if (isObject$7(mergeParentForViewportEnd)) {
          var mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;
          var renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeEnd, -1));
          if (renderableIndexAtMergeEnd > calc.endRow) {
            calc.endRow = renderableIndexAtMergeEnd;
            this.modifyViewportRowEnd(calc, nrOfColumns);
            return;
          }
        }
      }
    }
    /**
     * `afterViewportColumnCalculatorOverride` hook callback.
     *
     * @private
     * @param {object} calc The column calculator object.
     */
  }, {
    key: "onAfterViewportColumnCalculatorOverride",
    value: function onAfterViewportColumnCalculatorOverride(calc) {
      var nrOfRows = this.hot.countRows();
      this.modifyViewportColumnStart(calc, nrOfRows);
      this.modifyViewportColumnEnd(calc, nrOfRows);
    }
    /**
     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.
     *
     * @private
     * @param {object} calc The column calculator object.
     * @param {number} nrOfRows Number of visual rows.
     */
  }, {
    key: "modifyViewportColumnStart",
    value: function modifyViewportColumnStart(calc, nrOfRows) {
      var columnMapper = this.hot.columnIndexMapper;
      var visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);
      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);
        if (isObject$7(mergeParentForViewportStart)) {
          var renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.col, 1));
          if (renderableIndexAtMergeStart < calc.startColumn) {
            calc.startColumn = renderableIndexAtMergeStart;
            this.modifyViewportColumnStart(calc, nrOfRows);
            return;
          }
        }
      }
    }
    /**
     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.
     *
     * @private
     * @param {object} calc The column calculator object.
     * @param {number} nrOfRows Number of visual rows.
     */
  }, {
    key: "modifyViewportColumnEnd",
    value: function modifyViewportColumnEnd(calc, nrOfRows) {
      var columnMapper = this.hot.columnIndexMapper;
      var visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);
      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);
        if (isObject$7(mergeParentForViewportEnd)) {
          var mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;
          var renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeEnd, -1));
          if (renderableIndexAtMergeEnd > calc.endColumn) {
            calc.endColumn = renderableIndexAtMergeEnd;
            this.modifyViewportColumnEnd(calc, nrOfRows);
            return;
          }
        }
      }
    }
    /**
     * Translates merged cell coordinates to renderable indexes.
     *
     * @private
     * @param {number} parentRow Visual row index.
     * @param {number} rowspan Rowspan which describes shift which will be applied to parent row
     *                         to calculate renderable index which points to the most bottom
     *                         index position. Pass rowspan as `0` to calculate the most top
     *                         index position.
     * @param {number} parentColumn Visual column index.
     * @param {number} colspan Colspan which describes shift which will be applied to parent column
     *                         to calculate renderable index which points to the most right
     *                         index position. Pass colspan as `0` to calculate the most left
     *                         index position.
     * @returns {number[]}
     */
  }, {
    key: "translateMergedCellToRenderable",
    value: function translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {
      var _this$hot4 = this.hot, rowMapper = _this$hot4.rowIndexMapper, columnMapper = _this$hot4.columnIndexMapper;
      var firstNonHiddenRow;
      var firstNonHiddenColumn;
      if (rowspan === 0) {
        firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow, 1);
      } else {
        firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - 1, -1);
      }
      if (colspan === 0) {
        firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn, 1);
      } else {
        firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + colspan - 1, -1);
      }
      var renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;
      var renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;
      return [renderableRow, renderableColumn];
    }
    /**
     * The `modifyAutofillRange` hook callback.
     *
     * @private
     * @param {Array} drag The drag area coordinates.
     * @param {Array} select The selection information.
     * @returns {Array} The new drag area.
     */
  }, {
    key: "onModifyAutofillRange",
    value: function onModifyAutofillRange(drag, select) {
      this.autofillCalculations.correctSelectionAreaSize(select);
      var dragDirection = this.autofillCalculations.getDirection(select, drag);
      var dragArea = drag;
      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {
        dragArea = select;
        return dragArea;
      }
      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({
        from: {
          row: select[0],
          col: select[1]
        },
        to: {
          row: select[2],
          col: select[3]
        }
      });
      if (!mergedCellsWithinSelectionArea) {
        return dragArea;
      }
      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);
      return dragArea;
    }
    /**
     * `afterCreateCol` hook callback.
     *
     * @private
     * @param {number} column Column index.
     * @param {number} count Number of created columns.
     */
  }, {
    key: "onAfterCreateCol",
    value: function onAfterCreateCol(column, count) {
      this.mergedCellsCollection.shiftCollections("right", column, count);
    }
    /**
     * `afterRemoveCol` hook callback.
     *
     * @private
     * @param {number} column Column index.
     * @param {number} count Number of removed columns.
     */
  }, {
    key: "onAfterRemoveCol",
    value: function onAfterRemoveCol(column, count) {
      this.mergedCellsCollection.shiftCollections("left", column, count);
    }
    /**
     * `afterCreateRow` hook callback.
     *
     * @private
     * @param {number} row Row index.
     * @param {number} count Number of created rows.
     * @param {string} source Source of change.
     */
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(row, count, source) {
      if (source === "auto") {
        return;
      }
      this.mergedCellsCollection.shiftCollections("down", row, count);
    }
    /**
     * `afterRemoveRow` hook callback.
     *
     * @private
     * @param {number} row Row index.
     * @param {number} count Number of removed rows.
     */
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(row, count) {
      this.mergedCellsCollection.shiftCollections("up", row, count);
    }
    /**
     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.
     *
     * @private
     * @param {Array} changes The changes array.
     * @param {string} source Determines the source of the change.
     */
  }, {
    key: "onAfterChange",
    value: function onAfterChange2(changes, source) {
      if (source !== "Autofill.fill") {
        return;
      }
      this.autofillCalculations.recreateAfterDataPopulation(changes);
    }
    /**
     * `beforeDrawAreaBorders` hook callback.
     *
     * @private
     * @param {Array} corners Visual coordinates of the area corners.
     * @param {string} className Class name for the area.
     */
  }, {
    key: "onBeforeDrawAreaBorders",
    value: function onBeforeDrawAreaBorders(corners, className) {
      if (className && className === "area") {
        var selectedRange = this.hot.getSelectedRangeLast();
        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);
        arrayEach(mergedCellsWithinRange, function(mergedCell) {
          if (selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {
            corners[2] = mergedCell.row;
            corners[3] = mergedCell.col;
          }
        });
      }
    }
    /**
     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table
     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.
     *
     * @private
     * @param {CellCoords} coords Coordinates of the to-be-selected cell.
     * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down).
     * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down).
     */
  }, {
    key: "onAfterModifyTransformStart",
    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {
      if (!this.enabled) {
        return;
      }
      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);
      if (!mergedCellAtCoords) {
        return;
      }
      var goingDown = rowTransformDir > 0;
      var goingUp = rowTransformDir < 0;
      var goingLeft = colTransformDir < 0;
      var goingRight = colTransformDir > 0;
      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;
      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;
      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;
      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;
      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {
        coords.row = mergedCellAtCoords.row;
        coords.col = mergedCellAtCoords.col;
      }
    }
    /**
     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.
     *
     * @private
     * @param {number} currentRow Visual row index of the currently processed cell.
     * @param {number} currentColumn Visual column index of the currently cell.
     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.
     */
  }, {
    key: "onAfterDrawSelection",
    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {
      if (!cornersOfSelection) {
        return;
      }
      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);
    }
    /**
     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.
     *
     * @private
     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
     */
  }, {
    key: "onBeforeRemoveCellClassNames",
    value: function onBeforeRemoveCellClassNames() {
      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$9;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$8;
    }
  }]);
  return MergeCells2;
}(BasePlugin);
function _toArray(arr) {
  return _arrayWithHoles$2(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$9(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$9(o, minLen);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArray$8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function rootComparator(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    var _rowIndexWithValues = _toArray(rowIndexWithValues), values3 = _rowIndexWithValues.slice(1);
    var _nextRowIndexWithValu = _toArray(nextRowIndexWithValues), nextValues = _nextRowIndexWithValu.slice(1);
    return function getCompareResult(column) {
      var sortingOrder = sortingOrders[column];
      var columnMeta = columnMetas[column];
      var value = values3[column];
      var nextValue = nextValues[column];
      var pluginSettings = columnMeta.multiColumnSorting;
      var compareFunctionFactory2 = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      var compareResult = compareFunctionFactory2(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      if (compareResult === DO_NOT_SWAP) {
        var nextSortedColumn = column + 1;
        if (typeof columnMetas[nextSortedColumn] !== "undefined") {
          return getCompareResult(nextSortedColumn);
        }
      }
      return compareResult;
    }(0);
  };
}
var _templateObject$4;
function _taggedTemplateLiteral$4(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function warnAboutPluginsConflict() {
  warn$1(toSingleLine(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral$4(["Plugins `columnSorting` and `multiColumnSorting` should not be enabled simultaneously. \n    Only `multiColumnSorting` will work."], ["Plugins \\`columnSorting\\` and \\`multiColumnSorting\\` should not be enabled simultaneously. \n    Only \\`multiColumnSorting\\` will work."]))));
}
var COLUMN_ORDER_PREFIX = "sort";
function getClassesToAdd(columnStatesManager, column, showSortIndicator) {
  var cssClasses = [];
  if (showSortIndicator === false) {
    return cssClasses;
  }
  if (columnStatesManager.isColumnSorted(column) && columnStatesManager.getNumberOfSortedColumns() > 1) {
    cssClasses.push("".concat(COLUMN_ORDER_PREFIX, "-").concat(columnStatesManager.getIndexOfColumnInSortQueue(column) + 1));
  }
  return cssClasses;
}
function getClassesToRemove(htmlElement) {
  var cssClasses = htmlElement.className.split(" ");
  var sortSequenceRegExp = new RegExp("^".concat(COLUMN_ORDER_PREFIX, "-[0-9]{1,2}$"));
  return cssClasses.filter(function(cssClass) {
    return sortSequenceRegExp.test(cssClass);
  });
}
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$c(obj);
}
function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$k(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$7() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$7 = Reflect.get.bind();
  } else {
    _get$7 = function _get2(target, property, receiver) {
      var base = _superPropBase$7(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$7.apply(this, arguments);
}
function _superPropBase$7(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$b(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p2) {
  _setPrototypeOf$b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$b(o, p2);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self2, call2) {
  if (call2 && (_typeof$c(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$b(o);
}
var PLUGIN_KEY$8 = "multiColumnSorting";
var PLUGIN_PRIORITY$7 = 170;
var APPEND_COLUMN_CONFIG_STRATEGY = "append";
var CONFLICTED_PLUGIN_KEY = "columnSorting";
registerRootComparator(PLUGIN_KEY$8, rootComparator);
var MultiColumnSorting = /* @__PURE__ */ function(_ColumnSorting) {
  _inherits$b(MultiColumnSorting2, _ColumnSorting);
  var _super = _createSuper$b(MultiColumnSorting2);
  function MultiColumnSorting2(hotInstance) {
    var _this;
    _classCallCheck$k(this, MultiColumnSorting2);
    _this = _super.call(this, hotInstance);
    _this.pluginKey = PLUGIN_KEY$8;
    return _this;
  }
  _createClass$k(MultiColumnSorting2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "isEnabled", this).call(this);
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      if (!this.enabled && this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
        warnAboutPluginsConflict();
      }
      _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Sorts the table by chosen columns and orders.
     *
     * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
     * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
     * sort order (`asc` for ascending, `desc` for descending).
     *
     * **Note**: Please keep in mind that every call of `sort` function set an entirely new sort order. Previous sort configs aren't preserved.
     *
     * @example
     * ```js
     * // sort ascending first visual column
     * hot.getPlugin('multiColumnSorting').sort({ column: 0, sortOrder: 'asc' });
     *
     * // sort first two visual column in the defined sequence
     * hot.getPlugin('multiColumnSorting').sort([{
     *   column: 1, sortOrder: 'asc'
     * }, {
     *   column: 0, sortOrder: 'desc'
     * }]);
     * ```
     *
     * @fires Hooks#beforeColumnSort
     * @fires Hooks#afterColumnSort
     */
  }, {
    key: "sort",
    value: function sort3(sortConfig) {
      _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "sort", this).call(this, sortConfig);
    }
    /**
     * Clear the sort performed on the table.
     */
  }, {
    key: "clearSort",
    value: function clearSort() {
      _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "clearSort", this).call(this);
    }
    /**
     * Checks if the table is sorted (any column have to be sorted).
     *
     * @returns {boolean}
     */
  }, {
    key: "isSorted",
    value: function isSorted() {
      return _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "isSorted", this).call(this);
    }
    /**
     * Get sort configuration for particular column or for all sorted columns. Objects contain `column` and `sortOrder` properties.
     *
     * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key. They are handled by the `sort` function.
     *
     * @param {number} [column] Visual column index.
     * @returns {undefined|object|Array}
     */
  }, {
    key: "getSortConfig",
    value: function getSortConfig(column) {
      return _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "getSortConfig", this).call(this, column);
    }
    /**
     * @description
     * Warn: Useful mainly for providing server side sort implementation (see in the example below). It doesn't sort the data set. It just sets sort configuration for all sorted columns.
     * Note: Please keep in mind that this method doesn't re-render the table.
     *
     * @example
     * ```js
     * beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {
     *   const columnSortPlugin = this.getPlugin('multiColumnSorting');
     *
     *   columnSortPlugin.setSortConfig(destinationSortConfigs);
     *
     *   // const newData = ... // Calculated data set, ie. from an AJAX call.
     *
     *   this.loadData(newData); // Load new data set and re-render the table.
     *
     *   return false; // The blockade for the default sort action.
     * }
     * ```
     *
     * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
     * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
     * sort order (`asc` for ascending, `desc` for descending).
     */
  }, {
    key: "setSortConfig",
    value: function setSortConfig(sortConfig) {
      _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "setSortConfig", this).call(this, sortConfig);
    }
    /**
     * Get normalized sort configs.
     *
     * @private
     * @param {object|Array} [sortConfig=[]] Single column sort configuration or full sort configuration (for all sorted columns).
     * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
     * sort order (`asc` for ascending, `desc` for descending).
     * @returns {Array}
     */
  }, {
    key: "getNormalizedSortConfigs",
    value: function getNormalizedSortConfigs() {
      var sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (Array.isArray(sortConfig)) {
        return sortConfig;
      }
      return [sortConfig];
    }
    /**
     * Update header classes.
     *
     * @private
     * @param {HTMLElement} headerSpanElement Header span element.
     * @param {...*} args Extra arguments for helpers.
     */
  }, {
    key: "updateHeaderClasses",
    value: function updateHeaderClasses(headerSpanElement) {
      var _get2;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      (_get2 = _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "updateHeaderClasses", this)).call.apply(_get2, [this, headerSpanElement].concat(args));
      removeClass(headerSpanElement, getClassesToRemove(headerSpanElement));
      if (this.enabled !== false) {
        addClass(headerSpanElement, getClassesToAdd.apply(void 0, args));
      }
    }
    /**
     * Overwriting base plugin's `onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` isn't called
     * for `updateSettings` in specific situations.
     *
     * @private
     * @param {object} newSettings New settings object.
     */
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings(newSettings) {
      if (this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
        warnAboutPluginsConflict();
      }
      _get$7(_getPrototypeOf$b(MultiColumnSorting2.prototype), "onUpdateSettings", this).call(this, newSettings);
    }
    /**
     * Callback for the `onAfterOnCellMouseDown` hook.
     *
     * @private
     * @param {Event} event Event which are provided by hook.
     * @param {CellCoords} coords Visual coords of the selected cell.
     */
  }, {
    key: "onAfterOnCellMouseDown",
    value: function onAfterOnCellMouseDown(event2, coords) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event2, coords.col)) {
        if (this.hot.getShortcutManager().isCtrlPressed()) {
          this.hot.deselectCell();
          this.hot.selectColumns(coords.col);
          this.sort(this.getNextSortConfig(coords.col, APPEND_COLUMN_CONFIG_STRATEGY));
        } else {
          this.sort(this.getColumnNextConfig(coords.col));
        }
      }
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$8;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$7;
    }
  }]);
  return MultiColumnSorting2;
}(ColumnSorting);
function _typeof$b(obj) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$b(obj);
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$j(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$6() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$6 = Reflect.get.bind();
  } else {
    _get$6 = function _get2(target, property, receiver) {
      var base = _superPropBase$6(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$6.apply(this, arguments);
}
function _superPropBase$6(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$a(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p2) {
  _setPrototypeOf$a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$a(o, p2);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call2) {
  if (call2 && (_typeof$b(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$a(o);
}
var PLUGIN_KEY$7 = "multipleSelectionHandles";
var PLUGIN_PRIORITY$6 = 160;
var MultipleSelectionHandles = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$a(MultipleSelectionHandles2, _BasePlugin);
  var _super = _createSuper$a(MultipleSelectionHandles2);
  function MultipleSelectionHandles2(hotInstance) {
    var _this2;
    _classCallCheck$j(this, MultipleSelectionHandles2);
    _this2 = _super.call(this, hotInstance);
    _this2.dragged = [];
    _this2.eventManager = null;
    _this2.lastSetCell = null;
    return _this2;
  }
  _createClass$j(MultipleSelectionHandles2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return isMobileBrowser();
    }
    /**
     * Enable plugin for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      if (this.enabled) {
        return;
      }
      if (!this.eventManager) {
        this.eventManager = new EventManager$1(this);
      }
      this.registerListeners();
      _get$6(_getPrototypeOf$a(MultipleSelectionHandles2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Bind the touch events.
     *
     * @private
     */
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this3 = this;
      var _this = this;
      var rootElement = this.hot.rootElement;
      function removeFromDragged(query) {
        if (_this.dragged.length === 1) {
          _this.dragged.splice(0, _this.dragged.length);
          return true;
        }
        var entryPosition = _this.dragged.indexOf(query);
        if (entryPosition === -1) {
          return false;
        } else if (entryPosition === 0) {
          _this.dragged = _this.dragged.slice(0, 1);
        } else if (entryPosition === 1) {
          _this.dragged = _this.dragged.slice(-1);
        }
      }
      this.eventManager.addEventListener(rootElement, "touchstart", function(event2) {
        var selectedRange;
        if (hasClass(event2.target, "topSelectionHandle-HitArea")) {
          selectedRange = _this.hot.getSelectedRangeLast();
          _this.dragged.push("top");
          _this.touchStartRange = {
            width: selectedRange.getWidth(),
            height: selectedRange.getHeight(),
            direction: selectedRange.getDirection()
          };
          event2.preventDefault();
          return false;
        } else if (hasClass(event2.target, "bottomSelectionHandle-HitArea")) {
          selectedRange = _this.hot.getSelectedRangeLast();
          _this.dragged.push("bottom");
          _this.touchStartRange = {
            width: selectedRange.getWidth(),
            height: selectedRange.getHeight(),
            direction: selectedRange.getDirection()
          };
          event2.preventDefault();
          return false;
        }
      });
      this.eventManager.addEventListener(rootElement, "touchend", function(event2) {
        if (hasClass(event2.target, "topSelectionHandle-HitArea")) {
          removeFromDragged.call(_this, "top");
          _this.touchStartRange = void 0;
          event2.preventDefault();
          return false;
        } else if (hasClass(event2.target, "bottomSelectionHandle-HitArea")) {
          removeFromDragged.call(_this, "bottom");
          _this.touchStartRange = void 0;
          event2.preventDefault();
          return false;
        }
      });
      this.eventManager.addEventListener(rootElement, "touchmove", function(event2) {
        var rootDocument = _this3.hot.rootDocument;
        var targetCoords;
        var selectedRange;
        var rangeWidth;
        var rangeHeight;
        var rangeDirection;
        var newRangeCoords;
        if (_this.dragged.length === 0) {
          return;
        }
        var endTarget = rootDocument.elementFromPoint(event2.touches[0].clientX, event2.touches[0].clientY);
        if (!endTarget || endTarget === _this.lastSetCell) {
          return;
        }
        if (endTarget.nodeName === "TD" || endTarget.nodeName === "TH") {
          targetCoords = _this.hot.getCoords(endTarget);
          if (targetCoords.col === -1) {
            targetCoords.col = 0;
          }
          selectedRange = _this.hot.getSelectedRangeLast();
          rangeWidth = selectedRange.getWidth();
          rangeHeight = selectedRange.getHeight();
          rangeDirection = selectedRange.getDirection();
          if (rangeWidth === 1 && rangeHeight === 1) {
            _this.hot.selection.setRangeEnd(targetCoords);
          }
          newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, _this.touchStartRange.direction, rangeDirection, _this.dragged[0]);
          if (newRangeCoords.start !== null) {
            _this.hot.selection.setRangeStart(newRangeCoords.start);
          }
          _this.hot.selection.setRangeEnd(newRangeCoords.end);
          _this.lastSetCell = endTarget;
        }
        event2.preventDefault();
      });
    }
  }, {
    key: "getCurrentRangeCoords",
    value: function getCurrentRangeCoords(selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {
      var topStartCorner = selectedRange.getTopStartCorner();
      var bottomEndCorner = selectedRange.getBottomEndCorner();
      var bottomStartCorner = selectedRange.getBottomStartCorner();
      var topEndCorner = selectedRange.getTopEndCorner();
      var newCoords = {
        start: null,
        end: null
      };
      switch (touchStartDirection) {
        case "NE-SW":
          switch (currentDirection) {
            case "NE-SW":
            case "NW-SE":
              if (draggedHandle === "top") {
                newCoords = {
                  start: this.hot._createCellCoords(currentTouch.row, selectedRange.highlight.col),
                  end: this.hot._createCellCoords(bottomStartCorner.row, currentTouch.col)
                };
              } else {
                newCoords = {
                  start: this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),
                  end: this.hot._createCellCoords(currentTouch.row, topStartCorner.col)
                };
              }
              break;
            case "SE-NW":
              if (draggedHandle === "bottom") {
                newCoords = {
                  start: this.hot._createCellCoords(bottomEndCorner.row, currentTouch.col),
                  end: this.hot._createCellCoords(currentTouch.row, topStartCorner.col)
                };
              }
              break;
          }
          break;
        case "NW-SE":
          switch (currentDirection) {
            case "NE-SW":
              if (draggedHandle === "top") {
                newCoords = {
                  start: currentTouch,
                  end: bottomStartCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "NW-SE":
              if (draggedHandle === "top") {
                newCoords = {
                  start: currentTouch,
                  end: bottomEndCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "SE-NW":
              if (draggedHandle === "top") {
                newCoords = {
                  start: currentTouch,
                  end: topStartCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "SW-NE":
              if (draggedHandle === "top") {
                newCoords = {
                  start: currentTouch,
                  end: topEndCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
          }
          break;
        case "SW-NE":
          switch (currentDirection) {
            case "NW-SE":
              if (draggedHandle === "bottom") {
                newCoords = {
                  start: this.hot._createCellCoords(currentTouch.row, topStartCorner.col),
                  end: this.hot._createCellCoords(bottomStartCorner.row, currentTouch.col)
                };
              } else {
                newCoords = {
                  start: this.hot._createCellCoords(topStartCorner.row, currentTouch.col),
                  end: this.hot._createCellCoords(currentTouch.row, bottomEndCorner.col)
                };
              }
              break;
            case "SW-NE":
              if (draggedHandle === "top") {
                newCoords = {
                  start: this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),
                  end: this.hot._createCellCoords(currentTouch.row, bottomEndCorner.col)
                };
              } else {
                newCoords = {
                  start: this.hot._createCellCoords(currentTouch.row, topStartCorner.col),
                  end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)
                };
              }
              break;
            case "SE-NW":
              if (draggedHandle === "bottom") {
                newCoords = {
                  start: this.hot._createCellCoords(currentTouch.row, topEndCorner.col),
                  end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)
                };
              } else if (draggedHandle === "top") {
                newCoords = {
                  start: bottomStartCorner,
                  end: currentTouch
                };
              }
              break;
          }
          break;
        case "SE-NW":
          switch (currentDirection) {
            case "NW-SE":
            case "NE-SW":
            case "SW-NE":
              if (draggedHandle === "top") {
                newCoords.end = currentTouch;
              }
              break;
            case "SE-NW":
              if (draggedHandle === "top") {
                newCoords.end = currentTouch;
              } else {
                newCoords = {
                  start: currentTouch,
                  end: topStartCorner
                };
              }
              break;
          }
          break;
      }
      return newCoords;
    }
    /**
     * Check if user is currently dragging the handle.
     *
     * @returns {boolean} Dragging state.
     */
  }, {
    key: "isDragged",
    value: function isDragged() {
      return this.dragged.length > 0;
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$7;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$6;
    }
  }]);
  return MultipleSelectionHandles2;
}(BasePlugin);
function createDefaultHeaderSettings() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$label = _ref2.label, label = _ref$label === void 0 ? "" : _ref$label, _ref$colspan = _ref2.colspan, colspan = _ref$colspan === void 0 ? 1 : _ref$colspan, _ref$origColspan = _ref2.origColspan, origColspan = _ref$origColspan === void 0 ? 1 : _ref$origColspan, _ref$collapsible = _ref2.collapsible, collapsible = _ref$collapsible === void 0 ? false : _ref$collapsible, _ref$crossHiddenColum = _ref2.crossHiddenColumns, crossHiddenColumns = _ref$crossHiddenColum === void 0 ? [] : _ref$crossHiddenColum, _ref$isCollapsed = _ref2.isCollapsed, isCollapsed = _ref$isCollapsed === void 0 ? false : _ref$isCollapsed, _ref$isHidden = _ref2.isHidden, isHidden = _ref$isHidden === void 0 ? false : _ref$isHidden, _ref$isRoot = _ref2.isRoot, isRoot = _ref$isRoot === void 0 ? false : _ref$isRoot, _ref$isPlaceholder = _ref2.isPlaceholder, isPlaceholder = _ref$isPlaceholder === void 0 ? false : _ref$isPlaceholder;
  return {
    label,
    colspan,
    origColspan,
    collapsible,
    isCollapsed,
    crossHiddenColumns,
    isHidden,
    isRoot,
    isPlaceholder
  };
}
function createPlaceholderHeaderSettings() {
  return {
    label: "",
    isPlaceholder: true
  };
}
function _toConsumableArray$7(arr) {
  return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$8(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$8(o, minLen);
}
function _iterableToArray$7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$8(arr);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function normalizeSettings(sourceSettings) {
  var columnsLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  var normalizedSettings = [];
  if (columnsLimit === 0) {
    return normalizedSettings;
  }
  arrayEach(sourceSettings, function(headersSettings) {
    var columns = [];
    var columnIndex = 0;
    normalizedSettings.push(columns);
    arrayEach(headersSettings, function(sourceHeaderSettings) {
      var headerSettings = createDefaultHeaderSettings();
      if (isObject$7(sourceHeaderSettings)) {
        var label = sourceHeaderSettings.label, colspan = sourceHeaderSettings.colspan;
        headerSettings.label = stringify$1(label);
        if (typeof colspan === "number" && colspan > 1) {
          headerSettings.colspan = colspan;
          headerSettings.origColspan = colspan;
        }
      } else {
        headerSettings.label = stringify$1(sourceHeaderSettings);
      }
      columnIndex += headerSettings.origColspan;
      var cancelProcessing = false;
      if (columnIndex >= columnsLimit) {
        headerSettings.colspan = headerSettings.origColspan - (columnIndex - columnsLimit);
        headerSettings.origColspan = headerSettings.colspan;
        cancelProcessing = true;
      }
      columns.push(headerSettings);
      if (headerSettings.colspan > 1) {
        for (var i = 0; i < headerSettings.colspan - 1; i++) {
          columns.push(createPlaceholderHeaderSettings());
        }
      }
      return !cancelProcessing;
    });
  });
  var columnsLength = Math.max.apply(Math, _toConsumableArray$7(arrayMap(normalizedSettings, function(headersSettings) {
    return headersSettings.length;
  })));
  arrayEach(normalizedSettings, function(headersSettings) {
    if (headersSettings.length < columnsLength) {
      var defaultSettings = arrayMap(new Array(columnsLength - headersSettings.length), function() {
        return createDefaultHeaderSettings();
      });
      headersSettings.splice.apply(headersSettings, [headersSettings.length, 0].concat(_toConsumableArray$7(defaultSettings)));
    }
  });
  return normalizedSettings;
}
var _excluded$2 = ["row", "col"];
function ownKeys$3(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$i(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateFieldInitSpec$3(obj, privateMap, value) {
  _checkPrivateRedeclaration$3(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$3(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet$3(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$3(receiver, privateMap, "get");
  return _classApplyDescriptorGet$3(receiver, descriptor);
}
function _classApplyDescriptorGet$3(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$3(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$3(receiver, privateMap, "set");
  _classApplyDescriptorSet$3(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$3(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$3(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var HEADER_CONFIGURABLE_PROPS = ["label", "collapsible"];
var _data = /* @__PURE__ */ new WeakMap();
var _dataLength = /* @__PURE__ */ new WeakMap();
var _columnsLimit = /* @__PURE__ */ new WeakMap();
var SourceSettings = /* @__PURE__ */ function() {
  function SourceSettings2() {
    _classCallCheck$i(this, SourceSettings2);
    _classPrivateFieldInitSpec$3(this, _data, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec$3(this, _dataLength, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec$3(this, _columnsLimit, {
      writable: true,
      value: Infinity
    });
  }
  _createClass$i(SourceSettings2, [{
    key: "setColumnsLimit",
    value: (
      /**
       * Sets columns limit to the source settings will be trimmed. All headers which
       * overlap the column limit will be reduced to keep the structure solid.
       *
       * @param {number} columnsCount The number of columns to limit to.
       */
      function setColumnsLimit(columnsCount) {
        _classPrivateFieldSet$3(this, _columnsLimit, columnsCount);
      }
    )
    /**
     * Sets a new nested header configuration.
     *
     * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.
     */
  }, {
    key: "setData",
    value: function setData() {
      var nestedHeadersSettings = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      _classPrivateFieldSet$3(this, _data, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet$3(this, _columnsLimit)));
      _classPrivateFieldSet$3(this, _dataLength, _classPrivateFieldGet$3(this, _data).length);
    }
    /**
     * Gets normalized source settings.
     *
     * @returns {Array[]}
     */
  }, {
    key: "getData",
    value: function getData() {
      return _classPrivateFieldGet$3(this, _data);
    }
    /**
     * Merges settings with current source settings.
     *
     * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional
     *                                      properties to merge with current source settings.
     */
  }, {
    key: "mergeWith",
    value: function mergeWith(additionalSettings) {
      var _this = this;
      arrayEach(additionalSettings, function(_ref2) {
        var row = _ref2.row, col = _ref2.col, rest = _objectWithoutProperties$2(_ref2, _excluded$2);
        var headerSettings = _this.getHeaderSettings(row, col);
        if (headerSettings !== null) {
          extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);
        }
      });
    }
    /**
     * Maps the current state with a callback. For each source settings the callback function
     * is called. If the function returns value that value is merged with the source settings.
     *
     * @param {Function} callback A function that is called for every header settings.
     *                            Each time the callback is called, the returned value extends
     *                            header settings.
     */
  }, {
    key: "map",
    value: function map2(callback) {
      arrayEach(_classPrivateFieldGet$3(this, _data), function(header) {
        arrayEach(header, function(headerSettings) {
          var propsToExtend = callback(_objectSpread$3({}, headerSettings));
          if (isObject$7(propsToExtend)) {
            extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);
          }
        });
      });
    }
    /**
     * Gets source column header settings for a specified header. The returned
     * object contains information about the header label, its colspan length,
     * or if it is hidden in the header renderers.
     *
     * @param {number} headerLevel Header level (0 = most distant to the table).
     * @param {number} columnIndex A visual column index.
     * @returns {object|null}
     */
  }, {
    key: "getHeaderSettings",
    value: function getHeaderSettings(headerLevel, columnIndex) {
      var _headersSettings$colu;
      if (headerLevel >= _classPrivateFieldGet$3(this, _dataLength) || headerLevel < 0) {
        return null;
      }
      var headersSettings = _classPrivateFieldGet$3(this, _data)[headerLevel];
      if (columnIndex >= headersSettings.length) {
        return null;
      }
      return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;
    }
    /**
     * Gets source of column headers settings for specified headers. If the retrieved column
     * settings overlap the range "box" determined by "columnIndex" and "columnsLength"
     * the exception will be thrown.
     *
     * @param {number} headerLevel Header level (0 = most distant to the table).
     * @param {number} columnIndex A visual column index from which the settings will be extracted.
     * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.
     * @returns {object}
     */
  }, {
    key: "getHeadersSettings",
    value: function getHeadersSettings(headerLevel, columnIndex) {
      var columnsLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var headersSettingsChunks = [];
      if (headerLevel >= _classPrivateFieldGet$3(this, _dataLength) || headerLevel < 0) {
        return headersSettingsChunks;
      }
      var headersSettings = _classPrivateFieldGet$3(this, _data)[headerLevel];
      var currentLength = 0;
      for (var i = columnIndex; i < headersSettings.length; i++) {
        var headerSettings = headersSettings[i];
        if (headerSettings.isPlaceholder) {
          throw new Error("The first column settings cannot overlap the other header layers");
        }
        currentLength += headerSettings.colspan;
        headersSettingsChunks.push(headerSettings);
        if (headerSettings.colspan > 1) {
          i += headerSettings.colspan - 1;
        }
        if (currentLength === columnsLength) {
          break;
        }
        if (currentLength > columnsLength) {
          throw new Error("The last column settings cannot overlap the other header layers");
        }
      }
      return headersSettingsChunks;
    }
    /**
     * Gets a total number of headers levels.
     *
     * @returns {number}
     */
  }, {
    key: "getLayersCount",
    value: function getLayersCount() {
      return _classPrivateFieldGet$3(this, _dataLength);
    }
    /**
     * Gets a total number of columns count.
     *
     * @returns {number}
     */
  }, {
    key: "getColumnsCount",
    value: function getColumnsCount() {
      return _classPrivateFieldGet$3(this, _dataLength) > 0 ? _classPrivateFieldGet$3(this, _data)[0].length : 0;
    }
    /**
     * Clears the data.
     */
  }, {
    key: "clear",
    value: function clear2() {
      _classPrivateFieldSet$3(this, _data, []);
      _classPrivateFieldSet$3(this, _dataLength, 0);
    }
  }]);
  return SourceSettings2;
}();
function ownKeys$2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$h(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toConsumableArray$6(arr) {
  return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$7(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$7(o, minLen);
}
function _iterableToArray$6(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$7(arr);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var TRAVERSAL_DF_PRE = "DF-pre-order";
function depthFirstPreOrder(callback, context) {
  var continueTraverse = callback.call(context, this);
  for (var i = 0; i < this.childs.length; i++) {
    if (continueTraverse === false) {
      return false;
    }
    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);
  }
  return continueTraverse;
}
var TRAVERSAL_DF_POST = "DF-post-order";
function depthFirstPostOrder(callback, context) {
  for (var i = 0; i < this.childs.length; i++) {
    var continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);
    if (continueTraverse === false) {
      return false;
    }
  }
  return callback.call(context, this);
}
var TRAVERSAL_BF = "BF";
function breadthFirst(callback, context) {
  var queue2 = [this];
  function process2() {
    if (queue2.length === 0) {
      return;
    }
    var node = queue2.shift();
    queue2.push.apply(queue2, _toConsumableArray$6(node.childs));
    if (callback.call(context, node) !== false) {
      process2();
    }
  }
  process2();
}
var DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;
var TRAVERSAL_STRATEGIES = /* @__PURE__ */ new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);
var TreeNode = /* @__PURE__ */ function() {
  function TreeNode2(data2) {
    _classCallCheck$h(this, TreeNode2);
    _defineProperty$4(this, "data", {});
    _defineProperty$4(this, "parent", null);
    _defineProperty$4(this, "childs", []);
    this.data = data2;
  }
  _createClass$h(TreeNode2, [{
    key: "addChild",
    value: function addChild(node) {
      node.parent = this;
      this.childs.push(node);
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * @memberof TreeNode#
     * @function cloneTree
     *
     * Clones a tree structure deeply.
     *
     * For example, for giving a tree structure:
     *      .--(B1)--.
     *   .-(C1)   .-(C2)-.----.
     *  (D1)     (D2)   (D3) (D4)
     *
     * Cloning a tree starting from C2 node creates a mirrored tree structure.
     *     .-(C2')-.-----.
     *    (D2')   (D3') (D4')
     *
     * The cloned tree can be safely modified without affecting the original structure.
     * After modification, the clone can be merged with a tree using the "replaceTreeWith" method.
     *
     * @param {TreeNode} [nodeTree=this] A TreeNode to clone.
     * @returns {TreeNode}
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "cloneTree",
    value: function cloneTree() {
      var nodeTree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
      var clonedNode = new TreeNode2(_objectSpread$2({}, nodeTree.data));
      for (var i = 0; i < nodeTree.childs.length; i++) {
        clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));
      }
      return clonedNode;
    }
    /**
     * Replaces the current node with a passed tree structure.
     *
     * @param {TreeNode} nodeTree A TreeNode to replace with.
     */
  }, {
    key: "replaceTreeWith",
    value: function replaceTreeWith(nodeTree) {
      this.data = _objectSpread$2({}, nodeTree.data);
      this.childs = [];
      for (var i = 0; i < nodeTree.childs.length; i++) {
        this.addChild(nodeTree.childs[i]);
      }
    }
    /**
     * Traverses the tree structure through node childs. The walk down traversing supports
     * a three different strategies.
     *  - Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));
     *  - Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));
     *  - Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).
     *
     * @param {Function} callback The callback function which will be called for each node.
     * @param {string} [traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.
     */
  }, {
    key: "walkDown",
    value: function walkDown(callback) {
      var traversalStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;
      if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {
        throw new Error('Traversal strategy "'.concat(traversalStrategy, '" does not exist'));
      }
      TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);
    }
    /**
     * Traverses the tree structure through node parents.
     *
     * @param {Function} callback The callback function which will be called for each node.
     */
  }, {
    key: "walkUp",
    value: function walkUp(callback) {
      var context = this;
      var process2 = function process3(node) {
        var continueTraverse = callback.call(context, node);
        if (continueTraverse !== false && node.parent !== null) {
          process3(node.parent);
        }
      };
      process2(this);
    }
  }]);
  return TreeNode2;
}();
function ownKeys$1(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$6(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$g(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateFieldInitSpec$2(obj, privateMap, value) {
  _checkPrivateRedeclaration$2(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$2(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet$2(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$2(receiver, privateMap, "get");
  return _classApplyDescriptorGet$2(receiver, descriptor);
}
function _classApplyDescriptorGet$2(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$2(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$2(receiver, privateMap, "set");
  _classApplyDescriptorSet$2(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$2(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$2(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _rootNodes = /* @__PURE__ */ new WeakMap();
var _rootsIndex = /* @__PURE__ */ new WeakMap();
var _sourceSettings$1 = /* @__PURE__ */ new WeakMap();
var HeadersTree = /* @__PURE__ */ function() {
  function HeadersTree2(sourceSettings) {
    _classCallCheck$g(this, HeadersTree2);
    _classPrivateFieldInitSpec$2(this, _rootNodes, {
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    _classPrivateFieldInitSpec$2(this, _rootsIndex, {
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    _classPrivateFieldInitSpec$2(this, _sourceSettings$1, {
      writable: true,
      value: null
    });
    _classPrivateFieldSet$2(this, _sourceSettings$1, sourceSettings);
  }
  _createClass$g(HeadersTree2, [{
    key: "getRoots",
    value: function getRoots() {
      return Array.from(_classPrivateFieldGet$2(this, _rootNodes).values());
    }
    /**
     * Gets a root node by specified visual column index.
     *
     * @param {number} columnIndex A visual column index.
     * @returns {TreeNode|undefined}
     */
  }, {
    key: "getRootByColumn",
    value: function getRootByColumn(columnIndex) {
      var node;
      if (_classPrivateFieldGet$2(this, _rootsIndex).has(columnIndex)) {
        node = _classPrivateFieldGet$2(this, _rootNodes).get(_classPrivateFieldGet$2(this, _rootsIndex).get(columnIndex));
      }
      return node;
    }
    /**
     * Gets a tree node by its position in the grid settings.
     *
     * @param {number} headerLevel Header level index (there is support only for positive values).
     * @param {number} columnIndex A visual column index.
     * @returns {TreeNode|undefined}
     */
  }, {
    key: "getNode",
    value: function getNode(headerLevel, columnIndex) {
      var rootNode = this.getRootByColumn(columnIndex);
      if (!rootNode) {
        return;
      }
      var normColumnIndex = columnIndex - _classPrivateFieldGet$2(this, _rootsIndex).get(columnIndex);
      var columnCursor = 0;
      var treeNode;
      rootNode.walkDown(function(node) {
        var _node$data = node.data, origColspan = _node$data.origColspan, nodeHeaderLevel = _node$data.headerLevel;
        if (headerLevel === nodeHeaderLevel) {
          if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {
            treeNode = node;
            return false;
          }
          columnCursor += origColspan;
        }
      });
      return treeNode;
    }
    /**
     * Builds (or rebuilds if called again) root nodes indexes.
     */
  }, {
    key: "rebuildTreeIndex",
    value: function rebuildTreeIndex() {
      var _this = this;
      var columnIndex = 0;
      _classPrivateFieldGet$2(this, _rootsIndex).clear();
      arrayEach(_classPrivateFieldGet$2(this, _rootNodes), function(_ref2) {
        var _ref22 = _slicedToArray$1(_ref2, 2), colspan = _ref22[1].data.colspan;
        for (var i = columnIndex; i < columnIndex + colspan; i++) {
          _classPrivateFieldGet$2(_this, _rootsIndex).set(i, columnIndex);
        }
        columnIndex += colspan;
      });
    }
    /**
     * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built
     * from the previous call.
     */
  }, {
    key: "buildTree",
    value: function buildTree() {
      this.clear();
      var columnsCount = _classPrivateFieldGet$2(this, _sourceSettings$1).getColumnsCount();
      var columnIndex = 0;
      while (columnIndex < columnsCount) {
        var columnSettings = _classPrivateFieldGet$2(this, _sourceSettings$1).getHeaderSettings(0, columnIndex);
        var rootNode = new TreeNode();
        _classPrivateFieldGet$2(this, _rootNodes).set(columnIndex, rootNode);
        this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);
        columnIndex += columnSettings.origColspan;
      }
      this.rebuildTreeIndex();
    }
    /**
     * Builds leaves for specified tree node.
     *
     * @param {TreeNode} parentNode A node to which the leaves applies.
     * @param {number} columnIndex A visual column index.
     * @param {number} headerLevel Currently processed header level.
     * @param {number} [extractionLength=1] Determines column extraction length for node children.
     */
  }, {
    key: "buildLeaves",
    value: function buildLeaves(parentNode, columnIndex, headerLevel) {
      var _this2 = this;
      var extractionLength = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      var columnsSettings = _classPrivateFieldGet$2(this, _sourceSettings$1).getHeadersSettings(headerLevel, columnIndex, extractionLength);
      headerLevel += 1;
      arrayEach(columnsSettings, function(columnSettings) {
        var nodeData = _objectSpread$1(_objectSpread$1({}, columnSettings), {}, {
          /**
           * The header level (tree node depth level).
           *
           * @type {number}
           */
          headerLevel: headerLevel - 1,
          /**
           * A visual column index.
           *
           * @type {number}
           */
          columnIndex
        });
        var node;
        if (headerLevel === 1) {
          parentNode.data = nodeData;
          node = parentNode;
        } else {
          node = new TreeNode(nodeData);
          parentNode.addChild(node);
        }
        if (headerLevel < _classPrivateFieldGet$2(_this2, _sourceSettings$1).getLayersCount()) {
          _this2.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);
        }
        columnIndex += columnSettings.origColspan;
      });
    }
    /**
     * Clears the tree to the initial state.
     */
  }, {
    key: "clear",
    value: function clear2() {
      _classPrivateFieldGet$2(this, _rootNodes).clear();
      _classPrivateFieldGet$2(this, _rootsIndex).clear();
    }
  }]);
  return HeadersTree2;
}();
function traverseHiddenNodeColumnIndexes(node, callback) {
  node.walkDown(function(_ref2) {
    var data2 = _ref2.data, childs = _ref2.childs;
    if (!data2.isHidden) {
      callback(data2.columnIndex);
      if (childs.length === 0) {
        for (var i = 1; i < data2.colspan; i++) {
          callback(data2.columnIndex + i);
        }
      }
    }
  });
}
function getFirstChildProperty(_ref2, propertyName) {
  var childs = _ref2.childs;
  if (childs.length === 0) {
    return;
  }
  return childs[0].data[propertyName];
}
function isNodeReflectsFirstChildColspan(node) {
  return getFirstChildProperty(node, "origColspan") === node.data.origColspan;
}
function expandNode(nodeToProcess) {
  var nodeData = nodeToProcess.data, nodeChilds = nodeToProcess.childs;
  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: function rollbackModification() {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return expandNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = false;
  var allLeavesExceptMostLeft = nodeChilds.slice(1);
  var affectedColumns = /* @__PURE__ */ new Set();
  var colspanCompensation = 0;
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, function(node) {
      node.replaceTreeWith(node.data.clonedTree);
      node.data.clonedTree = null;
      var leafData = node.data;
      colspanCompensation += leafData.colspan;
      traverseHiddenNodeColumnIndexes(node, function(gridColumnIndex) {
        affectedColumns.add(gridColumnIndex);
      });
    });
  } else {
    var colspan = nodeData.colspan, origColspan = nodeData.origColspan, columnIndex = nodeData.columnIndex;
    colspanCompensation = origColspan - colspan;
    for (var i = 1; i < origColspan; i++) {
      affectedColumns.add(columnIndex + i);
    }
  }
  nodeToProcess.walkUp(function(node) {
    var data2 = node.data;
    data2.colspan += colspanCompensation;
    if (data2.colspan >= data2.origColspan) {
      data2.colspan = data2.origColspan;
      data2.isCollapsed = false;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data2.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: function rollbackModification() {
      return collapseNode(nodeToProcess);
    },
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}
function collapseNode(nodeToProcess) {
  var _getFirstChildPropert;
  var nodeData = nodeToProcess.data, nodeChilds = nodeToProcess.childs;
  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: function rollbackModification() {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return collapseNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = true;
  var allLeavesExceptMostLeft = nodeChilds.slice(1);
  var affectedColumns = /* @__PURE__ */ new Set();
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, function(node) {
      traverseHiddenNodeColumnIndexes(node, function(gridColumnIndex2) {
        affectedColumns.add(gridColumnIndex2);
      });
      node.data.clonedTree = node.cloneTree();
      node.walkDown(function(_ref2) {
        var data2 = _ref2.data;
        data2.isHidden = true;
      });
    });
  } else {
    var origColspan = nodeData.origColspan, columnIndex = nodeData.columnIndex;
    for (var i = 1; i < origColspan; i++) {
      var gridColumnIndex = columnIndex + i;
      affectedColumns.add(gridColumnIndex);
    }
  }
  var colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, "colspan")) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);
  nodeToProcess.walkUp(function(node) {
    var data2 = node.data;
    data2.colspan -= colspanCompensation;
    if (data2.colspan <= 1) {
      data2.colspan = 1;
      data2.isCollapsed = true;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data2.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: function rollbackModification() {
      return expandNode(nodeToProcess);
    },
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}
var _templateObject$3;
function _taggedTemplateLiteral$3(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function hideColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral$3(["The passed node is not the last node on the tree. Only for \nthe last node, the hide column modification can be applied."], ["The passed node is not the last node on the tree. Only for\\x20\nthe last node, the hide column modification can be applied."]))));
  }
  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;
  if (crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  var isCollapsibleNode = false;
  nodeToProcess.walkUp(function(node) {
    var collapsible = node.data.collapsible;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp(function(node) {
    var data2 = node.data;
    data2.crossHiddenColumns.push(gridColumnIndex);
    if (data2.colspan > 1) {
      data2.colspan -= 1;
    } else {
      data2.isHidden = true;
    }
  });
}
var _templateObject$2;
function _taggedTemplateLiteral$2(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function showColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral$2(["The passed node is not the last node on the tree. Only for \nthe last node, the show column modification can be applied."], ["The passed node is not the last node on the tree. Only for\\x20\nthe last node, the show column modification can be applied."]))));
  }
  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;
  if (!crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  var isCollapsibleNode = false;
  nodeToProcess.walkUp(function(node) {
    var collapsible = node.data.collapsible;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp(function(node) {
    var data2 = node.data;
    data2.crossHiddenColumns.splice(data2.crossHiddenColumns.indexOf(gridColumnIndex), 1);
    if (!data2.isHidden && data2.colspan < data2.origColspan) {
      data2.colspan += 1;
    }
    data2.isHidden = false;
  });
}
var availableModifiers = /* @__PURE__ */ new Map([["collapse", collapseNode], ["expand", expandNode], ["hide-column", hideColumn], ["show-column", showColumn]]);
function triggerNodeModification(actionName, nodeToProcess, gridColumnIndex) {
  if (!availableModifiers.has(actionName)) {
    throw new Error('The node modifier action ("'.concat(actionName, '") does not exist.'));
  }
  return availableModifiers.get(actionName)(nodeToProcess, gridColumnIndex);
}
var _excluded$1 = ["crossHiddenColumns"];
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function generateMatrix(headerRoots) {
  var matrix = [];
  arrayEach(headerRoots, function(rootNode) {
    rootNode.walkDown(function(node) {
      var nodeData = node.data;
      var origColspan = nodeData.origColspan, columnIndex = nodeData.columnIndex, headerLevel = nodeData.headerLevel, crossHiddenColumns = nodeData.crossHiddenColumns;
      var colspanHeaderLayer = createNestedArrayIfNecessary(matrix, headerLevel);
      var isRootSettingsFound = false;
      for (var i = columnIndex; i < columnIndex + origColspan; i++) {
        var isColumnHidden = crossHiddenColumns.includes(i);
        if (isColumnHidden || isRootSettingsFound) {
          colspanHeaderLayer.push(createPlaceholderHeaderSettings());
        } else {
          var headerRootSettings = createHeaderSettings(nodeData);
          headerRootSettings.isRoot = true;
          colspanHeaderLayer.push(headerRootSettings);
          isRootSettingsFound = true;
        }
      }
    });
  });
  return matrix;
}
function createHeaderSettings(nodeData) {
  var _createDefaultHeaderS = createDefaultHeaderSettings(nodeData);
  _createDefaultHeaderS.crossHiddenColumns;
  var headerRootSettings = _objectWithoutProperties$1(_createDefaultHeaderS, _excluded$1);
  return headerRootSettings;
}
function createNestedArrayIfNecessary(array, index2) {
  var subArray;
  if (Array.isArray(array[index2])) {
    subArray = array[index2];
  } else {
    subArray = [];
    array[index2] = subArray;
  }
  return subArray;
}
var _excluded = ["row"];
function ownKeys2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$f(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classPrivateFieldInitSpec$1(obj, privateMap, value) {
  _checkPrivateRedeclaration$1(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration$1(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet$1(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$1(receiver, privateMap, "set");
  _classApplyDescriptorSet$1(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet$1(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet$1(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$1(receiver, privateMap, "get");
  return _classApplyDescriptorGet$1(receiver, descriptor);
}
function _classExtractFieldDescriptor$1(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet$1(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _sourceSettings = /* @__PURE__ */ new WeakMap();
var _headersTree = /* @__PURE__ */ new WeakMap();
var _stateMatrix = /* @__PURE__ */ new WeakMap();
var StateManager = /* @__PURE__ */ function() {
  function StateManager2() {
    _classCallCheck$f(this, StateManager2);
    _classPrivateFieldInitSpec$1(this, _sourceSettings, {
      writable: true,
      value: new SourceSettings()
    });
    _classPrivateFieldInitSpec$1(this, _headersTree, {
      writable: true,
      value: new HeadersTree(_classPrivateFieldGet$1(this, _sourceSettings))
    });
    _classPrivateFieldInitSpec$1(this, _stateMatrix, {
      writable: true,
      value: [[]]
    });
  }
  _createClass$f(StateManager2, [{
    key: "setState",
    value: (
      /**
       * Sets a new state for the nested headers plugin based on settings passed
       * directly to the plugin.
       *
       * @param {Array[]} nestedHeadersSettings The user-defined settings.
       * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.
       */
      function setState(nestedHeadersSettings) {
        _classPrivateFieldGet$1(this, _sourceSettings).setData(nestedHeadersSettings);
        var hasError = false;
        try {
          _classPrivateFieldGet$1(this, _headersTree).buildTree();
        } catch (ex) {
          _classPrivateFieldGet$1(this, _headersTree).clear();
          _classPrivateFieldGet$1(this, _sourceSettings).clear();
          hasError = true;
        }
        _classPrivateFieldSet$1(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$1(this, _headersTree).getRoots()));
        return hasError;
      }
    )
    /**
     * Sets columns limit to the state will be trimmed. All headers (colspans) which
     * overlap the column limit will be reduced to keep the structure solid.
     *
     * @param {number} columnsCount The number of columns to limit to.
     */
  }, {
    key: "setColumnsLimit",
    value: function setColumnsLimit(columnsCount) {
      _classPrivateFieldGet$1(this, _sourceSettings).setColumnsLimit(columnsCount);
    }
    /**
     * Merges settings with current plugin state.
     *
     * By default only foreign keys are merged with source state and passed to the tree. But only
     * known keys are exported to matrix.
     *
     * @param {object[]} settings An array of objects to merge with the current source settings.
     *                            It is a requirement that every object has `row` and `col` properties
     *                            which points to the specific header settings object.
     */
  }, {
    key: "mergeStateWith",
    value: function mergeStateWith(settings) {
      var _this = this;
      var transformedSettings = arrayMap(settings, function(_ref2) {
        var row = _ref2.row, rest = _objectWithoutProperties(_ref2, _excluded);
        return _objectSpread({
          row: row < 0 ? _this.rowCoordsToLevel(row) : row
        }, rest);
      });
      _classPrivateFieldGet$1(this, _sourceSettings).mergeWith(transformedSettings);
      _classPrivateFieldGet$1(this, _headersTree).buildTree();
      _classPrivateFieldSet$1(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$1(this, _headersTree).getRoots()));
    }
    /**
     * Maps the current state with a callback. For each header settings the callback function
     * is called. If the function returns value that value is merged with the state.
     *
     * By default only foreign keys are merged with source state and passed to the tree. But only
     * known keys are exported to matrix.
     *
     * @param {Function} callback A function that is called for every header source settings.
     *                            Each time the callback is called, the returned value extends
     *                            header settings.
     */
  }, {
    key: "mapState",
    value: function mapState(callback) {
      _classPrivateFieldGet$1(this, _sourceSettings).map(callback);
      _classPrivateFieldGet$1(this, _headersTree).buildTree();
      _classPrivateFieldSet$1(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$1(this, _headersTree).getRoots()));
    }
    /**
     * Maps the current tree nodes with a callback. For each node the callback function
     * is called. If the function returns value that value is added to returned array.
     *
     * @param {Function} callback A function that is called for every tree node.
     *                            Each time the callback is called, the returned value is
     *                            added to returned array.
     * @returns {Array}
     */
  }, {
    key: "mapNodes",
    value: function mapNodes(callback) {
      return arrayReduce$1(_classPrivateFieldGet$1(this, _headersTree).getRoots(), function(acc, rootNode) {
        rootNode.walkDown(function(node) {
          var result = callback(node.data);
          if (result !== void 0) {
            acc.push(result);
          }
        });
        return acc;
      }, []);
    }
    /**
     * Triggers an action (e.g. "collapse") from the NodeModifiers module. The module
     * modifies a tree structure in such a way as to obtain the correct structure consistent with the
     * called action.
     *
     * @param {string} action An action name to trigger.
     * @param {number} headerLevel Header level index (there is support for negative and positive values).
     * @param {number} columnIndex A visual column index.
     * @returns {object|undefined}
     */
  }, {
    key: "triggerNodeModification",
    value: function triggerNodeModification$1(action, headerLevel, columnIndex) {
      if (headerLevel < 0) {
        headerLevel = this.rowCoordsToLevel(headerLevel);
      }
      var nodeToProcess = _classPrivateFieldGet$1(this, _headersTree).getNode(headerLevel, columnIndex);
      var actionResult;
      if (nodeToProcess) {
        actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);
        _classPrivateFieldSet$1(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$1(this, _headersTree).getRoots()));
      }
      return actionResult;
    }
    /**
     * Triggers an action (e.g. "hide-column") from the NodeModifiers module. The action is
     * triggered starting from the lowest header. The module modifies a tree structure in
     * such a way as to obtain the correct structure consistent with the called action.
     *
     * @param {string} action An action name to trigger.
     * @param {number} columnIndex A visual column index.
     * @returns {object|undefined}
     */
  }, {
    key: "triggerColumnModification",
    value: function triggerColumnModification(action, columnIndex) {
      return this.triggerNodeModification(action, -1, columnIndex);
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * @memberof StateManager#
     * @function rowCoordsToLevel
     *
     * Translates row coordinates into header level. The row coordinates counts from -1 to -N
     * and describes headers counting from most closest to most distant from the table.
     * The header levels are counted from 0 to N where 0 describes most distant header
     * from the table.
     *
     *  Row coords             Header level
     *           +--------------+
     *       -3  â A1 â A1      â  0
     *           +--------------+
     *       -2  â B1 â B2 â B3 â  1
     *           +--------------+
     *       -1  â C1 â C2 â C3 â  2
     *           +==============+
     *           â    â    â    â
     *           +--------------+
     *           â    â    â    â
     *
     * @param {number} rowIndex A visual row index.
     * @returns {number} Returns unsigned number.
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "rowCoordsToLevel",
    value: function rowCoordsToLevel(rowIndex) {
      var layersCount = Math.max(this.getLayersCount(), 1);
      var highestPossibleLevel = layersCount - 1;
      var lowestPossibleLevel = 0;
      return Math.min(Math.max(rowIndex + layersCount, lowestPossibleLevel), highestPossibleLevel);
    }
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * @memberof StateManager#
     * @function levelToRowCoords
     *
     * Translates header level into row coordinates. The row coordinates counts from -1 to -N
     * and describes headers counting from most closest to most distant from the table.
     * The header levels are counted from 0 to N where 0 describes most distant header
     * from the table.
     *
     *  Header level            Row coords
     *           +--------------+
     *        0  â A1 â A1      â  -3
     *           +--------------+
     *        1  â B1 â B2 â B3 â  -2
     *           +--------------+
     *        2  â C1 â C2 â C3 â  -1
     *           +==============+
     *           â    â    â    â
     *           +--------------+
     *           â    â    â    â
     *
     * @param {number} headerLevel Header level index.
     * @returns {number} Returns negative number.
     */
    /* eslint-enable jsdoc/require-description-complete-sentence */
  }, {
    key: "levelToRowCoords",
    value: function levelToRowCoords(headerLevel) {
      var layersCount = Math.max(this.getLayersCount(), 1);
      var highestPossibleRow = -1;
      var lowestPossibleRow = -layersCount;
      return Math.min(Math.max(headerLevel - layersCount, lowestPossibleRow), highestPossibleRow);
    }
    /**
     * Gets column header settings for a specified column and header index. The returned object contains
     * all information necessary for header renderers. It contains header label, colspan length, or hidden
     * flag.
     *
     * @param {number} headerLevel Header level (there is support for negative and positive values).
     * @param {number} columnIndex A visual column index.
     * @returns {object|null}
     */
  }, {
    key: "getHeaderSettings",
    value: function getHeaderSettings(headerLevel, columnIndex) {
      var _classPrivateFieldGet2, _classPrivateFieldGet3;
      if (headerLevel < 0) {
        headerLevel = this.rowCoordsToLevel(headerLevel);
      }
      if (headerLevel >= this.getLayersCount()) {
        return null;
      }
      return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet$1(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
    }
    /**
     * Gets tree data that is connected to the column header. The returned object contains all information
     * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header
     * label, colspan length, or visual column index that indicates which column index the node is rendered from.
     *
     * @param {number} headerLevel Header level (there is support for negative and positive values).
     * @param {number} columnIndex A visual column index.
     * @returns {object|null}
     */
  }, {
    key: "getHeaderTreeNodeData",
    value: function getHeaderTreeNodeData(headerLevel, columnIndex) {
      if (headerLevel < 0) {
        headerLevel = this.rowCoordsToLevel(headerLevel);
      }
      var node = _classPrivateFieldGet$1(this, _headersTree).getNode(headerLevel, columnIndex);
      if (!node) {
        return null;
      }
      return _objectSpread({}, node.data);
    }
    /**
     * The method is helpful in cases where the column index targets in-between currently
     * collapsed column. In that case, the method returns the left-most column index
     * where the nested header begins.
     *
     * @param {number} headerLevel Header level (there is support for negative and positive values).
     * @param {number} columnIndex A visual column index.
     * @returns {number}
     */
  }, {
    key: "findLeftMostColumnIndex",
    value: function findLeftMostColumnIndex(headerLevel, columnIndex) {
      var _this$getHeaderSettin;
      var _ref2 = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {
        isRoot: true
      }, isRoot = _ref2.isRoot;
      if (isRoot) {
        return columnIndex;
      }
      var stepBackColumn = columnIndex - 1;
      while (stepBackColumn >= 0) {
        var _this$getHeaderSettin2;
        var _ref3 = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {
          isRoot: true
        }, isRootNode = _ref3.isRoot;
        if (isRootNode) {
          break;
        }
        stepBackColumn -= 1;
      }
      return stepBackColumn;
    }
    /**
     * Gets a total number of headers levels.
     *
     * @returns {number}
     */
  }, {
    key: "getLayersCount",
    value: function getLayersCount() {
      return _classPrivateFieldGet$1(this, _sourceSettings).getLayersCount();
    }
    /**
     * Gets a total number of columns count.
     *
     * @returns {number}
     */
  }, {
    key: "getColumnsCount",
    value: function getColumnsCount() {
      return _classPrivateFieldGet$1(this, _sourceSettings).getColumnsCount();
    }
    /**
     * Clears the column state manager to the initial state.
     */
  }, {
    key: "clear",
    value: function clear2() {
      _classPrivateFieldSet$1(this, _stateMatrix, []);
      _classPrivateFieldGet$1(this, _sourceSettings).clear();
      _classPrivateFieldGet$1(this, _headersTree).clear();
    }
  }]);
  return StateManager2;
}();
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$e(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var GhostTable = /* @__PURE__ */ function() {
  function GhostTable2(hot, nestedHeaderSettingsGetter) {
    _classCallCheck$e(this, GhostTable2);
    _defineProperty$1(this, "hot", void 0);
    _defineProperty$1(this, "nestedHeaderSettingsGetter", void 0);
    _defineProperty$1(this, "layersCount", 0);
    _defineProperty$1(this, "container", void 0);
    _defineProperty$1(this, "widthsMap", void 0);
    this.hot = hot;
    this.nestedHeaderSettingsGetter = nestedHeaderSettingsGetter;
    this.widthsMap = this.hot.columnIndexMapper.createAndRegisterIndexMap("nestedHeaders.widthsMap", "physicalIndexToValue");
  }
  _createClass$e(GhostTable2, [{
    key: "setLayersCount",
    value: function setLayersCount(layersCount) {
      this.layersCount = layersCount;
      return this;
    }
    /**
     * Gets the column width based on the visual column index.
     *
     * @param {number} visualColumn Visual column index.
     * @returns {number|null}
     */
  }, {
    key: "getWidth",
    value: function getWidth(visualColumn) {
      return this.widthsMap.getValueAtIndex(this.hot.toPhysicalColumn(visualColumn));
    }
    /**
     * Build cache of the headers widths.
     */
  }, {
    key: "buildWidthsMap",
    value: function buildWidthsMap() {
      this.container = this.hot.rootDocument.createElement("div");
      this.container.classList.add("handsontable", "htGhostTable", "htAutoSize");
      this._buildGhostTable(this.container);
      this.hot.rootDocument.body.appendChild(this.container);
      var columns = this.container.querySelectorAll("tr:last-of-type th");
      var maxColumns = columns.length;
      this.widthsMap.clear();
      for (var column = 0; column < maxColumns; column++) {
        var visualColumnsIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(column);
        var physicalColumnIndex = this.hot.toPhysicalColumn(visualColumnsIndex);
        this.widthsMap.setValueAtIndex(physicalColumnIndex, columns[column].offsetWidth);
      }
      this.container.parentNode.removeChild(this.container);
      this.container = null;
    }
    /**
     * Build temporary table for getting minimal columns widths.
     *
     * @private
     * @param {HTMLElement} container The element where the DOM nodes are injected.
     */
  }, {
    key: "_buildGhostTable",
    value: function _buildGhostTable(container) {
      var _this$hot = this.hot, rootDocument = _this$hot.rootDocument, columnIndexMapper = _this$hot.columnIndexMapper;
      var fragment = rootDocument.createDocumentFragment();
      var table = rootDocument.createElement("table");
      var isDropdownEnabled = !!this.hot.getSettings().dropdownMenu;
      var maxRenderedCols = columnIndexMapper.getRenderableIndexesLength();
      for (var row = 0; row < this.layersCount; row++) {
        var tr = rootDocument.createElement("tr");
        for (var col = 0; col < maxRenderedCols; col++) {
          var visualColumnsIndex = columnIndexMapper.getVisualFromRenderableIndex(col);
          if (visualColumnsIndex === null) {
            visualColumnsIndex = col;
          }
          var th = rootDocument.createElement("th");
          var headerSettings = this.nestedHeaderSettingsGetter(row, visualColumnsIndex);
          if (headerSettings && (!headerSettings.isPlaceholder || headerSettings.isHidden)) {
            var label = headerSettings.label;
            if (isDropdownEnabled) {
              label += '<button class="changeType"></button>';
            }
            fastInnerHTML(th, label);
            th.colSpan = headerSettings.colspan;
            tr.appendChild(th);
          }
        }
        table.appendChild(tr);
      }
      fragment.appendChild(table);
      container.appendChild(fragment);
    }
    /**
     * Clear the widths cache.
     */
  }, {
    key: "clear",
    value: function clear2() {
      this.widthsMap.clear();
      this.container = null;
    }
  }]);
  return GhostTable2;
}();
const GhostTable$1 = GhostTable;
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$a(obj);
}
var _templateObject$1, _templateObject2;
function _taggedTemplateLiteral$1(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$d(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$5() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$5 = Reflect.get.bind();
  } else {
    _get$5 = function _get2(target, property, receiver) {
      var base = _superPropBase$5(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$5.apply(this, arguments);
}
function _superPropBase$5(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$9(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p2) {
  _setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$9(o, p2);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self2, call2) {
  if (call2 && (_typeof$a(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$9(o);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY$6 = "nestedHeaders";
var PLUGIN_PRIORITY$5 = 280;
var _stateManager = /* @__PURE__ */ new WeakMap();
var _hidingIndexMapObserver = /* @__PURE__ */ new WeakMap();
var NestedHeaders = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$9(NestedHeaders2, _BasePlugin);
  var _super = _createSuper$9(NestedHeaders2);
  function NestedHeaders2() {
    var _this;
    _classCallCheck$d(this, NestedHeaders2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _classPrivateFieldInitSpec(_assertThisInitialized$9(_this), _stateManager, {
      writable: true,
      value: new StateManager()
    });
    _classPrivateFieldInitSpec(_assertThisInitialized$9(_this), _hidingIndexMapObserver, {
      writable: true,
      value: null
    });
    _defineProperty(_assertThisInitialized$9(_this), "ghostTable", new GhostTable$1(_this.hot, function(row, column) {
      return _this.getHeaderSettings(row, column);
    }));
    _defineProperty(_assertThisInitialized$9(_this), "detectedOverlappedHeaders", false);
    return _this;
  }
  _createClass$d(NestedHeaders2, [{
    key: "isEnabled",
    value: (
      /**
       * Check if plugin is enabled.
       *
       * @returns {boolean}
       */
      function isEnabled() {
        return !!this.hot.getSettings()[PLUGIN_KEY$6];
      }
    )
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var _this$hot$getSettings = this.hot.getSettings(), nestedHeaders = _this$hot$getSettings.nestedHeaders;
      if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {
        warn$1(toSingleLine(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral$1(["Your Nested Headers plugin configuration is invalid. The settings has to be \n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]"], ["Your Nested Headers plugin configuration is invalid. The settings has to be\\x20\n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]"]))));
      }
      this.addHook("init", function() {
        return _this2.onInit();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseDown", function() {
        return _this2.onBeforeOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("afterOnCellMouseDown", function() {
        return _this2.onAfterOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseOver", function() {
        return _this2.onBeforeOnCellMouseOver.apply(_this2, arguments);
      });
      this.addHook("afterGetColumnHeaderRenderers", function(array) {
        return _this2.onAfterGetColumnHeaderRenderers(array);
      });
      this.addHook("modifyColWidth", function() {
        return _this2.onModifyColWidth.apply(_this2, arguments);
      });
      this.addHook("beforeHighlightingColumnHeader", function() {
        return _this2.onBeforeHighlightingColumnHeader.apply(_this2, arguments);
      });
      this.addHook("afterViewportColumnCalculatorOverride", function() {
        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);
      });
      _get$5(_getPrototypeOf$9(NestedHeaders2.prototype), "enablePlugin", this).call(this);
      this.updatePlugin();
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`nestedHeaders`](@/api/options.md#nestedheaders)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var _this3 = this;
      if (!this.hot.view) {
        return;
      }
      var _this$hot$getSettings2 = this.hot.getSettings(), nestedHeaders = _this$hot$getSettings2.nestedHeaders;
      _classPrivateFieldGet(this, _stateManager).setColumnsLimit(this.hot.countCols());
      if (Array.isArray(nestedHeaders)) {
        this.detectedOverlappedHeaders = _classPrivateFieldGet(this, _stateManager).setState(nestedHeaders);
      }
      if (this.detectedOverlappedHeaders) {
        warn$1(toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral$1(["Your Nested Headers plugin setup contains overlapping headers. This kind of configuration \n                        is currently not supported."], ["Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\\x20\n                        is currently not supported."]))));
      }
      if (this.enabled) {
        this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach(function(isColumnHidden, physicalColumnIndex) {
          var actionName = isColumnHidden === true ? "hide-column" : "show-column";
          _classPrivateFieldGet(_this3, _stateManager).triggerColumnModification(actionName, physicalColumnIndex);
        });
      }
      if (!_classPrivateFieldGet(this, _hidingIndexMapObserver) && this.enabled) {
        _classPrivateFieldSet(this, _hidingIndexMapObserver, this.hot.columnIndexMapper.createChangesObserver("hiding").subscribe(function(changes) {
          changes.forEach(function(_ref2) {
            var op = _ref2.op, columnIndex = _ref2.index, newValue = _ref2.newValue;
            if (op === "replace") {
              var actionName = newValue === true ? "hide-column" : "show-column";
              _classPrivateFieldGet(_this3, _stateManager).triggerColumnModification(actionName, columnIndex);
            }
          });
          _this3.ghostTable.buildWidthsMap();
        }));
      }
      this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();
      _get$5(_getPrototypeOf$9(NestedHeaders2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearColspans();
      _classPrivateFieldGet(this, _stateManager).clear();
      _classPrivateFieldGet(this, _hidingIndexMapObserver).unsubscribe();
      _classPrivateFieldSet(this, _hidingIndexMapObserver, null);
      this.ghostTable.clear();
      _get$5(_getPrototypeOf$9(NestedHeaders2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Returns an instance of the internal state manager of the plugin.
     *
     * @private
     * @returns {StateManager}
     */
  }, {
    key: "getStateManager",
    value: function getStateManager() {
      return _classPrivateFieldGet(this, _stateManager);
    }
    /**
     * Gets a total number of headers levels.
     *
     * @private
     * @returns {number}
     */
  }, {
    key: "getLayersCount",
    value: function getLayersCount() {
      return _classPrivateFieldGet(this, _stateManager).getLayersCount();
    }
    /**
     * Gets column settings for a specified header. The returned object contains
     * information about the header label, its colspan length, or if it is hidden
     * in the header renderers.
     *
     * @private
     * @param {number} headerLevel Header level (0 = most distant to the table).
     * @param {number} columnIndex A visual column index.
     * @returns {object}
     */
  }, {
    key: "getHeaderSettings",
    value: function getHeaderSettings(headerLevel, columnIndex) {
      return _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, columnIndex);
    }
    /**
     * Clear the colspans remaining after plugin usage.
     *
     * @private
     */
  }, {
    key: "clearColspans",
    value: function clearColspans() {
      if (!this.hot.view) {
        return;
      }
      var wt = this.hot.view._wt;
      var headerLevels = wt.getSetting("columnHeaders").length;
      var mainHeaders = wt.wtTable.THEAD;
      var topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
      var topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;
      for (var i = 0; i < headerLevels; i++) {
        var masterLevel = mainHeaders.childNodes[i];
        if (!masterLevel) {
          break;
        }
        var topLevel = topHeaders.childNodes[i];
        var topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
        for (var j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {
          masterLevel.childNodes[j].removeAttribute("colspan");
          removeClass(masterLevel.childNodes[j], "hiddenHeader");
          if (topLevel && topLevel.childNodes[j]) {
            topLevel.childNodes[j].removeAttribute("colspan");
            removeClass(topLevel.childNodes[j], "hiddenHeader");
          }
          if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
            topLeftCornerLevel.childNodes[j].removeAttribute("colspan");
            removeClass(topLeftCornerLevel.childNodes[j], "hiddenHeader");
          }
        }
      }
    }
    /**
     * Generates the appropriate header renderer for a header row.
     *
     * @private
     * @param {number} headerLevel The index of header level counting from the top (positive
     *                             values counting from 0 to N).
     * @returns {Function}
     * @fires Hooks#afterGetColHeader
     */
  }, {
    key: "headerRendererFactory",
    value: function headerRendererFactory(headerLevel) {
      var _this4 = this;
      var fixedColumnsStart = this.hot.view._wt.getSetting("fixedColumnsStart");
      return function(renderedColumnIndex, TH) {
        var _classPrivateFieldGet2;
        var _this4$hot = _this4.hot, rootDocument = _this4$hot.rootDocument, columnIndexMapper = _this4$hot.columnIndexMapper, view = _this4$hot.view;
        var visualColumnsIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
        if (visualColumnsIndex === null) {
          visualColumnsIndex = renderedColumnIndex;
        }
        TH.removeAttribute("colspan");
        removeClass(TH, "hiddenHeader");
        var _ref2 = (_classPrivateFieldGet2 = _classPrivateFieldGet(_this4, _stateManager).getHeaderSettings(headerLevel, visualColumnsIndex)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : {
          label: ""
        }, colspan = _ref2.colspan, label = _ref2.label, isHidden = _ref2.isHidden, isPlaceholder = _ref2.isPlaceholder;
        if (isPlaceholder || isHidden) {
          addClass(TH, "hiddenHeader");
        } else if (colspan > 1) {
          var _wtOverlays$topInline, _wtOverlays$inlineSta;
          var wtOverlays = view._wt.wtOverlays;
          var isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);
          var isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);
          var correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;
          if (correctedColspan > 1) {
            TH.setAttribute("colspan", correctedColspan);
          }
        }
        var divEl = rootDocument.createElement("div");
        var spanEl = rootDocument.createElement("span");
        addClass(divEl, "relative");
        addClass(spanEl, "colHeader");
        fastInnerHTML(spanEl, label);
        divEl.appendChild(spanEl);
        empty(TH);
        TH.appendChild(divEl);
        _this4.hot.runHooks("afterGetColHeader", visualColumnsIndex, TH);
      };
    }
    /**
     * Allows to control which header DOM element will be used to highlight.
     *
     * @private
     * @param {number} visualColumn A visual column index of the highlighted row header.
     * @param {number} headerLevel A row header level that is currently highlighted.
     * @param {object} highlightMeta An object with meta data that describes the highlight state.
     * @returns {number}
     */
  }, {
    key: "onBeforeHighlightingColumnHeader",
    value: function onBeforeHighlightingColumnHeader(visualColumn, headerLevel, highlightMeta) {
      var headerNodeData = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumn);
      if (!headerNodeData) {
        return visualColumn;
      }
      var classNames = highlightMeta.classNames, columnCursor = highlightMeta.columnCursor, selectionType = highlightMeta.selectionType, selectionWidth = highlightMeta.selectionWidth;
      var _classPrivateFieldGet3 = _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, visualColumn), isRoot = _classPrivateFieldGet3.isRoot, colspan = _classPrivateFieldGet3.colspan;
      if (selectionType === HEADER_TYPE) {
        if (!isRoot) {
          return headerNodeData.columnIndex;
        }
      } else if (selectionType === ACTIVE_HEADER_TYPE) {
        if (colspan > selectionWidth - columnCursor || !isRoot) {
          classNames.length = 0;
        }
      }
      return visualColumn;
    }
    /**
     * Allows to block the column selection that is controlled by the core Selection module.
     *
     * @private
     * @param {MouseEvent} event Mouse event.
     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
     * @param {CellCoords} TD The table cell or header element.
     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
     *                            a boolean value that allows or disallows changing the selection for that particular area.
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD, controller) {
      var headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
      if (headerNodeData) {
        controller.column = true;
      }
    }
    /**
     * Allows to control how the column selection based on the coordinates and the nested headers is made.
     *
     * @private
     * @param {MouseEvent} event Mouse event.
     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
     */
  }, {
    key: "onAfterOnCellMouseDown",
    value: function onAfterOnCellMouseDown(event2, coords) {
      var headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
      if (!headerNodeData) {
        return;
      }
      var selection = this.hot.selection;
      var currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
      var columnsToSelect = [];
      var columnIndex = headerNodeData.columnIndex, origColspan = headerNodeData.origColspan;
      var allowRightClickSelection = !selection.inInSelection(coords);
      if (event2.shiftKey && currentSelection) {
        if (coords.col < currentSelection.from.col) {
          columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);
        } else if (coords.col > currentSelection.from.col) {
          columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);
        } else {
          columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
        }
      } else if (isLeftClick(event2) || isRightClick(event2) && allowRightClickSelection) {
        columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
      }
      selection.selectColumns.apply(selection, columnsToSelect);
    }
    /**
     * Makes the header-selection properly select the nested headers.
     *
     * @private
     * @param {MouseEvent} event Mouse event.
     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
     * @param {HTMLElement} TD The cell element.
     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
     *                            a boolean value that allows or disallows changing the selection for that particular area.
     */
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event2, coords, TD, controller) {
      var _this$hot;
      if (!this.hot.view.isMouseDown()) {
        return;
      }
      var headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
      if (!headerNodeData) {
        return;
      }
      var columnIndex = headerNodeData.columnIndex, origColspan = headerNodeData.origColspan;
      var selectedRange = this.hot.getSelectedRangeLast();
      var topStartCoords = selectedRange.getTopStartCorner();
      var bottomEndCoords = selectedRange.getBottomEndCorner();
      var from3 = selectedRange.from;
      controller.column = true;
      controller.cell = true;
      var columnsToSelect = [];
      if (coords.col < from3.col) {
        columnsToSelect.push(bottomEndCoords.col, columnIndex);
      } else if (coords.col > from3.col) {
        columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1);
      } else {
        columnsToSelect.push(columnIndex, columnIndex + origColspan - 1);
      }
      (_this$hot = this.hot).selectColumns.apply(_this$hot, columnsToSelect);
    }
    /**
     * `afterGetColumnHeader` hook callback - prepares the header structure.
     *
     * @private
     * @param {Array} renderersArray Array of renderers.
     */
  }, {
    key: "onAfterGetColumnHeaderRenderers",
    value: function onAfterGetColumnHeaderRenderers(renderersArray) {
      if (renderersArray) {
        renderersArray.length = 0;
        for (var headerLayer = 0; headerLayer < _classPrivateFieldGet(this, _stateManager).getLayersCount(); headerLayer++) {
          renderersArray.push(this.headerRendererFactory(headerLayer));
        }
      }
    }
    /**
     * Make the renderer render the first nested column in its entirety.
     *
     * @private
     * @param {object} calc Viewport column calculator.
     */
  }, {
    key: "onAfterViewportColumnCalculatorOverride",
    value: function onAfterViewportColumnCalculatorOverride(calc) {
      var headerLayersCount = _classPrivateFieldGet(this, _stateManager).getLayersCount();
      var newStartColumn = calc.startColumn;
      var nonRenderable = !!headerLayersCount;
      for (var headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {
        var startColumn = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(headerLayer, calc.startColumn);
        var renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);
        if (startColumn >= 0) {
          nonRenderable = false;
        }
        if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {
          newStartColumn = renderedStartColumn;
          break;
        }
      }
      calc.startColumn = nonRenderable ? _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;
    }
    /**
     * `modifyColWidth` hook callback - returns width from cache, when is greater than incoming from hook.
     *
     * @private
     * @param {number} width Width from hook.
     * @param {number} column Visual index of an column.
     * @returns {number}
     */
  }, {
    key: "onModifyColWidth",
    value: function onModifyColWidth(width, column) {
      var cachedWidth = this.ghostTable.getWidth(column);
      return width > cachedWidth ? width : cachedWidth;
    }
    /**
     * Updates the plugin state after HoT initialization.
     *
     * @private
     */
  }, {
    key: "onInit",
    value: function onInit() {
      this.updatePlugin();
    }
    /**
     * Updates the plugin state after new dataset load.
     *
     * @private
     * @param {Array[]} sourceData Array of arrays or array of objects containing data.
     * @param {boolean} initialLoad Flag that determines whether the data has been loaded
     *                              during the initialization.
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(sourceData, initialLoad) {
      if (!initialLoad) {
        this.updatePlugin();
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet(this, _stateManager, null);
      if (_classPrivateFieldGet(this, _hidingIndexMapObserver) !== null) {
        _classPrivateFieldGet(this, _hidingIndexMapObserver).unsubscribe();
        _classPrivateFieldSet(this, _hidingIndexMapObserver, null);
      }
      _get$5(_getPrototypeOf$9(NestedHeaders2.prototype), "destroy", this).call(this);
    }
    /**
     * Gets the tree data that belongs to the column headers pointed by the passed coordinates.
     *
     * @private
     * @param {CellCoords} coords The CellCoords instance.
     * @returns {object|undefined}
     */
  }, {
    key: "_getHeaderTreeNodeDataByCoords",
    value: function _getHeaderTreeNodeDataByCoords(coords) {
      if (coords.row >= 0 || coords.col < 0) {
        return;
      }
      return _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(coords.row, coords.col);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$6;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$5;
    }
    /**
     * The state manager for the nested headers.
     *
     * @private
     * @type {StateManager}
     */
  }]);
  return NestedHeaders2;
}(BasePlugin);
function _toConsumableArray$5(arr) {
  return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$5(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$5(o, minLen);
}
function _iterableToArray$5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$5(arr);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$9(obj);
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$c(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DataManager = /* @__PURE__ */ function() {
  function DataManager2(nestedRowsPlugin, hotInstance) {
    _classCallCheck$c(this, DataManager2);
    this.hot = hotInstance;
    this.data = null;
    this.plugin = nestedRowsPlugin;
    this.parentReference = /* @__PURE__ */ new WeakMap();
    this.cache = {
      levels: [],
      levelCount: 0,
      rows: [],
      nodeInfo: /* @__PURE__ */ new WeakMap()
    };
  }
  _createClass$c(DataManager2, [{
    key: "setData",
    value: function setData(data2) {
      this.data = data2;
    }
    /**
     * Get the data cached in the manager.
     *
     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}
     */
  }, {
    key: "getData",
    value: function getData() {
      return this.data;
    }
    /**
     * Load the "raw" source data, without NestedRows' modifications.
     *
     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}
     */
  }, {
    key: "getRawSourceData",
    value: function getRawSourceData() {
      var rawSourceData = null;
      this.plugin.disableCoreAPIModifiers();
      rawSourceData = this.hot.getSourceData();
      this.plugin.enableCoreAPIModifiers();
      return rawSourceData;
    }
    /**
     * Update the Data Manager with new data and refresh cache.
     *
     * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.
     */
  }, {
    key: "updateWithData",
    value: function updateWithData(data2) {
      this.setData(data2);
      this.rewriteCache();
    }
    /**
     * Rewrite the nested structure cache.
     *
     * @private
     */
  }, {
    key: "rewriteCache",
    value: function rewriteCache() {
      var _this = this;
      this.cache = {
        levels: [],
        levelCount: 0,
        rows: [],
        nodeInfo: /* @__PURE__ */ new WeakMap()
      };
      rangeEach(0, this.data.length - 1, function(i) {
        _this.cacheNode(_this.data[i], 0, null);
      });
    }
    /**
     * Cache a data node.
     *
     * @private
     * @param {object} node Node to cache.
     * @param {number} level Level of the node.
     * @param {object} parent Parent of the node.
     */
  }, {
    key: "cacheNode",
    value: function cacheNode(node, level, parent) {
      var _this2 = this;
      if (!this.cache.levels[level]) {
        this.cache.levels[level] = [];
        this.cache.levelCount += 1;
      }
      this.cache.levels[level].push(node);
      this.cache.rows.push(node);
      this.cache.nodeInfo.set(node, {
        parent,
        row: this.cache.rows.length - 1,
        level
      });
      if (this.hasChildren(node)) {
        arrayEach(node.__children, function(elem) {
          _this2.cacheNode(elem, level + 1, node);
        });
      }
    }
    /**
     * Get the date for the provided visual row number.
     *
     * @param {number} row Row index.
     * @returns {object}
     */
  }, {
    key: "getDataObject",
    value: function getDataObject(row) {
      return row === null || row === void 0 ? null : this.cache.rows[row];
    }
    /**
     * Read the row tree in search for a specific row index or row object.
     *
     * @private
     * @param {object} parent The initial parent object.
     * @param {number} readCount Number of read nodes.
     * @param {number} neededIndex The row index we search for.
     * @param {object} neededObject The row object we search for.
     * @returns {number|object}
     */
  }, {
    key: "readTreeNodes",
    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {
      var _this3 = this;
      var rootLevel = false;
      var readNodesCount = readCount;
      if (isNaN(readNodesCount) && readNodesCount.end) {
        return readNodesCount;
      }
      var parentObj = parent;
      if (!parentObj) {
        parentObj = {
          __children: this.data
        };
        rootLevel = true;
        readNodesCount -= 1;
      }
      if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {
        return {
          result: parentObj,
          end: true
        };
      }
      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {
        return {
          result: readNodesCount,
          end: true
        };
      }
      readNodesCount += 1;
      if (parentObj.__children) {
        arrayEach(parentObj.__children, function(val) {
          _this3.parentReference.set(val, rootLevel ? null : parentObj);
          readNodesCount = _this3.readTreeNodes(val, readNodesCount, neededIndex, neededObject);
          if (isNaN(readNodesCount) && readNodesCount.end) {
            return false;
          }
        });
      }
      return readNodesCount;
    }
    /**
     * Mock a parent node.
     *
     * @private
     * @returns {*}
     */
  }, {
    key: "mockParent",
    value: function mockParent() {
      var fakeParent = this.mockNode();
      fakeParent.__children = this.data;
      return fakeParent;
    }
    /**
     * Mock a data node.
     *
     * @private
     * @returns {{}}
     */
  }, {
    key: "mockNode",
    value: function mockNode() {
      var fakeNode = {};
      objectEach(this.data[0], function(val, key) {
        fakeNode[key] = null;
      });
      return fakeNode;
    }
    /**
     * Get the row index for the provided row object.
     *
     * @param {object} rowObj The row object.
     * @returns {number} Row index.
     */
  }, {
    key: "getRowIndex",
    value: function getRowIndex(rowObj) {
      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;
    }
    /**
     * Get the index of the provided row index/row object within its parent.
     *
     * @param {number|object} row Row index / row object.
     * @returns {number}
     */
  }, {
    key: "getRowIndexWithinParent",
    value: function getRowIndexWithinParent(row) {
      var rowObj = null;
      if (isNaN(row)) {
        rowObj = row;
      } else {
        rowObj = this.getDataObject(row);
      }
      var parent = this.getRowParent(row);
      if (parent === null || parent === void 0) {
        return this.data.indexOf(rowObj);
      }
      return parent.__children.indexOf(rowObj);
    }
    /**
     * Count all rows (including all parents and children).
     *
     * @returns {number}
     */
  }, {
    key: "countAllRows",
    value: function countAllRows() {
      var rootNodeMock = {
        __children: this.data
      };
      return this.countChildren(rootNodeMock);
    }
    /**
     * Count children of the provided parent.
     *
     * @param {object|number} parent Parent node.
     * @returns {number} Children count.
     */
  }, {
    key: "countChildren",
    value: function countChildren(parent) {
      var _this4 = this;
      var rowCount = 0;
      var parentNode = parent;
      if (!isNaN(parentNode)) {
        parentNode = this.getDataObject(parentNode);
      }
      if (!parentNode || !parentNode.__children) {
        return 0;
      }
      arrayEach(parentNode.__children, function(elem) {
        rowCount += 1;
        if (elem.__children) {
          rowCount += _this4.countChildren(elem);
        }
      });
      return rowCount;
    }
    /**
     * Get the parent of the row at the provided index.
     *
     * @param {number|object} row Physical row index.
     * @returns {object}
     */
  }, {
    key: "getRowParent",
    value: function getRowParent(row) {
      var rowObject;
      if (isNaN(row)) {
        rowObject = row;
      } else {
        rowObject = this.getDataObject(row);
      }
      return this.getRowObjectParent(rowObject);
    }
    /**
     * Get the parent of the provided row object.
     *
     * @private
     * @param {object} rowObject The row object (tree node).
     * @returns {object|null}
     */
  }, {
    key: "getRowObjectParent",
    value: function getRowObjectParent(rowObject) {
      if (!rowObject || _typeof$9(rowObject) !== "object") {
        return null;
      }
      return this.cache.nodeInfo.get(rowObject).parent;
    }
    /**
     * Get the nesting level for the row with the provided row index.
     *
     * @param {number} row Row index.
     * @returns {number|null} Row level or null, when row doesn't exist.
     */
  }, {
    key: "getRowLevel",
    value: function getRowLevel(row) {
      var rowObject = null;
      if (isNaN(row)) {
        rowObject = row;
      } else {
        rowObject = this.getDataObject(row);
      }
      return rowObject ? this.getRowObjectLevel(rowObject) : null;
    }
    /**
     * Get the nesting level for the row with the provided row index.
     *
     * @private
     * @param {object} rowObject Row object.
     * @returns {number} Row level.
     */
  }, {
    key: "getRowObjectLevel",
    value: function getRowObjectLevel(rowObject) {
      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;
    }
    /**
     * Check if the provided row/row element has children.
     *
     * @param {number|object} row Row number or row element.
     * @returns {boolean}
     */
  }, {
    key: "hasChildren",
    value: function hasChildren(row) {
      var rowObj = row;
      if (!isNaN(rowObj)) {
        rowObj = this.getDataObject(rowObj);
      }
      return !!(rowObj.__children && rowObj.__children.length);
    }
    /**
     * Returns `true` if the row at the provided index has a parent.
     *
     * @param {number} index Row index.
     * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.
     */
  }, {
    key: "isChild",
    value: function isChild(index2) {
      return this.getRowParent(index2) !== null;
    }
    /**
     * Get child at a provided index from the parent element.
     *
     * @param {object} parent The parent row object.
     * @param {number} index Index of the child element to be retrieved.
     * @returns {object|null} The child element or `null` if the child doesn't exist.
     */
  }, {
    key: "getChild",
    value: function getChild(parent, index2) {
      var _parent$__children;
      return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index2]) || null;
    }
    /**
     * Return `true` of the row at the provided index is located at the topmost level.
     *
     * @param {number} index Row index.
     * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.
     */
  }, {
    key: "isRowHighestLevel",
    value: function isRowHighestLevel(index2) {
      return !this.isChild(index2);
    }
    /**
     * Return `true` if the provided row index / row object represents a parent in the nested structure.
     *
     * @param {number|object} row Row index / row object.
     * @returns {boolean} `true` if the row is a parent, `false` otherwise.
     */
  }, {
    key: "isParent",
    value: function isParent(row) {
      var _rowObj$__children;
      var rowObj = row;
      if (!isNaN(rowObj)) {
        rowObj = this.getDataObject(rowObj);
      }
      return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;
    }
    /**
     * Add a child to the provided parent. It's optional to add a row object as the "element".
     *
     * @param {object} parent The parent row object.
     * @param {object} [element] The element to add as a child.
     */
  }, {
    key: "addChild",
    value: function addChild(parent, element) {
      var childElement = element;
      this.hot.runHooks("beforeAddChild", parent, childElement);
      var parentIndex = null;
      if (parent) {
        parentIndex = this.getRowIndex(parent);
      }
      this.hot.runHooks("beforeCreateRow", parentIndex + this.countChildren(parent) + 1, 1);
      var functionalParent = parent;
      if (!parent) {
        functionalParent = this.mockParent();
      }
      if (!functionalParent.__children) {
        functionalParent.__children = [];
      }
      if (!childElement) {
        childElement = this.mockNode();
      }
      functionalParent.__children.push(childElement);
      this.rewriteCache();
      var newRowIndex = this.getRowIndex(childElement);
      this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);
      this.hot.runHooks("afterCreateRow", newRowIndex, 1);
      this.hot.runHooks("afterAddChild", parent, childElement);
    }
    /**
     * Add a child node to the provided parent at a specified index.
     *
     * @param {object} parent Parent node.
     * @param {number} index Index to insert the child element at.
     * @param {object} [element] Element (node) to insert.
     */
  }, {
    key: "addChildAtIndex",
    value: function addChildAtIndex(parent, index2, element) {
      var childElement = element;
      var flattenedIndex;
      if (!childElement) {
        childElement = this.mockNode();
      }
      this.hot.runHooks("beforeAddChild", parent, childElement, index2);
      if (parent) {
        var parentIndex = this.getRowIndex(parent);
        var finalChildIndex = parentIndex + index2 + 1;
        this.hot.runHooks("beforeCreateRow", finalChildIndex, 1);
        parent.__children.splice(index2, null, childElement);
        this.rewriteCache();
        this.plugin.disableCoreAPIModifiers();
        this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), "__children", parent.__children, "NestedRows.addChildAtIndex");
        this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);
        this.plugin.enableCoreAPIModifiers();
        this.hot.runHooks("afterCreateRow", finalChildIndex, 1);
        flattenedIndex = finalChildIndex;
      } else {
        this.plugin.disableCoreAPIModifiers();
        this.hot.alter("insert_row", index2, 1, "NestedRows.addChildAtIndex");
        this.plugin.enableCoreAPIModifiers();
        flattenedIndex = this.getRowIndex(this.data[index2]);
      }
      childElement = this.getDataObject(flattenedIndex);
      this.hot.runHooks("afterAddChild", parent, childElement, index2);
    }
    /**
     * Add a sibling element at the specified index.
     *
     * @param {number} index New element sibling's index.
     * @param {('above'|'below')} where Direction in which the sibling is to be created.
     */
  }, {
    key: "addSibling",
    value: function addSibling(index2) {
      var where = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "below";
      var translatedIndex = this.translateTrimmedRow(index2);
      var parent = this.getRowParent(translatedIndex);
      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);
      switch (where) {
        case "below":
          this.addChildAtIndex(parent, indexWithinParent + 1, null);
          break;
        case "above":
          this.addChildAtIndex(parent, indexWithinParent, null);
          break;
      }
    }
    /**
     * Detach the provided element from its parent and add it right after it.
     *
     * @param {object|Array} elements Row object or an array of selected coordinates.
     * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.
     */
  }, {
    key: "detachFromParent",
    value: function detachFromParent(elements) {
      var _this5 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var element = null;
      var rowObjects = [];
      if (Array.isArray(elements)) {
        rangeEach(elements[0], elements[2], function(i) {
          var translatedIndex = _this5.translateTrimmedRow(i);
          rowObjects.push(_this5.getDataObject(translatedIndex));
        });
        rangeEach(0, rowObjects.length - 2, function(i) {
          _this5.detachFromParent(rowObjects[i], false);
        });
        element = rowObjects[rowObjects.length - 1];
      } else {
        element = elements;
      }
      var childRowIndex = this.getRowIndex(element);
      var childCount = this.countChildren(element);
      var indexWithinParent = this.getRowIndexWithinParent(element);
      var parent = this.getRowParent(element);
      var grandparent = this.getRowParent(parent);
      var grandparentRowIndex = this.getRowIndex(grandparent);
      var movedElementRowIndex = null;
      this.hot.runHooks("beforeDetachChild", parent, element);
      if (indexWithinParent !== null && indexWithinParent !== void 0) {
        var removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));
        this.hot.runHooks("beforeRemoveRow", childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);
        parent.__children.splice(indexWithinParent, 1);
        this.rewriteCache();
        this.hot.runHooks("afterRemoveRow", childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);
        if (grandparent) {
          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);
          var lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);
          var lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);
          this.hot.runHooks("beforeCreateRow", lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);
          grandparent.__children.push(element);
        } else {
          movedElementRowIndex = this.hot.countRows() + 1;
          this.hot.runHooks("beforeCreateRow", movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);
          this.data.push(element);
        }
      }
      this.rewriteCache();
      this.hot.runHooks("afterCreateRow", movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);
      this.hot.runHooks("afterDetachChild", parent, element, this.getRowIndex(element));
      if (forceRender) {
        this.hot.render();
      }
    }
    /**
     * Filter the data by the `logicRows` array.
     *
     * @private
     * @param {number} index Index of the first row to remove.
     * @param {number} amount Number of elements to remove.
     * @param {Array} logicRows Array of indexes to remove.
     */
  }, {
    key: "filterData",
    value: function filterData(index2, amount, logicRows) {
      var _this6 = this;
      var elementsToRemove = [];
      arrayEach(logicRows, function(elem) {
        elementsToRemove.push(_this6.getDataObject(elem));
      });
      arrayEach(elementsToRemove, function(elem) {
        var indexWithinParent = _this6.getRowIndexWithinParent(elem);
        var tempParent = _this6.getRowParent(elem);
        if (tempParent === null) {
          _this6.data.splice(indexWithinParent, 1);
        } else {
          tempParent.__children.splice(indexWithinParent, 1);
        }
      });
      this.rewriteCache();
    }
    /**
     * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the
     * default script.
     *
     * @private
     * @param {number} index Physical index of the element at the splice beginning.
     * @param {number} amount Number of elements to be removed.
     * @param {object[]} elements Array of row objects to add.
     */
  }, {
    key: "spliceData",
    value: function spliceData(index2, amount, elements) {
      var previousElement = this.getDataObject(index2 - 1);
      var newRowParent = null;
      var indexWithinParent = index2;
      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {
        newRowParent = previousElement;
        indexWithinParent = 0;
      } else if (index2 < this.countAllRows()) {
        newRowParent = this.getRowParent(index2);
        indexWithinParent = this.getRowIndexWithinParent(index2);
      }
      if (newRowParent) {
        if (elements) {
          var _newRowParent$__child;
          (_newRowParent$__child = newRowParent.__children).splice.apply(_newRowParent$__child, [indexWithinParent, amount].concat(_toConsumableArray$5(elements)));
        } else {
          newRowParent.__children.splice(indexWithinParent, amount);
        }
      } else if (elements) {
        var _this$data;
        (_this$data = this.data).splice.apply(_this$data, [indexWithinParent, amount].concat(_toConsumableArray$5(elements)));
      } else {
        this.data.splice(indexWithinParent, amount);
      }
      this.rewriteCache();
    }
    /**
     * Update the `__children` key of the upmost parent of the provided row object.
     *
     * @private
     * @param {object} rowElement Row object.
     */
  }, {
    key: "syncRowWithRawSource",
    value: function syncRowWithRawSource(rowElement) {
      var upmostParent = rowElement;
      var tempParent = null;
      do {
        tempParent = this.getRowParent(tempParent);
        if (tempParent !== null) {
          upmostParent = tempParent;
        }
      } while (tempParent !== null);
      this.plugin.disableCoreAPIModifiers();
      this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), "__children", upmostParent.__children, "NestedRows.syncRowWithRawSource");
      this.plugin.enableCoreAPIModifiers();
    }
    /* eslint-disable jsdoc/require-param */
    /**
     * Move a single row.
     *
     * @param {number} fromIndex Index of the row to be moved.
     * @param {number} toIndex Index of the destination.
     * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.
     * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.
     */
    /* eslint-enable jsdoc/require-param */
  }, {
    key: "moveRow",
    value: function moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {
      var moveToLastRow = toIndex === this.hot.countRows();
      var fromParent = this.getRowParent(fromIndex);
      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);
      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);
      var movingUp = fromIndex > toIndex;
      var toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);
      if (toParent === null || toParent === void 0) {
        toParent = this.getRowParent(toIndex - 1);
      }
      if (toParent === null || toParent === void 0) {
        toParent = this.getDataObject(toIndex - 1);
      }
      if (!toParent) {
        toParent = this.getDataObject(toIndex);
        toParent.__children = [];
      } else if (!toParent.__children) {
        toParent.__children = [];
      }
      var indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);
      var sameParent = fromParent === toParent;
      toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);
      fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);
      this.syncRowWithRawSource(fromParent);
      if (!sameParent) {
        this.syncRowWithRawSource(toParent);
      }
    }
    /**
     * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.
     *
     * @private
     * @param {number} row Row index.
     * @returns {number}
     */
  }, {
    key: "translateTrimmedRow",
    value: function translateTrimmedRow(row) {
      if (this.plugin.collapsingUI) {
        return this.plugin.collapsingUI.translateTrimmedRow(row);
      }
      return row;
    }
    /**
     * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.
     *
     * @private
     * @param {number} row Row index.
     * @returns {number}
     */
  }, {
    key: "untranslateTrimmedRow",
    value: function untranslateTrimmedRow(row) {
      if (this.plugin.collapsingUI) {
        return this.plugin.collapsingUI.untranslateTrimmedRow(row);
      }
      return row;
    }
  }]);
  return DataManager2;
}();
const DataManager$1 = DataManager;
function _defineProperties$b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$b(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var BaseUI = /* @__PURE__ */ _createClass$b(function BaseUI2(pluginInstance, hotInstance) {
  _classCallCheck$b(this, BaseUI2);
  this.hot = hotInstance;
  this.plugin = pluginInstance;
});
const BaseUI$1 = BaseUI;
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$8(obj);
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$a(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p2) {
  _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$8(o, p2);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self2, call2) {
  if (call2 && (_typeof$8(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$8(o);
}
var HeadersUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$8(HeadersUI2, _BaseUI);
  var _super = _createSuper$8(HeadersUI2);
  function HeadersUI2(nestedRowsPlugin, hotInstance) {
    var _this;
    _classCallCheck$a(this, HeadersUI2);
    _this = _super.call(this, nestedRowsPlugin, hotInstance);
    _this.dataManager = _this.plugin.dataManager;
    _this.collapsingUI = _this.plugin.collapsingUI;
    _this.rowHeaderWidthCache = null;
    return _this;
  }
  _createClass$a(HeadersUI2, [{
    key: "appendLevelIndicators",
    value: function appendLevelIndicators(row, TH) {
      var rowIndex = this.hot.toPhysicalRow(row);
      var rowLevel = this.dataManager.getRowLevel(rowIndex);
      var rowObject = this.dataManager.getDataObject(rowIndex);
      var innerDiv = TH.getElementsByTagName("DIV")[0];
      var innerSpan = innerDiv.querySelector("span.rowHeader");
      var previousIndicators = innerDiv.querySelectorAll('[class^="ht_nesting"]');
      arrayEach(previousIndicators, function(elem) {
        if (elem) {
          innerDiv.removeChild(elem);
        }
      });
      addClass(TH, HeadersUI2.CSS_CLASSES.indicatorContainer);
      if (rowLevel) {
        var rootDocument = this.hot.rootDocument;
        var initialContent = innerSpan.cloneNode(true);
        innerDiv.innerHTML = "";
        rangeEach(0, rowLevel - 1, function() {
          var levelIndicator = rootDocument.createElement("SPAN");
          addClass(levelIndicator, HeadersUI2.CSS_CLASSES.emptyIndicator);
          innerDiv.appendChild(levelIndicator);
        });
        innerDiv.appendChild(initialContent);
      }
      if (this.dataManager.hasChildren(rowObject)) {
        var buttonsContainer = this.hot.rootDocument.createElement("DIV");
        addClass(TH, HeadersUI2.CSS_CLASSES.parent);
        if (this.collapsingUI.areChildrenCollapsed(rowIndex)) {
          addClass(buttonsContainer, "".concat(HeadersUI2.CSS_CLASSES.button, " ").concat(HeadersUI2.CSS_CLASSES.expandButton));
        } else {
          addClass(buttonsContainer, "".concat(HeadersUI2.CSS_CLASSES.button, " ").concat(HeadersUI2.CSS_CLASSES.collapseButton));
        }
        innerDiv.appendChild(buttonsContainer);
      }
    }
    /**
     * Update the row header width according to number of levels in the dataset.
     *
     * @private
     * @param {number} deepestLevel Cached deepest level of nesting.
     */
  }, {
    key: "updateRowHeaderWidth",
    value: function updateRowHeaderWidth(deepestLevel) {
      var deepestLevelIndex = deepestLevel;
      if (!deepestLevelIndex) {
        deepestLevelIndex = this.dataManager.cache.levelCount;
      }
      this.rowHeaderWidthCache = Math.max(50, 11 + 10 * deepestLevelIndex + 25);
      this.hot.render();
    }
  }], [{
    key: "CSS_CLASSES",
    get: (
      /**
       * CSS classes used in the row headers.
       *
       * @type {object}
       */
      function get2() {
        return {
          indicatorContainer: "ht_nestingLevels",
          parent: "ht_nestingParent",
          indicator: "ht_nestingLevel",
          emptyIndicator: "ht_nestingLevel_empty",
          button: "ht_nestingButton",
          expandButton: "ht_nestingExpand",
          collapseButton: "ht_nestingCollapse"
        };
      }
    )
  }]);
  return HeadersUI2;
}(BaseUI$1);
const HeadersUI$1 = HeadersUI;
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$7(obj);
}
function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$4(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$4(o, minLen);
}
function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$4(arr);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$9(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p2) {
  _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$7(o, p2);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self2, call2) {
  if (call2 && (_typeof$7(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$7(o);
}
var CollapsingUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$7(CollapsingUI2, _BaseUI);
  var _super = _createSuper$7(CollapsingUI2);
  function CollapsingUI2(nestedRowsPlugin, hotInstance) {
    var _this;
    _classCallCheck$9(this, CollapsingUI2);
    _this = _super.call(this, nestedRowsPlugin, hotInstance);
    _this.dataManager = _this.plugin.dataManager;
    _this.collapsedRows = [];
    _this.collapsedRowsStash = {
      stash: function stash() {
        var forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        _this.lastCollapsedRows = _this.collapsedRows.slice(0);
        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);
      },
      shiftStash: function shiftStash(baseIndex, targetIndex) {
        var delta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        if (targetIndex === null || targetIndex === void 0) {
          targetIndex = Infinity;
        }
        arrayEach(_this.lastCollapsedRows, function(elem, i) {
          if (elem >= baseIndex && elem < targetIndex) {
            _this.lastCollapsedRows[i] = elem + delta;
          }
        });
      },
      applyStash: function applyStash() {
        var forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);
        _this.lastCollapsedRows = void 0;
      },
      trimStash: function trimStash(realElementIndex, amount) {
        rangeEach(realElementIndex, realElementIndex + amount - 1, function(i) {
          var indexOfElement = _this.lastCollapsedRows.indexOf(i);
          if (indexOfElement > -1) {
            _this.lastCollapsedRows.splice(indexOfElement, 1);
          }
        });
      }
    };
    return _this;
  }
  _createClass$9(CollapsingUI2, [{
    key: "collapseChildren",
    value: function collapseChildren(row) {
      var _this2 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToCollapse = [];
      var rowObject = null;
      var rowIndex = null;
      var rowsToTrim = null;
      if (isNaN(row)) {
        rowObject = row;
        rowIndex = this.dataManager.getRowIndex(rowObject);
      } else {
        rowObject = this.dataManager.getDataObject(row);
        rowIndex = row;
      }
      if (this.dataManager.hasChildren(rowObject)) {
        arrayEach(rowObject.__children, function(elem) {
          rowsToCollapse.push(_this2.dataManager.getRowIndex(elem));
        });
      }
      rowsToTrim = this.collapseRows(rowsToCollapse, true, false);
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
      if (this.collapsedRows.indexOf(rowIndex) === -1) {
        this.collapsedRows.push(rowIndex);
      }
      return rowsToTrim;
    }
    /**
     * Collapse multiple children.
     *
     * @param {Array} rows Rows to collapse (including their children).
     * @param {boolean} [forceRender=true] `true` if the table should be rendered after finishing the function.
     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
     */
  }, {
    key: "collapseMultipleChildren",
    value: function collapseMultipleChildren(rows) {
      var _this3 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToTrim = [];
      arrayEach(rows, function(elem) {
        rowsToTrim.push.apply(rowsToTrim, _toConsumableArray$4(_this3.collapseChildren(elem, false, false)));
      });
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
    }
    /**
     * Collapse a single row.
     *
     * @param {number} rowIndex Index of the row to collapse.
     * @param {boolean} [recursive=true] `true` if it should collapse the row's children.
     */
  }, {
    key: "collapseRow",
    value: function collapseRow(rowIndex) {
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      this.collapseRows([rowIndex], recursive);
    }
    /**
     * Collapse multiple rows.
     *
     * @param {Array} rowIndexes Array of row indexes to collapse.
     * @param {boolean} [recursive=true] `true` if it should collapse the rows' children.
     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
     * @returns {Array} Rows prepared for trimming (or trimmed, if doTrimming == true).
     */
  }, {
    key: "collapseRows",
    value: function collapseRows(rowIndexes) {
      var _this4 = this;
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var rowsToTrim = [];
      arrayEach(rowIndexes, function(elem) {
        rowsToTrim.push(elem);
        if (recursive) {
          _this4.collapseChildRows(elem, rowsToTrim);
        }
      });
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
      return rowsToTrim;
    }
    /**
     * Collapse child rows of the row at the provided index.
     *
     * @param {number} parentIndex Index of the parent node.
     * @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty array.
     * @param {boolean} [recursive] `true` if the collapsing process should be recursive.
     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
     */
  }, {
    key: "collapseChildRows",
    value: function collapseChildRows(parentIndex) {
      var _this5 = this;
      var rowsToTrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (this.dataManager.hasChildren(parentIndex)) {
        var parentObject = this.dataManager.getDataObject(parentIndex);
        arrayEach(parentObject.__children, function(elem) {
          var elemIndex = _this5.dataManager.getRowIndex(elem);
          rowsToTrim.push(elemIndex);
          _this5.collapseChildRows(elemIndex, rowsToTrim);
        });
      }
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
    }
    /**
     * Expand a single row.
     *
     * @param {number} rowIndex Index of the row to expand.
     * @param {boolean} [recursive=true] `true` if it should expand the row's children recursively.
     */
  }, {
    key: "expandRow",
    value: function expandRow(rowIndex) {
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      this.expandRows([rowIndex], recursive);
    }
    /**
     * Expand multiple rows.
     *
     * @param {Array} rowIndexes Array of indexes of the rows to expand.
     * @param {boolean} [recursive=true] `true` if it should expand the rows' children recursively.
     * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
     * @returns {Array} Array of row indexes to be untrimmed.
     */
  }, {
    key: "expandRows",
    value: function expandRows(rowIndexes) {
      var _this6 = this;
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var rowsToUntrim = [];
      arrayEach(rowIndexes, function(elem) {
        rowsToUntrim.push(elem);
        if (recursive) {
          _this6.expandChildRows(elem, rowsToUntrim);
        }
      });
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
      return rowsToUntrim;
    }
    /**
     * Expand child rows of the provided index.
     *
     * @param {number} parentIndex Index of the parent row.
     * @param {Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.
     * @param {boolean} [recursive] `true` if it should expand the rows' children recursively.
     * @param {boolean} [doTrimming=false] I determine whether collapsing should envolve trimming rows.
     */
  }, {
    key: "expandChildRows",
    value: function expandChildRows(parentIndex) {
      var _this7 = this;
      var rowsToUntrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (this.dataManager.hasChildren(parentIndex)) {
        var parentObject = this.dataManager.getDataObject(parentIndex);
        arrayEach(parentObject.__children, function(elem) {
          if (!_this7.isAnyParentCollapsed(elem)) {
            var elemIndex = _this7.dataManager.getRowIndex(elem);
            rowsToUntrim.push(elemIndex);
            _this7.expandChildRows(elemIndex, rowsToUntrim);
          }
        });
      }
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
    }
    /**
     * Expand the children of the row passed as an argument.
     *
     * @param {number|object} row Parent row.
     * @param {boolean} [forceRender=true] Whether to render the table after the function ends.
     * @param {boolean} [doTrimming=true] If set to `true`, the trimming will be applied when the function finishes.
     * @returns {number[]}
     */
  }, {
    key: "expandChildren",
    value: function expandChildren(row) {
      var _this8 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToExpand = [];
      var rowObject = null;
      var rowIndex = null;
      var rowsToUntrim = null;
      if (isNaN(row)) {
        rowObject = row;
        rowIndex = this.dataManager.getRowIndex(row);
      } else {
        rowObject = this.dataManager.getDataObject(row);
        rowIndex = row;
      }
      this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);
      if (this.dataManager.hasChildren(rowObject)) {
        arrayEach(rowObject.__children, function(elem) {
          var childIndex = _this8.dataManager.getRowIndex(elem);
          rowsToExpand.push(childIndex);
        });
      }
      rowsToUntrim = this.expandRows(rowsToExpand, true, false);
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
      return rowsToUntrim;
    }
    /**
     * Expand multiple rows' children.
     *
     * @param {Array} rows Array of rows which children are about to be expanded.
     * @param {boolean} [forceRender=true] `true` if the table should render after finishing the function.
     * @param {boolean} [doTrimming=true] `true` if the rows should be untrimmed after finishing the function.
     */
  }, {
    key: "expandMultipleChildren",
    value: function expandMultipleChildren(rows) {
      var _this9 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToUntrim = [];
      arrayEach(rows, function(elem) {
        rowsToUntrim.push.apply(rowsToUntrim, _toConsumableArray$4(_this9.expandChildren(elem, false, false)));
      });
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
    }
    /**
     * Collapse all collapsable rows.
     */
  }, {
    key: "collapseAll",
    value: function collapseAll() {
      var _this10 = this;
      var data2 = this.dataManager.getData();
      var parentsToCollapse = [];
      arrayEach(data2, function(elem) {
        if (_this10.dataManager.hasChildren(elem)) {
          parentsToCollapse.push(elem);
        }
      });
      this.collapseMultipleChildren(parentsToCollapse);
      this.renderAndAdjust();
    }
    /**
     * Expand all collapsable rows.
     */
  }, {
    key: "expandAll",
    value: function expandAll() {
      var _this11 = this;
      var data2 = this.dataManager.getData();
      var parentsToExpand = [];
      arrayEach(data2, function(elem) {
        if (_this11.dataManager.hasChildren(elem)) {
          parentsToExpand.push(elem);
        }
      });
      this.expandMultipleChildren(parentsToExpand);
      this.renderAndAdjust();
    }
    /**
     * Trim rows.
     *
     * @param {Array} rows Physical row indexes.
     */
  }, {
    key: "trimRows",
    value: function trimRows(rows) {
      var _this12 = this;
      this.hot.batchExecution(function() {
        arrayEach(rows, function(physicalRow) {
          _this12.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);
        });
      }, true);
    }
    /**
     * Untrim rows.
     *
     * @param {Array} rows Physical row indexes.
     */
  }, {
    key: "untrimRows",
    value: function untrimRows(rows) {
      var _this13 = this;
      this.hot.batchExecution(function() {
        arrayEach(rows, function(physicalRow) {
          _this13.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);
        });
      }, true);
    }
    /**
     * Check if all child rows are collapsed.
     *
     * @private
     * @param {number|object|null} row The parent row. `null` for the top level.
     * @returns {boolean}
     */
  }, {
    key: "areChildrenCollapsed",
    value: function areChildrenCollapsed(row) {
      var _this14 = this;
      var rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);
      var allCollapsed = true;
      if (rowObj === null) {
        rowObj = {
          __children: this.dataManager.data
        };
      }
      if (this.dataManager.hasChildren(rowObj)) {
        arrayEach(rowObj.__children, function(elem) {
          var rowIndex = _this14.dataManager.getRowIndex(elem);
          if (!_this14.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {
            allCollapsed = false;
            return false;
          }
        });
      }
      return allCollapsed;
    }
    /**
     * Check if any of the row object parents are collapsed.
     *
     * @private
     * @param {object} rowObj Row object.
     * @returns {boolean}
     */
  }, {
    key: "isAnyParentCollapsed",
    value: function isAnyParentCollapsed(rowObj) {
      var parent = rowObj;
      while (parent !== null) {
        parent = this.dataManager.getRowParent(parent);
        var parentIndex = this.dataManager.getRowIndex(parent);
        if (this.collapsedRows.indexOf(parentIndex) > -1) {
          return true;
        }
      }
      return false;
    }
    /**
     * Toggle collapsed state. Callback for the `beforeOnCellMousedown` hook.
     *
     * @private
     * @param {MouseEvent} event `mousedown` event.
     * @param {object} coords Coordinates of the clicked cell/header.
     */
  }, {
    key: "toggleState",
    value: function toggleState(event2, coords) {
      if (coords.col >= 0) {
        return;
      }
      var row = this.translateTrimmedRow(coords.row);
      if (hasClass(event2.target, HeadersUI$1.CSS_CLASSES.button)) {
        if (this.areChildrenCollapsed(row)) {
          this.expandChildren(row);
        } else {
          this.collapseChildren(row);
        }
        stopImmediatePropagation(event2);
      }
    }
    /**
     * Translate visual row after trimming to physical base row index.
     *
     * @private
     * @param {number} row Row index.
     * @returns {number} Base row index.
     */
  }, {
    key: "translateTrimmedRow",
    value: function translateTrimmedRow(row) {
      return this.hot.toPhysicalRow(row);
    }
    /**
     * Translate physical row after trimming to visual base row index.
     *
     * @private
     * @param {number} row Row index.
     * @returns {number} Base row index.
     */
  }, {
    key: "untranslateTrimmedRow",
    value: function untranslateTrimmedRow(row) {
      return this.hot.toVisualRow(row);
    }
    /**
     * Helper function to render the table and call the `adjustElementsSize` method.
     *
     * @private
     */
  }, {
    key: "renderAndAdjust",
    value: function renderAndAdjust() {
      this.hot.render();
      this.hot.view.adjustElementsSize();
    }
  }]);
  return CollapsingUI2;
}(BaseUI$1);
const CollapsingUI$1 = CollapsingUI;
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$6(obj);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$8(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$6(o, p2);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call2) {
  if (call2 && (_typeof$6(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$6(o);
}
var privatePool$1 = /* @__PURE__ */ new WeakMap();
var ContextMenuUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$6(ContextMenuUI2, _BaseUI);
  var _super = _createSuper$6(ContextMenuUI2);
  function ContextMenuUI2(nestedRowsPlugin, hotInstance) {
    var _this;
    _classCallCheck$8(this, ContextMenuUI2);
    _this = _super.call(this, nestedRowsPlugin, hotInstance);
    privatePool$1.set(_assertThisInitialized$6(_this), {
      row_above: function row_above(key, selection) {
        var lastSelection = selection[selection.length - 1];
        _this.dataManager.addSibling(lastSelection.start.row, "above");
      },
      row_below: function row_below(key, selection) {
        var lastSelection = selection[selection.length - 1];
        _this.dataManager.addSibling(lastSelection.start.row, "below");
      }
    });
    _this.dataManager = _this.plugin.dataManager;
    return _this;
  }
  _createClass$8(ContextMenuUI2, [{
    key: "appendOptions",
    value: function appendOptions(defaultOptions) {
      var _this2 = this;
      var newEntries = [{
        key: "add_child",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD);
        },
        callback: function callback() {
          var translatedRowIndex = _this2.dataManager.translateTrimmedRow(_this2.hot.getSelectedLast()[0]);
          var parent = _this2.dataManager.getDataObject(translatedRowIndex);
          _this2.dataManager.addChild(parent);
        },
        disabled: function disabled() {
          var selected = _this2.hot.getSelectedLast();
          return !selected || selected[0] < 0 || _this2.hot.selection.isSelectedByColumnHeader() || _this2.hot.countRows() >= _this2.hot.getSettings().maxRows;
        }
      }, {
        key: "detach_from_parent",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD);
        },
        callback: function callback() {
          _this2.dataManager.detachFromParent(_this2.hot.getSelectedLast());
        },
        disabled: function disabled() {
          var selected = _this2.hot.getSelectedLast();
          var translatedRowIndex = _this2.dataManager.translateTrimmedRow(selected[0]);
          var parent = _this2.dataManager.getRowParent(translatedRowIndex);
          return !parent || !selected || selected[0] < 0 || _this2.hot.selection.isSelectedByColumnHeader() || _this2.hot.countRows() >= _this2.hot.getSettings().maxRows;
        }
      }, {
        name: "---------"
      }];
      rangeEach(0, defaultOptions.items.length - 1, function(i) {
        if (i === 0) {
          arrayEach(newEntries, function(val, j) {
            defaultOptions.items.splice(i + j, 0, val);
          });
          return false;
        }
      });
      return this.modifyRowInsertingOptions(defaultOptions);
    }
    /**
     * Modify how the row inserting options work.
     *
     * @private
     * @param {object} defaultOptions Default context menu items.
     * @returns {*}
     */
  }, {
    key: "modifyRowInsertingOptions",
    value: function modifyRowInsertingOptions(defaultOptions) {
      var priv = privatePool$1.get(this);
      rangeEach(0, defaultOptions.items.length - 1, function(i) {
        var option = priv[defaultOptions.items[i].key];
        if (option !== null && option !== void 0) {
          defaultOptions.items[i].callback = option;
        }
      });
      return defaultOptions;
    }
  }]);
  return ContextMenuUI2;
}(BaseUI$1);
const ContextMenuUI$1 = ContextMenuUI;
var _templateObject;
function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o, minLen);
}
function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$3(arr);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$7(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var RowMoveController = /* @__PURE__ */ function() {
  function RowMoveController2(plugin) {
    _classCallCheck$7(this, RowMoveController2);
    this.plugin = plugin;
    this.hot = plugin.hot;
    this.dataManager = plugin.dataManager;
    this.collapsingUI = plugin.collapsingUI;
  }
  _createClass$7(RowMoveController2, [{
    key: "onBeforeRowMove",
    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {
      var _this = this;
      var improperUsage = this.displayAPICompatibilityWarning({
        rows,
        finalIndex,
        dropIndex,
        movePossible
      });
      if (improperUsage) {
        return false;
      }
      this.movedToCollapsed = false;
      var dropToLastRow = dropIndex === this.hot.countRows();
      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);
      var allowMove = true;
      var physicalStartIndexes = rows.map(function(rowIndex) {
        if (!allowMove) {
          return false;
        }
        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);
        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);
        return physicalRowIndex;
      });
      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;
      if (!allowMove || !willDataChange) {
        return false;
      }
      var baseParent = this.getBaseParent(physicalStartIndexes);
      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);
      var sameParent = baseParent === targetParent;
      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);
      this.collapsingUI.collapsedRowsStash.stash();
      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);
      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);
      this.dataManager.rewriteCache();
      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);
      this.collapsingUI.collapsedRowsStash.applyStash(false);
      this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));
      this.hot.render();
      this.selectCells(rows, dropIndex);
      return false;
    }
    /**
     * Display a `dragRows`/`moveRows` method compatibility warning if needed.
     *
     * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.
     * @returns {boolean} `true` if is a result of an improper usage of the moving API.
     */
  }, {
    key: "displayAPICompatibilityWarning",
    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {
      var rows = beforeMoveRowHookArgs.rows, finalIndex = beforeMoveRowHookArgs.finalIndex, dropIndex = beforeMoveRowHookArgs.dropIndex, movePossible = beforeMoveRowHookArgs.movePossible;
      var shouldTerminate = false;
      if (isUndefined(dropIndex)) {
        warn$1(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral(["Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead."], ["Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\x20\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead."]))));
        this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, false);
        shouldTerminate = true;
      }
      return shouldTerminate;
    }
    /**
     * Check if the moving action should be allowed.
     *
     * @param {number} physicalRowIndex Physical start row index.
     * @param {number} physicalDropIndex Physical drop index.
     * @returns {boolean} `true` if it should continue with the moving action.
     */
  }, {
    key: "shouldAllowMoving",
    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {
      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);
    }
    /**
     * Get the base row parent.
     *
     * @param {number} physicalStartIndexes Physical start row index.
     * @returns {object|null} The base row parent.
     */
  }, {
    key: "getBaseParent",
    value: function getBaseParent(physicalStartIndexes) {
      return this.dataManager.getRowParent(physicalStartIndexes[0]);
    }
    /**
     * Get the target row parent.
     *
     * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.
     * @param {number} physicalDropIndex Physical drop row index.
     * @returns {object|null} The target row parent.
     */
  }, {
    key: "getTargetParent",
    value: function getTargetParent(dropToLastRow, physicalDropIndex) {
      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);
      if (targetParent === null || targetParent === void 0) {
        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);
      }
      return targetParent;
    }
    /**
     * Shift the cached collapsible rows position according to the move action.
     *
     * @param {number[]} physicalStartIndexes Physical start row indexes.
     * @param {number} physicalDropIndex Physical drop index.
     * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.
     */
  }, {
    key: "shiftCollapsibleParentsLocations",
    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {
      if (!sameParent) {
        if (Math.max.apply(Math, _toConsumableArray$3(physicalStartIndexes)) <= physicalDropIndex) {
          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);
        } else {
          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);
        }
      }
    }
    /**
     * Move the rows at the provided coordinates.
     *
     * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.
     * @param {number} physicalDropIndex Physical drop index.
     * @param {object} targetParent Parent of the destination row.
     */
  }, {
    key: "moveRows",
    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {
      var _this2 = this;
      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;
      this.hot.batchRender(function() {
        physicalStartIndexes.forEach(function(physicalStartIndex) {
          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);
        });
      });
    }
    /**
     * Move the cell meta for multiple rows.
     *
     * @param {number[]} baseIndexes Array of indexes for the rows being moved.
     * @param {number} targetIndex Index of the destination of the move.
     */
  }, {
    key: "moveCellsMeta",
    value: function moveCellsMeta(baseIndexes, targetIndex) {
      var _this3 = this, _this$hot;
      var rowsOfMeta = [];
      var movingDown = Math.max.apply(Math, _toConsumableArray$3(baseIndexes)) < targetIndex;
      baseIndexes.forEach(function(baseIndex) {
        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));
      });
      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);
      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));
    }
    /**
     * Select cells after the move.
     *
     * @param {Array} rows Array of visual row indexes to be moved.
     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we
     *   are going to drop the moved elements. To check visualization of drop index please take a look at
     *   [documentation](@/guides/rows/row-moving.md).
     */
  }, {
    key: "selectCells",
    value: function selectCells(rows, dropIndex) {
      var rowsLen = rows.length;
      var startRow = 0;
      var endRow = 0;
      var selection = null;
      var lastColIndex = null;
      if (this.movedToCollapsed) {
        var physicalDropIndex = null;
        if (rows[rowsLen - 1] < dropIndex) {
          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);
        } else {
          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);
        }
        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);
        var parentIndex = this.dataManager.getRowIndex(parentObject);
        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);
        endRow = startRow;
      } else if (rows[rowsLen - 1] < dropIndex) {
        endRow = dropIndex - 1;
        startRow = endRow - rowsLen + 1;
      } else {
        startRow = dropIndex;
        endRow = startRow + rowsLen - 1;
      }
      selection = this.hot.selection;
      lastColIndex = this.hot.countCols() - 1;
      selection.setRangeStart(this.hot._createCellCoords(startRow, 0));
      selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);
    }
    // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.
    /**
     * Indicates if order of rows was changed.
     *
     * @param {Array} movedRows Array of visual row indexes to be moved.
     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements
     *   will be placed after the moving action. To check the visualization of the final index, please take a look at
     *   [documentation](@/guides/rows/row-moving.md).
     * @returns {boolean}
     */
  }, {
    key: "isRowOrderChanged",
    value: function isRowOrderChanged(movedRows, finalIndex) {
      return movedRows.some(function(row, nrOfMovedElement) {
        return row - nrOfMovedElement !== finalIndex;
      });
    }
  }]);
  return RowMoveController2;
}();
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$5(obj);
}
function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o, minLen);
}
function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$2(arr);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$4() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$4 = Reflect.get.bind();
  } else {
    _get$4 = function _get2(target, property, receiver) {
      var base = _superPropBase$4(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$4.apply(this, arguments);
}
function _superPropBase$4(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$5(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$5(o, p2);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call2) {
  if (call2 && (_typeof$5(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
var PLUGIN_KEY$5 = "nestedRows";
var PLUGIN_PRIORITY$4 = 300;
var privatePool = /* @__PURE__ */ new WeakMap();
var WRONG_DATA_TYPE_ERROR = "The Nested Rows plugin requires an Array of Objects as a dataset to be provided. The plugin has been disabled.";
var NestedRows = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$5(NestedRows2, _BasePlugin);
  var _super = _createSuper$5(NestedRows2);
  function NestedRows2(hotInstance) {
    var _this;
    _classCallCheck$6(this, NestedRows2);
    _this = _super.call(this, hotInstance);
    _this.dataManager = null;
    _this.headersUI = null;
    _this.collapsedRowsMap = null;
    privatePool.set(_assertThisInitialized$5(_this), {
      movedToCollapsed: false,
      skipRender: null,
      skipCoreAPIModifiers: false
    });
    return _this;
  }
  _createClass$6(NestedRows2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$5];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.collapsedRowsMap = this.hot.rowIndexMapper.registerMap("nestedRows", new TrimmingMap());
      this.dataManager = new DataManager$1(this, this.hot);
      this.collapsingUI = new CollapsingUI$1(this, this.hot);
      this.headersUI = new HeadersUI$1(this, this.hot);
      this.contextMenuUI = new ContextMenuUI$1(this, this.hot);
      this.rowMoveController = new RowMoveController(this);
      this.addHook("afterInit", function() {
        return _this2.onAfterInit.apply(_this2, arguments);
      });
      this.addHook("beforeViewRender", function() {
        return _this2.onBeforeViewRender.apply(_this2, arguments);
      });
      this.addHook("modifyRowData", function() {
        return _this2.onModifyRowData.apply(_this2, arguments);
      });
      this.addHook("modifySourceLength", function() {
        return _this2.onModifySourceLength.apply(_this2, arguments);
      });
      this.addHook("beforeDataSplice", function() {
        return _this2.onBeforeDataSplice.apply(_this2, arguments);
      });
      this.addHook("filterData", function() {
        return _this2.onFilterData.apply(_this2, arguments);
      });
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.onAfterContextMenuDefaultOptions.apply(_this2, arguments);
      });
      this.addHook("afterGetRowHeader", function() {
        return _this2.onAfterGetRowHeader.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseDown", function() {
        return _this2.onBeforeOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("beforeRemoveRow", function() {
        return _this2.onBeforeRemoveRow.apply(_this2, arguments);
      });
      this.addHook("afterRemoveRow", function() {
        return _this2.onAfterRemoveRow.apply(_this2, arguments);
      });
      this.addHook("beforeAddChild", function() {
        return _this2.onBeforeAddChild.apply(_this2, arguments);
      });
      this.addHook("afterAddChild", function() {
        return _this2.onAfterAddChild.apply(_this2, arguments);
      });
      this.addHook("beforeDetachChild", function() {
        return _this2.onBeforeDetachChild.apply(_this2, arguments);
      });
      this.addHook("afterDetachChild", function() {
        return _this2.onAfterDetachChild.apply(_this2, arguments);
      });
      this.addHook("modifyRowHeaderWidth", function() {
        return _this2.onModifyRowHeaderWidth.apply(_this2, arguments);
      });
      this.addHook("afterCreateRow", function() {
        return _this2.onAfterCreateRow.apply(_this2, arguments);
      });
      this.addHook("beforeRowMove", function() {
        return _this2.onBeforeRowMove.apply(_this2, arguments);
      });
      this.addHook("beforeLoadData", function(data2) {
        return _this2.onBeforeLoadData(data2);
      });
      _get$4(_getPrototypeOf$5(NestedRows2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap("nestedRows");
      _get$4(_getPrototypeOf$5(NestedRows2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`nestedRows`](@/api/options.md#nestedrows)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      var currentSourceData = this.dataManager.getData();
      this.enablePlugin();
      this.dataManager.updateWithData(currentSourceData);
      _get$4(_getPrototypeOf$5(NestedRows2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * `beforeRowMove` hook callback.
     *
     * @private
     * @param {Array} rows Array of visual row indexes to be moved.
     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements
     *   will be placed after the moving action. To check the visualization of the final index, please take a look at
     *   [documentation](@/guides/rows/row-summary.md).
     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we
     *   are going to drop the moved elements. To check visualization of drop index please take a look at
     *   [documentation](@/guides/rows/row-summary.md).
     * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
     * @fires Hooks#afterRowMove
     * @returns {boolean}
     */
  }, {
    key: "onBeforeRowMove",
    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {
      return this.rowMoveController.onBeforeRowMove(rows, finalIndex, dropIndex, movePossible);
    }
    /**
     * Enable the modify hook skipping flag - allows retrieving the data from Handsontable without this plugin's
     * modifications.
     */
  }, {
    key: "disableCoreAPIModifiers",
    value: function disableCoreAPIModifiers() {
      var priv = privatePool.get(this);
      priv.skipCoreAPIModifiers = true;
    }
    /**
     * Disable the modify hook skipping flag.
     */
  }, {
    key: "enableCoreAPIModifiers",
    value: function enableCoreAPIModifiers() {
      var priv = privatePool.get(this);
      priv.skipCoreAPIModifiers = false;
    }
    /**
     * `beforeOnCellMousedown` hook callback.
     *
     * @private
     * @param {MouseEvent} event Mousedown event.
     * @param {object} coords Cell coords.
     * @param {HTMLElement} TD Clicked cell.
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD) {
      this.collapsingUI.toggleState(event2, coords, TD);
    }
    /**
     * The modifyRowData hook callback.
     *
     * @private
     * @param {number} row Visual row index.
     * @returns {boolean}
     */
  }, {
    key: "onModifyRowData",
    value: function onModifyRowData(row) {
      var priv = privatePool.get(this);
      if (priv.skipCoreAPIModifiers) {
        return;
      }
      return this.dataManager.getDataObject(row);
    }
    /**
     * Modify the source data length to match the length of the nested structure.
     *
     * @private
     * @returns {number}
     */
  }, {
    key: "onModifySourceLength",
    value: function onModifySourceLength() {
      var priv = privatePool.get(this);
      if (priv.skipCoreAPIModifiers) {
        return;
      }
      return this.dataManager.countAllRows();
    }
    /**
     * @private
     * @param {number} index The index where the data was spliced.
     * @param {number} amount An amount of items to remove.
     * @param {object} element An element to add.
     * @returns {boolean}
     */
  }, {
    key: "onBeforeDataSplice",
    value: function onBeforeDataSplice(index2, amount, element) {
      var priv = privatePool.get(this);
      if (priv.skipCoreAPIModifiers || this.dataManager.isRowHighestLevel(index2)) {
        return true;
      }
      this.dataManager.spliceData(index2, amount, element);
      return false;
    }
    /**
     * Provide custom source data filtering. It's handled by core method and replaces the native filtering.
     *
     * @private
     * @param {number} index The index where the data filtering starts.
     * @param {number} amount An amount of rows which filtering applies to.
     * @param {number} physicalRows Physical row indexes.
     * @returns {Array}
     */
  }, {
    key: "onFilterData",
    value: function onFilterData(index2, amount, physicalRows) {
      var priv = privatePool.get(this);
      this.collapsingUI.collapsedRowsStash.stash();
      this.collapsingUI.collapsedRowsStash.trimStash(physicalRows[0], amount);
      this.collapsingUI.collapsedRowsStash.shiftStash(physicalRows[0], null, -1 * amount);
      this.dataManager.filterData(index2, amount, physicalRows);
      priv.skipRender = true;
      return this.dataManager.getData().slice();
    }
    /**
     * `afterContextMenuDefaultOptions` hook callback.
     *
     * @private
     * @param {object} defaultOptions The default context menu items order.
     * @returns {boolean}
     */
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(defaultOptions) {
      return this.contextMenuUI.appendOptions(defaultOptions);
    }
    /**
     * `afterGetRowHeader` hook callback.
     *
     * @private
     * @param {number} row Row index.
     * @param {HTMLElement} TH Row header element.
     */
  }, {
    key: "onAfterGetRowHeader",
    value: function onAfterGetRowHeader(row, TH) {
      this.headersUI.appendLevelIndicators(row, TH);
    }
    /**
     * `modifyRowHeaderWidth` hook callback.
     *
     * @private
     * @param {number} rowHeaderWidth The initial row header width(s).
     * @returns {number}
     */
  }, {
    key: "onModifyRowHeaderWidth",
    value: function onModifyRowHeaderWidth(rowHeaderWidth) {
      return this.headersUI.rowHeaderWidthCache || rowHeaderWidth;
    }
    /**
     * `onAfterRemoveRow` hook callback.
     *
     * @private
     * @param {number} index Removed row.
     * @param {number} amount Amount of removed rows.
     * @param {Array} logicRows An array of the removed physical rows.
     * @param {string} source Source of action.
     */
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(index2, amount, logicRows, source) {
      var _this3 = this;
      if (source === this.pluginName) {
        return;
      }
      var priv = privatePool.get(this);
      setTimeout(function() {
        priv.skipRender = null;
        _this3.headersUI.updateRowHeaderWidth();
        _this3.collapsingUI.collapsedRowsStash.applyStash();
      }, 0);
    }
    /**
     * Callback for the `beforeRemoveRow` change list of removed physical indexes by reference. Removing parent node
     * has effect in removing children nodes.
     *
     * @private
     * @param {number} index Visual index of starter row.
     * @param {number} amount Amount of rows to be removed.
     * @param {Array} physicalRows List of physical indexes.
     */
  }, {
    key: "onBeforeRemoveRow",
    value: function onBeforeRemoveRow(index2, amount, physicalRows) {
      var _this4 = this;
      var modifiedPhysicalRows = Array.from(physicalRows.reduce(function(removedRows, physicalIndex) {
        if (_this4.dataManager.isParent(physicalIndex)) {
          var children = _this4.dataManager.getDataObject(physicalIndex).__children;
          removedRows.add(physicalIndex);
          if (Array.isArray(children)) {
            children.forEach(function(child) {
              return removedRows.add(_this4.dataManager.getRowIndex(child));
            });
          }
          return removedRows;
        }
        return removedRows.add(physicalIndex);
      }, /* @__PURE__ */ new Set()));
      physicalRows.length = 0;
      physicalRows.push.apply(physicalRows, modifiedPhysicalRows);
    }
    /**
     * `beforeAddChild` hook callback.
     *
     * @private
     */
  }, {
    key: "onBeforeAddChild",
    value: function onBeforeAddChild() {
      this.collapsingUI.collapsedRowsStash.stash();
    }
    /**
     * `afterAddChild` hook callback.
     *
     * @private
     * @param {object} parent Parent element.
     * @param {object} element New child element.
     */
  }, {
    key: "onAfterAddChild",
    value: function onAfterAddChild(parent, element) {
      this.collapsingUI.collapsedRowsStash.shiftStash(this.dataManager.getRowIndex(element));
      this.collapsingUI.collapsedRowsStash.applyStash();
      this.headersUI.updateRowHeaderWidth();
    }
    /**
     * `beforeDetachChild` hook callback.
     *
     * @private
     */
  }, {
    key: "onBeforeDetachChild",
    value: function onBeforeDetachChild() {
      this.collapsingUI.collapsedRowsStash.stash();
    }
    /**
     * `afterDetachChild` hook callback.
     *
     * @private
     * @param {object} parent Parent element.
     * @param {object} element New child element.
     * @param {number} finalElementRowIndex The final row index of the detached element.
     */
  }, {
    key: "onAfterDetachChild",
    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {
      this.collapsingUI.collapsedRowsStash.shiftStash(finalElementRowIndex, null, -1);
      this.collapsingUI.collapsedRowsStash.applyStash();
      this.headersUI.updateRowHeaderWidth();
    }
    /**
     * `afterCreateRow` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow() {
      this.dataManager.rewriteCache();
    }
    /**
     * `afterInit` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      var deepestLevel = Math.max.apply(Math, _toConsumableArray$2(this.dataManager.cache.levels));
      if (deepestLevel > 0) {
        this.headersUI.updateRowHeaderWidth(deepestLevel);
      }
    }
    /**
     * `beforeViewRender` hook callback.
     *
     * @param {boolean} force Indicates if the render call was trigered by a change of settings or data.
     * @param {object} skipRender An object, holder for skipRender functionality.
     * @private
     */
  }, {
    key: "onBeforeViewRender",
    value: function onBeforeViewRender(force, skipRender) {
      var priv = privatePool.get(this);
      if (priv.skipRender) {
        skipRender.skipRender = true;
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$4(_getPrototypeOf$5(NestedRows2.prototype), "destroy", this).call(this);
    }
    /**
     * `beforeLoadData` hook callback.
     *
     * @param {Array} data The source data.
     * @private
     */
  }, {
    key: "onBeforeLoadData",
    value: function onBeforeLoadData(data2) {
      if (!isArrayOfObjects(data2)) {
        error(WRONG_DATA_TYPE_ERROR);
        this.hot.getSettings()[PLUGIN_KEY$5] = false;
        this.disablePlugin();
        return;
      }
      this.dataManager.setData(data2);
      this.dataManager.rewriteCache();
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$5;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$4;
    }
  }]);
  return NestedRows2;
}(BasePlugin);
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Storage = /* @__PURE__ */ function() {
  function Storage2(prefix) {
    var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
    _classCallCheck$5(this, Storage2);
    this.rootWindow = rootWindow;
    this.prefix = prefix;
    this.savedKeys = [];
    this.loadSavedKeys();
  }
  _createClass$5(Storage2, [{
    key: "saveValue",
    value: function saveValue(key, value) {
      this.rootWindow.localStorage.setItem("".concat(this.prefix, "_").concat(key), JSON.stringify(value));
      if (this.savedKeys.indexOf(key) === -1) {
        this.savedKeys.push(key);
        this.saveSavedKeys();
      }
    }
    /**
     * Load data from localStorage.
     *
     * @param {string} key Key string.
     * @param {object} defaultValue Object containing the loaded data.
     *
     * @returns {object|undefined}
     */
  }, {
    key: "loadValue",
    value: function loadValue(key, defaultValue) {
      var itemKey = typeof key === "undefined" ? defaultValue : key;
      var value = this.rootWindow.localStorage.getItem("".concat(this.prefix, "_").concat(itemKey));
      return value === null ? void 0 : JSON.parse(value);
    }
    /**
     * Reset given data from localStorage.
     *
     * @param {string} key Key string.
     */
  }, {
    key: "reset",
    value: function reset(key) {
      this.rootWindow.localStorage.removeItem("".concat(this.prefix, "_").concat(key));
    }
    /**
     * Reset all data from localStorage.
     *
     */
  }, {
    key: "resetAll",
    value: function resetAll() {
      var _this = this;
      arrayEach(this.savedKeys, function(value, index2) {
        _this.rootWindow.localStorage.removeItem("".concat(_this.prefix, "_").concat(_this.savedKeys[index2]));
      });
      this.clearSavedKeys();
    }
    /**
     * Load and save all keys from localStorage.
     *
     * @private
     */
  }, {
    key: "loadSavedKeys",
    value: function loadSavedKeys() {
      var keysJSON = this.rootWindow.localStorage.getItem("".concat(this.prefix, "__persistentStateKeys"));
      var keys3 = typeof keysJSON === "string" ? JSON.parse(keysJSON) : void 0;
      this.savedKeys = keys3 || [];
    }
    /**
     * Save saved key in localStorage.
     *
     * @private
     */
  }, {
    key: "saveSavedKeys",
    value: function saveSavedKeys() {
      this.rootWindow.localStorage.setItem("".concat(this.prefix, "__persistentStateKeys"), JSON.stringify(this.savedKeys));
    }
    /**
     * Clear saved key from localStorage.
     *
     * @private
     */
  }, {
    key: "clearSavedKeys",
    value: function clearSavedKeys() {
      this.savedKeys.length = 0;
      this.saveSavedKeys();
    }
  }]);
  return Storage2;
}();
const Storage$1 = Storage;
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$3() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$3 = Reflect.get.bind();
  } else {
    _get$3 = function _get2(target, property, receiver) {
      var base = _superPropBase$3(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$3.apply(this, arguments);
}
function _superPropBase$3(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$4(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$4(o, p2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call2) {
  if (call2 && (_typeof$4(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
Hooks$1.getSingleton().register("persistentStateSave");
Hooks$1.getSingleton().register("persistentStateLoad");
Hooks$1.getSingleton().register("persistentStateReset");
var PLUGIN_KEY$4 = "persistentState";
var PLUGIN_PRIORITY$3 = 0;
var PersistentState = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$4(PersistentState2, _BasePlugin);
  var _super = _createSuper$4(PersistentState2);
  function PersistentState2(hotInstance) {
    var _this;
    _classCallCheck$4(this, PersistentState2);
    _this = _super.call(this, hotInstance);
    _this.storage = void 0;
    return _this;
  }
  _createClass$4(PersistentState2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$4];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      if (!this.storage) {
        this.storage = new Storage$1(this.hot.rootElement.id, this.hot.rootWindow);
      }
      this.addHook("persistentStateSave", function(key, value) {
        return _this2.saveValue(key, value);
      });
      this.addHook("persistentStateLoad", function(key, saveTo) {
        return _this2.loadValue(key, saveTo);
      });
      this.addHook("persistentStateReset", function() {
        return _this2.resetValue();
      });
      _get$3(_getPrototypeOf$4(PersistentState2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.storage = void 0;
      _get$3(_getPrototypeOf$4(PersistentState2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`persistentState`](@/api/options.md#persistentstate)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$3(_getPrototypeOf$4(PersistentState2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Loads the value from local storage.
     *
     * @param {string} key Storage key.
     * @param {object} saveTo Saved value from local storage.
     */
  }, {
    key: "loadValue",
    value: function loadValue(key, saveTo) {
      saveTo.value = this.storage.loadValue(key);
    }
    /**
     * Saves the data to local storage.
     *
     * @param {string} key Storage key.
     * @param {Mixed} value Value to save.
     */
  }, {
    key: "saveValue",
    value: function saveValue(key, value) {
      this.storage.saveValue(key, value);
    }
    /**
     * Resets the data or all data from local storage.
     *
     * @param {string} key [optional] Storage key.
     */
  }, {
    key: "resetValue",
    value: function resetValue(key) {
      if (typeof key === "undefined") {
        this.storage.resetAll();
      } else {
        this.storage.reset(key);
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$3(_getPrototypeOf$4(PersistentState2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$4;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$3;
    }
  }]);
  return PersistentState2;
}(BasePlugin);
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o, minLen);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$2() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$2 = Reflect.get.bind();
  } else {
    _get$2 = function _get2(target, property, receiver) {
      var base = _superPropBase$2(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$2.apply(this, arguments);
}
function _superPropBase$2(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$3(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$3(o, p2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call2) {
  if (call2 && (_typeof$3(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
var PLUGIN_KEY$3 = "search";
var PLUGIN_PRIORITY$2 = 190;
var DEFAULT_SEARCH_RESULT_CLASS = "htSearchResult";
var DEFAULT_CALLBACK = function DEFAULT_CALLBACK2(instance, row, col, data2, testResult) {
  instance.getCellMeta(row, col).isSearchResult = testResult;
};
var DEFAULT_QUERY_METHOD = function DEFAULT_QUERY_METHOD2(query, value, cellProperties) {
  if (isUndefined(query) || query === null || !query.toLocaleLowerCase || query.length === 0) {
    return false;
  }
  if (isUndefined(value) || value === null) {
    return false;
  }
  return value.toString().toLocaleLowerCase(cellProperties.locale).indexOf(query.toLocaleLowerCase(cellProperties.locale)) !== -1;
};
var Search = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$3(Search2, _BasePlugin);
  var _super = _createSuper$3(Search2);
  function Search2(hotInstance) {
    var _this;
    _classCallCheck$3(this, Search2);
    _this = _super.call(this, hotInstance);
    _this.callback = DEFAULT_CALLBACK;
    _this.queryMethod = DEFAULT_QUERY_METHOD;
    _this.searchResultClass = DEFAULT_SEARCH_RESULT_CLASS;
    return _this;
  }
  _createClass$3(Search2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$3];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var searchSettings = this.hot.getSettings()[PLUGIN_KEY$3];
      this.updatePluginSettings(searchSettings);
      this.addHook("beforeRenderer", function() {
        return _this2.onBeforeRenderer.apply(_this2, arguments);
      });
      _get$2(_getPrototypeOf$3(Search2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      var beforeRendererCallback = function beforeRendererCallback2() {
        return _this3.onBeforeRenderer.apply(_this3, arguments);
      };
      this.hot.addHook("beforeRenderer", beforeRendererCallback);
      this.hot.addHookOnce("afterViewRender", function() {
        _this3.hot.removeHook("beforeRenderer", beforeRendererCallback);
      });
      _get$2(_getPrototypeOf$3(Search2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`search`](@/api/options.md#search)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$2(_getPrototypeOf$3(Search2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Makes the query.
     *
     * @param {string} queryStr Value to be search.
     * @param {Function} [callback] Callback function performed on cells with values which matches to the searched query.
     * @param {Function} [queryMethod] Query function responsible for determining whether a query matches the value stored in a cell.
     * @returns {object[]} Return an array of objects with `row`, `col`, `data` properties or empty array.
     */
  }, {
    key: "query",
    value: function query(queryStr) {
      var _this4 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getCallback();
      var queryMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getQueryMethod();
      var rowCount = this.hot.countRows();
      var colCount = this.hot.countCols();
      var queryResult = [];
      var instance = this.hot;
      rangeEach(0, rowCount - 1, function(rowIndex) {
        rangeEach(0, colCount - 1, function(colIndex) {
          var cellData = _this4.hot.getDataAtCell(rowIndex, colIndex);
          var cellProperties = _this4.hot.getCellMeta(rowIndex, colIndex);
          var cellCallback = cellProperties.search.callback || callback;
          var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
          var testResult = cellQueryMethod(queryStr, cellData, cellProperties);
          if (testResult) {
            var singleResult = {
              row: rowIndex,
              col: colIndex,
              data: cellData
            };
            queryResult.push(singleResult);
          }
          if (cellCallback) {
            cellCallback(instance, rowIndex, colIndex, cellData, testResult);
          }
        });
      });
      return queryResult;
    }
    /**
     * Gets the callback function.
     *
     * @returns {Function} Return the callback function.
     */
  }, {
    key: "getCallback",
    value: function getCallback() {
      return this.callback;
    }
    /**
     * Sets the callback function. This function will be called during querying for each cell.
     *
     * @param {Function} newCallback A callback function.
     */
  }, {
    key: "setCallback",
    value: function setCallback(newCallback) {
      this.callback = newCallback;
    }
    /**
     * Gets the query method function.
     *
     * @returns {Function} Return the query method.
     */
  }, {
    key: "getQueryMethod",
    value: function getQueryMethod() {
      return this.queryMethod;
    }
    /**
     * Sets the query method function. The function is responsible for determining whether a query matches the value stored in a cell.
     *
     * @param {Function} newQueryMethod A function with specific match logic.
     */
  }, {
    key: "setQueryMethod",
    value: function setQueryMethod(newQueryMethod) {
      this.queryMethod = newQueryMethod;
    }
    /**
     * Gets search result cells class name.
     *
     * @returns {string} Return the cell class name.
     */
  }, {
    key: "getSearchResultClass",
    value: function getSearchResultClass() {
      return this.searchResultClass;
    }
    /**
     * Sets search result cells class name. This class name will be added to each cell that belongs to the searched query.
     *
     * @param {string} newElementClass CSS class name.
     */
  }, {
    key: "setSearchResultClass",
    value: function setSearchResultClass(newElementClass) {
      this.searchResultClass = newElementClass;
    }
    /**
     * Updates the settings of the plugin.
     *
     * @param {object} searchSettings The plugin settings, taken from Handsontable configuration.
     * @private
     */
  }, {
    key: "updatePluginSettings",
    value: function updatePluginSettings(searchSettings) {
      if (isObject$7(searchSettings)) {
        if (searchSettings.searchResultClass) {
          this.setSearchResultClass(searchSettings.searchResultClass);
        }
        if (searchSettings.queryMethod) {
          this.setQueryMethod(searchSettings.queryMethod);
        }
        if (searchSettings.callback) {
          this.setCallback(searchSettings.callback);
        }
      }
    }
    /**
     * The `beforeRenderer` hook callback.
     *
     * @private
     * @param {HTMLTableCellElement} TD The rendered `TD` element.
     * @param {number} row Visual row index.
     * @param {number} col Visual column index.
     * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
     * @param {string} value Value of the rendered cell.
     * @param {object} cellProperties Object containing the cell's properties.
     */
  }, {
    key: "onBeforeRenderer",
    value: function onBeforeRenderer(TD, row, col, prop, value, cellProperties) {
      var className = cellProperties.className || [];
      var classArray = [];
      if (typeof className === "string") {
        classArray = className.split(" ");
      } else {
        var _classArray;
        (_classArray = classArray).push.apply(_classArray, _toConsumableArray$1(className));
      }
      if (this.isEnabled() && cellProperties.isSearchResult) {
        if (!classArray.includes(this.searchResultClass)) {
          classArray.push("".concat(this.searchResultClass));
        }
      } else if (classArray.includes(this.searchResultClass)) {
        classArray.splice(classArray.indexOf(this.searchResultClass), 1);
      }
      cellProperties.className = classArray.join(" ");
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get$2(_getPrototypeOf$3(Search2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$3;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$2;
    }
  }]);
  return Search2;
}(BasePlugin);
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get$1() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$1 = Reflect.get.bind();
  } else {
    _get$1 = function _get2(target, property, receiver) {
      var base = _superPropBase$1(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$1.apply(this, arguments);
}
function _superPropBase$1(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$2(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call2) {
  if (call2 && (_typeof$2(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
var PLUGIN_KEY$2 = "touchScroll";
var PLUGIN_PRIORITY$1 = 200;
var TouchScroll = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$2(TouchScroll2, _BasePlugin);
  var _super = _createSuper$2(TouchScroll2);
  function TouchScroll2(hotInstance) {
    var _this;
    _classCallCheck$2(this, TouchScroll2);
    _this = _super.call(this, hotInstance);
    _this.scrollbars = [];
    _this.clones = [];
    _this.lockedCollection = false;
    _this.freezeOverlays = false;
    return _this;
  }
  _createClass$2(TouchScroll2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return isTouchSupported();
    }
    /**
     * Enable the plugin.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterViewRender", function() {
        return _this2.onAfterViewRender();
      });
      this.registerEvents();
      _get$1(_getPrototypeOf$2(TouchScroll2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin to use the latest options you have specified.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.lockedCollection = false;
      _get$1(_getPrototypeOf$2(TouchScroll2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disable plugin for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get$1(_getPrototypeOf$2(TouchScroll2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Register all necessary events.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this3 = this;
      this.addHook("beforeTouchScroll", function() {
        return _this3.onBeforeTouchScroll();
      });
      this.addHook("afterMomentumScroll", function() {
        return _this3.onAfterMomentumScroll();
      });
    }
    /**
     * After view render listener.
     *
     * @private
     */
  }, {
    key: "onAfterViewRender",
    value: function onAfterViewRender() {
      if (this.lockedCollection) {
        return;
      }
      var _this$hot$view$_wt$wt = this.hot.view._wt.wtOverlays, topOverlay = _this$hot$view$_wt$wt.topOverlay, bottomOverlay = _this$hot$view$_wt$wt.bottomOverlay, inlineStartOverlay = _this$hot$view$_wt$wt.inlineStartOverlay, topInlineStartCornerOverlay = _this$hot$view$_wt$wt.topInlineStartCornerOverlay, bottomInlineStartCornerOverlay = _this$hot$view$_wt$wt.bottomInlineStartCornerOverlay;
      this.lockedCollection = true;
      this.scrollbars.length = 0;
      this.scrollbars.push(topOverlay);
      if (bottomOverlay.clone) {
        this.scrollbars.push(bottomOverlay);
      }
      this.scrollbars.push(inlineStartOverlay);
      if (topInlineStartCornerOverlay) {
        this.scrollbars.push(topInlineStartCornerOverlay);
      }
      if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
        this.scrollbars.push(bottomInlineStartCornerOverlay);
      }
      this.clones = [];
      if (topOverlay.needFullRender) {
        this.clones.push(topOverlay.clone.wtTable.holder.parentNode);
      }
      if (bottomOverlay.needFullRender) {
        this.clones.push(bottomOverlay.clone.wtTable.holder.parentNode);
      }
      if (inlineStartOverlay.needFullRender) {
        this.clones.push(inlineStartOverlay.clone.wtTable.holder.parentNode);
      }
      if (topInlineStartCornerOverlay) {
        this.clones.push(topInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
      }
      if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
        this.clones.push(bottomInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
      }
    }
    /**
     * Touch scroll listener.
     *
     * @private
     */
  }, {
    key: "onBeforeTouchScroll",
    value: function onBeforeTouchScroll() {
      this.freezeOverlays = true;
      arrayEach(this.clones, function(clone2) {
        addClass(clone2, "hide-tween");
      });
    }
    /**
     * After momentum scroll listener.
     *
     * @private
     */
  }, {
    key: "onAfterMomentumScroll",
    value: function onAfterMomentumScroll() {
      var _this4 = this;
      this.freezeOverlays = false;
      arrayEach(this.clones, function(clone2) {
        removeClass(clone2, "hide-tween");
        addClass(clone2, "show-tween");
      });
      this.hot._registerTimeout(function() {
        arrayEach(_this4.clones, function(clone2) {
          removeClass(clone2, "show-tween");
        });
      }, 400);
      arrayEach(this.scrollbars, function(scrollbar) {
        scrollbar.refresh();
        scrollbar.resetFixedPosition();
      });
      this.hot.view._wt.wtOverlays.syncScrollWithMaster();
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$2;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY$1;
    }
  }, {
    key: "SETTING_KEYS",
    get: function get2() {
      return true;
    }
  }]);
  return TouchScroll2;
}(BasePlugin);
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call2) {
  if (call2 && (_typeof$1(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
var PLUGIN_KEY$1 = "trimRows";
var PLUGIN_PRIORITY = 330;
var TrimRows = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1(TrimRows2, _BasePlugin);
  var _super = _createSuper$1(TrimRows2);
  function TrimRows2(hotInstance) {
    var _this;
    _classCallCheck$1(this, TrimRows2);
    _this = _super.call(this, hotInstance);
    _this.trimmedRowsMap = null;
    return _this;
  }
  _createClass$1(TrimRows2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$1];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap("trimRows", new TrimmingMap());
      this.trimmedRowsMap.addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      _get(_getPrototypeOf$1(TrimRows2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin's state.
     *
     * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
     *  - [`trimRows`](@/api/options.md#trimrows)
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var _this3 = this;
      var trimmedRows = this.hot.getSettings()[PLUGIN_KEY$1];
      if (Array.isArray(trimmedRows)) {
        this.hot.batchExecution(function() {
          _this3.trimmedRowsMap.clear();
          arrayEach(trimmedRows, function(physicalRow) {
            _this3.trimmedRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
      }
      _get(_getPrototypeOf$1(TrimRows2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap("trimRows");
      _get(_getPrototypeOf$1(TrimRows2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Get list of trimmed rows.
     *
     * @returns {Array} Physical rows.
     */
  }, {
    key: "getTrimmedRows",
    value: function getTrimmedRows() {
      return this.trimmedRowsMap.getTrimmedIndexes();
    }
    /**
     * Trims the rows provided in the array.
     *
     * @param {number[]} rows Array of physical row indexes.
     * @fires Hooks#beforeTrimRow
     * @fires Hooks#afterTrimRow
     */
  }, {
    key: "trimRows",
    value: function trimRows(rows) {
      var _this4 = this;
      var currentTrimConfig = this.getTrimmedRows();
      var isValidConfig = this.isValidConfig(rows);
      var destinationTrimConfig = currentTrimConfig;
      if (isValidConfig) {
        destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));
      }
      var allowTrimRow = this.hot.runHooks("beforeTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig);
      if (allowTrimRow === false) {
        return;
      }
      if (isValidConfig) {
        this.hot.batchExecution(function() {
          arrayEach(rows, function(physicalRow) {
            _this4.trimmedRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
      }
      this.hot.runHooks("afterTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);
    }
    /**
     * Trims the row provided as a physical row index (counting from 0).
     *
     * @param {...number} row Physical row index.
     */
  }, {
    key: "trimRow",
    value: function trimRow() {
      for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {
        row[_key] = arguments[_key];
      }
      this.trimRows(row);
    }
    /**
     * Untrims the rows provided in the array.
     *
     * @param {number[]} rows Array of physical row indexes.
     * @fires Hooks#beforeUntrimRow
     * @fires Hooks#afterUntrimRow
     */
  }, {
    key: "untrimRows",
    value: function untrimRows(rows) {
      var currentTrimConfig = this.getTrimmedRows();
      var isValidConfig = this.isValidConfig(rows);
      var destinationTrimConfig = currentTrimConfig;
      var trimmingMapValues = this.trimmedRowsMap.getValues().slice();
      var isAnyRowUntrimmed = rows.length > 0;
      if (isValidConfig && isAnyRowUntrimmed) {
        arrayEach(rows, function(physicalRow) {
          trimmingMapValues[physicalRow] = false;
        });
        destinationTrimConfig = arrayReduce$1(trimmingMapValues, function(trimmedIndexes, isTrimmed, physicalIndex) {
          if (isTrimmed) {
            trimmedIndexes.push(physicalIndex);
          }
          return trimmedIndexes;
        }, []);
      }
      var allowUntrimRow = this.hot.runHooks("beforeUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);
      if (allowUntrimRow === false) {
        return;
      }
      if (isValidConfig && isAnyRowUntrimmed) {
        this.trimmedRowsMap.setValues(trimmingMapValues);
      }
      this.hot.runHooks("afterUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);
    }
    /**
     * Untrims the row provided as a physical row index (counting from 0).
     *
     * @param {...number} row Physical row index.
     */
  }, {
    key: "untrimRow",
    value: function untrimRow() {
      for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        row[_key2] = arguments[_key2];
      }
      this.untrimRows(row);
    }
    /**
     * Checks if given row is hidden.
     *
     * @param {number} physicalRow Physical row index.
     * @returns {boolean}
     */
  }, {
    key: "isTrimmed",
    value: function isTrimmed(physicalRow) {
      return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;
    }
    /**
     * Untrims all trimmed rows.
     */
  }, {
    key: "untrimAll",
    value: function untrimAll() {
      this.untrimRows(this.getTrimmedRows());
    }
    /**
     * Get if trim config is valid. Check whether all of the provided physical row indexes are within source data.
     *
     * @param {Array} trimmedRows List of physical row indexes.
     * @returns {boolean}
     */
  }, {
    key: "isValidConfig",
    value: function isValidConfig(trimmedRows) {
      var sourceRows = this.hot.countSourceRows();
      return trimmedRows.every(function(trimmedRow) {
        return Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows;
      });
    }
    /**
     * On map initialized hook callback.
     *
     * @private
     */
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      var _this5 = this;
      var trimmedRows = this.hot.getSettings()[PLUGIN_KEY$1];
      if (Array.isArray(trimmedRows)) {
        this.hot.batchExecution(function() {
          arrayEach(trimmedRows, function(physicalRow) {
            _this5.trimmedRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get(_getPrototypeOf$1(TrimRows2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get2() {
      return PLUGIN_KEY$1;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get2() {
      return PLUGIN_PRIORITY;
    }
  }]);
  return TrimRows2;
}(BasePlugin);
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var SHORTCUTS_GROUP = "undoRedo";
var PLUGIN_KEY = "undoRedo";
function UndoRedo(instance) {
  var plugin = this;
  this.instance = instance;
  this.doneActions = [];
  this.undoneActions = [];
  this.ignoreNewActions = false;
  this.enabled = false;
  instance.addHook("afterChange", function(changes, source) {
    var _this = this;
    var changesLen = changes && changes.length;
    if (!changesLen) {
      return;
    }
    var hasDifferences = changes.find(function(change) {
      var _change = _slicedToArray(change, 4), oldValue = _change[2], newValue = _change[3];
      return oldValue !== newValue;
    });
    if (!hasDifferences) {
      return;
    }
    var wrappedAction = function wrappedAction2() {
      var clonedChanges = changes.reduce(function(arr, change) {
        arr.push(_toConsumableArray(change));
        return arr;
      }, []);
      arrayEach(clonedChanges, function(change) {
        change[1] = instance.propToCol(change[1]);
      });
      var selected = changesLen > 1 ? _this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];
      return new UndoRedo.ChangeAction(clonedChanges, selected);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateRow", function(index2, amount, source) {
    plugin.done(function() {
      return new UndoRedo.CreateRowAction(index2, amount);
    }, source);
  });
  instance.addHook("beforeRemoveRow", function(index2, amount, logicRows, source) {
    var wrappedAction = function wrappedAction2() {
      var originalData = plugin.instance.getSourceDataArray();
      var rowIndex = (originalData.length + index2) % originalData.length;
      var physicalRowIndex = instance.toPhysicalRow(rowIndex);
      var removedData = deepClone(originalData.slice(physicalRowIndex, physicalRowIndex + amount));
      return new UndoRedo.RemoveRowAction(rowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateCol", function(index2, amount, source) {
    plugin.done(function() {
      return new UndoRedo.CreateColumnAction(index2, amount);
    }, source);
  });
  instance.addHook("beforeRemoveCol", function(index2, amount, logicColumns, source) {
    var wrappedAction = function wrappedAction2() {
      var originalData = plugin.instance.getSourceDataArray();
      var columnIndex = (plugin.instance.countCols() + index2) % plugin.instance.countCols();
      var removedData = [];
      var headers = [];
      var indexes = [];
      rangeEach(originalData.length - 1, function(i) {
        var column = [];
        var origRow = originalData[i];
        rangeEach(columnIndex, columnIndex + (amount - 1), function(j) {
          column.push(origRow[instance.toPhysicalColumn(j)]);
        });
        removedData.push(column);
      });
      rangeEach(amount - 1, function(i) {
        indexes.push(instance.toPhysicalColumn(columnIndex + i));
      });
      if (Array.isArray(instance.getSettings().colHeaders)) {
        rangeEach(amount - 1, function(i) {
          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);
        });
      }
      var columnsMap = instance.columnIndexMapper.getIndexesSequence();
      var rowsMap = instance.rowIndexMapper.getIndexesSequence();
      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsStart);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("beforeCellAlignment", function(stateBefore, range, type, alignment) {
    plugin.done(function() {
      return new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment);
    });
  });
  instance.addHook("beforeFilter", function(conditionsStack) {
    plugin.done(function() {
      return new UndoRedo.FiltersAction(conditionsStack);
    });
  });
  instance.addHook("beforeRowMove", function(rows, finalIndex) {
    if (rows === false) {
      return;
    }
    plugin.done(function() {
      return new UndoRedo.RowMoveAction(rows, finalIndex);
    });
  });
  instance.addHook("beforeMergeCells", function(cellRange, auto) {
    if (auto) {
      return;
    }
    plugin.done(function() {
      return new UndoRedo.MergeCellsAction(instance, cellRange);
    });
  });
  instance.addHook("afterUnmergeCells", function(cellRange, auto) {
    if (auto) {
      return;
    }
    plugin.done(function() {
      return new UndoRedo.UnmergeCellsAction(instance, cellRange);
    });
  });
  instance.addHook("afterInit", function() {
    plugin.init();
  });
}
UndoRedo.prototype.done = function(wrappedAction, source) {
  if (this.ignoreNewActions) {
    return;
  }
  var isBlockedByDefault = source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto";
  if (isBlockedByDefault) {
    return;
  }
  var doneActionsCopy = this.doneActions.slice();
  var continueAction = this.instance.runHooks("beforeUndoStackChange", doneActionsCopy, source);
  if (continueAction === false) {
    return;
  }
  var newAction = wrappedAction();
  var undoneActionsCopy = this.undoneActions.slice();
  this.doneActions.push(newAction);
  this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
  this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
  this.undoneActions.length = 0;
  this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
};
UndoRedo.prototype.undo = function() {
  if (this.isUndoAvailable()) {
    var doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    var action = this.doneActions.pop();
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    var actionClone = deepClone(action);
    var continueAction = this.instance.runHooks("beforeUndo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    var that = this;
    var undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    action.undo(this.instance, function() {
      that.ignoreNewActions = false;
      that.undoneActions.push(action);
    });
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    this.instance.runHooks("afterUndo", actionClone);
  }
};
UndoRedo.prototype.redo = function() {
  if (this.isRedoAvailable()) {
    var undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    var action = this.undoneActions.pop();
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    var actionClone = deepClone(action);
    var continueAction = this.instance.runHooks("beforeRedo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    var that = this;
    var doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    action.redo(this.instance, function() {
      that.ignoreNewActions = false;
      that.doneActions.push(action);
    });
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    this.instance.runHooks("afterRedo", actionClone);
  }
};
UndoRedo.prototype.isUndoAvailable = function() {
  return this.doneActions.length > 0;
};
UndoRedo.prototype.isRedoAvailable = function() {
  return this.undoneActions.length > 0;
};
UndoRedo.prototype.clear = function() {
  this.doneActions.length = 0;
  this.undoneActions.length = 0;
};
UndoRedo.prototype.isEnabled = function() {
  return this.enabled;
};
UndoRedo.prototype.enable = function() {
  if (this.isEnabled()) {
    return;
  }
  var hot = this.instance;
  this.enabled = true;
  exposeUndoRedoMethods(hot);
  this.registerShortcuts();
  hot.addHook("afterChange", onAfterChange);
};
UndoRedo.prototype.disable = function() {
  if (!this.isEnabled()) {
    return;
  }
  var hot = this.instance;
  this.enabled = false;
  removeExposedUndoRedoMethods(hot);
  this.unregisterShortcuts();
  hot.removeHook("afterChange", onAfterChange);
};
UndoRedo.prototype.destroy = function() {
  this.clear();
  this.instance = null;
  this.doneActions = null;
  this.undoneActions = null;
};
UndoRedo.Action = function() {
};
UndoRedo.Action.prototype.undo = function() {
};
UndoRedo.Action.prototype.redo = function() {
};
UndoRedo.ChangeAction = function(changes, selected) {
  this.changes = changes;
  this.selected = selected;
  this.actionType = "change";
};
inherit(UndoRedo.ChangeAction, UndoRedo.Action);
UndoRedo.ChangeAction.prototype.undo = function(instance, undoneCallback) {
  var data2 = deepClone(this.changes);
  var emptyRowsAtTheEnd = instance.countEmptyRows(true);
  var emptyColsAtTheEnd = instance.countEmptyCols(true);
  for (var i = 0, len = data2.length; i < len; i++) {
    data2[i].splice(3, 1);
  }
  instance.addHookOnce("afterChange", undoneCallback);
  instance.setDataAtCell(data2, null, null, "UndoRedo.undo");
  for (var _i2 = 0, _len = data2.length; _i2 < _len; _i2++) {
    var _data$_i = _slicedToArray(data2[_i2], 2), row = _data$_i[0], column = _data$_i[1];
    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {
      instance.alter("remove_row", parseInt(row + 1, 10), instance.getSettings().minSpareRows);
      instance.undoRedo.doneActions.pop();
    }
    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {
      instance.alter("remove_col", parseInt(column + 1, 10), instance.getSettings().minSpareCols);
      instance.undoRedo.doneActions.pop();
    }
  }
  instance.selectCells(this.selected, false, false);
};
UndoRedo.ChangeAction.prototype.redo = function(instance, onFinishCallback) {
  var data2 = deepClone(this.changes);
  for (var i = 0, len = data2.length; i < len; i++) {
    data2[i].splice(2, 1);
  }
  instance.addHookOnce("afterChange", onFinishCallback);
  instance.setDataAtCell(data2, null, null, "UndoRedo.redo");
  if (this.selected) {
    instance.selectCells(this.selected, false, false);
  }
};
UndoRedo.CreateRowAction = function(index2, amount) {
  this.index = index2;
  this.amount = amount;
  this.actionType = "insert_row";
};
inherit(UndoRedo.CreateRowAction, UndoRedo.Action);
UndoRedo.CreateRowAction.prototype.undo = function(instance, undoneCallback) {
  var rowCount = instance.countRows();
  var minSpareRows = instance.getSettings().minSpareRows;
  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {
    this.index -= minSpareRows;
  }
  instance.addHookOnce("afterRemoveRow", undoneCallback);
  instance.alter("remove_row", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateRow", redoneCallback);
  instance.alter("insert_row", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveRowAction = function(index2, data2, fixedRowsBottom, fixedRowsTop) {
  this.index = index2;
  this.data = data2;
  this.actionType = "remove_row";
  this.fixedRowsBottom = fixedRowsBottom;
  this.fixedRowsTop = fixedRowsTop;
};
inherit(UndoRedo.RemoveRowAction, UndoRedo.Action);
UndoRedo.RemoveRowAction.prototype.undo = function(instance, undoneCallback) {
  var settings = instance.getSettings();
  settings.fixedRowsBottom = this.fixedRowsBottom;
  settings.fixedRowsTop = this.fixedRowsTop;
  instance.alter("insert_row", this.index, this.data.length, "UndoRedo.undo");
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.populateFromArray(this.index, 0, this.data, void 0, void 0, "UndoRedo.undo");
};
UndoRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveRow", redoneCallback);
  instance.alter("remove_row", this.index, this.data.length, "UndoRedo.redo");
};
UndoRedo.CreateColumnAction = function(index2, amount) {
  this.index = index2;
  this.amount = amount;
  this.actionType = "insert_col";
};
inherit(UndoRedo.CreateColumnAction, UndoRedo.Action);
UndoRedo.CreateColumnAction.prototype.undo = function(instance, undoneCallback) {
  instance.addHookOnce("afterRemoveCol", undoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateCol", redoneCallback);
  instance.alter("insert_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveColumnAction = function(index2, indexes, data2, headers, columnPositions, rowPositions, fixedColumnsStart) {
  this.index = index2;
  this.indexes = indexes;
  this.data = data2;
  this.amount = this.data[0].length;
  this.headers = headers;
  this.columnPositions = columnPositions.slice(0);
  this.rowPositions = rowPositions.slice(0);
  this.actionType = "remove_col";
  this.fixedColumnsStart = fixedColumnsStart;
};
inherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);
UndoRedo.RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
  var _this2 = this;
  var settings = instance.getSettings();
  settings.fixedColumnsStart = this.fixedColumnsStart;
  var ascendingIndexes = this.indexes.slice(0).sort();
  var sortByIndexes = function sortByIndexes2(elem, j, arr) {
    return arr[_this2.indexes.indexOf(ascendingIndexes[j])];
  };
  var removedDataLength = this.data.length;
  var sortedData = [];
  for (var rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {
    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));
  }
  var sortedHeaders = arrayMap(this.headers, sortByIndexes);
  var changes = [];
  instance.alter("insert_col", this.indexes[0], this.indexes.length, "UndoRedo.undo");
  arrayEach(instance.getSourceDataArray(), function(rowData, rowIndex2) {
    arrayEach(ascendingIndexes, function(changedIndex, contiquesIndex) {
      rowData[changedIndex] = sortedData[rowIndex2][contiquesIndex];
      changes.push([rowIndex2, changedIndex, rowData[changedIndex]]);
    });
  });
  instance.setSourceDataAtCell(changes, void 0, void 0, "UndoRedo.undo");
  instance.columnIndexMapper.insertIndexes(ascendingIndexes[0], ascendingIndexes.length);
  if (typeof this.headers !== "undefined") {
    arrayEach(sortedHeaders, function(headerData, columnIndex) {
      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;
    });
  }
  instance.batchExecution(function() {
    instance.rowIndexMapper.setIndexesSequence(_this2.rowPositions);
    instance.columnIndexMapper.setIndexesSequence(_this2.columnPositions);
  }, true);
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveCol", redoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.CellAlignmentAction = function(stateBefore, range, type, alignment) {
  this.stateBefore = stateBefore;
  this.range = range;
  this.type = type;
  this.alignment = alignment;
};
UndoRedo.CellAlignmentAction.prototype.undo = function(instance, undoneCallback) {
  var _this3 = this;
  arrayEach(this.range, function(range) {
    range.forAll(function(row, col) {
      if (row >= 0 && col >= 0) {
        instance.setCellMeta(row, col, "className", _this3.stateBefore[row][col] || " htLeft");
      }
    });
  });
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.CellAlignmentAction.prototype.redo = function(instance, undoneCallback) {
  align(this.range, this.type, this.alignment, function(row, col) {
    return instance.getCellMeta(row, col);
  }, function(row, col, key, value) {
    return instance.setCellMeta(row, col, key, value);
  });
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.FiltersAction = function(conditionsStack) {
  this.conditionsStack = conditionsStack;
  this.actionType = "filter";
};
inherit(UndoRedo.FiltersAction, UndoRedo.Action);
UndoRedo.FiltersAction.prototype.undo = function(instance, undoneCallback) {
  var filters = instance.getPlugin("filters");
  instance.addHookOnce("afterViewRender", undoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));
  filters.filter();
};
UndoRedo.FiltersAction.prototype.redo = function(instance, redoneCallback) {
  var filters = instance.getPlugin("filters");
  instance.addHookOnce("afterViewRender", redoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack);
  filters.filter();
};
var MergeCellsAction = /* @__PURE__ */ function(_UndoRedo$Action) {
  _inherits(MergeCellsAction2, _UndoRedo$Action);
  var _super = _createSuper(MergeCellsAction2);
  function MergeCellsAction2(instance, cellRange) {
    var _this4;
    _classCallCheck(this, MergeCellsAction2);
    _this4 = _super.call(this);
    _this4.cellRange = cellRange;
    var topStartCorner = _this4.cellRange.getTopStartCorner();
    var bottomEndCorner = _this4.cellRange.getBottomEndCorner();
    _this4.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col);
    return _this4;
  }
  _createClass(MergeCellsAction2, [{
    key: "undo",
    value: function undo(instance, undoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterViewRender", undoneCallback);
      mergeCellsPlugin.unmergeRange(this.cellRange, true);
      var topStartCorner = this.cellRange.getTopStartCorner();
      instance.populateFromArray(topStartCorner.row, topStartCorner.col, this.rangeData, void 0, void 0, "MergeCells");
    }
  }, {
    key: "redo",
    value: function redo(instance, redoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterViewRender", redoneCallback);
      mergeCellsPlugin.mergeRange(this.cellRange);
    }
  }]);
  return MergeCellsAction2;
}(UndoRedo.Action);
UndoRedo.MergeCellsAction = MergeCellsAction;
var UnmergeCellsAction = /* @__PURE__ */ function(_UndoRedo$Action2) {
  _inherits(UnmergeCellsAction2, _UndoRedo$Action2);
  var _super2 = _createSuper(UnmergeCellsAction2);
  function UnmergeCellsAction2(instance, cellRange) {
    var _this5;
    _classCallCheck(this, UnmergeCellsAction2);
    _this5 = _super2.call(this);
    _this5.cellRange = cellRange;
    return _this5;
  }
  _createClass(UnmergeCellsAction2, [{
    key: "undo",
    value: function undo(instance, undoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterViewRender", undoneCallback);
      mergeCellsPlugin.mergeRange(this.cellRange, true);
    }
  }, {
    key: "redo",
    value: function redo(instance, redoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterViewRender", redoneCallback);
      mergeCellsPlugin.unmergeRange(this.cellRange, true);
      instance.render();
    }
  }]);
  return UnmergeCellsAction2;
}(UndoRedo.Action);
UndoRedo.UnmergeCellsAction = UnmergeCellsAction;
UndoRedo.RowMoveAction = function(rows, finalIndex) {
  this.rows = rows.slice();
  this.finalIndex = finalIndex;
  this.actionType = "row_move";
};
inherit(UndoRedo.RowMoveAction, UndoRedo.Action);
UndoRedo.RowMoveAction.prototype.undo = function(instance, undoneCallback) {
  var _this6 = this;
  var manualRowMove = instance.getPlugin("manualRowMove");
  var copyOfRows = [].concat(this.rows);
  var rowsMovedUp = copyOfRows.filter(function(a) {
    return a > _this6.finalIndex;
  });
  var rowsMovedDown = copyOfRows.filter(function(a) {
    return a <= _this6.finalIndex;
  });
  var allMovedRows = rowsMovedUp.sort(function(a, b2) {
    return b2 - a;
  }).concat(rowsMovedDown.sort(function(a, b2) {
    return a - b2;
  }));
  instance.addHookOnce("afterViewRender", undoneCallback);
  for (var i = 0; i < allMovedRows.length; i += 1) {
    var newPhysicalRow = instance.toVisualRow(allMovedRows[i]);
    manualRowMove.moveRow(newPhysicalRow, allMovedRows[i]);
  }
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);
};
UndoRedo.RowMoveAction.prototype.redo = function(instance, redoneCallback) {
  var manualRowMove = instance.getPlugin("manualRowMove");
  instance.addHookOnce("afterViewRender", redoneCallback);
  manualRowMove.moveRows(this.rows.slice(), this.finalIndex);
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.finalIndex, this.finalIndex + this.rows.length - 1);
};
UndoRedo.prototype.init = function() {
  var settings = this.instance.getSettings().undo;
  var pluginEnabled = typeof settings === "undefined" || settings;
  if (!this.instance.undoRedo) {
    this.instance.undoRedo = this;
  }
  if (pluginEnabled) {
    this.instance.undoRedo.enable();
  } else {
    this.instance.undoRedo.disable();
  }
};
UndoRedo.prototype.registerShortcuts = function() {
  var _this7 = this;
  var shortcutManager = this.instance.getShortcutManager();
  var gridContext = shortcutManager.getContext("grid");
  var runOnlyIf = function runOnlyIf2(event2) {
    return !event2.altKey;
  };
  var config = {
    runOnlyIf,
    group: SHORTCUTS_GROUP
  };
  gridContext.addShortcuts([{
    keys: [["Control/Meta", "z"]],
    callback: function callback() {
      _this7.undo();
    }
  }, {
    keys: [["Control/Meta", "y"], ["Control/Meta", "Shift", "z"]],
    callback: function callback() {
      _this7.redo();
    }
  }], config);
};
UndoRedo.prototype.unregisterShortcuts = function() {
  var shortcutManager = this.instance.getShortcutManager();
  var gridContext = shortcutManager.getContext("grid");
  gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);
};
function onAfterChange(changes, source) {
  var instance = this;
  if (source === "loadData") {
    return instance.undoRedo.clear();
  }
}
function exposeUndoRedoMethods(instance) {
  instance.undo = function() {
    return instance.undoRedo.undo();
  };
  instance.redo = function() {
    return instance.undoRedo.redo();
  };
  instance.isUndoAvailable = function() {
    return instance.undoRedo.isUndoAvailable();
  };
  instance.isRedoAvailable = function() {
    return instance.undoRedo.isRedoAvailable();
  };
  instance.clearUndo = function() {
    return instance.undoRedo.clear();
  };
}
function removeExposedUndoRedoMethods(instance) {
  delete instance.undo;
  delete instance.redo;
  delete instance.isUndoAvailable;
  delete instance.isRedoAvailable;
  delete instance.clearUndo;
}
var hook = Hooks$1.getSingleton();
hook.add("afterUpdateSettings", function() {
  var _this$getPlugin;
  (_this$getPlugin = this.getPlugin("undoRedo")) === null || _this$getPlugin === void 0 ? void 0 : _this$getPlugin.init();
});
hook.register("beforeUndo");
hook.register("afterUndo");
hook.register("beforeRedo");
hook.register("afterRedo");
UndoRedo.PLUGIN_KEY = PLUGIN_KEY;
UndoRedo.SETTING_KEYS = true;
function registerAllPlugins() {
  registerPlugin(AutoColumnSize);
  registerPlugin(Autofill);
  registerPlugin(AutoRowSize);
  registerPlugin(BindRowsWithHeaders);
  registerPlugin(CollapsibleColumns);
  registerPlugin(ColumnSorting);
  registerPlugin(ColumnSummary);
  registerPlugin(Comments);
  registerPlugin(ContextMenu);
  registerPlugin(CopyPaste);
  registerPlugin(CustomBorders);
  registerPlugin(DragToScroll);
  registerPlugin(DropdownMenu);
  registerPlugin(ExportFile);
  registerPlugin(Filters);
  registerPlugin(Formulas);
  registerPlugin(HiddenColumns);
  registerPlugin(HiddenRows);
  registerPlugin(ManualColumnFreeze);
  registerPlugin(ManualColumnMove);
  registerPlugin(ManualColumnResize);
  registerPlugin(ManualRowMove);
  registerPlugin(ManualRowResize);
  registerPlugin(MergeCells);
  registerPlugin(MultiColumnSorting);
  registerPlugin(MultipleSelectionHandles);
  registerPlugin(NestedHeaders);
  registerPlugin(NestedRows);
  registerPlugin(PersistentState);
  registerPlugin(Search);
  registerPlugin(TouchScroll);
  registerPlugin(TrimRows);
  registerPlugin(UndoRedo);
}
function registerAllModules() {
  registerAllEditors();
  registerAllRenderers();
  registerAllValidators();
  registerAllCellTypes();
  registerAllPlugins();
}
registerAllModules();
const spreadsheet = React.memo(function SpreadsheetRenderer(props) {
  let { name, id: id2, SVs, actions, callAction } = useDoenetRenderer(props);
  let onChangeVisibility = (isVisible2) => {
    callAction({
      action: actions.recordVisibilityChange,
      args: { isVisible: isVisible2 }
    });
  };
  reactExports.useEffect(() => {
    return () => {
      callAction({
        action: actions.recordVisibilityChange,
        args: { isVisible: false }
      });
    };
  }, []);
  if (SVs.hidden) {
    return null;
  }
  return /* @__PURE__ */ jsx(VisibilitySensor, { partialVisibility: true, onChange: onChangeVisibility, children: /* @__PURE__ */ jsxs("div", { id: id2, style: { margin: "12px 0" }, children: [
    /* @__PURE__ */ jsx("a", { name: id2 }),
    /* @__PURE__ */ jsx(
      HotTable,
      {
        licenseKey: "non-commercial-and-evaluation",
        data: SVs.cells.map((x2) => [...x2]),
        colHeaders: SVs.columnHeaders,
        rowHeaders: SVs.rowHeaders,
        width: sizeToCSS(SVs.width),
        height: sizeToCSS(SVs.height),
        afterChange: (changes, source) => callAction({ action: actions.onChange, args: { changes, source } }),
        formulas: {
          engine: HyperFormula
        },
        fixedRowsTop: SVs.fixedRowsTop,
        fixedColumnsLeft: SVs.fixedColumnsLeft,
        hiddenColumns: {
          columns: SVs.hiddenColumns.map((x2) => x2 - 1),
          indicators: false
        },
        hiddenRows: {
          rows: SVs.hiddenRows.map((x2) => x2 - 1),
          indicators: false
        },
        readOnly: SVs.disabled,
        disableVisualSelection: SVs.disabled,
        stretchH: "all"
      }
    )
  ] }) });
});
export {
  spreadsheet as default
};
